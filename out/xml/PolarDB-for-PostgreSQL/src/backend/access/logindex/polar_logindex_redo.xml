<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_logindex_redo.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_logindex_redo.c
 *   Implementation of parse xlog states and replay.
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *    src/backend/access/logindex/polar_logindex_redo.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_csnlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_backtrace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_bitpos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RMGR</name><parameter_list>(<parameter><type><name>symname</name></type></parameter>,<parameter><type><name>name</name></type></parameter>,<parameter><type><name>redo</name></type></parameter>,<parameter><type><name>polar_idx_save</name></type></parameter>, <parameter><type><name>polar_idx_parse</name></type></parameter>, <parameter><type><name>polar_idx_redo</name></type></parameter>, <parameter><type><name>desc</name></type></parameter>,<parameter><type><name>identify</name></type></parameter>,<parameter><type><name>startup</name></type></parameter>,<parameter><type><name>cleanup</name></type></parameter>,<parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{name, polar_idx_save, polar_idx_parse, polar_idx_redo},</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>                  <name>polar_logindex_bloom_blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>                  <name>polar_rel_size_cache_blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>polar_logindex_redo_ctl_t</name></type>   <name>polar_logindex_redo_instance</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: Flag set when replaying and marking buffer dirty */</comment>
<decl_stmt><decl><type><name>polar_logindex_bg_proc_t</name></type> <name>polar_bg_replaying_process</name> <init>= <expr><name>POLAR_NOT_LOGINDEX_BG_PROC</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Define the ratio of memory configured by polar_logindex_mem_size used for wal logindex and fullpage logindex */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_LOGINDEX_MEM_RATIO</name></cpp:macro>          <cpp:value>(0.75)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FULLPAGE_LOGINDEX_MEM_RATIO</name></cpp:macro>     <cpp:value>(0.25)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAL_LOGINDEX_DIR</name></cpp:macro>                <cpp:value>"pg_logindex"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FULLPAGE_LOGINDEX_DIR</name></cpp:macro>           <cpp:value>"polar_fullpage"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELATION_SIZE_CACHE_DIR</name></cpp:macro>         <cpp:value>"polar_rel_size_cache"</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>BUF_NEED_REPLAY</name></decl>,
	<decl><name>BUF_IS_REPLAYING</name></decl>,
	<decl><name>BUF_IS_REPLAYED</name></decl>,
	<decl><name>BUF_IS_FLUSHED</name></decl>,
	<decl><name>BUF_IS_TRUNCATED</name></decl>,
}</block></enum></type> <name>buf_replay_stat_t</name>;</typedef>

<comment type="block">/*
 * The backend process can have only one page iterator for wal logindex snapshot or fullpage logindex snapshot.
 * When backend process receive cancel query signal the memory allocated for
 * page iterator must be released.
 * This static variable is used to track allocated memory for page iterator and release
 * memory when receive signal.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>log_index_page_iter_t</name></type> <name>wal_page_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>log_index_page_iter_t</name></type> <name>fullpage_page_iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>BufferDesc</name> <modifier>*</modifier></type><name>polar_replaying_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>log_index_page_iter_t</name></type> <name>iter_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>polar_redo_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>log_index_redo_t</name></type> <name><name>polar_idx_redo</name><index>[<expr><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>=
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rmgrlist.h"</cpp:file></cpp:include>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_only_replay_exists_buffer</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>log_index_page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_logindex_apply_one_page</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>log_index_page_iter_t</name></type> <name>iter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>polar_logindex_apply_page_from</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>polar_page_lock_t</name></type> <name>page_lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_evict_buffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_extend_block_if_not_exist</name><parameter_list>(<parameter><decl><type><name>BufferTag</name><modifier>*</modifier></type> <name>tag</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_xlog_log</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type>      <name>rmid</name> <init>= <expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_identify</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s lsn=%X/%X UNKNOWN (%X)"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>lsn</name></expr></argument>,
							   <argument><expr><name>info</name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s lsn=%X/%X %s/%s"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>lsn</name></expr></argument>, <argument><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_name</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Call this function when we abort transaction.
 * If transaction is aborted, the buffer replaying is stopped,
 * so we have to clear its POLAR_REDO_REPLAYING flag.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_logindex_abort_replaying_buffer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>polar_replaying_buffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name> <init>= <expr><call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>polar_replaying_buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>redo_state</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>POLAR_REDO_REPLAYING</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>polar_replaying_buffer</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Abort replaying buf_id=%d, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>, <argument><expr><name><name>polar_replaying_buffer</name><operator>-&gt;</operator><name>buf_id</name></name></expr></argument>,
			 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polar_replaying_buffer</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_replaying_buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For the block file in tag, extend it to tag-&gt;blockNum blocks.
 * TODO: blocks are extended one by one, which can be optimized in the future. 
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_extend_block_if_not_exist</name><parameter_list>(<parameter><decl><type><name>BufferTag</name><modifier>*</modifier></type> <name>tag</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>extendBuf</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>extendBufIsInit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>smgr</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extendBufIsInit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>extendBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extendBufIsInit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name><name>tag</name><operator>-&gt;</operator><name>blockNum</name></name> <operator>&gt;=</operator> <name>nblocks</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>, <argument><expr><name>extendBuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nblocks</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_apply_one_record</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>polar_idx_redo</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>]</index></name><operator>.</operator><name>rm_polar_idx_redo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_CONSISTENT_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_BUFFER_TAG_INFO</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"rmid = %d has not polar_idx_redo function"</literal></expr></argument>,
			 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s %d %X/%X, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
												  <argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
												  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
												  <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
										   <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
										   <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>polar_idx_redo</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>]</index></name><operator>.</operator><call><name>rm_polar_idx_redo</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecord</name> <modifier>*</modifier></type>
<name>polar_logindex_read_xlog</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>errormsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">100000</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Failed to read record which lsn=%X/%X"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>polar_read_vm_buffer</name><parameter_list>(<parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>heap_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name><name>heap_tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>heap_tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Buffer</name></type>
<name>polar_logindex_outdate_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>heap_tag</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>get_cleanup_lock</name></decl></parameter>, <parameter><decl><type><name>polar_page_lock_t</name> <modifier>*</modifier></type><name>page_lock</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>vm_parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>page_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name>      <modifier>*</modifier></type><name>partition_lock</name></decl>;</decl_stmt>    <comment type="block">/* buffer partition lock for it */</comment>
	<decl_stmt><decl><type><name>int</name></type>         <name>buf_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>      <name>buffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>vm_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name>   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vm_parse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>heap_tag</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>vm_tag</name><operator>.</operator><name>rnode</name></name> <operator>=</operator> <name><name>heap_tag</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vm_tag</name><operator>.</operator><name>forkNum</name></name> <operator>=</operator> <name>VISIBILITYMAP_FORKNUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vm_tag</name><operator>.</operator><name>blockNum</name></name> <operator>=</operator> <call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>heap_tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tag</name> <operator>=</operator> <operator>&amp;</operator><name>vm_tag</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>page_hash</name> <operator>=</operator> <call><name>BufTableHashCode</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition_lock</name> <operator>=</operator> <call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>page_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check whether the block is already in the buffer pool */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <call><name>BufTableLookup</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>page_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Found the buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_pin_buffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>redo_state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 1. A backend process is reading this buffer from storage and it will redo for this buffer.
		 * 2. The mini transaction lock is acquired by the startup process.
		 * 3. We add lsn to logindex in startup process with the acquired mini transaction lock.
		 * 4. When backend process compete buffer read and start to redo for buffer, it will redo to this lsn
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_READ_IO_END</name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><operator>(</operator><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_REPLAYING</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>get_cleanup_lock</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>redo_state</name> <operator>|=</operator> <name>POLAR_REDO_OUTDATE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POLAR_LOGINDEX_MINI_TRANS_ADD_LSN</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>,
											  <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><operator>*</operator><name>page_lock</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><operator>*</operator><name>page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vm_parse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>RBM_NORMAL_NO_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_read_vm_buffer</name><argument_list>(<argument><expr><name>heap_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>get_cleanup_lock</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_lock_buffer_for_cleanup_ext</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>polar_lock_buffer_ext</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_CONSISTENT_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_LOG_BUFFER_TAG_INFO</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to read page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>page_lock</name> <operator>=</operator> <call><name>polar_logindex_mini_trans_lock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POLAR_LOGINDEX_MINI_TRANS_ADD_LSN</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>,
											  <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><operator>*</operator><name>page_lock</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Force to get buffer descriptor again to avoid different buffer descriptor when buffer is evicted before */</comment>
			<expr_stmt><expr><name>buf_desc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>redo_state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>redo_state</name> <operator>|=</operator> <name>POLAR_REDO_OUTDATE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_logindex_messages</name> <operator>&lt;=</operator> <name>DEBUG4</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>page_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Page</name></type> <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>page_lsn</name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s buf_id=%d page_lsn=%X/%X, xlog=%X/%X, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
								 <argument><expr><name>buf_id</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>page_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>page_lsn</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
								 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_xlog_log</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Polar: extend blocks if not exist in standby mode;
		 *
		 * The semantic of parsing WAL is that the data of the WAL can be
		 * queried after parsing. However, some queries depend on the number of
		 * blocks in the storage (e.g. select * from &lt;table&gt;). The data in the
		 * buffer won't be queried if its block is not extended in the storage.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>POLAR_IN_PARALLEL_REPLAY_STANDBY_MODE</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_extend_block_if_not_exist</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>POLAR_LOGINDEX_MINI_TRANS_ADD_LSN</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>,
										  <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><operator>*</operator><name>page_lock</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Buffer</name></type>
<name>polar_logindex_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>get_cleanup_lock</name></decl></parameter>, <parameter><decl><type><name>polar_page_lock_t</name> <modifier>*</modifier></type><name>page_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>      <name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_logindex_outdate_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>get_cleanup_lock</name></expr></argument>, <argument><expr><name>page_lock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_logindex_parse_tag</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>get_cleanup_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type>   <name>page_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>              <name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page_lock</name> <operator>=</operator> <call><name>polar_logindex_mini_trans_lock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_logindex_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>get_cleanup_lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_save_block</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>block_id</name> <operator>&lt;=</operator> <name>XLR_MAX_BLOCK_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blk</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>blk</name><operator>-&gt;</operator><name>forknum</name></name></expr></argument>, <argument><expr><name><name>blk</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator> <operator>==</operator> <name>XLOG_FPSI</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_INDEX_ADD_LSN</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_INDEX_ADD_LSN</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_redo_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_parse_tag</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_cleanup_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_parse_tag</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_save_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type> <name>rmid</name> <init>= <expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polar_idx_redo</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_polar_idx_save</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>polar_idx_redo</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_polar_idx_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_CONSISTENT_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"rm_polar_idx_save is not set for rmid=%d"</literal></expr></argument>, <argument><expr><name>rmid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_enable_logindex_parse</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If it's replica mode and logindex is enabled, we parse XLOG and save it to logindex.
	 * If it's standby parallel replay mode and logindex is enabled, we also parse XLOG and
	 * save it to logindex.
	 *
	 * During recovery we read XLOG from checkpoint, master node can drop or truncate table
	 * after this checkpoint. We can't read these removed data blocks, so it will be PANIC
	 * if we read data block and replay XLOG.
	 * In master node it will create table if it does not exist, but we can not do this in
	 * replica mode.
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_logindex_redo_instance</name><operator>)</operator> <operator>||</operator>
		<call><name>POLAR_IN_PARALLEL_REPLAY_STANDBY_MODE</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_redo_parse_start_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instance</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_logindex_check_valid_start_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_logindex_parse_xlog</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>RmgrId</name></type> <name>rmid</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>redo_start_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>mini_trans_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>redo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>parse_valid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><call><name>polar_logindex_redo_parse_start_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parse_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parse_valid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>redo</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"wal logindex parse from %lX"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mini_trans_lsn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mini_trans_lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Polar: In standby mode, parallel replay can be triggered only when
	 * consistency reached, temporarily!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>POLAR_IN_PARALLEL_REPLAY_STANDBY_MODE</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>reachedConsistency</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>polar_idx_redo</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_polar_idx_parse</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_logindex_messages</name> <operator>&lt;=</operator> <name>DEBUG4</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_xlog_log</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_logindex_mini_trans_start</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>redo</name> <operator>=</operator> <name><name>polar_idx_redo</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_polar_idx_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * We can not end mini transaction here because XLogCtl-&gt;lastReplayedEndRecPtr is not updated.
			 * If we end mini transaction here, and one backend start to do buffer replay,
			 * it can not acquire mini transaction lock and  replay to XLogCtl-&gt;lastReplayedEndRecPtr,
			 * so the current record which was parsed and saved to logindex will be lost.
			 * We will end mini transaction after startup process update XLogCtl-&gt;lastReplayedEndRecPtr.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>mini_trans_lsn</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* POLAR: create and save logindex in master and standby. */</comment>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>polar_idx_redo</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_polar_idx_save</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>polar_idx_redo</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><call><name>rm_polar_idx_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * POLAR: If current record lsn is smaller than redo start lsn, then we only parse xlog and create logindex.
	 * Sometimes, currRecPtr will be the start position of xlog block which would make the following condition
	 * unexpectedly failed. So we should use ReadRecPtr.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&lt;</operator> <name>redo_start_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>redo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>redo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Apply the WAL record from start_lsn to end_lsn - 1.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_apply_page</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>,
						  <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>end_lsn</name> <operator>&lt;=</operator> <name>start_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * 1. When do online promote, the page could be flushed after replayed, so end_lsn may be smaller than start_lsn
		 * 2. The new created RO node, which received primary consistent lsn but rw didn't have new ro node's replayed lsn,
		 * and then end_lsn may be smaller than start_lsn
		 * 3. The end_lsn is the start point of last replayed record, while start_lsn is set by consistent lsn , which is the end point of last replayed record,
		 * then end_lsn is smaller than start_lsn.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>end_lsn</name> <operator>&lt;</operator> <name>start_lsn</name> <operator>&amp;&amp;</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Try to replay page "</literal><name>POLAR_LOG_BUFFER_TAG_FORMAT</name><literal type="string">" which end_lsn=%lX is smaller than start_lsn=%lX, page_lsn=%lX"</literal></expr></argument>,
								 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>start_lsn</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s %d %X/%X %X/%X, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
												  <argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>start_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
												  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>start_lsn</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>end_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
												  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>end_lsn</name></expr></argument>,
												  <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
										   <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
										   <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wal_page_iter</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Logindex record the start position of XLOG and we search LSN between [start_lsn, end_lsn].
	 * And end_lsn points to the end position of the last xlog, so we should subtract 1 here .
	 */</comment>
	<expr_stmt><expr><name>wal_page_iter</name> <operator>=</operator> <call><name>polar_logindex_create_page_iterator</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>,
														<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_ONLINE_PROMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>polar_logindex_page_iterator_state</name><argument_list>(<argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ITERATE_STATE_FINISHED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to iterate data for "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name> <literal type="string">", which start_lsn=%X/%X and end_lsn=%X/%X"</literal></expr></argument>,
			 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>start_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>start_lsn</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>end_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_apply_one_page</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_release_page_iterator</name><argument_list>(<argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_page_iter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>end_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>polar_logindex_apply_page_from</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>polar_page_lock_t</name></type> <name>page_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If block was truncated before, then we change the start lsn to the lsn when truncate block */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>valid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn_changed</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>polar_check_rel_block_valid_and_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>,  <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s change start_lsn from %lX to %lX for page_lsn=%lX "</literal><name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
														  <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>lsn_changed</name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name>lsn_changed</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this buffer replaying is protected by mini transaction page_lock and replaying lsn is added to logindex
	 * then we replay to the record which is currently replaying.
	 * Otherwise we replay to the last record which is successfully replayed.
	 * If we replay to the currently replaying record without mini transaction page_lock, we may get inconsistent
	 * date structure in memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>page_lock</name> <operator>!=</operator> <name>POLAR_INVALID_PAGE_LOCK</name> <operator>&amp;&amp;</operator>
			<call><name>polar_logindex_mini_trans_get_page_added</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>page_lock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>polar_get_replay_end_rec_ptr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>polar_logindex_apply_page</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search xlog base on the buffer tag and replay these xlog record for the buffer.
 * Return true if page lsn changed after replay
 */</comment>
<function><type><name>bool</name></type>
<name>polar_logindex_lock_apply_page_from</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>page_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>origin_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>         <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record the buffer that is replaying.If we abort transaction in
	 * this backend process, we need to clear POLAR_REDO_REPLAYING from
	 * buffer redo state
	 */</comment>
	<expr_stmt><expr><name>polar_replaying_buffer</name> <operator>=</operator> <name>buf_hdr</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent interrupts while replaying to avoid inconsistent buffer redo state
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should finish reading data from storage and then replay xlog for page,
	 * so we set redo_state to be POLAR_REDO_READ_IO_END | POLAR_REDO_REPLAYING.
	 */</comment>
	<expr_stmt><expr><name>redo_state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>redo_state</name> <operator>|=</operator> <operator>(</operator><name>POLAR_REDO_READ_IO_END</name> <operator>|</operator> <name>POLAR_REDO_REPLAYING</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>redo_state</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>POLAR_REDO_OUTDATE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>origin_lsn</name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>page_lock</name> <operator>=</operator> <call><name>polar_logindex_mini_trans_cond_lock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <call><name>polar_logindex_apply_page_from</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>redo_state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_OUTDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>redo_state</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>POLAR_REDO_OUTDATE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>redo_state</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>POLAR_REDO_REPLAYING</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>page_lock</name> <operator>!=</operator> <name>POLAR_INVALID_PAGE_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_REPLAYING</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can allow interrupts again */</comment>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_replaying_buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>origin_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_promote_mark_buf_dirty</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>page_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page_lsn</name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If page lsn is larger than the last replayed xlog lsn, then this buffer
	 * was modified after online promote and we don't need to mark it dirty
	 * again
	 *
	 * There is a situation when a wal is parsed, dispatched, replayed and the
	 * page lsn is updated but GetXLogReplayRecPtr(NULL) has not been updated, so
	 * that the new page won't be marked as dirty, which is wrong.
	 * 
	 * GetXLogReplayRecPtr(NULL) won't be changed during online promote.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>POLAR_BG_PARALLEL_REPLAYING</name> <operator>&amp;&amp;</operator>
		<name>page_lsn</name> <operator>&gt;</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During online promote the start_lsn is the background process replayed lsn which used as the lower limit
	 * to create logindex iterator. If page lsn is smaller or equal to start_lsn, then we have no xlog record
	 * to replay when visist this buffer, so we don't need to mark it dirty
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>page_lsn</name> <operator>&lt;=</operator> <name>start_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply the specific buffer from the start lsn to the last parsed lsn.
 * We must acquire mini transaction page lock
 * to avoid add lsn for this page.This is used when enable page invalid and
 * apply buffer when a backend process use this buffer.
 */</comment>
<function><type><name>void</name></type>
<name>polar_logindex_lock_apply_buffer</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>bg_replayed_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_desc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_redo_check_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>POLAR_REDO_OUTDATE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bg_replayed_lsn</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_SET_BACKEND_READ_MIN_LSN</name><argument_list>(<argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the buffer may lose some flashback log record,
		 * just insert it to flashback log list as a candidator.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_may_buf_lost_flog</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_flog_insert</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_logindex_lock_apply_page_from</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>bg_replayed_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf_desc</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_promote_mark_buf_dirty</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>POLAR_RESET_BACKEND_READ_MIN_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type>
<name>polar_allocate_xlog_reader</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_local_xlog_page</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_logindex_apply_one_page</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>log_index_page_iter_t</name></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>iter_context</name> <operator>=</operator> <name>iter</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>state</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_allocate_xlog_reader</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>lsn_info</name> <operator>=</operator> <call><name>polar_logindex_page_iterator_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_read_xlog</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_apply_one_record</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type>
<name>polar_create_bg_redo_ctl</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>enable_processes_pool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>ctl</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_logindex_bg_redo_ctl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>bg_replayed_lsn</name> <init>= <expr><call><name>polar_bg_redo_get_replayed_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name> <operator>=</operator> <name>instance</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>lsn_iter</name></name> <operator>=</operator> <call><name>polar_logindex_create_lsn_iterator</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>polar_allocate_xlog_reader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_batch_size</name></name> <operator>=</operator> <name>polar_bg_replay_batch_size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_processes_pool</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>sched_ctl</name></name> <operator>=</operator> <call><name>polar_create_parallel_replay_sched_ctl</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_start_proc_pool</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>sched_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Start background replay iter from %X/%X"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>bg_replayed_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>bg_replayed_lsn</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ctl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_release_bg_redo_ctl</name><parameter_list>(<parameter><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>sched_ctl</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_release_task_sched_ctl</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>sched_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_release_lsn_iterator</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>lsn_iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Apply record in background to catch up replayed lsn updated in Startup.
 *
 * In this func, it use a iterator from logindex to go through xlog record, and
 * apply record on related page if page buffer is in buffer pool. If current record
 * is not in logindex, such as clog record, it will skip replay of it and advance
 * bg_replayed_lsn directly. Initial xlog record lsn is set when reachedConsistency
 * turns true in Startup process.
 *
 * This func is called in Bgwriter process in Replica node. Each run, it apply
 * polar_bg_replay_batch_size xlog records at most.
 *
 * It will advance bg_replayed_lsn which will be replied to master as restart_lsn of
 * replication slot. And that will stop master from deleting wal segments before
 * bg_replayed_lsn.
 *
 * Return true if no more records need replay, otherwise false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_logindex_apply_xlog_background</name><parameter_list>(<parameter><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>     <name>replayed_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>replayed_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>bg_redo_state</name> <init>= <expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>bg_redo_state</name> <operator>==</operator> <name>POLAR_BG_REDO_NOT_START</name> <operator>||</operator> <name>bg_redo_state</name> <operator>==</operator> <name>POLAR_BG_WAITING_RESET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>replayed_lsn</name> <operator>=</operator> <call><name>polar_get_last_replayed_read_ptr</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure there's room for us to pin buffer */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>replayed_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>replayed_count</name> <operator>&lt;</operator> <name><name>ctl</name><operator>-&gt;</operator><name>replay_batch_size</name></name></expr>;</condition> <incr><expr><name>replayed_count</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>current_ptr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>=</operator>
				<call><name>polar_logindex_lsn_iterator_next</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>lsn_iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If no more item in logindex, exit and retry next run */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now, we get one record from logindex lsn iterator */</comment>

		<comment type="block">/* If current xlog record is beyond replayed lsn, just break */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&gt;</operator> <name>replayed_lsn</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* we get a new record now, set current_ptr as the lsn of it */</comment>
		<expr_stmt><expr><name>current_ptr</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * replay each page of current record. because we checked log_index_page-&gt;lsn &lt; replayed_lsn,
		 * we will get all related pages of the record, so use do-while to go through each page replay
		 */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_only_replay_exists_buffer</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>=</operator>
				<call><name>polar_logindex_lsn_iterator_next</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>lsn_iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		while <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>current_ptr</name> <operator>==</operator> <name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition>;</do>

		<comment type="block">/* now, record related pages have all been replayed, so we can advance bg_replayed_lsn */</comment>
		<expr_stmt><expr><call><name>polar_bg_redo_set_replayed_lsn</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>, <argument><expr><name>current_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>(</operator><name>replayed_count</name> <operator>&lt;</operator> <name>polar_bg_replay_batch_size</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Evict selectd buffer.
 *
 * In some case, we need to release buffer's content lock if we have before
 * put it back to free list. In other word, if the buffer is locked and pined
 * before this func, and it will be released and un-pined while being evicted.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_evict_buffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>buf_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name> <init>= <expr><name><name>buf_desc</name><operator>-&gt;</operator><name>tag</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><call><name>BufTableHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>partition_lock</name> <init>= <expr><call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>evict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>evict</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <call><name>LockBufHdr</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We should already pin this buffer, and then evict it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BUF_STATE_GET_REFCOUNT</name><argument_list>(<argument><expr><name>buf_state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_DIRTY</name><operator>)</operator>
			<operator>&amp;&amp;</operator> <operator>(</operator><name>buf_state</name> <operator>&amp;</operator> <name>BM_TAG_VALID</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name><name>buf_desc</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BUF_FLAG_MASK</name> <operator>|</operator> <name>BUF_USAGECOUNT_MASK</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>evict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockBufHdr</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>buf_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>evict</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * POLAR: Make true there are no flashback record of the buffer.
		 */</comment>
		<expr_stmt><expr><call><name>polar_make_true_no_flog</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>redo_state</name> <operator>=</operator> <call><name>polar_lock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>redo_state</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>POLAR_BUF_REDO_FLAG_MASK</name> <operator>|</operator> <name>POLAR_BUF_FLASHBACK_FLAG_MASK</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_unlock_redo_state</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>redo_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BufTableDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Insert the buffer at the head of the list of free buffers.
		 */</comment>
		<expr_stmt><expr><call><name>StrategyFreeBuffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>evict</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_bg_redo_read_record</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If needed record has not been read, just read it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>!=</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>errormsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* In XLogReadRecord, it may enlarge buffer of XlogReaderState, so we should switch context */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_CONSISTENT_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read record from WAL at %lX"</literal></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_bg_redo_get_record_id</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferTag</name></type> <name>blk_tag</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>blk_tag</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name>blk_tag</name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to find block id in XLogRecord when lsn=%lX for "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
		 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_bg_redo_apply_read_record</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>,
								<parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_bg_redo_read_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>blk_id</name> <init>= <expr><call><name>polar_bg_redo_get_record_id</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * When create new page, it call log_newpage which is FPI xlog record and then extend the file.
		 * So during online promote when replay FPI xlog record, RBM_NORMAL_NO_LOG could return InvalidBuffer.
		 * We use flag RBM_ZERO_ON_ERROR which will extend the file if page does not exist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecBlockImageApply</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>blk_id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Don't replay this block if it's truncated or dropped */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>polar_check_rel_block_valid_only</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>RBM_ZERO_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>buf_desc</name> <operator>=</operator> <call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_logindex_messages</name> <operator>&lt;=</operator> <name>DEBUG4</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_BUFFER_DESC</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_PAGE_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_CONSISTENT_LSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check redo state again, if it's replaying then this xlog will be replayed by replaying
	 * process.
	 */</comment>
	<expr_stmt><expr><call><name>polar_lock_buffer_ext</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Critical section begin */</comment>

	<comment type="block">/* Apply current record on page */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_apply_one_record</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_promote_mark_buf_dirty</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Critical section end */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Pin buffer if it exists in the buffer pool */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>polar_pin_buffer_for_replay</name><parameter_list>(<parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>partition_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>buf_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tag</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>BufTableHashCode</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition_lock</name> <operator>=</operator> <call><name>BufMappingPartitionLock</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See if the block is in the buffer pool already */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_id</name> <operator>=</operator> <call><name>BufTableLookup</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If page is in buffer, we can apply record, otherwise we do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><name>buf_id</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buf_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>valid</name></decl>;</decl_stmt>

		<comment type="block">/* Pin buffer from being evicted */</comment>
		<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>polar_pin_buffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Can release the mapping lock as soon as possible */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_desc</name><operator>-&gt;</operator><name>polar_redo_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We can only replay buffer after POLAR_REDO_IO_END is set, which means buffer content is read from storage.
			 * The backend process clear POLAR_REDO_REPLAYING and then set BM_VALID flag.
			 * If startup parse xlog and set POLAR_REDO_OUTDATE, POLAR_REDO_REPLAYING
			 * flag is cleard but BM_VALID is not set, then we need to replay this buffer
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_READ_IO_END</name><operator>)</operator> <operator>&amp;&amp;</operator> 
					<operator>(</operator><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_OUTDATE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_REPLAYING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Invalid buffer means some other process is reading or replaying this page
			 * currently. After reading or replaying, xlog replay will be done, so we don't need to
			 * replay it. Even error occurs while io, invalid buffer will be read from
			 * disk next access try, or evicted from buffer pool if no one else access it.
			 */</comment>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>buffer</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partition_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>InvalidBuffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>buf_replay_stat_t</name></type>
<name>polar_buffer_need_replay</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>page_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>redo_state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_desc</name><operator>-&gt;</operator><name>polar_redo_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Background process don't need to replay if Buffer is replaying or already replayed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_INVALIDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>BUF_IS_TRUNCATED</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_REPLAYING</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>BUF_IS_REPLAYING</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>in_range</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_range</name> <operator>=</operator> <call><name>polar_check_rel_block_valid_only</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf_desc</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_range</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>BUF_IS_TRUNCATED</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>page_lsn</name> <operator>=</operator> <call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>page_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Background process don't need to replay if page lsn is larger than xlog record's lsn,
			 * which means this record is already replayed by backend process
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>page_lsn</name> <operator>&gt;</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>BUF_IS_REPLAYED</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>BUF_NEED_REPLAY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Apply one record on one page.
 *
 * We will check existence of buffer page in buffer pool first. If hit, replay record on it,
 * otherwise do nothing. While buffer hit, buffer should be pinned before replaying from being
 * evicted in which target buffer may be not the requested one.
 *
 * If pinned buffer is invalid, buffer is doing io now. After io operation, page will be replayed,
 * so no need to replay it in background.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_only_replay_exists_buffer</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>log_index_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>log_index_page</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_pin_buffer_for_replay</name><argument_list>(<argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If page is in buffer, we can apply record, otherwise we do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>buf_replay_stat_t</name></type> <name>stat</name> <init>= <expr><call><name>polar_buffer_need_replay</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>==</operator> <name>BUF_NEED_REPLAY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consist_lsn</name> <init>= <expr><call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>consist_lsn</name> <operator>&gt;</operator> <name><name>log_index_page</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&amp;&amp;</operator> <call><name>polar_evict_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"Evict buffer=%d when consist_lsn=%lX and xlog_lsn=%lX for "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
					 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>consist_lsn</name></expr></argument>, <argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_bg_redo_apply_read_record</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><literal type="string">"The buf state=%d, so don't replay buf=%d when lsn=%lX for "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
				 <argument><expr><name>stat</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name><name>log_index_page</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Return max lsn of a and b.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_max_xlog_rec_ptr</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>b</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>Max</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Return min lsn of a and b.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_min_xlog_rec_ptr</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>b</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Lock redo state - set POLAR_REDO_LOCKED in redo state
 */</comment>
<function><type><name>uint32</name></type>
<name>polar_lock_redo_state</name><parameter_list>(<parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpinDelayStatus</name></type> <name>delayStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>old_redo_state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_local_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* set POLAR_REDO_LOCKED flag */</comment>
		<expr_stmt><expr><name>old_redo_state</name> <operator>=</operator> <call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>polar_redo_state</name></name></expr></argument>, <argument><expr><name>POLAR_REDO_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if it wasn't set before we're OK */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>old_redo_state</name> <operator>&amp;</operator> <name>POLAR_REDO_LOCKED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>perform_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>finish_spin_delay</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delayStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>old_redo_state</name> <operator>|</operator> <name>POLAR_REDO_LOCKED</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_log_page_iter_context</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>iter_context</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>polar_logindex_page_iterator_buf_tag</name><argument_list>(<argument><expr><name>iter_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Page iter start_lsn=%lX, end_lsn=%lX for page="</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
			 <argument><expr><call><name>polar_logindex_page_iterator_min_lsn</name><argument_list>(<argument><expr><name>iter_context</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>polar_logindex_page_iterator_max_lsn</name><argument_list>(<argument><expr><name>iter_context</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR; if we read a future page, then call this function to restore old version page
 */</comment>
<function><type><name>bool</name></type>
<name>polar_logindex_restore_fullpage_snapshot_if_needed</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>replayed_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name> <init>= <expr><name>PG_INT64_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>    <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>start_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>retry</name>:</label>

	<comment type="block">/*
	 * POLAR: If page lsn is larger than replayed xlog lsn,
	 * then this replica read a future page
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_future_page</name><argument_list>(<argument><expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOGINDEX_WAIT_FULLPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>replayed_lsn</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fullpage_page_iter</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Logindex record the start position of XLOG and we search LSN between [replayed_lsn, end_lsn].
	 * And end_lsn points to the end position of the last xlog, so we should subtract 1 here .
	 */</comment>
	<expr_stmt><expr><name>fullpage_page_iter</name> <operator>=</operator> <call><name>polar_logindex_create_page_iterator</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>tag</name></expr></argument>,
															 <argument><expr><name>replayed_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_ONLINE_PROMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_logindex_page_iterator_state</name><argument_list>(<argument><expr><name>fullpage_page_iter</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ITERATE_STATE_FINISHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to iterate data for "</literal><name>POLAR_LOG_BUFFER_TAG_FORMAT</name><literal type="string">", which replayed_lsn=%X/%X and end_lsn=%X/%X"</literal></expr></argument>,
			 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>replayed_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>replayed_lsn</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>end_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_local_xlog_page</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>state</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lsn_info</name> <operator>=</operator> <call><name>polar_logindex_page_iterator_next</name><argument_list>(<argument><expr><name>fullpage_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lsn_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_logindex_read_xlog</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_apply_one_record</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_release_page_iterator</name><argument_list>(<argument><expr><name>fullpage_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fullpage_page_iter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Force FATAL future page if we wait fullpage logindex too long */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>start_time</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name>polar_wait_old_version_page_timeout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Read a future page due to timeout, page lsn = %lx, replayed_lsn = %lx, page_tag="</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
				 <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>replayed_lsn</name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 0.1ms */</comment>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>retry</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s restore page "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name> <literal type="string">" LSN=%X/%X"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
		 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_logindex_redo_ctl_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_logindex_redo_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>polar_logindex_redo_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_mem_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_logindex_redo_ctl_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_logindex_mini_trans_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
					<argument><expr><call><name>polar_logindex_shmem_size</name><argument_list>(<argument><expr><call><name>polar_logindex_convert_mem_tbl_size</name><argument_list>(<argument><expr><name>polar_logindex_mem_size</name> <operator>*</operator> <name>WAL_LOGINDEX_MEM_RATIO</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>polar_logindex_bloom_blocks</name> <operator>*</operator> <name>WAL_LOGINDEX_MEM_RATIO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_rel_size_cache_blocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_rel_size_shmem_size</name><argument_list>(<argument><expr><name>polar_rel_size_cache_blocks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_xlog_queue_buffers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_xlog_queue_size</name><argument_list>(<argument><expr><name>polar_xlog_queue_buffers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_max_local_cache_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_local_cache_shmem_size</name><argument_list>(<argument><expr><name>polar_logindex_max_local_cache_segments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
					<argument><expr><call><name>polar_logindex_shmem_size</name><argument_list>(<argument><expr><call><name>polar_logindex_convert_mem_tbl_size</name><argument_list>(<argument><expr><name>polar_logindex_mem_size</name> <operator>*</operator> <name>FULLPAGE_LOGINDEX_MEM_RATIO</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>polar_logindex_bloom_blocks</name> <operator>*</operator> <name>FULLPAGE_LOGINDEX_MEM_RATIO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_fullpage_shmem_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_max_local_cache_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_local_cache_shmem_size</name><argument_list>(<argument><expr><name>polar_logindex_max_local_cache_segments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_parallel_replay_proc_num</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>polar_parallel_replay_task_queue_depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>polar_calc_task_sched_shmem_size</name><argument_list>(<argument><expr><name>polar_parallel_replay_proc_num</name></expr></argument>,
															   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>parallel_replay_task_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>polar_parallel_replay_task_queue_depth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>polar_logindex_redo_ctl_t</name></type>
<name>polar_logindex_redo_ctl_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <operator>(</operator><name>polar_logindex_redo_ctl_t</name><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>polar_logindex_redo_ctl_shmem_size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_logindex_redo_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Init logindex memory context which is static variable */</comment>
		<expr_stmt><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>ctl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_logindex_redo_table_flushable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>log_mem_table_t</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>POLAR_LOGINDEX_FLUSHABLE_LSN</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <call><name>polar_logindex_mem_table_max_lsn</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_redo_shmem_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_mem_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>instance</name> <operator>=</operator> <operator>(</operator><name>polar_logindex_redo_ctl_t</name><operator>)</operator> <call><name>polar_logindex_redo_ctl_init</name><argument_list>(<argument><expr><literal type="string">"logindex_redo_ctl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name> <operator>=</operator> <call><name>polar_logindex_mini_trans_shmem_init</name><argument_list>(<argument><expr><literal type="string">"logindex_redo_minitrans"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name> <operator>=</operator> <call><name>polar_logindex_snapshot_shmem_init</name><argument_list>(<argument><expr><name>WAL_LOGINDEX_DIR</name></expr></argument>,
																		 <argument><expr><call><name>polar_logindex_convert_mem_tbl_size</name><argument_list>(<argument><expr><name>polar_logindex_mem_size</name> <operator>*</operator> <name>WAL_LOGINDEX_MEM_RATIO</name></expr></argument>)</argument_list></call></expr></argument>,
																		 <argument><expr><name>polar_logindex_bloom_blocks</name> <operator>*</operator> <name>WAL_LOGINDEX_MEM_RATIO</name></expr></argument>, <argument><expr><name>LWTRANCHE_WAL_LOGINDEX_BEGIN</name></expr></argument>, <argument><expr><name>LWTRANCHE_WAL_LOGINDEX_END</name></expr></argument>,
																		 <argument><expr><name>polar_logindex_redo_table_flushable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_rel_size_cache_blocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name> <operator>=</operator> <call><name>polar_rel_size_shmem_init</name><argument_list>(<argument><expr><name>RELATION_SIZE_CACHE_DIR</name></expr></argument>, <argument><expr><name>polar_rel_size_cache_blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_xlog_queue_buffers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name> <operator>=</operator> <call><name>polar_xlog_queue_init</name><argument_list>(<argument><expr><literal type="string">"polar_xlog_queue"</literal></expr></argument>, <argument><expr><name>LWTRANCHE_POLAR_XLOG_QUEUE</name></expr></argument>,
													 <argument><expr><name>polar_xlog_queue_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_max_local_cache_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_create_local_cache</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><literal type="string">"wal_logindex"</literal></expr></argument>,
										  <argument><expr><name>polar_logindex_max_local_cache_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name> <operator>=</operator> <call><name>polar_logindex_snapshot_shmem_init</name><argument_list>(<argument><expr><name>FULLPAGE_LOGINDEX_DIR</name></expr></argument>,
																			  <argument><expr><call><name>polar_logindex_convert_mem_tbl_size</name><argument_list>(<argument><expr><name>polar_logindex_mem_size</name> <operator>*</operator> <name>FULLPAGE_LOGINDEX_MEM_RATIO</name></expr></argument>)</argument_list></call></expr></argument>,
																			  <argument><expr><name>polar_logindex_bloom_blocks</name> <operator>*</operator> <name>FULLPAGE_LOGINDEX_MEM_RATIO</name></expr></argument>, <argument><expr><name>LWTRANCHE_FULLPAGE_LOGINDEX_BEGIN</name></expr></argument>,
																			  <argument><expr><name>LWTRANCHE_FULLPAGE_LOGINDEX_END</name></expr></argument>, <argument><expr><name>polar_logindex_redo_table_flushable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_ctl</name></name> <operator>=</operator> <call><name>polar_fullpage_shmem_init</name><argument_list>(<argument><expr><name>FULLPAGE_LOGINDEX_DIR</name></expr></argument>,
													   <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>, <argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_logindex_max_local_cache_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_create_local_cache</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><literal type="string">"fullpage_logindex"</literal></expr></argument>,
										  <argument><expr><name>polar_logindex_max_local_cache_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>bg_redo_state</name></name></expr></argument>, <argument><expr><name>POLAR_BG_REDO_NOT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_parallel_replay_proc_num</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>polar_parallel_replay_task_queue_depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>parallel_sched</name></name> <operator>=</operator> <call><name>polar_create_proc_task_sched</name><argument_list>(<argument><expr><literal type="string">"polar_parallel_replay_sched"</literal></expr></argument>,
																<argument><expr><name>polar_parallel_replay_proc_num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>parallel_replay_task_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
																<argument><expr><name>polar_parallel_replay_task_queue_depth</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>polar_logindex_redo_instance</name> <operator>=</operator> <name>instance</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_remove_old_files</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>min_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>instance</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>min_lsn</name> <operator>=</operator> <call><name>polar_calc_min_used_lsn</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Truncate relation size cache which saved in local file system*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_truncate_rel_size_cache</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>, <argument><expr><name>min_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Truncate the following files which saved in shared storage */</comment>

	<comment type="block">/* Truncate logindex before removing wal files */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_truncate</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>min_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Truncate fullpage data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_ctl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_remove_old_fullpage_files</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_ctl</name></name></expr></argument>, <argument><expr><name>min_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_remove_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* replica cannot remove file from storage */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>WAL_LOGINDEX_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rmtree</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLAR_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FULLPAGE_LOGINDEX_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rmtree</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_redo_start_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>instance</name> <operator>&amp;&amp;</operator> <name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>polar_logindex_start_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_redo_init</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>checkpoint_lsn</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <call><name>polar_logindex_snapshot_init</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>, <argument><expr><name>read_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_snapshot_init</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>, <argument><expr><name>read_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polar logindex change from %lx to %lx"</literal></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_replay_from</name></name> <operator>=</operator> <name>checkpoint_lsn</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>start_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_redo_flush_data</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>instance</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_flush_table</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_flush_table</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_logindex_redo_bg_flush_data</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>write_done</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>write_done</name> <operator>&amp;=</operator> <call><name>polar_logindex_bg_write</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>write_done</name> <operator>&amp;=</operator> <call><name>polar_logindex_bg_write</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>write_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_logindex_bg_dispatch</name><parameter_list>(<parameter><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_hold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_task_sched_ctl_t</name> <modifier>*</modifier></type><name>sched_ctl</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>sched_ctl</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>dispatch_done</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>bg_replayed_lsn</name></decl>, <decl><type ref="prev"/><name>backend_min_lsn</name></decl>, <decl><type ref="prev"/><name>xlog_replayed_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>can_hold</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Remove finished task from running queue */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_sched_empty_running_task</name><argument_list>(<argument><expr><name>sched_ctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_sched_remove_finished_task</name><argument_list>(<argument><expr><name>sched_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dispatch new task to replay */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>parallel_replay_task_node_t</name></type> <name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dst_node</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>xlog_replayed_lsn</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>=</operator> <call><name>polar_logindex_lsn_iterator_next</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>,
																<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>lsn_iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If no more item in logindex, exit and retry next run */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If current xlog record is beyond replayed lsn, just break */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&gt;</operator> <call><name>polar_get_last_replayed_read_ptr</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>tag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name><name>node</name><operator>.</operator><name>tag</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>.</operator><name>prev_lsn</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name><operator>-&gt;</operator><name>prev_lsn</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>dst_node</name> <operator>=</operator> <operator>(</operator><name>parallel_replay_task_node_t</name> <operator>*</operator><operator>)</operator><call><name>polar_sched_add_task</name><argument_list>(<argument><expr><name>sched_ctl</name></expr></argument>, <argument><expr><operator>(</operator><name>polar_task_node_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dst_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>proc</name> <init>= <expr><call><name>POLAR_TASK_NODE_PROC</name><argument_list>(<argument><expr><operator>(</operator><name>polar_task_node_t</name> <operator>*</operator><operator>)</operator><name>dst_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>max_dispatched_lsn</name></name> <operator>=</operator> <name><name>node</name><operator>.</operator><name>lsn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>replay_page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Dispatch lsn=%lX, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name> <literal type="string">" to proc=%d"</literal></expr></argument>,
														  <argument><expr><name><name>dst_node</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst_node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name><name>sched_ctl</name><operator>-&gt;</operator><name>sub_proc</name><index>[<expr><name>proc</name></expr>]</index></name><operator>.</operator><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call><operator>,</operator>
												   <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We can not add this task because task queue is full, so the caller can hold a while */</comment>
			<expr_stmt><expr><operator>*</operator><name>can_hold</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dispatch_done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* Break this loop when fail to dispatch */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>true</name></expr>)</condition>;</do>

	<comment type="block">/*
	 * Set dispatch_done to be true when there's no running task and no new WAL
	 * to dispatch.
	 *
	 * If dispatch done, bg_replayed_lsn need to be forwarded to
	 * GetXLogReplayRecPtr(NULL) to make it able to do the latest ckpt.
	 *
	 * Notice: we need to fetch GetXLogReplayRecPtr(NULL) at the very beginning,
	 * because WALs may be appended into logindex snapshot during our check.
	 * Forwarding to an improper RecPtr may skip the newly added WALs without
	 * replaying.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dispatch_done</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dispatch_done</name> <operator>=</operator> <call><name>polar_sched_empty_running_task</name><argument_list>(<argument><expr><name>sched_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dispatch_done</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_bg_redo_set_replayed_lsn</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>xlog_replayed_lsn</name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>max_dispatched_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s: forward bg_replayed_lsn to %lX"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>xlog_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>bg_replayed_lsn</name> <operator>=</operator> <call><name>polar_bg_redo_get_replayed_lsn</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>backend_min_lsn</name> <operator>=</operator> <call><name>polar_get_backend_min_replay_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name><operator>-&gt;</operator><name>promote_oldest_lsn</name></name> <operator>=</operator> <ternary><condition><expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>backend_min_lsn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>bg_replayed_lsn</name></expr> </then><else>: <expr><name>backend_min_lsn</name></expr></else></ternary></expr>;</expr_stmt>

	<return>return <expr><name>dispatch_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_logindex_bg_online_promote</name><parameter_list>(<parameter><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_hold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>dispatch_done</name> <init>= <expr><call><name>polar_logindex_bg_dispatch</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>can_hold</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dispatch_done</name> <operator>&amp;&amp;</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><call><name>polar_get_backend_min_replay_lsn</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_set_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>POLAR_BG_REDO_NOT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Request an (online) checkpoint now. This
		 * isn't required for consistency, but the last restartpoint might be far
		 * back, and in case of a crash, recovering from it might take a longer
		 * than is appropriate now that we're not in standby mode anymore.
		 */</comment>
		<expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Background process finished replay for online promote, last_replayed_end_lsn=%lX"</literal></expr></argument>,
			 <argument><expr><call><name>polar_bg_redo_get_replayed_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dispatch_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_logindex_redo_bg_replay</name><parameter_list>(<parameter><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_hold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>replay_done</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make sure we get background redo state */</comment>

	<expr_stmt><expr><operator>*</operator><name>can_hold</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>POLAR_BG_RO_BUF_REPLAYING</name></expr>:</case>
			<expr_stmt><expr><name>replay_done</name> <operator>=</operator> <call><name>polar_logindex_apply_xlog_background</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>POLAR_BG_PARALLEL_REPLAYING</name></expr>:</case>
			<expr_stmt><expr><name>replay_done</name> <operator>=</operator> <call><name>polar_logindex_bg_dispatch</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>can_hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>POLAR_BG_ONLINE_PROMOTE</name></expr>:</case>
			<expr_stmt><expr><name>replay_done</name> <operator>=</operator> <call><name>polar_logindex_bg_online_promote</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>can_hold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>replay_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_logindex_bg_promoted</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_REDO_NOT_START</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_redo_online_promote</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instance</name> <operator>||</operator> <operator>!</operator><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_online_promote</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_online_promote</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_redo_abort</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instance</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_abort_replaying_buffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_abort_mini_transaction</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>wal_page_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_release_page_iterator</name><argument_list>(<argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wal_page_iter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fullpage_page_iter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_release_page_iterator</name><argument_list>(<argument><expr><name>fullpage_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fullpage_page_iter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_redo_get_min_replay_from_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>consist_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>result</name> <init>= <expr><name>consist_lsn</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>      <name>bg_replayed_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instance</name> <operator>||</operator> <operator>!</operator><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This checkpoint lsn can avoid clear xlog when restore old fullpage */</comment>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_checkpoint_redo_lsn</name> <init>= <expr><call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>last_checkpoint_redo_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>last_checkpoint_redo_lsn</name> <operator>&lt;</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>last_checkpoint_redo_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>bg_replayed_lsn</name> <operator>=</operator> <call><name>polar_bg_redo_get_replayed_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bg_replayed_lsn</name> <operator>&lt;</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>bg_replayed_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Apply xlog for buffer which already acquired buffer io lock */</comment>
<function><type><name>bool</name></type>
<name>polar_logindex_io_lock_apply</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name></decl></parameter>,
							 <parameter><decl><type><name>XLogRecPtr</name></type> <name>replay_from</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>replay_from</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>lsn_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>InRecovery</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>reachedConsistency</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_BACKTRACE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"%s apply buffer before reached consistency %X/%X, "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>replay_from</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>replay_from</name></expr></argument>,
			 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>lsn_changed</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>BufferDescriptorGetBuffer</name><argument_list>(<argument><expr><name>buf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we read a future page, then restore old fullpage version and reset start_lsn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>polar_logindex_restore_fullpage_snapshot_if_needed</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name>checkpoint_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When it is read from disk, it doesn't lose any flashback log because that
	 * the flashback log is flushed to disk before the data page.
	 * Mark it flashback lost checked to ignore to check it again.
	 */</comment>
	<expr_stmt><expr><call><name>polar_set_buf_flog_lost_checked</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lsn_changed</name> <operator>=</operator> <call><name>polar_logindex_lock_apply_page_from</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buf_hdr</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we read buffer from storage and have no xlog to do replay, then it does not necessary to mark it dirty */</comment>
	<if_stmt><if>if <condition>(<expr><name>lsn_changed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_promote_mark_buf_dirty</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>lsn_changed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: 1. Read xlog record from xlog queue and save to logindex
 * 2. Remove unnecessary data from xlog queue
 * 3. Flush fullpage active logindex table
 */</comment>
<function><type><name>void</name></type>
<name>polar_logindex_rw_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_flush_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instance</name> <operator>||</operator> <operator>!</operator><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>record</name> <operator>=</operator> <call><name>polar_xlog_send_queue_record_pop</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_xlog_remove_payload</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_save_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>polar_xlog_send_queue_keep_data</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_flush_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
									   <argument><expr><name>polar_write_logindex_active_table_delay</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_logindex_flush_active_table</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_flush_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_set_bg_redo_state</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>bg_redo_state</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Set background replayed lsn.
 */</comment>
<function><type><name>void</name></type>
<name>polar_bg_redo_set_replayed_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Get background replayed lsn.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_bg_redo_get_replayed_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_set_last_replayed_read_ptr</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>last_replayed_read_ptr</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_get_last_replayed_read_ptr</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>last_replayed_read_ptr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_wakeup_bg_replay</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>read_ptr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>instance</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>state</name> <init>= <expr><name>POLAR_BG_REDO_NOT_START</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>last_replayed_read_ptr</name></name> <operator>=</operator> <name>read_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name> <operator>=</operator> <name>end_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>POLAR_ENABLE_PARALLEL_REPLAY_STANDBY_MODE</name><argument_list>()</argument_list></call> <operator>||</operator>
			<operator>(</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_enable_ro_prewarm</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>promote_oldest_lsn</name></name> <operator>=</operator> <name>end_ptr</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>state</name> <operator>=</operator> <name>POLAR_BG_PARALLEL_REPLAYING</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <name>POLAR_BG_RO_BUF_REPLAYING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>POLAR_BG_REDO_NOT_START</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_set_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>NOTIFY_LOGINDEX_BG_WORKER</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>bg_worker_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_ctl</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_fullpage_bgworker_wakeup</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_ctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_logindex_require_backend_redo</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>fork_num</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>replay_from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>required</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consist_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instance</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>required</name> <operator>=</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_PARALLEL_REPLAYING</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>replay_from</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>replay_from</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>consist_lsn</name> <operator>=</operator> <call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>required</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_ONLINE_PROMOTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name> <operator>&lt;=</operator> <name><name>instance</name><operator>-&gt;</operator><name>last_replayed_read_ptr</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>replay_from</name> <operator>=</operator> <name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>required</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_SET_BACKEND_READ_MIN_LSN</name><argument_list>(<argument><expr><operator>*</operator><name>replay_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>required</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>consist_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>replay_from</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>consist_lsn</name></expr></argument>, <argument><expr><operator>*</operator><name>replay_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>redo_lsn</name> <init>= <expr><call><name>GetRedoRecPtr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>POLAR_IN_PARALLEL_REPLAY_STANDBY_MODE</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * POLAR: When in standby_mode with parallel_replay_enabled, the
			 * replay_from lsn should be bg_replayed_lsn
			 */</comment>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>bg_replayed_lsn</name> <init>= <expr><call><name>polar_bg_redo_get_replayed_lsn</name><argument_list>(<argument><expr><name>polar_logindex_redo_instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>replay_from</name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>bg_replayed_lsn</name></expr> </then><else>: <expr><name>redo_lsn</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><operator>*</operator><name>replay_from</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POLAR_SET_BACKEND_READ_MIN_LSN</name><argument_list>(<argument><expr><operator>*</operator><name>replay_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * POLAR: After replication is terminated, RO doesn't know what happened to RW.
			 * Meanwhile, if RW is in recovery state, it would reflushed some data block to
			 * make page's lsn lower than consist_lsn. If RO read these old pages and replay
			 * them from consist_lsn, RO will PANIC! So, we don't want RO replay data block
			 * from consist_lsn after replication is not streaming.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>replay_from</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>consist_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>WalRcvStreaming</name><argument_list>()</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>consist_lsn</name></expr> </then><else>: <expr><name>redo_lsn</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>redo_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POLAR_SET_BACKEND_READ_MIN_LSN</name><argument_list>(<argument><expr><name>redo_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>required</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: set valid information to enable logindex parse.
 * set it only when logindex snapshot state is writable in current node.
 * For Primary/Standby node, logindex snapshot is writable
 * For Replica node, logindex snapshot is readonly
 * For Datamax node, logindex won't be enabled
 */</comment>
<function><type><name>void</name></type>
<name>polar_logindex_redo_set_valid_info</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_of_log</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call>
				<operator>&amp;&amp;</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><call><name>polar_logindex_check_valid_start_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_set_start_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>end_of_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><call><name>polar_logindex_check_valid_start_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_set_start_lsn</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>end_of_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_online_promote_fake_oldest_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>promote_oldest_lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>polar_logindex_redo_instance</name><operator>-&gt;</operator><name>promote_oldest_lsn</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_clean_redo_context</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>polar_redo_context</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>polar_redo_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_redo_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>MemoryContext</name></type>
<name>polar_get_redo_context</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>polar_redo_context</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>polar_redo_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"polar working context"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>polar_clean_redo_context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>polar_redo_context</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>get_parallel_replay_task_tag</name><parameter_list>(<parameter><decl><type><name>polar_task_node_t</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>parallel_replay_task_node_t</name> <modifier>*</modifier></type><name>parallel_task</name> <init>= <expr><operator>(</operator><name>parallel_replay_task_node_t</name> <operator>*</operator><operator>)</operator><name>task</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>parallel_task</name><operator>-&gt;</operator><name>tag</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parallel_replay_task_finished</name><parameter_list>(<parameter><decl><type><name>polar_task_sched_t</name> <modifier>*</modifier></type><name>sched</name></decl></parameter>, <parameter><decl><type><name>polar_task_node_t</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>parallel_replay_task_node_t</name> <modifier>*</modifier></type><name>parallel_task</name> <init>= <expr><operator>(</operator><name>parallel_replay_task_node_t</name> <operator>*</operator><operator>)</operator><name>task</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>parallel_replay_task_node_t</name> <modifier>*</modifier></type><name>parallel_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>head_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sched</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parallel_head</name> <operator>=</operator> <operator>(</operator><name>parallel_replay_task_node_t</name> <operator>*</operator><operator>)</operator><call><name>POLAR_SCHED_RUNNING_QUEUE_HEAD</name><argument_list>(<argument><expr><name>sched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>head_lsn</name> <operator>=</operator> <name><name>parallel_head</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sched</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>head_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>head_lsn</name> <operator>==</operator> <name><name>parallel_task</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name> <operator>&lt;</operator> <name><name>parallel_task</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>bg_replayed_lsn</name></name> <operator>=</operator> <name><name>parallel_task</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>instance</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>polar_xlog_need_replay</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>buf_replay_stat_t</name> <modifier>*</modifier></type><name>buf_stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_pin_buffer_for_replay</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>buf_stat</name> <operator>=</operator> <call><name>polar_buffer_need_replay</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf_stat</name> <operator>==</operator> <name>BUF_NEED_REPLAY</name> <operator>&amp;&amp;</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>consist_lsn</name> <init>= <expr><call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;</operator> <name>consist_lsn</name> <operator>&amp;&amp;</operator> <call><name>polar_evict_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"Evict buffer=%d when consist_lsn=%lX and xlog_lsn=%lX for "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
					 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>consist_lsn</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>buf_stat</name> <operator>=</operator> <name>BUF_IS_FLUSHED</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;</operator> <call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_stat</name> <operator>=</operator> <name>BUF_IS_FLUSHED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Don't replay this block if it's truncated or dropped */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>polar_check_rel_block_valid_only</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogReadBufferExtended</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>forkNum</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>RBM_NORMAL_NO_LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>buf_stat</name> <operator>=</operator> <name>BUF_NEED_REPLAY</name></expr>;</expr_stmt>

				<comment type="block">/* Mark the buffer no flashback log lost while read it from disk. */</comment>
				<expr_stmt><expr><call><name>polar_set_buf_flog_lost_checked</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_stat</name> <operator>=</operator> <name>BUF_IS_TRUNCATED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>POLAR_REL_SIZE_CACHE_LOCK</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handle_parallel_replay_task</name><parameter_list>(<parameter><decl><type><name>polar_task_sched_t</name> <modifier>*</modifier></type><name>sched</name></decl></parameter>, <parameter><decl><type><name>polar_task_node_t</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name> <init>= <expr><operator>(</operator><name>polar_logindex_redo_ctl_t</name><operator>)</operator><operator>(</operator><name><name>sched</name><operator>-&gt;</operator><name>run_arg</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>parallel_replay_task_node_t</name> <modifier>*</modifier></type><name>parallel_task</name> <init>= <expr><operator>(</operator><name>parallel_replay_task_node_t</name> <operator>*</operator><operator>)</operator><name>task</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>buf_replay_stat_t</name></type> <name>buf_stat</name> <init>= <expr><name>BUF_NEED_REPLAY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>handled</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instance</name> <operator>&amp;&amp;</operator> <name><name>instance</name><operator>-&gt;</operator><name>rel_size_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>state</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_allocate_xlog_reader</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_xlog_need_replay</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parallel_task</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name><name>parallel_task</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf_stat</name> <operator>==</operator> <name>BUF_NEED_REPLAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_bg_redo_apply_read_record</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>parallel_task</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parallel_task</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>buf_stat</name> <operator>==</operator> <name>BUF_IS_REPLAYING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>handled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>buf_stat</name> <operator>==</operator> <name>BUF_IS_REPLAYED</name> <operator>&amp;&amp;</operator> <call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_desc</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_lock_buffer_ext</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the buffer may lose some flashback log record,
		 * just insert it to flashback log list as a candidator.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_may_buf_lost_flog</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buf_desc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_flog_insert</name><argument_list>(<argument><expr><name>flog_instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_promote_mark_buf_dirty</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>parallel_task</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>handled</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parallel_replay_task_finished</name><argument_list>(<argument><expr><name>sched</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>handled</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parallel_replay_task_startup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>run_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* When do parallel replay we will exit process on any error */</comment>
	<expr_stmt><expr><name>ExitOnAnyError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>polar_bg_replaying_process</name> <operator>=</operator> <name>POLAR_LOGINDEX_PARALLEL_REPLAY</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure there's room for us to pin buffer */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerEnlargeBuffers</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>polar_task_sched_ctl_t</name> <modifier>*</modifier></type>
<name>polar_create_parallel_replay_sched_ctl</name><parameter_list>(<parameter><decl><type><name>polar_logindex_bg_redo_ctl_t</name> <modifier>*</modifier></type><name>bg_ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_task_sched_ctl_t</name> <modifier>*</modifier></type><name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name> <init>= <expr><name><name>bg_ctl</name><operator>-&gt;</operator><name>instance</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_sched_reg_handler</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>parallel_sched</name></name></expr></argument>, <argument><expr><name>parallel_replay_task_startup</name></expr></argument>, <argument><expr><name>handle_parallel_replay_task</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>get_parallel_replay_task_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <call><name>polar_create_task_sched_ctl</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>parallel_sched</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferTag</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ctl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_need_do_bg_replay</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>instance</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator>
           <call><name>polar_bg_redo_state_is_parallel</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set bg_replayed_lsn(bl) as old_consist_lsn(ol) if ol &lt; bl
 * Set the state of LogindexBgWriter as OnlinePromoting
 */</comment>
<function><type><name>void</name></type>
<name>polar_reset_bg_replayed_lsn</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>bg_replayed_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>new_bg_replayed_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>old_consist_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>old_til</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name> <init>= <expr><call><name>polar_get_oldest_applied_lsn</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>old_consist_lsn</name> <operator>=</operator> <call><name>polar_get_primary_consist_ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>old_consist_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GetOldestRestartPoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old_consist_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_til</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>old_consist_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>oldest_apply_lsn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>oldest_apply_lsn</name> <operator>&lt;</operator> <name>old_consist_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_set_oldest_applied_lsn</name><argument_list>(<argument><expr><name>old_consist_lsn</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bg_replayed_lsn</name> <operator>=</operator> <call><name>polar_bg_redo_get_replayed_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_bg_replayed_lsn</name> <operator>=</operator> <ternary><condition><expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>old_consist_lsn</name></expr> </then><else>:
						  <expr><call><name>Min</name><argument_list>(<argument><expr><name>old_consist_lsn</name></expr></argument>, <argument><expr><name>bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_bg_redo_set_replayed_lsn</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>new_bg_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instance</name><operator>-&gt;</operator><name>promote_oldest_lsn</name></name> <operator>=</operator> <name>new_bg_replayed_lsn</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_set_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>POLAR_BG_ONLINE_PROMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>bg_worker_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"startup complete online promote, and reset bg_replayed_lsn=%lX, old_consist_lsn=%lX"</literal></expr></argument>, <argument><expr><name>new_bg_replayed_lsn</name></expr></argument>, <argument><expr><name>old_consist_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_online_promote_data</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>oldest_active_xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_replayed_lsn</name> <init>= <expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Begin function %s"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: promote clog/commit_ts/multixact/csn
	 */</comment>
	<expr_stmt><expr><call><name>polar_promote_clog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_promote_commit_ts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_promote_multixact_offset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_promote_multixact_member</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_csn_enable</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_promote_csnlog</name><argument_list>(<argument><expr><name>oldest_active_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* reload persisted slot from polarstore */</comment>
	<expr_stmt><expr><call><name>polar_reload_replication_slots_from_shared_storage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: Notice: We don't support standby connect to ro node, so we can clear xlog queue data.
	 * For rw node xlog queue keep the latest wal meta
	 */</comment>
	<expr_stmt><expr><call><name>polar_ringbuf_reset</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_update_promoted_info</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>last_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_update_promoted_info</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>last_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"End function %s"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_standby_promote_data</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_replayed_lsn</name> <init>= <expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Begin function %s"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release reference in xlog_queue ringbuf, which is allocated during recovery */</comment>
	<expr_stmt><expr><call><name>polar_xlog_send_queue_release_data_ref</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear ringbuf, otherwise left WALs will be inserted into logindex twice */</comment>
	<expr_stmt><expr><call><name>polar_ringbuf_reset</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>xlog_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_update_promoted_info</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>last_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_update_promoted_info</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>fullpage_logindex_snapshot</name></name></expr></argument>, <argument><expr><name>last_replayed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"End function %s"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_wait_logindex_bg_stop_replay</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<comment type="block">/* Wait background process handle online promote signal */</comment>
	<while>while <condition>(<expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>POLAR_BG_WAITING_RESET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>latch</name></expr></argument>,
					   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
					   <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_RECOVERY_APPLY_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no cover begin */</comment>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* no cover end */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"background process handled online promote signal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: find the first XLOG_FPI/XLOG_FPI_MULTI/XLOG_FPI_FOR_HIN WAL record
 * from start_lsn to end_lsn - 1.
 *
 * start_lsn: The start lsn.
 * end_len: The end lsn.
 * tag: The buffer tag.
 * buffer: The buffer.
 * apply: apply it.
 *
 * Find the first record is XLOG_FPI/XLOG_FPI_MULTI/XLOG_FPI_FOR_HINT return true,
 * otherwise return false.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_find_first_fpi</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>,
		<parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>apply</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>end_lsn</name> <operator>&lt;=</operator> <name>start_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"The end WAL LSN %lX to find a full page image is "</literal>
				<literal type="string">"not larger than the start LSN %lX"</literal></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>lsn</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wal_page_iter</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Logindex record the start position of XLOG and we search LSN between [start_lsn, end_lsn].
	 * And end_lsn points to the end position of the last xlog, so we should subtract 1 here .
	 */</comment>
	<expr_stmt><expr><name>wal_page_iter</name> <operator>=</operator> <call><name>polar_logindex_create_page_iterator</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>wal_logindex_snapshot</name></name></expr></argument>,
			<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>polar_get_bg_redo_state</name><argument_list>(<argument><expr><name>instance</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_BG_ONLINE_PROMOTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>polar_logindex_page_iterator_state</name><argument_list>(<argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ITERATE_STATE_FINISHED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to iterate data for "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name> <literal type="string">", which start_lsn=%X/%X and end_lsn=%X/%X"</literal></expr></argument>,
			 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>start_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>start_lsn</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>end_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>iter_context</name> <operator>=</operator> <name>wal_page_iter</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>state</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>polar_allocate_xlog_reader</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lsn_info</name> <operator>=</operator> <call><name>polar_logindex_page_iterator_next</name><argument_list>(<argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type> <name>info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RmgrId</name></type> <name>rmid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_logindex_read_xlog</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rmid</name> <operator>=</operator> <call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>info</name> <operator>==</operator> <name>XLOG_FPI</name> <operator>||</operator> <name>info</name> <operator>==</operator> <name>XLOG_FPI_MULTI</name> <operator>||</operator> <name>info</name> <operator>==</operator> <name>XLOG_FPI_FOR_HINT</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>apply</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_logindex_apply_one_record</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"The first WAL record of "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name> <literal type="string">""</literal>
					<literal type="string">"from %lx to %lx is not a full page image"</literal></expr></argument>, <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>start_lsn</name></expr></argument>, <argument><expr><name>end_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_release_page_iterator</name><argument_list>(<argument><expr><name>wal_page_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal_page_iter</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>
</unit>
