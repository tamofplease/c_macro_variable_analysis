<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_queue_manager.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_queue_manager.c
 *      Polar logindex queuen manager
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *    src/backend/access/logindex/polar_queue_manager.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * We use queue to keep xlog meta info and clog record.
 * 1. In master mode there exists one send queue which keep xlog meta be sent to replica.
 *  1.1 When backend create XLOG record it reserve space from send queue in atomic way.
 *  1.2 When xlog meta space is reserved from queue backend processes save xlog meta parallelly.
 *  1.3 WAL writer process read xlog data from the queue and save to logindex table.
 *  1.3 WAL sender process read from the queue and send xlog meta to replica
 * 2. In replica mode there exists one recv queue.
 *  2.1 WAL receiver save received xlog meta to receive queue.
 *  2.2 Startup process parse xlog meta from the queue and save to logindex table.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gistxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_queue_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_ringbuf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>

<typedef>typedef <type><name>uint32</name></type> <name>main_data_len_t</name>;</typedef>
<typedef>typedef <type><name>uint8</name></type>  <name>block_id_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_MAIN_DATA_LEN</name><parameter_list>(<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(block_id_t) + sizeof(main_data_len_t) + (len))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>       <name>polar_xlog_queue_buffers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>   <name>xlog_queue_catch_up</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function><type><name>Size</name></type>
<name>polar_xlog_queue_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size_MB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* xlog queue size */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>size_MB</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>*</operator> <literal type="number">1024L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_xlog_remove_payload</name><parameter_list>(<parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RmgrId</name></type> <name>rmid</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>info</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>==</operator> <name>RM_HEAP_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_HEAP2_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_BTREE_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_HASH_ID</name>
			<operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_GIN_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_GIST_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_SEQ_ID</name>
			<operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_SPGIST_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_BRIN_ID</name> <operator>||</operator> <name>rmid</name> <operator>==</operator> <name>RM_GENERIC_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rmid</name> <operator>!=</operator> <name>RM_XLOG_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_FPI</name> <operator>&amp;&amp;</operator>
			<name>info</name> <operator>!=</operator> <name>XLOG_FPI_FOR_HINT</name> <operator>&amp;&amp;</operator>
			<name>info</name> <operator>!=</operator> <name>XLOG_FPSI</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Size</name></type>
<name>polar_reserve_main_data_size</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>polar_get_main_data_len</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_xlog_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fullpage_no */</comment>
		<case>case <expr><name>XLOG_FPSI</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_heap_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapInsert</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapDelete</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapUpdate</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapLock</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_heap2_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapClean</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapFreezePage</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapCleanupInfo</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapVisible</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapMultiInsert</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfHeapLockUpdated</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_REWRITE</name></expr>:</case>
			<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_heap_rewrite_mapping</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_gist_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name> <init>= <expr><call><name>polar_get_main_data_head</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_GIST_PAGE_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Flollowing function gistXLogUpdate to reserve size for gistxlogPageUpdate*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rdata</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rdata</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_reserve_main_data_size</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_hash_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_HASH_VACUUM_ONE_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_reserve_main_data_size</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_btree_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_BTREE_DELETE</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_REUSE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_main_data_size</name><argument_list>()</argument_list></call></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_spg_data_size</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>POLAR_MAIN_DATA_LEN</name><argument_list>(<argument><expr><name>SizeOfSpgxlogVacuumRedirect</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>polar_reserve_data_size</name><parameter_list>(<parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>rdata</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>info</name> <init>= <expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RM_HEAP_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_heap_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RM_HEAP2_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_heap2_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RM_GIST_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_gist_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RM_HASH_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_hash_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RM_BTREE_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_btree_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RM_SPGIST_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_spg_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RM_XLOG_ID</name></expr>:</case>
			<return>return <expr><call><name>polar_reserve_xlog_data_size</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>polar_xlog_reserve_size</name><parameter_list>(<parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>rdata</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><call><name>polar_xlog_remove_payload</name><argument_list>(<argument><expr><name>rechdr</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			   <expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name></expr> </then><else>: <expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>polar_reserve_data_size</name><argument_list>(<argument><expr><name>rdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>polar_ringbuf_t</name></type>
<name>polar_xlog_queue_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_MB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>POLAR_RINGBUF_MAX_SLOT</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CHAR_BIT</name></expr></argument>,
					 <argument><expr><literal type="string">"POLAR_RINGBUF_MAX_SLOT is larger than 64"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>polar_xlog_queue_size</name><argument_list>(<argument><expr><name>size_MB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>polar_ringbuf_init</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>tranche_id</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_WRITE_MAIN_DATA</name><parameter_list>(<parameter><type><name>queue</name></type></parameter>, <parameter><type><name>dlen</name></type></parameter>, <parameter><type><name>rbuf_pos</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		uint8 block_id = XLR_BLOCK_ID_POLAR_EXTRA; \
		XLogRecData *main_data = polar_get_main_data_head(); \
		uint8 *data = (uint8 *)(main_data-&gt;data); \
		main_data_len_t data_len = dlen; \
		if (rbuf_pos &lt; 0 || rbuf_pos &gt;= queue-&gt;size) \
			ereport(PANIC, (errmsg("rbuf_pos=%lu is incorrect for xlog queue, queue size is %lu", \
								   rbuf_pos, queue-&gt;size))); \
		len = polar_ringbuf_pkt_write(queue, rbuf_pos, \
									  offset, (uint8 *)(&amp;block_id), sizeof(block_id_t)); \
		len += polar_ringbuf_pkt_write(queue, rbuf_pos, \
									   offset+len, (uint8 *)(&amp;data_len), sizeof(data_len)); \
		len += polar_ringbuf_pkt_write(queue, rbuf_pos, \
									   offset+len, (uint8 *)(data), data_len); \
	} while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_heap_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapInsert</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapDelete</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapUpdate</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapLock</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_heap2_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapClean</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapFreezePage</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapCleanupInfo</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapVisible</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapMultiInsert</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfHeapLockUpdated</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_REWRITE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_heap_rewrite_mapping</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_push_main_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>main_data_len_t</name></type> <name>data_len</name> <init>= <expr><call><name>polar_reserve_main_data_size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>block_id</name> <init>= <expr><name>XLR_BLOCK_ID_POLAR_EXTRA</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name> <init>= <expr><call><name>polar_get_main_data_head</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rbuf_pos</name> <operator>&gt;=</operator> <name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rbuf_pos=%ld is incorrect for xlog queue, xlog_queue_size=%ld"</literal></expr></argument>,
							   <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>,
								  <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>block_id</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>block_id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>,
								   <argument><expr><name>offset</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>data_len</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>data_len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>,
									   <argument><expr><name>offset</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>rdata</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdata</name> <operator>=</operator> <name><name>rdata</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_gist_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name> <init>= <expr><call><name>polar_get_main_data_head</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_GIST_PAGE_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Following function gistXLogUpdate to reserve size for gistxlogPageUpdate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rdata</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rdata</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_push_main_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_hash_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_HASH_VACUUM_ONE_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_push_main_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_btree_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_BTREE_DELETE</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_REUSE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_push_main_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_spg_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>SizeOfSpgxlogVacuumRedirect</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_push_xlog_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>!=</operator> <name>XLOG_FPSI</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_WRITE_MAIN_DATA</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_xlog_send_queue_push_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>XLogRecData</name></name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name><name>rdata</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>info</name> <init>= <expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RM_HEAP_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_heap_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_HEAP2_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_heap2_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_GIST_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_gist_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_HASH_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_hash_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_BTREE_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_btree_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_SPGIST_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_spg_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_XLOG_ID</name></expr>:</case>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>polar_xlog_push_xlog_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_xlog_send_queue_push</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rbuf_pos</name></decl></parameter>, <parameter><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>copy_len</name></decl></parameter>,
						   <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>xlog_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>data_size</name> <init>= <expr><call><name>polar_reserve_data_size</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecData</name> <modifier>*</modifier></type><name>rdata</name> <init>= <expr><name>record</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rbuf_pos</name> <operator>&gt;=</operator> <name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rbuf_pos=%ld is incorrect for xlog queue, xlog_queu_size=%ld"</literal></expr></argument>,
							   <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>,
									  <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>end_lsn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>end_lsn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>,
									  <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlog_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlog_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>copy_len</name> <operator>-</operator> <name>data_size</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>rdata</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: In case, rdata-&gt;len is bigger than (copy_len - data_size). */</comment>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>write_len</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>copy_len</name> <operator>-</operator> <name>data_size</name></expr></argument>, <argument><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>copy_size</name> <init>= <expr><call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>,
													<argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>rdata</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></argument>, <argument><expr><name>write_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>copy_size</name> <operator>!=</operator> <name>write_len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to write packet to ringbuf, rbuf_pos=%lu, offset=%d, copy_size=%ld, rdata_len=%u"</literal></expr></argument>,
				 <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>copy_size</name></expr></argument>, <argument><expr><name><name>rdata</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>write_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_len</name> <operator>-=</operator> <name>write_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdata</name> <operator>=</operator> <name><name>rdata</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>copy_len</name> <operator>-=</operator> <call><name>polar_xlog_send_queue_push_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>copy_len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to push data to send queue, rbuf_pos=%lu, offset=%d, left=%d"</literal></expr></argument>,
			 <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_ringbuf_set_pkt_flag</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>rbuf_pos</name></expr></argument>, <argument><expr><name>POLAR_RINGBUF_PKT_WAL_META</name> <operator>|</operator> <name>POLAR_RINGBUF_PKT_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s lsn=%x/%x"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>end_lsn</name> <operator>-</operator> <name>xlog_len</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>end_lsn</name> <operator>-</operator> <name>xlog_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Create XLOG meta and push them into polar_xlog_queue in startup.
 * The caller must make sure that polar_xlog_queue is enable.
 */</comment>
<function><type><name>void</name></type>
<name>polar_standby_xlog_send_queue_push</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>StartPos</name> <init>= <expr><name><name>xlogreader</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>EndPos</name> <init>= <expr><name><name>xlogreader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>     <name>RbufPos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>RbufLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecData</name></type> <name>rdata</name> <init>=
	<expr><block>{
		<expr><operator>.</operator><name>next</name> <operator>=</operator> <name>NULL</name></expr>,
		<expr><operator>.</operator><name>data</name> <operator>=</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>,
		<expr><operator>.</operator><name>len</name>  <operator>=</operator> <name><name>xlogreader</name><operator>-&gt;</operator><name>polar_logindex_meta_size</name></name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_xlog_send_queue_keep_data</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR END */</comment>
	<expr_stmt><expr><call><name>polar_set_main_data</name><argument_list>(<argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>, <argument><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>main_data_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>RbufLen</name> <operator>=</operator> <call><name>polar_xlog_reserve_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_XLOG_QUEUE_FREE_SIZE</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>RbufLen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_XLOG_QUEUE_FREE_UP</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>RbufLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>RbufPos</name> <operator>=</operator> <call><name>POLAR_XLOG_QUEUE_RESERVE</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>RbufLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_XLOG_QUEUE_SET_PKT_LEN</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>RbufPos</name></expr></argument>, <argument><expr><name>RbufLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: Make rdata contain the whole xlog. */</comment>
	<expr_stmt><expr><name><name>rdata</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>EndPos</name> <operator>-</operator> <name>StartPos</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_xlog_send_queue_push</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>RbufPos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rdata</name></expr></argument>, <argument><expr><name>RbufLen</name></expr></argument>, <argument><expr><name>EndPos</name></expr></argument>, <argument><expr><name>EndPos</name> <operator>-</operator> <name>StartPos</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WalSndWakeup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s push %X/%X to queue"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>EndPos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>EndPos</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_reset_main_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_xlog_send_queue_next_lsn</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>pktlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>POLAR_RINGBUF_PKT_INVALID_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pktlen</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_ringbuf_read_next_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>pktlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type>
<name>polar_xlog_send_queue_raw_data_pop</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,
								   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>max_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>copy_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>  <name>free_size</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>POLAR_RINGBUF_PKT_INVALID_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * When walreceiver decode data from queue, it read pktlen first and then read packet data,
		 * so free space must be large enough to include uint32 which save pktlen and data which size is
		 * pktlen.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pktlen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>free_size</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_read_next_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Pop XLOG which is already been written out and flushed to disk.
		 * It's unsafe to send XLOG that is not securely down to disk on the master:
		 * if the master crashes and restarts, replica must not hava applied any XLOG
		 * that got lost on the master.
		 * Note: We record end position of XLOG in the queue
		 *
		 * POLAR: Flush lsn is not updated in recovery mode, especially for replica and standby.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <call><name>POLAR_LOGINDEX_FLUSHABLE_LSN</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>polar_ringbuf_read_next_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>pktlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <name>pktlen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>xlog_len</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlog_len</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlog_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s lsn=%x/%x"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lsn</name> <operator>-</operator> <name>xlog_len</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>-</operator> <name>xlog_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>pktlen</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_size</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>free_size</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>max_lsn</name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>copy_size</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">//TODO: recheck logical</comment>
<function><type><name>bool</name></type>
<name>polar_xlog_send_queue_check</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_point</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>     <name>lsn_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>       <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>start_point</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 1. If it's weak reference, try to promote to strong reference
	 * 2. If reference is evicted, then create a new weak reference and promote new weak reference to strong reference.
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>strong</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_ringbuf_get_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_XLOG_QUEUE_NEW_REF</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>rbuf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>ref_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal>
				<operator>||</operator> <operator>(</operator><operator>(</operator><name>type</name> <operator>=</operator> <call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>POLAR_RINGBUF_PKT_INVALID_TYPE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>POLAR_RINGBUF_PKT_WAL_META</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_read_next_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
					<operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to read LSN from ringbuf for ref %s"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>ref_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_read_next_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>lsn_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
					<operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to read lsn_len from ringbuf for ref %s"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>ref_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name>lsn</name> <operator>-</operator> <name>lsn_len</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>start_lsn</name> <operator>&lt;=</operator> <name>start_point</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ret</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polar_xlog_queue_check succeed for ref %s, start_point = %lx"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>ref_name</name></name></expr></argument>, <argument><expr><name>start_point</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>start_lsn</name> <operator>&gt;=</operator> <name>start_point</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>true</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ref</name><operator>-&gt;</operator><name>strong</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_ringbuf_clear_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_xlog_queue_update_reader</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>read_rec_ptr</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_rec_ptr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>data_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>read_page_ptr</name> <init>= <expr><name>read_rec_ptr</name> <operator>-</operator> <operator>(</operator><name>read_rec_ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>end_page_ptr</name> <init>= <expr><name>end_rec_ptr</name> <operator>-</operator> <operator>(</operator><name>end_rec_ptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>  <name>target_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>target_page_off</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>=</operator> <name>data_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>end_rec_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>read_rec_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>noPayload</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>read_page_ptr</name> <operator>!=</operator> <name>end_page_ptr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>end_page_ptr</name></expr></argument>, <argument><expr><name>target_seg_no</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wal_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>target_page_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>read_page_ptr</name></expr></argument>, <argument><expr><name>target_seg_no</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wal_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>target_page_off</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>read_page_ptr</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>wal_segment_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name> <operator>=</operator> <name>target_seg_no</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readOff</name></name> <operator>=</operator> <name>target_page_off</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>latestPagePtr</name></name> <operator>=</operator> <name>end_page_ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>polar_xlog_queue_remove_outdate</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>xlog_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>read_rec_ptr</name></decl>, <decl><type ref="prev"/><name>end_rec_ptr</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_rec_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlog_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_rec_ptr</name> <operator>=</operator> <name>end_rec_ptr</name> <operator>-</operator> <name>xlog_len</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>read_rec_ptr</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block>
	while <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>POLAR_RINGBUF_PKT_WAL_META</name></expr>)</condition>;</do>

	<return>return <expr><name>read_rec_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type>
<name>polar_xlog_queue_pop_record</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pktlen</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>decode_payload</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>xlog_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>read_rec_ptr</name></decl>, <decl><type ref="prev"/><name>end_rec_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_rec_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlog_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>read_rec_ptr</name> <operator>=</operator> <name>end_rec_ptr</name> <operator>-</operator> <name>xlog_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <name>pktlen</name> <operator>-</operator> <name>POLAR_XLOG_HEAD_SIZE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>data_len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>allocate_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_xlog_queue_update_reader</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>read_rec_ptr</name></expr></argument>, <argument><expr><name>end_rec_ptr</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_xlog_queue_decode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>decode_payload</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type>
<name>polar_xlog_queue_ref_pop</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>decode_payload</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>  <name>pkt_type</name> <init>= <expr><name>POLAR_RINGBUF_PKT_INVALID_TYPE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pkt_type</name> <operator>=</operator> <call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>pkt_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>POLAR_RINGBUF_PKT_WAL_META</name></expr>:</case>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>xlog_queue_catch_up</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>catch_up_ptr</name> <init>= <expr><call><name>polar_xlog_queue_remove_outdate</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* The record in queue is same as the record read from file */</comment>
				<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>==</operator> <name>catch_up_ptr</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>xlog_queue_catch_up</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Polar: switch xlog record source from file to queue when catch_up_ptr=%lX"</literal></expr></argument>, <argument><expr><name>catch_up_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>polar_xlog_queue_pop_record</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>pktlen</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>decode_payload</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>POLAR_RINGBUF_PKT_WAL_STORAGE_BEGIN</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_reset_xlog_source</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>xlog_queue_catch_up</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>xlog_queue_catch_up</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Polar: switch xlog record source from queue to file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>POLAR_RINGBUF_PKT_INVALID_TYPE</name></expr>:</case>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlog_queue_catch_up</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Polar: Invalid xlog queue pkt type %d"</literal></expr></argument>, <argument><expr><name>pkt_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s lsn=%x/%x"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_reset_blk</name><parameter_list>(<parameter><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_reset_decoder</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>block_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>block_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>;</condition> <incr><expr><name>block_id</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_reset_blk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_save_vm_block</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>vm_block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vm_blk</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>block_id</name> <operator>&lt;=</operator> <name>XLR_MAX_BLOCK_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blk</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vm_blk</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>vm_block_id</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>vm_blk</name><operator>-&gt;</operator><name>in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_reset_blk</name><argument_list>(<argument><expr><name>vm_blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vm_blk</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vm_blk</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vm_blk</name><operator>-&gt;</operator><name>forknum</name></name> <operator>=</operator> <name>VISIBILITYMAP_FORKNUM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vm_blk</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>blk</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr></argument>, <argument><expr><name>vm_block_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_update_save_vm_logindex</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hotupdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno_old</name></decl>, <decl><type ref="prev"/><name>blkno_new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_update</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_update</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>in_use</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno_new</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>in_use</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* HOT updates are never done across pages */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>hotupdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>blkno_old</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>blkno_old</name> <operator>=</operator> <name>blkno_new</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkno_new</name> <operator>!=</operator> <name>blkno_old</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_xlog_queue_decode_heap</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>info</name> <init>= <expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_insert</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_delete</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_update_save_vm_logindex</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_update_save_vm_logindex</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_lock</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_xlog_queue_decode_heap2</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>info</name> <init>= <expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_lock_updated</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock_updated</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_heap_save_vm_block</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_xlog_decode_data</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>rechdr</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rechdr</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RM_HEAP_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_xlog_queue_decode_heap</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RM_HEAP2_ID</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_xlog_queue_decode_heap2</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_xlog_queue_decode</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>decode_payload</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_CONTENT</name><parameter_list>(<parameter><type><name>_dst</name></type></parameter>, <parameter><type><name>_size</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do {\
		if((state-&gt;readLen - offset) &lt; (_size)) \
		{ \
			POLAR_LOG_XLOG_RECORD_INFO(state); \
			ereport(PANIC, (errmsg("polar: Failed to read from xlog send queue from offset %ld and size %ld, the remaining size is %ld", \
								   offset, (long)(_size), state-&gt;readLen - offset))); \
		} \
		memcpy(_dst, ptr + offset, _size); \
		offset += (_size); \
	} while (0)</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>uint8</name></type>  <name>block_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name>     <modifier>*</modifier></type><name>rnode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>record</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_reset_decoder</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_xlog_remove_payload</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>decoded_record</name></name> <operator>=</operator> <name>record</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readLen</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DecodedBkpBlock</name> <modifier>*</modifier></type><name>blk</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block_id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>block_id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_DATA_SHORT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint8</name></type> <name>data_len</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_DATA_LONG</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type> <name>data_len</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_ORIGIN</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RepOriginId</name></type> <name>id</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RepOriginId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>block_id</name> <operator>==</operator> <name>XLR_BLOCK_ID_POLAR_EXTRA</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>main_data_len_t</name></type> <name>data_len</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>data_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>=</operator> <name>data_len</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr></argument>,
															  <argument><expr><name>BLCKSZ</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_bufsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data</name></name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rmid=%d info=%d main_data_len=%d"</literal></expr></argument>,
											 <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name></expr></argument>,
											 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>main_data_len</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>block_id</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"polar: xlog queue out-of-order block_id %u and %X/%X"</literal></expr></argument>,
									  <argument><expr><name>block_id</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>max_block_id</name></name> <operator>=</operator> <name>block_id</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>blk</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>block_id</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>forknum</name></name> <operator>=</operator> <name><name>blk</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BKPBLOCK_FORK_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BKPBLOCK_HAS_IMAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BKPBLOCK_HAS_DATA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* cross-check that the HAS_DATA flag is set if data_len&gt;0 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>&amp;&amp;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"polar: xlog queue BKPBLOCK_HAS_DATA set, but no data included at block_id %u and %X/%X"</literal></expr></argument>,
									  <argument><expr><name>block_id</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blk</name><operator>-&gt;</operator><name>has_data</name></name> <operator>&amp;&amp;</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
									  <argument><expr><literal type="string">"polar: xlog queue BKPBLOCK_HAS_DATA not set, but data len is %d included at block_id %u and %X/%X"</literal></expr></argument>,
									  <argument><expr><name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
									  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>has_image</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>apply_image</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_APPLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * cross-check that hole_offset &gt; 0, hole_length &gt; 0 and
				 * bimg_len &lt; BLCKSZ if the HAS_HOLE flag is set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
						<operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>==</operator> <name>BLCKSZ</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>

					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"polar: xlog queue BKPIMAGE_HAS_HOLE set ,but hole offset %u length %u block image length %u at block_id %u and %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>,
										  <argument><expr><name>block_id</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * cross-check that hole_offset == 0 and hole_length == 0 if
				 * the HAS_HOLE flag is not set.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
						<operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"polar: xlog queue BKPIMAGE_HAS_HOLE not set, but hole offset %u length %u at block_id %u and %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_offset</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>hole_length</name></name></expr></argument>,
										  <argument><expr><name>block_id</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * cross-check that bimg_len &lt; BLCKSZ if the IS_COMPRESSED
				 * flag is set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name><operator>)</operator> <operator>&amp;&amp;</operator>
						<name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>==</operator> <name>BLCKSZ</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"polar: xlog queue BKPIMAGE_IS_COMPRESSED set , but block image length %u at block_id %u and %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name></expr></argument>,
										  <argument><expr><name>block_id</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * cross-check that bimg_len = BLCKSZ if neither HAS_HOLE nor
				 * IS_COMPRESSED flag is set.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_HAS_HOLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
						<operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>bimg_info</name></name> <operator>&amp;</operator> <name>BKPIMAGE_IS_COMPRESSED</name><operator>)</operator> <operator>&amp;&amp;</operator>
						<name><name>blk</name><operator>-&gt;</operator><name>bimg_len</name></name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"polar: xlog queue neither BKPIMAGE_HAS_HOLE nor BKPIMAGE_IS_COMPRESSED set, but block image length is %u at block_id %u and %X/%X"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>blk</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>,
										  <argument><expr><name>block_id</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>blk</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BKPBLOCK_SAME_REL</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rnode</name> <operator>=</operator> <operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>report_invalid_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
										  <argument><expr><literal type="string">"polar: xlog queue BKPBLOCK_SAME_REL set but no previous rel at block_id %u and %X/%X"</literal></expr></argument>,
										  <argument><expr><name>block_id</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
										  <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>err</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>blk</name><operator>-&gt;</operator><name>rnode</name></name> <operator>=</operator> <operator>*</operator><name>rnode</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>COPY_CONTENT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>blk</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>polar_xlog_decode_data</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>decode_payload</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>DecodeXLogRecord</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>

<label><name>err</name>:</label>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecord</name> <modifier>*</modifier></type>
<name>polar_xlog_send_queue_record_pop</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>pkt_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errormsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>polar_ringbuf_ref_t</name></type> <name>ref</name> <init>= <expr><block>{ <expr><operator>.</operator><name>slot</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>ref</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_XLOG_QUEUE_NEW_REF</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"rw_xlog_queue_record_pop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xlog_queue_catch_up</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <operator>(</operator><name>pkt_type</name> <operator>=</operator> <call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>POLAR_RINGBUF_PKT_INVALID_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pkt_type</name> <operator>!=</operator> <name>POLAR_RINGBUF_PKT_WAL_META</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"For xlog send queue there should be only WAL META, but we got %d from ref %s"</literal></expr></argument>,
				 <argument><expr><name>pkt_type</name></expr></argument>, <argument><expr><name><name>ref</name><operator>.</operator><name>ref_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_read_next_pkt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Master save logindex when xlog is flushed */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>polar_xlog_queue_ref_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errormsg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Got errormsg when pop xlog queue: %s"</literal></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to pop record from xlog queue from ref %s"</literal></expr></argument>, <argument><expr><name><name>ref</name><operator>.</operator><name>ref_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>polar_ringbuf_ref_t</name></type> <name>polar_data_ref</name> <init>= <expr><block>{ <expr><operator>.</operator><name>slot</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>polar_xlog_send_queue_keep_data</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>polar_data_ref</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_XLOG_QUEUE_NEW_REF</name><argument_list>(<argument><expr><operator>&amp;</operator><name>polar_data_ref</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"xlog_queue_data_keep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>polar_data_ref</name><operator>.</operator><name>rbuf</name></name> <operator>==</operator> <name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_ringbuf_ref_keep_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>polar_data_ref</name></expr></argument>, <argument><expr><name>POLAR_XLOG_QUEUE_DATA_KEEP_RATIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_xlog_send_queue_release_data_ref</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>polar_data_ref</name><operator>.</operator><name>slot</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_ringbuf_release_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>polar_data_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_xlog_recv_queue_push_storage_begin</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>polar_interrupt_callback</name></type> <name>callback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>polar_ringbuf_free_size</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>POLAR_RINGBUF_PKTHDRSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_ringbuf_free_up</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>POLAR_RINGBUF_PKTHDRSIZE</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>polar_ringbuf_pkt_reserve</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>POLAR_RINGBUF_PKTHDRSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to reserve space from xlog recv queue for storage packet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_ringbuf_set_pkt_length</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_ringbuf_set_pkt_flag</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>POLAR_RINGBUF_PKT_WAL_STORAGE_BEGIN</name> <operator>|</operator> <name>POLAR_RINGBUF_PKT_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_xlog_recv_queue_push</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>polar_interrupt_callback</name></type> <name>callback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>copy_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>write_len</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>polar_ringbuf_free_size</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>POLAR_RINGBUF_PKT_SIZE</name><argument_list>(<argument><expr><name>pktlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_ringbuf_free_up</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><call><name>POLAR_RINGBUF_PKT_SIZE</name><argument_list>(<argument><expr><name>pktlen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>polar_ringbuf_pkt_reserve</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><call><name>POLAR_RINGBUF_PKT_SIZE</name><argument_list>(<argument><expr><name>pktlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx</name> <operator>&gt;=</operator> <name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to reserve space from xlog recv queue, idx=%ld, queue size=%ld"</literal></expr></argument>,
								   <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_set_pkt_length</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>pktlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>write_len</name> <operator>=</operator> <call><name>polar_ringbuf_pkt_write</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>pktlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>!=</operator> <name>pktlen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to copy xlog recv queue, idx=%ld, queue size=%ld, pktlen=%d and write_len=%d"</literal></expr></argument>,
								   <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>pktlen</name></expr></argument>, <argument><expr><name>write_len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_set_pkt_flag</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>POLAR_RINGBUF_PKT_WAL_META</name> <operator>|</operator> <name>POLAR_RINGBUF_PKT_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_enable_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>  <name>xlog_len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlog_len</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlog_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s lsn=%x/%x"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lsn</name> <operator>-</operator> <name>xlog_len</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>-</operator> <name>xlog_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>write_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_len</name> <operator>+=</operator> <name>write_len</name></expr>;</expr_stmt>

	</block_content>}</block>
	while <condition>(<expr><name>copy_len</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>copy_len</name> <operator>!=</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to copy xlog recv queue, idx=%ld, queue size=%ld, len=%ld and copy_len=%ld"</literal></expr></argument>,
							   <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_xlog_recv_queue_check</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>%</operator> <name><name>state</name><operator>-&gt;</operator><name>wal_segment_size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name><operator>)</operator> <operator>==</operator> <name>SizeOfXLogLongPHD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>%</operator> <name>XLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name><operator>)</operator> <operator>==</operator> <name>SizeOfXLogShortPHD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecord</name> <modifier>*</modifier></type>
<name>polar_xlog_recv_queue_pop</name><parameter_list>(<parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>RecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>err_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>streaming_reply_sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>polar_ringbuf_ref_t</name></type> <name>ref</name> <init>= <expr><block>{ <expr><operator>.</operator><name>slot</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl> ;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>last_read_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>xlogfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>activitymsg</name><index>[<expr><name>MAXFNAMELEN</name> <operator>+</operator> <literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>ref</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_ringbuf_new_ref</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><literal type="string">"recv_queue_ref"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_XLOG_RECORD_INFO</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to get ref from xlog recv queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_ringbuf_auto_release_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xlog_queue_catch_up</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>RecPtr</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>RecPtr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>=</operator> <name>RecPtr</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>record</name> <operator>=</operator> <call><name>polar_xlog_queue_ref_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since we have replayed everything we have received so
		 * far and are about to start waiting for more WAL, let's
		 * tell the upstream server our replay location now so
		 * that pg_stat_replication doesn't show stale
		 * information.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>streaming_reply_sent</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WalRcvForceReply</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>streaming_reply_sent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Handle interrupts of startup process */</comment>
			<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CheckForStandbyTrigger</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>xlog_queue_catch_up</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Force to read from wal file to check we read all xlog record if we read from xlog queue previously*/</comment>
					<expr_stmt><expr><call><name>polar_xlog_recv_queue_push_storage_begin</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>polar_ringbuf_release_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ref</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>WalRcvStreaming</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* POLAR: In shared storage, we need wal receiver to communicate with rw node, so keep it up. */</comment>
				<expr_stmt><expr><call><name>polar_keep_wal_receiver_up</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * POLAR: If wal streaming is running either null from xlog queue or read from file means
				 * we can get new xlog record from xlog queue in the next step
				 */</comment>
				<expr_stmt><expr><name>xlog_queue_catch_up</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>errormsg</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>!=</operator> <name>err_lsn</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>err_lsn</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Get error xlog, lsn=%lX errormsg=%s"</literal></expr></argument>, <argument><expr><name>err_lsn</name></expr></argument>, <argument><expr><operator>*</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_wait_primary_xlog_message</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_xlog_recv_queue_check</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"xlog queue pop unmatched record: currRecPtr=%lX, ReadRecPtr=%lX, check whether it's CHECKPOINT_SHUTDOWN"</literal></expr></argument>,
				 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_update_receipt_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_set_read_and_end_rec_ptr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: In shared storage, we need wal receiver to communicate with rw node, so keep it up. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlog_queue_catch_up</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_keep_wal_receiver_up</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: If last read segment number is updated, so report it in PS display inside startup process. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name> <operator>!=</operator> <name>last_read_segno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readPageTLI</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"recovering %s"</literal></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_read_segno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readSegNo</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>
</unit>
