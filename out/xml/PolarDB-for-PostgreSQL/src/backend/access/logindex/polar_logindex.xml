<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_logindex.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_logindex.c
 *   Implementation of parse xlog states and replay.
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *    src/backend/access/logindex/polar_logindex.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_crc32c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hashutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>log_index_io_err_t</name></type>       <name>logindex_io_err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>                      <name>logindex_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_index_insert_new_item</name><parameter_list>(<parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>log_seg_id_t</name></type> <name>new_item_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_index_insert_new_seg</name><parameter_list>(<parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_seg_id_t</name></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>log_seg_id_t</name></type> <name>seg_id</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>bool</name></type>
<name>polar_logindex_check_state</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MemoryContext</name></type>
<name>polar_logindex_memory_context</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										<argument><expr><literal type="string">"logindex snapshot mem context"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>context</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>log_index_item_max_lsn</name><parameter_list>(<parameter><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_item_seg_t</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>head_seg</name></name> <operator>==</operator> <name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>LOG_INDEX_SEG_MAX_LSN</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>log_index_item_seg</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>LOG_INDEX_SEG_MAX_LSN</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>log_index_mem_tbl_shmem_size</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>logindex_mem_tbl_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>log_index_snapshot_t</name></expr></argument>, <argument><expr><name>mem_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_mem_table_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The number of logindex memory table is at least 3 */</comment>
	<if_stmt><if>if <condition>(<expr><name>logindex_mem_tbl_size</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"The number=%ld of logindex memory table is less than 3"</literal></expr></argument>, <argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The total log index memory table size is %ld"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>log_index_bloom_shmem_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>bloom_blocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>  <name>size</name> <init>= <expr><call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>bloom_blocks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>log_index_lwlock_shmem_size</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>logindex_mem_tbl_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LWLockMinimallyPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>LOG_INDEX_LWLOCK_NUM</name><argument_list>(<argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>polar_logindex_shmem_size</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>logindex_mem_tbl_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bloom_blocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>log_index_mem_tbl_shmem_size</name><argument_list>(<argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>log_index_bloom_shmem_size</name><argument_list>(<argument><expr><name>bloom_blocks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>log_index_lwlock_shmem_size</name><argument_list>(<argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_table_saved_before_promote</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_promoted_info_t</name> <modifier>*</modifier></type><name>promoted_info</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>promoted_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>saved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_tid</name></name> <operator>!=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_tid</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_tid</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name> <operator>!=</operator> <name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"promote last table max_lsn=%lX, max lsn saved by old rw is %lX"</literal></expr></argument>,
					 <argument><expr><name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr></argument>, <argument><expr><name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>saved</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_flush_table</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flush_active</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>mid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_flush</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>succeed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>flushed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>write_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_flush_max_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mid</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name> <init>= <expr><name>LOG_INDEX_TABLE_INVALID_ID</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>table_min_lsn</name></decl>, <decl><type ref="prev"/><name>table_max_lsn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name> <operator>||</operator>
				<operator>(</operator><name>flush_active</name> <operator>&amp;&amp;</operator>
				 <call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>LOG_INDEX_MEM_TBL_IS_NEW</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lock</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Nothing to change since last flush table */</comment>
			<if_stmt><if>if <condition>(<expr><name>flush_active</name> <operator>&amp;&amp;</operator>
					<call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name> <operator>&amp;&amp;</operator>
					<name>last_flush_max_lsn</name> <operator>==</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>LOG_INDEX_MEM_TBL_IS_NEW</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>write_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check state again, it may be force flushed by other process.
			 * During crash recovery GetFlushRecPtr return invalid value, so we compare
			 * with GetXLogReplayRecPtr().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name> <operator>||</operator>
					<call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name><operator>)</operator>
					<operator>&amp;&amp;</operator> <call><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>table_flushable</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>extra_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * After promoting don't write table which was flushed by previous rw node
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>log_index_table_saved_before_promote</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>succeed</name> <operator>=</operator> <call><name>log_index_write_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>succeed</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Only inactive table can set FLUSHED */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* save last flush fullpage logindex max_lsn for active table */</comment>
					<if_stmt><if>if <condition>(<expr><name>flush_active</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>last_flush_max_lsn</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>flushed</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>table_max_lsn</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>table_min_lsn</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>min_lsn</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"flush logindex tid=%ld,min_lsn=%lX,max_lsn=%lX"</literal></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>table_min_lsn</name></expr></argument>, <argument><expr><name>table_max_lsn</name></expr></argument>)</argument_list></call><operator>,</operator>
														   <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
														   <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If checkpoint lsn is valid we will flush all table which state is INACTIVE
		 * and table's lsn is smaller than checkpoint lsn.
		 * If consistent lsn is larger than max saved logindex lsn, we will try to flush table until saved logindex lsn
		 * is larger than consistent lsn.
		 * Otherwise we will try to flush all INACTIVE table, but don't flush table number more
		 * than polar_logindex_table_batch_size.
		 */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>need_flush</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_flush</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>checkpoint_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>need_flush</name> <operator>=</operator> <name>flushed</name> <operator>&lt;</operator> <name>polar_logindex_table_batch_size</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>need_flush</name> <operator>=</operator> <operator>(</operator><name>checkpoint_lsn</name> <operator>&gt;</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name>
							  <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>checkpoint_lsn</name> <operator>&gt;=</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>min_lsn</name></name> <operator>&amp;&amp;</operator> <name>checkpoint_lsn</name> <operator>&lt;=</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>write_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>mid</name> <operator>%=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>need_flush</name></expr>)</condition>;</do>

	<return>return <expr><name>write_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_rw_bg_write</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>log_index_flush_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_flush_table</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>log_index_flush_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_flush_active_table</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>log_index_flush_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_invalid_bloom_cache</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pageno</name> <init>= <expr><call><name>LOG_INDEX_TBL_BLOOM_PAGE_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_slru_invalid_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_logindex_local_cache_seg2str</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>seg_str</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOG_INDEX_LOCAL_CACHE_SEG_NAME</name><argument_list>(<argument><expr><name>seg_str</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_logindex_local_cache_scan_callback</name><parameter_list>(<parameter><decl><type><name>polar_local_cache</name></type> <name>cache</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cache_file</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>cur_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>suffix</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>cache_file</name></expr></argument>, <argument><expr><literal type="string">"%016lX%4s"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur_segno</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>, <argument><expr><literal type="string">".tbl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cur_segno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cur_segno</name> <operator>&lt;</operator> <name>segno</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_local_cache_remove</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>cur_segno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_logindex_truncate_local_cache</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>last_min_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>last_min_segno</name> <operator>&lt;</operator> <name>segno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_local_cache_scan</name><argument_list>(
				<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name></expr></argument>,
				<argument><expr><name>polar_logindex_local_cache_scan_callback</name></expr></argument>,
				<argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_min_segno</name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_update_ro_table_state</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>max_saved_tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>mid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_flush</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_saved_tid</name> <operator>==</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>max_saved_tid</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>

	<comment type="block">/* Update table state from maximum saved table to maximum table in memory */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lock</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>need_flush</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_flush</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check state again, it may be force flushed by other process */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name>
					<operator>&amp;&amp;</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>max_saved_tid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_logindex_invalid_bloom_cache</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_PREV_ID</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>need_flush</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_ro_bg_write</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>max_tid</name></decl>, <decl><type ref="prev"/><name>max_saved_tid</name> <init>= <expr><name>LOG_INDEX_TABLE_INVALID_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>log_idx_table_id_t</name></type> <name>last_max_table_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>fresh_min_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_tid</name> <operator>=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_tid</name> <operator>==</operator> <name>last_max_table_id</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Return true if no new table is added and no table state need to be updated */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>last_max_table_id</name> <operator>=</operator> <name>max_tid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>max_saved_tid</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fresh_min_segno</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name><operator>.</operator><name>segment_no</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Failed to get logindex meta from storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_index_update_ro_table_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>max_saved_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_truncate_local_cache</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>fresh_min_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return true because we updated all table state which we can update */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_logindex_bg_write</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>write_done</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_ADDING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>write_done</name> <operator>&amp;=</operator> <call><name>log_index_ro_bg_write</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>write_done</name> <operator>&amp;=</operator> <call><name>log_index_rw_bg_write</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>write_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_init_lwlock</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>tranche_id</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>offset</name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>lwlock_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name><operator>)</operator></expr></argument>, <argument><expr><name>tranche_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_logindex_snapshot_remove_data</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We cannot remove logindex files if it's not writable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_FILE_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>rmtree</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>logindex_snapshot_init_promoted_info</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_promoted_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>promoted_info</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>old_rw_saved_max_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>old_rw_max_inserted_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>old_rw_max_tid</name></name> <operator>=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>old_rw_saved_max_tid</name></name> <operator>=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>polar_logindex_snapshot_base_init</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>checkpoint_lsn</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_INITIALIZED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>checkpoint_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset logindex when we can not get correct logindex meta from storage
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_snapshot_remove_data</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>meta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logindex_snapshot_init_promoted_info</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>LOG_INDEX_MEM_TBL_ACTIVE_ID</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_table</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_mem_table_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If meta-&gt;start_lsn is invalid, we will not parse xlog and save it to logindex.
	 * RO will check logindex meta again when parse checkpoint xlog.
	 * RW will set logindex meta start lsn and save to storage when create new checkpoint.
	 * This will make ro and rw to create logindex from the same checkpoint.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name> <operator>&lt;</operator> <name>checkpoint_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When we start to truncate lsn , latest_page_number may not be set up; insert a
	 * suitable value to bypass the sanity test in SimpleLruTruncate.
	 */</comment>
	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name><operator>.</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When initialize log index snapshot, we load max table id's data to memory.
	 * When first insert lsn to memory table, need to check whether it already exists
	 * in previous table
	 */</comment>
	<expr_stmt><expr><call><name>polar_load_logindex_snapshot_from_storage</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_INITIALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>start_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_snapshot_init</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>checkpoint_lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>read_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>read_only</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>POLAR_DATA_DIR</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_validate_dir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <call><name>polar_logindex_snapshot_base_init</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>checkpoint_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Init %s succeed"</literal></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>start_lsn</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_init_lwlock_array</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id_begin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tranche_id</name> <init>= <expr><name>tranche_id_begin</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The tranche id defined for logindex must map the following call sequence.
	 * See the definition of LWTRANCE_WAL_LOGINDEX_BEGIN and LWTRANCHE_WAL_LOGINDEX_END as example
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">" %s_mem"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_index_init_lwlock</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEMTBL_LOCK_OFFSET</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr></argument>,
						  <argument><expr><name>tranche_id</name><operator>++</operator></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">" %s_hash"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_index_init_lwlock</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>LOG_INDEX_HASH_LOCK_OFFSET</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_HASH_LOCK_NUM</name></expr></argument>,
						  <argument><expr><name>tranche_id</name><operator>++</operator></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">" %s_io"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_index_init_lwlock</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>LOG_INDEX_IO_LOCK_OFFSET</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>tranche_id</name><operator>++</operator></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">" %s_bloom"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_index_init_lwlock</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>LOG_INDEX_BLOOM_LRU_LOCK_OFFSET</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>tranche_id</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>trache_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tranche_id</name> <operator>==</operator> <name>tranche_id_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>LOG_INDEX_MAX_TRACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_page_precedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>page1</name> <operator>&lt;</operator> <name>page2</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>logindex_snapshot_t</name></type>
<name>polar_logindex_snapshot_shmem_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>logindex_mem_tbl_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bloom_blocks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id_begin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id_end</name></decl></parameter>,
								   <parameter><decl><type><name>logindex_table_flushable</name></type> <name>table_flushable</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGINDEX_SNAPSHOT_SUFFIX</name></cpp:macro> <cpp:value>"_snapshot"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGINDEX_LOCK_SUFFIX</name></cpp:macro> <cpp:value>"_lock"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGINDEX_BLOOM_SUFFIX</name></cpp:macro> <cpp:value>"_bloom"</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found_locks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>item_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>log_index_mem_tbl_shmem_size</name><argument_list>(<argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_item_head_t</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>LOG_INDEX_TBL_SEG_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"log_item_head_t size is not same as LOG_INDEX_MEM_TBL_SEG_SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_item_seg_t</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>LOG_INDEX_TBL_SEG_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"log_item_seg_t size is not same as LOG_INDEX_MEM_TBL_SEG_SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>LOG_INDEX_FILE_TBL_BLOOM_SIZE</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_file_table_bloom_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"LOG_INDEX_FILE_TBL_BLOOM_SIZE is not enough for log_file_table_bloom_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>LOGINDEX_SNAPSHOT_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>logindex_snapshot</name> <operator>=</operator> <operator>(</operator><name>logindex_snapshot_t</name><operator>)</operator>
						<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>logindex_snapshot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>LOGINDEX_LOCK_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Align lwlocks to cacheline boundary */</comment>
	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>lwlock_array</name></name> <operator>=</operator> <operator>(</operator><name>LWLockMinimallyPadded</name> <operator>*</operator><operator>)</operator>
									  <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><call><name>log_index_lwlock_shmem_size</name><argument_list>(<argument><expr><name>logindex_mem_tbl_size</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>found_locks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found_snapshot</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found_locks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name> <operator>=</operator> <name>logindex_mem_tbl_size</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>log_index_init_lwlock_array</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>tranche_id_begin</name></expr></argument>, <argument><expr><name>tranche_id_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_allocated_seg_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>table_flushable</name></name> <operator>=</operator> <name>table_flushable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>extra_data</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found_snapshot</name> <operator>&amp;&amp;</operator> <name>found_locks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name><operator>.</operator><name>PagePrecedes</name></name> <operator>=</operator> <name>log_index_page_precedes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">" %s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>LOGINDEX_BLOOM_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Notice: When define tranche id for logindex, the last one is used for logindex bloom.
	 * See the definition between LWTRANCE_WAL_LOGINDEX_BEGIN and LWTRANCE_WAL_LOGINDEX_END
	 */</comment>
	<expr_stmt><expr><call><name>SimpleLruInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>item_name</name></expr></argument>,
				  <argument><expr><name>bloom_blocks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				  <argument><expr><name>LOG_INDEX_BLOOM_LRU_LOCK</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
				  <argument><expr><name>tranche_id_end</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>logindex_snapshot</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_handle_update_v1_to_v2</name><parameter_list>(<parameter><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>polar_is_standby</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_data_compatible</name><parameter_list>(<parameter><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<return>return <expr><call><name>log_index_handle_update_v1_to_v2</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>LOG_INDEX_VERSION</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>log_index_get_meta</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>    <name>crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>meta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><call><name>POLAR_DATA_DIR</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>LOG_INDEX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>polar_file_pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_META_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": read %d of %d and errno=%d"</literal></expr></argument>,
						<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>crc</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>crc</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>LOG_INDEX_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The magic number of meta file is incorrect, got %d, expect %d"</literal></expr></argument>,
						<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>LOG_INDEX_MAGIC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>log_index_calc_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>meta</name><operator>-&gt;</operator><name>crc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The crc of file %s is incorrect, got %d but expect %d"</literal></expr></argument>, <argument><expr><name>meta_path</name></expr></argument>,
						<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name> <operator>!=</operator> <name>LOG_INDEX_VERSION</name>
			<operator>&amp;&amp;</operator> <operator>!</operator><call><name>log_index_data_compatible</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The version is incorrect and incompatible, got %d, expect %d"</literal></expr></argument>,
						<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name>LOG_INDEX_VERSION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_start_lsn</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>logindex_snapshot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>start_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>start_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_log_index_write_meta</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>         <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>         <name><name>meta_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>          <name>flag</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>          <name>save_errno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><call><name>POLAR_DATA_DIR</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>LOG_INDEX_META_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>LOG_INDEX_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>LOG_INDEX_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>log_index_calc_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": \"%s\""</literal></expr></argument>, <argument><expr><name>meta_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileWrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>meta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_META_WRITE</name></expr></argument>)</argument_list></call>
			<operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_index_meta_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": \"%s\""</literal></expr></argument>, <argument><expr><name>meta_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_META_FLUSH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not flush file \"%s\": \"%s\""</literal></expr></argument>, <argument><expr><name>meta_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Save table if it's running in master node's recovery process.
 * During master recovery, bgwriter is not started and we have to
 * synchronized save table to get active table.
 */</comment>
<function><type><name>void</name></type>
<name>log_index_force_save_table</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>log_idx_table_id_t</name></type> <name>force_table</name> <init>= <expr><name>LOG_INDEX_TABLE_INVALID_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name> <init>= <expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>force_table</name> <operator>!=</operator> <name>tid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"force save table %ld"</literal></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>force_table</name> <operator>=</operator> <name>tid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>max_tid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_tid</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to get logindex meta from storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>max_tid</name> <operator>&gt;=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_logindex_invalid_bloom_cache</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>table_flushable</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>extra_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>succeed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>log_index_table_saved_before_promote</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>log_index_write_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeed</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to save logindex table, table id=%ld"</literal></expr></argument>, <argument><expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Notify background process to flush logindex table */</comment>
	<expr_stmt><expr><call><name>NOTIFY_LOGINDEX_BG_WORKER</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bg_worker_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_wait_active</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LWLock</name>     <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>end</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>table</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Wait table state changed from INACTIVE to ACTIVE.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We only save table to storage when polar_streaming_xlog_meta is true.
		 * If the table we are waiting is inactive then force to save it in this process.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_index_force_save_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_mem_table_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_FREE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_NEW_ACTIVE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name>
				<operator>&amp;&amp;</operator> <operator>!</operator><call><name>LOG_INDEX_MEM_TBL_FULL</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>end</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HandleStartupProcInterrupts</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>log_seg_id_t</name></type>
<name>log_index_mem_tbl_exists_page</name><parameter_list>(<parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>,
							  <parameter><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_seg_id_t</name></type>    <name>exists</name> <init>= <expr><call><name>LOG_INDEX_TBL_SLOT_VALUE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>log_index_item_head</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>item</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>exists</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next_item</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>log_index_item_head</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_mem_seg_full</name><parameter_list>(<parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_seg_id_t</name></type> <name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_item_seg_t</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>head</name> <operator>!=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name> <operator>==</operator> <name>head</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name>LOG_INDEX_ITEM_HEAD_LSN_NUM</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>log_index_item_seg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seg</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name>LOG_INDEX_ITEM_SEG_LSN_NUM</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_insert_new_item</name><parameter_list>(<parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>,
						  <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>key</name></decl></parameter>,
						  <parameter><decl><type><name>log_seg_id_t</name></type> <name>new_item_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>new_item</name> <init>= <expr><call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>new_item_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_seg_id_t</name>   <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>&lt;</operator> <name>LOG_INDEX_MEM_TBL_HASH_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>LOG_INDEX_TBL_SLOT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>head_seg</name></name> <operator>=</operator> <name>new_item_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>next_item</name></name> <operator>=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>next_seg</name></name> <operator>=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>tail_seg</name></name> <operator>=</operator> <name>new_item_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>new_item</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>prev_page_lsn</name></name> <operator>=</operator> <name><name>lsn_info</name><operator>-&gt;</operator><name>prev_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG_INDEX_INSERT_LSN_INFO</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lsn_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>slot</name> <operator>==</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>slot</name> <operator>=</operator> <name>new_item_id</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_item</name><operator>-&gt;</operator><name>next_item</name></name> <operator>=</operator> <operator>*</operator><name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>slot</name> <operator>=</operator> <name>new_item_id</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_insert_new_seg</name><parameter_list>(<parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_seg_id_t</name></type> <name>head</name></decl></parameter>,
						 <parameter><decl><type><name>log_seg_id_t</name></type> <name>seg_id</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_item_seg_t</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><call><name>log_index_item_seg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>seg_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>head_seg</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name> <operator>==</operator> <name>head</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next_seg</name></name> <operator>=</operator> <name>seg_id</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_item_seg_t</name> <modifier>*</modifier></type><name>pre_seg</name> <init>= <expr><call><name>log_index_item_seg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pre_seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_MEM_TABLE_INFO</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The log index table is corrupted, the segment %d is NULL;head=%d, seg_id=%d"</literal></expr></argument>,
								   <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>seg_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>pre_seg</name><operator>-&gt;</operator><name>next_seg</name></name> <operator>=</operator> <name>seg_id</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>prev_seg</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name> <operator>=</operator> <name>seg_id</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>next_seg</name></name> <operator>=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG_INDEX_INSERT_LSN_INFO</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lsn_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8</name></type>
<name>log_index_append_lsn</name><parameter_list>(<parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_seg_id_t</name></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_item_seg_t</name>  <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>           <name>idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>head</name> <operator>!=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name> <operator>==</operator> <name>head</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;</operator> <name>LOG_INDEX_ITEM_HEAD_LSN_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOG_INDEX_INSERT_LSN_INFO</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lsn_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>number</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>log_index_item_seg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>seg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>seg</name><operator>-&gt;</operator><name>number</name></name> <operator>&lt;</operator> <name>LOG_INDEX_ITEM_SEG_LSN_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>seg</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOG_INDEX_INSERT_LSN_INFO</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>lsn_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seg</name><operator>-&gt;</operator><name>number</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>log_seg_id_t</name></type>
<name>log_index_next_free_seg</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>active_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_seg_id_t</name></type>    <name>dst</name> <init>= <expr><name>LOG_INDEX_TBL_INVALID_SEG</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>active</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>next_mem_id</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>active</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * 1. However when we get a new active table, we don't know its data.prefix_lsn,
			 * we assign InvalidXLogRecPtr lsn to data.prefix_lsn, so we should
			 * distinguish which table is new without prefix_lsn, and reassign it
			 * 2. If active table is full or
			 * new lsn prefix is different than this table's lsn prefix
			 * we will allocate new active memory table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_IS_NEW</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_PREFIX_LSN</name><argument_list>(<argument><expr><name>active</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_UPDATE_FREE_HEAD</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_FULL</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call> <operator>||</operator>
					 <operator>!</operator><call><name>LOG_INDEX_SAME_TABLE_LSN_PREFIX</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>active</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_INACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_mem_id</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_NEXT_ID</name><argument_list>(<argument><expr><name>LOG_INDEX_MEM_TBL_ACTIVE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_UPDATE_FREE_HEAD</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>dst</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>next_mem_id</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>active</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL</name><argument_list>(<argument><expr><name>next_mem_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>active_table</name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>NOTIFY_LOGINDEX_BG_WORKER</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bg_worker_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOGINDEX_WAIT_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_index_wait_active</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>next_mem_id</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>LOG_INDEX_MEM_TBL_ACTIVE_ID</name> <operator>=</operator> <name>next_mem_id</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* never reach here */</comment>
	<return>return <expr><name>LOG_INDEX_TBL_INVALID_SEG</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>log_file_table_bloom_t</name> <modifier>*</modifier></type>
<name>log_index_get_bloom_lru</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pageno</name> <init>= <expr><call><name>LOG_INDEX_TBL_BLOOM_PAGE_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>LOG_INDEX_TBL_BLOOM_PAGE_OFFSET</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruShared</name></type>  <name>shared</name> <init>= <expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>slot</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>slot</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>log_file_table_bloom_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><operator>*</operator><name>slot</name></expr>]</index></name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type>
<name>log_index_get_tbl_bloom</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pageno</name> <init>= <expr><call><name>LOG_INDEX_TBL_BLOOM_PAGE_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>LOG_INDEX_TBL_BLOOM_PAGE_OFFSET</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruShared</name></type>  <name>shared</name> <init>= <expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>,
									  <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>log_file_table_bloom_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_calc_bloom</name><parameter_list>(<parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type><name>bloom</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bloom_filter</name> <modifier>*</modifier></type><name>filter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>filter</name> <operator>=</operator> <call><name>bloom_init_struct</name><argument_list>(<argument><expr><name><name>bloom</name><operator>-&gt;</operator><name>bloom_bytes</name></name></expr></argument>, <argument><expr><name><name>bloom</name><operator>-&gt;</operator><name>buf_size</name></name></expr></argument>,
							   <argument><expr><name>LOG_INDEX_BLOOM_ELEMS_NUM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LOG_INDEX_MEM_TBL_HASH_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_seg_id_t</name></type> <name>id</name> <init>= <expr><call><name>LOG_INDEX_TBL_SLOT_VALUE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>bloom</name><operator>-&gt;</operator><name>max_lsn</name></name></expr></argument>,
									 <argument><expr><call><name>log_index_item_max_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>min_lsn</name></name> <operator>=</operator>
					<call><name>Min</name><argument_list>(<argument><expr><name><name>bloom</name><operator>-&gt;</operator><name>min_lsn</name></name></expr></argument>, <argument><expr><call><name>LOG_INDEX_SEG_MIN_LSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bloom_add_element</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
								  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>next_item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_save_table</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>File</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type><name>bloom</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>segno</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>idx_table_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>idx_table_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>min_lsn</name></name> <operator>=</operator> <name><name>bloom</name><operator>-&gt;</operator><name>min_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>bloom</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>log_index_calc_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>polar_file_pwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>table</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_TBL_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>table</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_WRITE_FAILED</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not write whole table to file \"%s\" at offset %lu, write size %d, errno %d"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>FileSync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_TBL_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_FSYNC_FAILED</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not fsync file \"%s\", errno %d"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_get_bloom_data</name><parameter_list>(<parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type><name>bloom</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>idx_table_id</name></name> <operator>=</operator> <name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>min_lsn</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>buf_size</name></name> <operator>=</operator> <name>LOG_INDEX_FILE_TBL_BLOOM_SIZE</name> <operator>-</operator>
					  <call><name>offsetof</name><argument_list>(<argument><expr><name>log_file_table_bloom_t</name></expr></argument>, <argument><expr><name>bloom_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_index_calc_bloom</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>bloom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bloom</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>log_index_calc_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>bloom</name></expr></argument>, <argument><expr><name>LOG_INDEX_FILE_TBL_BLOOM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_save_bloom</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type><name>bloom</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type><name>lru_bloom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruShared</name></type>  <name>shared</name> <init>= <expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_BLOOM_LRU_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lru_bloom</name> <operator>=</operator> <call><name>log_index_get_bloom_lru</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lru_bloom</name></expr></argument>, <argument><expr><name>bloom</name></expr></argument>, <argument><expr><name>LOG_INDEX_FILE_TBL_BLOOM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slot</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * If this tid write from offset=0, then this segment file does not exits,
	 * O_CREAT flag will be set to open this file.Otherwise we will open this segment file
	 * without O_CREAT flag to append bloom data.
	 */</comment>
	<expr_stmt><expr><call><name>polar_slru_append_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_BLOOM_LRU_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>log_index_open_table_file</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readonly</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>segno</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>readonly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_OPEN_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\", errno %d"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>log_index_read_table_data</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type> <name>crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>segno</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>log_index_open_table_file</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>polar_file_pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_TBL_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_READ_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not read whole table from file \"%s\" at offset %lu, read size %d, errno %d"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>crc</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>crc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <call><name>log_index_calc_crc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>crc</name> <operator>!=</operator> <name><name>table</name><operator>-&gt;</operator><name>crc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_CRC_FAILED</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The crc32 check failed in file \"%s\" at offset %lu, result crc %u, expected crc %u"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_write_table_data</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_file_table_bloom_t</name> <modifier>*</modifier></type><name>bloom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name> <init>= <expr><name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>idx_table_id</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>log_index_open_table_file</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bloom</name> <operator>=</operator> <operator>(</operator><name>log_file_table_bloom_t</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>LOG_INDEX_FILE_TBL_BLOOM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_index_get_bloom_data</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>bloom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: we save bloom data before table data, in case that replica
	 * read bloom data with zero page
	 */</comment>
	<expr_stmt><expr><call><name>log_index_save_bloom</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>bloom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>log_index_save_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bloom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bloom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_report_io_error</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>segno</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>logindex_errno</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>logindex_io_err</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LOG_INDEX_OPEN_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\" for tid=%ld"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LOG_INDEX_SEEK_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not seek in file \"%s\" to offset %u for tid=%ld"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LOG_INDEX_READ_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not read from file \"%s\" at offset %u for tid=%ld"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LOG_INDEX_WRITE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not write to file \"%s\" at offset %u for tid=%ld"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LOG_INDEX_FSYNC_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not fsync file \"%s\" for tid=%ld"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LOG_INDEX_CLOSE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not close file \"%s\" for tid=%ld"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LOG_INDEX_CRC_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The crc32 check failed in file \"%s\" at offset %u for tid=%ld"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* can't get here, we trust */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LogIndex error cause: %d for tid=%ld"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>logindex_io_err</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_read_seg_file</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_table_cache_t</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_meta_t</name></type> <name>meta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>delta_table</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LOG_INDEX_COPY_META</name><argument_list>(<argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>delta_table</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>meta</name><operator>.</operator><name>max_idx_table_id</name></name> <operator>&gt;=</operator> <operator>(</operator><name>segno</name> <operator>*</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name><operator>)</operator><operator>)</operator></expr> ?</condition><then>
				  <expr><name><name>meta</name><operator>.</operator><name>max_idx_table_id</name></name> <operator>-</operator> <operator>(</operator><name>segno</name> <operator>*</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name> <operator>&amp;&amp;</operator> <name>delta_table</name> <operator>&gt;=</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_local_cache_read</name><argument_list>(
					<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>LOG_INDEX_TABLE_CACHE_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_READ_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name><name>io_error</name><operator>.</operator><name>save_errno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bytes</name> <operator>=</operator> <name>LOG_INDEX_TABLE_CACHE_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>   <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>File</name></type> <name>fd</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_OPEN_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\", errno %d"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>FileRead</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>LOG_INDEX_TABLE_CACHE_SIZE</name></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGINDEX_TBL_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><name>logindex_io_err</name> <operator>=</operator> <name>LOG_INDEX_READ_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>logindex_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not read whole table from file \"%s\" at offset 0, read size %d, errno %d"</literal></expr></argument>,
								 <argument><expr><name>path</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>logindex_errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* segno start from 0, while log_index_table_id_t start from 1 */</comment>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>=</operator> <name>segno</name> <operator>*</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>table_data</name> <operator>=</operator> <operator>(</operator><name>log_idx_table_data_t</name> <operator>*</operator><operator>)</operator><name><name>cache</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>table_data</name><operator>-&gt;</operator><name>idx_table_id</name></name> <operator>!=</operator> <name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>||</operator> <name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>&gt;</operator> <name><name>meta</name><operator>.</operator><name>max_idx_table_id</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Read unexpected logindex segment=%ld file, min_id=%ld, max_id=%ld, tid=%ld"</literal></expr></argument>,
			 <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name></expr></argument>, <argument><expr><name><name>meta</name><operator>.</operator><name>max_idx_table_id</name></name></expr></argument>, <argument><expr><name><name>table_data</name><operator>-&gt;</operator><name>idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>bytes</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this segment file is renamed from previous segment file, maybe there're old tables
	 * in the end of the file. So we have to compare to get max table id, and compare with meta to
	 * check it's already full flushed to the storage.
	 */</comment>
	<while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>table_data</name> <operator>=</operator> <operator>(</operator><name>log_idx_table_data_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cache</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>table_data</name><operator>-&gt;</operator><name>idx_table_id</name></name> <operator>&gt;=</operator> <name><name>cache</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>&amp;&amp;</operator> <name><name>table_data</name><operator>-&gt;</operator><name>idx_table_id</name></name> <operator>&lt;=</operator> <name><name>meta</name><operator>.</operator><name>max_idx_table_id</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <name><name>table_data</name><operator>-&gt;</operator><name>idx_table_id</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Read logindex table base on tid and return the table content.
 * If the return table content is from the logindex memory table,
 * then the output param *mem_table point to the table in logindex memory table, otherwise *mem_table is NULL.
 */</comment>
<function><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type>
<name>log_index_read_table</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>mem_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>log_table_cache_t</name></type> <name>table_cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>tid</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>LOG_INDEX_MEM_TBL</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>table_lock</name> <init>= <expr><call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_data_t</name>    <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>mem_table</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Return table if it's already in shared memory */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><name>table_lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>tid</name> <operator>==</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>mem_table</name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>
			<return>return <expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>table_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>table_cache</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			<name><name>tid</name> <argument_list type="generic">&lt; <argument><expr><name><name>table_cache</name><operator>.</operator><name>min_idx_table_id</name></name> <operator>||</operator> <name>tid</name></expr></argument> &gt;</argument_list></name> <name><name>table_cache</name><operator>.</operator><name>max_idx_table_id</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>log_index_read_seg_file</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_cache</name></expr></argument>, <argument><expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_index_report_io_error</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>table_cache</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tid</name> <argument_list type="generic">&lt; <argument><expr><name><name>table_cache</name><operator>.</operator><name>min_idx_table_id</name></name> <operator>||</operator> <name>tid</name></expr></argument> &gt;</argument_list></name> <name><name>table_cache</name><operator>.</operator><name>max_idx_table_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to read tid = %ld, while min_tid = %ld and max_tid = %ld"</literal></expr></argument>,
			 <argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>table_cache</name><operator>.</operator><name>min_idx_table_id</name></name></expr></argument>, <argument><expr><name><name>table_cache</name><operator>.</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>LOG_INDEX_GET_CACHE_TABLE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_cache</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace the table with the same position in shared memory and its state is FLUSHED */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><name>table_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name> <operator>&amp;&amp;</operator> <name>tid</name> <operator>!=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>table_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>log_index_write_table</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>succeed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>segment_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_file_segment_t</name> <modifier>*</modifier></type><name>min_seg</name> <init>= <expr><operator>&amp;</operator><name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>  <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl> ;</decl_stmt>

	<expr_stmt><expr><name>tid</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save logindex table base on the table id order
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tid</name> <operator>==</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>log_index_write_table_data</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_index_report_io_error</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* We don't update meta when flush active memtable */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Flush active memtable, nothing to do */</comment>
			<expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>segment_no</name> <operator>=</operator> <call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name></expr></argument>, <argument><expr><name>segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name> <operator>==</operator> <name>segment_no</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr></argument>, <argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>=</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name> <operator>*</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_log_index_write_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>succeed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_index_update_min_segment</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name>            <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_file_segment_t</name>    <modifier>*</modifier></type><name>min_seg</name> <init>= <expr><operator>&amp;</operator><name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>=</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name> <operator>*</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <operator>(</operator><name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>LOG_INDEX_TABLE_NUM_PER_FILE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>log_index_read_table_data</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>, <argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to read log index which tid=%ld when truncate logindex"</literal></expr></argument>,
							<argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<expr_stmt><expr><call><name>polar_log_index_write_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_rename_segment_file</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>old_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>new_file</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>new_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>max_seg_no</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_allocated_seg_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_seg_no</name> <operator>=</operator> <name>max_seg_no</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>new_file</name></expr></argument>, <argument><expr><name>new_seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>polar_durable_rename</name><argument_list>(<argument><expr><name>old_file</name></expr></argument>, <argument><expr><name>new_file</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_allocated_seg_no</name></name> <operator>=</operator> <name>new_seg_no</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"logindex rename %s to %s"</literal></expr></argument>, <argument><expr><name>old_file</name></expr></argument>, <argument><expr><name>new_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_truncate</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name>            <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_file_segment_t</name>    <modifier>*</modifier></type><name>min_seg</name> <init>= <expr><operator>&amp;</operator><name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>                      <name>bloom_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>                        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>                      <name>min_segment_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>                      <name>max_segment_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type>          <name>max_unused_tid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>crc</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>max_lsn</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>&gt;=</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>&gt;=</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep last saved segment file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update meta first. If meta update succeed but fail to remove files, we will not read these files.
	 * Otherwise if we remove files succeed but fail to update meta, we will fail to read file base on meta data.
	 */</comment>
	<expr_stmt><expr><name>max_segment_no</name> <operator>=</operator> <call><name>LOG_INDEX_FILE_TABLE_SEGMENT_NO</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>min_segment_no</name> <operator>=</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>segment_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_unused_tid</name> <operator>=</operator> <name><name>min_seg</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_index_update_min_segment</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_segment_no</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_allocated_seg_no</name></name></expr></argument>, <argument><expr><name>max_segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG_INDEX_FILE_TABLE_NAME</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>min_segment_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bloom_page</name> <operator>=</operator> <call><name>LOG_INDEX_TBL_BLOOM_PAGE_NO</name><argument_list>(<argument><expr><name>max_unused_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"logindex truncate bloom id=%ld page=%ld"</literal></expr></argument>, <argument><expr><name>max_unused_tid</name></expr></argument>, <argument><expr><name>bloom_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SimpleLruTruncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name></name></expr></argument>, <argument><expr><name>bloom_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_segment_no</name> <operator>-</operator> <name>min_segment_no</name> <operator>&lt;</operator> <name>polar_max_logindex_files</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rename unused file for next segment */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>log_index_rename_segment_file</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_truncate</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>polar_logindex_memory_context</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>log_index_truncate</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Truncate logindex %s from lsn=%lX"</literal></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>log_index_exists_in_saved_table</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>mid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>      <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_lsn_t</name></type> <name>saved_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mid</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_PREV_ID</name><argument_list>(<argument><expr><name>LOG_INDEX_MEM_TBL_ACTIVE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>saved_lsn</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <operator>&amp;</operator><name>tag</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>last_order</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>log_index_get_order_lsn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_lsn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>lsn_info</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name><name>saved_lsn</name><operator>.</operator><name>tag</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>log_index_insert_lsn</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>log_index_lsn_t</name> <modifier>*</modifier></type><name>lsn_info</name></decl></parameter>,  <parameter><decl><type><name>uint32</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_mem_table_t</name>     <modifier>*</modifier></type><name>active</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>                <name>new_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_seg_id_t</name></type>        <name>head</name> <init>= <expr><name>LOG_INDEX_TBL_INVALID_SEG</name></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>prev_lsn</name></name> <operator>&lt;</operator> <name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>active</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 1. Logindex table state is atomic uint32, it's safe to change state without table lock
	 * 2. Only one process insert lsn, so it's safe to check exists page without hash lock
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_STATE</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_MEM_TBL_STATE_ACTIVE</name> <operator>&amp;&amp;</operator>
			<call><name>LOG_INDEX_SAME_TABLE_LSN_PREFIX</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>log_index_mem_tbl_exists_page</name><argument_list>(<argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_item</name> <operator>=</operator> <operator>(</operator><name>head</name> <operator>==</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_item</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>log_index_mem_seg_full</name><argument_list>(<argument><expr><name>active</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type> <name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LOG_INDEX_HASH_LOCK</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>log_index_append_lsn</name><argument_list>(<argument><expr><name>active</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>lsn_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_ADD_ORDER</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tail_seg</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_HASH_LOCK</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_seg_id_t</name></type>    <name>dst</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>old_active</name> <init>= <expr><name>active</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>log_index_next_free_seg</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dst</name> <operator>!=</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LOG_INDEX_HASH_LOCK</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_item</name> <operator>||</operator> <name>active</name> <operator>!=</operator> <name>old_active</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_index_insert_new_item</name><argument_list>(<argument><expr><name>lsn_info</name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_index_insert_new_seg</name><argument_list>(<argument><expr><name>active</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>lsn_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_ADD_ORDER</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_HASH_LOCK</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>min_lsn</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>lsn_info</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>min_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_add_lsn</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>prev</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>key</name> <init>= <expr><call><name>LOG_INDEX_MEM_TBL_HASH_PAGE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_lsn_t</name></type> <name>lsn_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tag</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lsn_info</name><operator>.</operator><name>tag</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsn_info</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lsn_info</name><operator>.</operator><name>prev_lsn</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_ADDING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Insert logindex from meta-&gt;start_lsn, so We don't save logindex which lsn is less then meta-&gt;start_lsn */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;</operator> <name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If log index initialization is not finished
		 * we don't save lsn if it's less than max saved lsn,
		 * which means it's already in saved table
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If lsn is equal to max saved lsn then
		 * we check whether the tag is in saved table
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>==</operator> <name>lsn</name>
				<operator>&amp;&amp;</operator> <call><name>log_index_exists_in_saved_table</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn_info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we come here which means complete to check lsn overlap
		 * then we can save lsn to logindex memory table
		 */</comment>
		<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_ADDING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s log index is insert from %lx"</literal></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>log_index_insert_lsn</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn_info</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_logindex_messages</name> <operator>&lt;=</operator> <name>DEBUG4</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>active</name> <init>= <expr><call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>last_order</name> <init>= <expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>last_order</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s add %lX, t=%ld, o=%d, i=%d, f=%d, s=%d "</literal> <name>POLAR_LOG_BUFFER_TAG_FORMAT</name></expr></argument>,
							 <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>,
							 <argument><expr><name>lsn</name></expr></argument>,
							 <argument><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>idx_table_id</name></name></expr></argument>,
							 <argument><expr><name>last_order</name></expr></argument>,
							 <argument><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>idx_order</name><index>[<expr><name>last_order</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
							 <argument><expr><name><name>active</name><operator>-&gt;</operator><name>free_head</name></name></expr></argument>,
							 <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>POLAR_LOG_BUFFER_TAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>log_item_head_t</name> <modifier>*</modifier></type>
<name>log_index_tbl_find</name><parameter_list>(<parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>,
				   <parameter><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_seg_id_t</name></type>    <name>item_id</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>table</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>item_id</name> <operator>=</operator> <call><name>log_index_mem_tbl_exists_page</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>log_index_item_head</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>item_id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_get_logindex_snapshot_max_lsn</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>max_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_lsn</name> <operator>=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>max_lsn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: load flushed/active tables from storages
 */</comment>
<function><type><name>void</name></type>
<name>polar_load_logindex_snapshot_from_storage</name><parameter_list>(<parameter><decl><type><name>log_index_snapshot_t</name> <modifier>*</modifier></type><name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>new_max_idx_table_id</name> <init>= <expr><name>LOG_INDEX_TABLE_INVALID_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>active</name> <init>= <expr><call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_mem_table_t</name> <modifier>*</modifier></type><name>mem_tbl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>log_idx_table_data_t</name></type> <name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>tid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>min_tid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>state</name> <init>= <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's RW node, we only load tables whose min_lsn is less than start_lsn.
	 * But if we enable wal prefetch, we will create lsn iterator during
	 * recovery, so loading flushed table into memory can improve performance
	 * in some degree.
	 * If it's ro node, we will load all saved table from max_idx_table_id to memory table.
	 * It's optimization for the following page iterator, saving time to load table from storage.
	 */</comment>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_max_idx_table_id</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No table in storage */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_max_idx_table_id</name> <operator>==</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * POLAR: if we are initializing now, we load tables from big to small
	 * we cannot load all tables, because memtable is limited, so we should
	 * calculate min table to load
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>POLAR_LOGINDEX_STATE_INITIALIZED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we load at most mem_tbl_size tables */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_max_idx_table_id</name> <operator>&gt;</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_tid</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>new_max_idx_table_id</name> <operator>-</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						  <argument><expr><name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name><operator>.</operator><name>min_idx_table_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_tid</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name><operator>.</operator><name>min_idx_table_id</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* min_segment_info.min_idx_table_id = 0 ? */</comment>
		<if_stmt><if>if <condition>(<expr><name>min_tid</name> <operator>==</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_tid</name> <operator>=</operator> <name>new_max_idx_table_id</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * When db start, there is no table to load, so active table_id is
		 * still invalid, at this situation, we should assign tid to active
		 * table(tid = 1)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_index_wait_active</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>min_tid</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We cannot wrap active table slot, so limit max tid to load */</comment>
		<expr_stmt><expr><name>new_max_idx_table_id</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>new_max_idx_table_id</name></expr></argument>,
								   <argument><expr><name>min_tid</name> <operator>+</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>min_tid</name> <operator>!=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we have more flushed tables to loaded */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_max_idx_table_id</name> <operator>&gt;=</operator> <name>min_tid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tid from big to small */</comment>
		<expr_stmt><expr><name>tid</name> <operator>=</operator> <name>new_max_idx_table_id</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>tid</name> <operator>&gt;=</operator> <name>min_tid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>tid</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mem_tbl</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* POLAR: mark current memory table FLUSHED */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>mem_tbl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>log_index_read_table_data</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mem_tbl</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_SET_STATE</name><argument_list>(<argument><expr><name>mem_tbl</name></expr></argument>, <argument><expr><name>LOG_INDEX_MEM_TBL_STATE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_FREE_HEAD</name><argument_list>(<argument><expr><name>mem_tbl</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>LOG_INDEX_MEM_TBL_SEG_NUM</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_invalid_bloom_cache</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>mem_tbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>table</name><operator>.</operator><name>idx_table_id</name></name> <operator>==</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tid</name><operator>--</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name>start_lsn</name> <operator>&gt;=</operator> <name><name>table</name><operator>.</operator><name>min_lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Switch to the old active table */</comment>
		<expr_stmt><expr><name>LOG_INDEX_MEM_TBL_ACTIVE_ID</name> <operator>=</operator> <operator>(</operator><name>new_max_idx_table_id</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>active</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <name>new_max_idx_table_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>;</expr_stmt>
		<comment type="block">/* Switch to the new active table */</comment>
		<expr_stmt><expr><name>LOG_INDEX_MEM_TBL_ACTIVE_ID</name> <operator>=</operator> <name>new_max_idx_table_id</name> <operator>%</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>active</name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_ACTIVE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* wait active to become available */</comment>
		<expr_stmt><expr><call><name>log_index_wait_active</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If logindex is initialized we will try to read active table data from storage.
	 * When we flush active table data to storage we will not update logindex meta
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>state</name> <operator>&amp;</operator> <name>POLAR_LOGINDEX_STATE_INITIALIZED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>idx_table_id</name></name> <operator>!=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read active mem table, maybe table has been reused, so must make sure
	 * table.idx_table_id == read_idx_table_id
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>log_index_read_table_data</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>polar_trace_logindex</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>table</name><operator>.</operator><name>idx_table_id</name></name> <operator>==</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Table data in storage is fresh */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>.</operator><name>max_lsn</name></name> <operator>&gt;</operator> <name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_MEM_TBL_LOCK</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name> <operator>&gt;=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>=</operator> <call><name>LOG_INDEX_MEM_TBL_TID</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_lsn</name></name> <operator>=</operator> <name><name>active</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* When we read active memtable from storage, maybe free_head is too old */</comment>
		<while>while <condition>(<expr><operator>!</operator><call><name>LOG_INDEX_MEM_TBL_FULL</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>log_item_head_t</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>log_index_item_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>active</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>LOG_INDEX_MEM_TBL_FREE_HEAD</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>item</name><operator>-&gt;</operator><name>head_seg</name></name> <operator>==</operator> <name>LOG_INDEX_TBL_INVALID_SEG</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>LOG_INDEX_MEM_TBL_UPDATE_FREE_HEAD</name><argument_list>(<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>uint64</name></type>
<name>polar_logindex_mem_tbl_size</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>logindex_snapshot</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>mem_tbl_size</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type>
<name>polar_logindex_used_mem_tbl_size</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>mem_tbl_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>logindex_snapshot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mem_tbl_size</name> <operator>=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_idx_table_id</name></name> <operator>-</operator>
					   <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name><operator>.</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_SNAPSHOT_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>mem_tbl_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type>
<name>polar_logindex_convert_mem_tbl_size</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>mem_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>mem_size</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>log_mem_table_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LWLockMinimallyPadded</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>polar_get_logindex_snapshot_dir</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_get_logindex_snapshot_storage_min_lsn</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name>            <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_file_segment_t</name>    <modifier>*</modifier></type><name>min_seg</name> <init>= <expr><operator>&amp;</operator><name><name>meta</name><operator>-&gt;</operator><name>min_segment_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_data_t</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>min_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>min_seg</name><operator>-&gt;</operator><name>min_idx_table_id</name></name> <operator>!=</operator> <name>LOG_INDEX_TABLE_INVALID_ID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>log_index_read_table_data</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>min_idx_table_id</name></name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to read log index which tid=%ld when truncate logindex"</literal></expr></argument>,
							<argument><expr><name><name>min_seg</name><operator>-&gt;</operator><name>min_idx_table_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>min_lsn</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>min_lsn</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>min_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_online_promote</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruShared</name></type> <name>shared</name> <init>= <expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bloom_ctl</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_index_promoted_info_t</name> <modifier>*</modifier></type><name>promoted_info</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>promoted_info</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>log_idx_table_id_t</name></type> <name>max_saved_tid</name> <init>= <expr><name>LOG_INDEX_TABLE_INVALID_ID</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_lsn</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_saved_max_tid</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>promoted_info</name><operator>-&gt;</operator><name>old_rw_max_tid</name></name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>max_saved_tid</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to read logindex meta from shared storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_ro_promoting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_fetch_or_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Force to update logindex table which is inactive to be flushed */</comment>
	<expr_stmt><expr><call><name>log_index_update_ro_table_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>max_saved_tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Logindex %s is promoted"</literal></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_LOG_LOGINDEX_META_INFO</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_check_valid_start_lsn</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>InRecovery</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When reach consistency in replica node, read meta from storage is meta start lsn is invalid
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>log_index_get_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Failed to read logindex meta from shared storage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>start_lsn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_set_start_lsn</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_meta_t</name> <modifier>*</modifier></type><name>meta</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>meta</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>start_lsn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>meta</name><operator>-&gt;</operator><name>start_lsn</name></name> <operator>=</operator> <name>start_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_log_index_write_meta</name><argument_list>(<argument><expr><name>logindex_snapshot</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LOG_INDEX_IO_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>polar_logindex_mem_table_max_lsn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>log_mem_table_t</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>table</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>max_lsn</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_create_local_cache</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cache_name</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>max_segments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>io_permission</name> <init>= <expr><name>POLAR_CACHE_LOCAL_FILE_READ</name> <operator>|</operator> <name>POLAR_CACHE_LOCAL_FILE_WRITE</name> <operator>|</operator>
						   <name>POLAR_CACHE_SHARED_FILE_READ</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name> <operator>=</operator> <call><name>polar_create_local_cache</name><argument_list>(<argument><expr><name>cache_name</name></expr></argument>, <argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>,
																<argument><expr><name>max_segments</name></expr></argument>, <argument><expr><name>LOG_INDEX_TABLE_NUM_PER_FILE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>log_idx_table_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
																<argument><expr><name>LWTRANCHE_POLAR_LOGINDEX_LOCAL_CACHE</name></expr></argument>, <argument><expr><name>io_permission</name></expr></argument>, <argument><expr><name>polar_logindex_local_cache_seg2str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: remove local cache file after create local cache */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_local_cache_move_trash</name><argument_list>(<argument><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>segment_cache</name><operator>-&gt;</operator><name>dir_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_set_writer_latch</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Latch</name></name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>bg_worker_latch</name></name> <operator>=</operator> <name>latch</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>polar_trace_logindex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>trace_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>trace_level</name> <operator>&lt;</operator> <name>LOG</name> <operator>&amp;&amp;</operator>
			<name>trace_level</name> <operator>&gt;=</operator> <name>polar_trace_logindex_messages</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>LOG</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>trace_level</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_logindex_update_promoted_info</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>last_replayed_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>log_index_promoted_info_t</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>&amp;</operator><name><name>logindex_snapshot</name><operator>-&gt;</operator><name>promoted_info</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>old_rw_max_inserted_lsn</name></name> <operator>=</operator> <name>last_replayed_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>old_rw_max_tid</name></name> <operator>=</operator> <name><name>logindex_snapshot</name><operator>-&gt;</operator><name>max_idx_table_id</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
