<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_nbtxlog_idx.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_nbtxlog_idx.c
 *   Implementation of parse btree records.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *    src/backend/access/logindex/polar_nbtxlog_idx.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_insert_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isleaf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ismeta</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ismeta</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_insert_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isleaf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ismeta</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ismeta</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_split_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_split_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>rtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>    <name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type>    <name>rpage_lock</name></decl>;</decl_stmt>

	<comment type="block">/* block id 3 is set only when isleaf is false */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rtag</name></expr></argument>, <argument><expr><name>rpage_lock</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>rpage_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_delete_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we have any conflict processing to do, it must happen before we
	 * update the page.
	 *
	 * Btree delete records can conflict with standby queries.  You might
	 * think that vacuum records would conflict as well, but we've handled
	 * that already.  XLOG_HEAP2_CLEANUP_INFO records provide the highest xid
	 * cleaned by the vacuum of the heap and so we can resolve any conflicts
	 * just once when that arrives.  After that we know that no conflicts
	 * exist from individual btree vacuum records on that index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><call><name>btree_xlog_delete_get_latestRemovedXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_reuse_page_parse</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Btree reuse_page records exist to provide a conflict point when we
	 * reuse pages in the index via the FSM.  That's all they do though.
	 *
	 * latestRemovedXid was the page's btpo.xact.  The btpo.xact &lt;
	 * RecentGlobalXmin test in _bt_page_recyclable() conceptually mirrors the
	 * pgxact-&gt;xmin &gt; limitXmin test in GetConflictingVirtualXIDs().
	 * Consequently, one XID value achieves the same exclusion effect on
	 * master and standby.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_reuse_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_reuse_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>,
											<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_unlink_page_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_unlink_page_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* block 1 is set when leftsib is not P_NONE */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_newroot_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_btree_xlog_newroot_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>root_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>    <name>root_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type>    <name>root_lock</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>root_tag</name></expr></argument>, <argument><expr><name>root_lock</name></expr></argument>, <argument><expr><name>root_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* block 1 is set when xlrec-&gt;level &gt; 0 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>root_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>root_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>root_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_clear_incomplete_split -- clear INCOMPLETE_SPLIT flag on a page
 *
 * This is a common subroutine of the redo functions of all the WAL record
 * types that can insert a downlink: insert, split, and newroot.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_bt_clear_incomplete_split</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>pageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_bt_restore_meta</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>metabuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>metapg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>md</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_metadata</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BTREE_METAPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_btree_metadata</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>md</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_magic</name></name> <operator>=</operator> <name>BTREE_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>=</operator> <name>BTREE_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>fastroot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>fastlevel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>oldest_btpo_xact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>md</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>last_cleanup_num_heap_tuples</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_META</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set pd_lower just past the end of the metadata.  This is essential,
	 * because without doing so, metadata will be lost if xlog.c compresses
	 * the page.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>metapg</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>md</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metapg</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_insert</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isleaf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ismeta</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
						<parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name><name>tags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Insertion to an internal page finishes an incomplete split at the child
		 * level.  Clear the incomplete-split flag in the child.  Note: during
		 * normal operation, the child and parent pages are locked at the same
		 * time, so that clearing the flag and inserting the downlink appear
		 * atomic to other backends.  We don't bother with that during replay,
		 * because readers don't care about the incomplete-split flag and there
		 * cannot be updates happening.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>polar_bt_clear_incomplete_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datapos</name> <init>= <expr><call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>datapos</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"btree_insert_redo: failed to add item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ismeta</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: in normal operation, we'd update the metapage while still holding
			 * lock on the page we inserted into.  But during replay it's not
			 * necessary to hold that lock, since no other index updates can be
			 * happening concurrently, and readers will cope fine with following an
			 * obsolete link from the metapage.
			 */</comment>
			<return>return <expr><call><name>polar_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BTPageOpaque</name></type>
<name>polar_restore_right</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>rpage</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_btree_split</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_split</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>isleaf</name> <init>= <expr><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datapos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rnext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>ropaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rnext</name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>datapos</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ropaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rnext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <ternary><condition><expr><name>isleaf</name></expr> ?</condition><then> <expr><name>BTP_LEAF</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_restore_page</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>datapos</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ropaque</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_vacuum</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>vacuum_tag</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>UNUSED</name></cpp:ifdef>
	<comment type="block">/* Should never be here, we delete some unused codes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>vacuum_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>vacuum_tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Like in btvacuumpage(), we need to take a cleanup lock on every leaf
	 * page. See nbtree/README for details.
	 */</comment>
	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unend</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>unend</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unend</name> <operator>-</operator> <name>unused</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name>unend</name> <operator>-</operator> <name>unused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Mark the page as not containing any LP_DEAD items --- see comments
		 * in _bt_delitems_vacuum().
		 */</comment>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_split</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onleft</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lhighkey</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
					   <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_split</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_split</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>isleaf</name> <init>= <expr><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>rpage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>ropaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datapos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>left_hikey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>left_hikeysz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rnext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name><name>tags</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* leftsib */</comment>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* rightsib */</comment>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rnext</name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Clear the incomplete split flag on the left sibling of the child page
		 * this is a downlink for.  (Like in polar_btree_xlog_insert, this can be done
		 * before locking the other pages)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name><name>tags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>polar_bt_clear_incomplete_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rpage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_restore_right</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>rpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now reconstruct left (original) sibling page */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type> <name>fake_rpage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * To retain the same physical order of the tuples that they had, we
			 * initialize a temporary empty page for the left page and add all the
			 * items to that in item number order.  This mirrors how _bt_split()
			 * works.  It's not strictly required to retain the same physical
			 * order, as long as the items are in the correct item number order,
			 * but it helps debugging.  See also _bt_restore_page(), which does
			 * the same for the right page.
			 */</comment>
			<decl_stmt><decl><type><name>Page</name></type>        <name>lpage</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>newitem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>newitemsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>        <name>newlpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>leftoff</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datapos</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>onleft</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newitem</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>datapos</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newitemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>newitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>datapos</name> <operator>+=</operator> <name>newitemsz</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>datalen</name> <operator>-=</operator> <name>newitemsz</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Extract left hikey and its size (assuming 16-bit alignment) */</comment>
			<if_stmt><if>if <condition>(<expr><name>lhighkey</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>left_hikey</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>datapos</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>left_hikeysz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>left_hikey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>datalen</name> <operator>-=</operator> <name>left_hikeysz</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemId</name></type>      <name>hiItemId</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>fake_rpage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Restore right page */</comment>
				<expr_stmt><expr><name>ropaque</name> <operator>=</operator> <call><name>polar_restore_right</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>fake_rpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>hiItemId</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>fake_rpage</name></expr></argument>, <argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>ropaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isleaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>left_hikey</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>fake_rpage</name></expr></argument>, <argument><expr><name>hiItemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>left_hikeysz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>hiItemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datalen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newlpage</name> <operator>=</operator> <call><name>PageGetTempPageCopySpecial</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set high key */</comment>
			<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>left_hikey</name></expr></argument>, <argument><expr><name>left_hikeysz</name></expr></argument>,
							<argument><expr><name>P_HIKEY</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add high key to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lopaque</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>firstright</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemId</name></type>      <name>itemid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexTuple</name></type>      <name>item</name></decl>;</decl_stmt>

				<comment type="block">/* add the new item if it was inserted on left page */</comment>
				<if_stmt><if>if <condition>(<expr><name>onleft</name> <operator>&amp;&amp;</operator> <name>off</name> <operator>==</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newitem</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>item</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add old item to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* cope with possibility that newitem goes at the end */</comment>
			<if_stmt><if>if <condition>(<expr><name>onleft</name> <operator>&amp;&amp;</operator> <name>off</name> <operator>==</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>newitem</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to left page after split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fix opaque fields */</comment>
			<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_LEAF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blockNum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>fake_rpage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fake_rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fix left-link of the page to the right of the new right sibling.
	 *
	 * Note: in normal operation, we do this while still holding lock on the
	 * two split pages.  However, that's not necessary for correctness in WAL
	 * replay, because no other index update can be in progress, and readers
	 * will cope properly when following an obsolete left-link.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rnext</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blockNum</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_delete</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>  <name>del_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't need to take a cleanup lock to apply these changes. See
	 * nbtree/README for details.
	 */</comment>
	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>SizeOfBtreeDelete</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlrec</name> <operator>+</operator> <name>SizeOfBtreeDelete</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Mark the page as not containing any LP_DEAD items --- see comments
		 * in _bt_delitems_delete().
		 */</comment>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_mark_page_halfdead</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_mark_page_halfdead</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_mark_page_halfdead</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In normal operation, we would lock all the pages this WAL record
		 * touches before changing any of them.  In WAL replay, it should be okay
		 * to lock just one page at a time, since no concurrent index updates can
		 * be happening, and readers should not care whether they arrive at the
		 * target page or not (since it's surely empty).
		 */</comment>

		<comment type="block">/* parent page */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>poffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>      <name>itemid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>itup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nextoffset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>poffset</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>poffset</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>nextoffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rightsib</name> <operator>=</operator> <call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTreeInnerTupleSetDownLink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rightsib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextoffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>poffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rewrite the leaf page as a halfdead page */</comment>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leftblk</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>rightblk</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_HALF_DEAD</name> <operator>|</operator> <name>BTP_LEAF</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Construct a dummy hikey item that points to the next parent to be
		 * deleted (if any).
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTreeTupleSetTopParent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>topparent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not add dummy high key to half-dead page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_unlink_page</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_unlink_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_unlink_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightsib</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name><name>tags</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>leftsib</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leftsib</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightsib</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>rightsib</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In normal operation, we would lock all the pages this WAL record
		 * touches before changing any of them.  In WAL replay, it should be okay
		 * to lock just one page at a time, since no concurrent index updates can
		 * be happening, and readers should not care whether they arrive at the
		 * target page or not (since it's surely empty).
		 */</comment>

		<comment type="block">/* Fix left-link of right sibling */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftsib</name> <operator>!=</operator> <name>P_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fix right-link of left sibling, if any */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rewrite target page as empty deleted page */</comment>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>leftsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightsib</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>xact</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>btpo_xact</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_DELETED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we deleted a parent of the targeted leaf page, instead of the leaf
		 * itself, update the leaf to point to the next remaining child in the
		 * branch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/*
			 * There is no real data on the page, so we just re-create it from
			 * scratch using the information from the WAL record.
			 */</comment>
			<decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_HALF_DEAD</name> <operator>|</operator> <name>BTP_LEAF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leafleftsib</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>leafrightsib</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Add a dummy hikey item */</comment>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTreeTupleSetTopParent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>topparent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not add dummy high key to half-dead page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Update metapage if needed */</comment>
			<return>return <expr><call><name>polar_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_btree_xlog_newroot</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_btree_newroot</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_btree_newroot</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>pageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name><name>tags</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_ROOT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>pageop</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_LEAF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>pageop</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_restore_page</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* move _bt_clear_incomplete_split to here, important by kangxian */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Clear the incomplete-split flag in left child */</comment>
			<return>return <expr><call><name>polar_bt_clear_incomplete_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name><name>tags</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>polar_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_btree_idx_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_BTREE_INSERT_LEAF</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_insert_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_INSERT_UPPER</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_insert_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_INSERT_META</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_insert_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_SPLIT_L</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_SPLIT_R</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_SPLIT_L_HIGHKEY</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_SPLIT_R_HIGHKEY</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_split_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_VACUUM</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_MARK_PAGE_HALFDEAD</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_UNLINK_PAGE</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_unlink_page_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_NEWROOT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_newroot_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_REUSE_PAGE</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_META_CLEANUP</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_btree_idx_save: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_btree_idx_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_BTREE_INSERT_LEAF</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_insert_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_INSERT_UPPER</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_insert_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_INSERT_META</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_insert_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_SPLIT_L</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_SPLIT_R</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_SPLIT_L_HIGHKEY</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_SPLIT_R_HIGHKEY</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_split_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_VACUUM</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_cleanup_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_delete_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_MARK_PAGE_HALFDEAD</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_UNLINK_PAGE</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_unlink_page_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_NEWROOT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_newroot_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_REUSE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_btree_xlog_reuse_page_parse</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_META_CLEANUP</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_btree_idx_parse: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRedoAction</name></type>
<name>polar_btree_idx_redo</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_BTREE_INSERT_LEAF</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_insert</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_INSERT_UPPER</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_insert</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_INSERT_META</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_insert</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_SPLIT_L</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_split</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_SPLIT_L_HIGHKEY</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_split</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_SPLIT_R</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_split</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_SPLIT_R_HIGHKEY</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_split</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_VACUUM</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_vacuum</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_DELETE</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_delete</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_MARK_PAGE_HALFDEAD</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_mark_page_halfdead</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_UNLINK_PAGE</name></expr>:</case>
		<case>case <expr><name>XLOG_BTREE_UNLINK_PAGE_META</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_unlink_page</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_NEWROOT</name></expr>:</case>
			<return>return <expr><call><name>polar_btree_xlog_newroot</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_BTREE_REUSE_PAGE</name></expr>:</case>
			<comment type="block">/* Never go to here */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_BTREE_META_CLEANUP</name></expr>:</case>
			<return>return <expr><call><name>polar_bt_restore_meta</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_btree_idx_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
</unit>
