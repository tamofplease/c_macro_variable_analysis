<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_fullpage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_fullpage.c
 *    
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *           src/backend/access/logindex/polar_fullpage.c
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_fullpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_fullpage_online_promote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>open_fullpage_file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>open_fullpage_file_seg_no</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_old_fullpage_files</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>polar_xlog_read_fullpage_no</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialization of shared memory for fullpage control
 */</comment>
<function><type><name>Size</name></type>
<name>polar_fullpage_shmem_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_fullpage_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>polar_fullpage_ctl_t</name></type>
<name>polar_fullpage_shmem_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>polar_ringbuf_t</name></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FULLPAGE_SUFFIX</name></cpp:macro> <cpp:value>"_fp_ctl"</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>bool</name></type>    <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>item_name</name><index>[<expr><name>POLAR_MAX_SHMEM_NAME</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><name>POLAR_MAX_SHMEM_NAME</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FULLPAGE_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <operator>(</operator><name>polar_fullpage_ctl_t</name><operator>)</operator>
		  <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>item_name</name></expr></argument>, <argument><expr><call><name>polar_fullpage_shmem_size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_fullpage_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Init fullpage lock */</comment>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_FULLPAGE_FILE</name></expr></argument>, <argument><expr><literal type="string">"fullpage_file_lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>file_lock</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_FULLPAGE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAX_FULLPAGE_DIR_NAME_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>procno</name></name></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name> <operator>=</operator> <name>logindex_snapshot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <name>queue</name></expr>;</expr_stmt>

		<comment type="block">/* Validate that dir to save fullpage files is created */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>POLAR_DATA_DIR</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_validate_dir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>ctl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When initializing, we can only get max_fullpage_no from wal file, because we
 * don't save max_fullpage_no in meta file for compatibility.
 * If wal file is removed, it assume fullpage file isn't needed by anyone, just
 * reset fullpage_no to 0
 */</comment>
<function><type><name>void</name></type>
<name>polar_logindex_calc_max_fullpage_no</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullpage_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>   <name>xlog_seg_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set max_fullpage_no when logindex snapshot state is writable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl</name> <operator>||</operator> <operator>!</operator><call><name>polar_logindex_check_state</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>POLAR_LOGINDEX_STATE_WRITABLE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if max_fullpage_no has been set, nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"redo done at max_fullpage_no = %ld"</literal></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lsn</name> <operator>=</operator> <call><name>polar_get_logindex_snapshot_max_lsn</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check wal file is exist or not */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>xlog_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>xlog_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* wal file has been removed olready, we cannot get fullpage_no by lsn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>fullpage_no</name> <operator>=</operator> <call><name>polar_xlog_read_fullpage_no</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"redo done at max_fullpage_no = %ld"</literal></expr></argument>, <argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: we update max_fullpage_no when replay wal, we guarantee that fullpage_no
 * keep the same order with wal lsn, so last fullpage_no must be max_fullpage_no
 */</comment>
<function><type><name>void</name></type>
<name>polar_update_max_fullpage_no</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>fullpage_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install a new FULLPAGE segment file as a current or future log segment.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>install_fullpage_file_segment</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>seg_no</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmppath</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>max_segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FULLPAGE_SEG_FILE_NAME</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><name>seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to be sure that only one process does this at a time.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FULLPAGE_FILE_LOCK</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find a free slot to put it in */</comment>
	<while>while <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>seg_no</name><operator>)</operator> <operator>&gt;=</operator> <name>max_segno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Failed to find a free slot within specified range */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FULLPAGE_FILE_LOCK</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>seg_no</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FULLPAGE_SEG_FILE_NAME</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><name>seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Perform the rename using link if available, paranoidly trying to avoid
	 * overwriting an existing file (there shouldn't be one).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>durable_link_or_rename</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FULLPAGE_FILE_LOCK</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* durable_link_or_rename already emitted log message */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FULLPAGE_FILE_LOCK</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_fullpage_file_zero_pages</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tmppath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_MB</name></cpp:macro> <cpp:value>(1024 * 1024L)</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>aligned_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>POLAR_BUFFER_EXTEND_SIZE</name><argument_list>(<argument><expr><name>ONE_MB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aligned_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>POLAR_BUFFER_ALIGN</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FULLPAGE_FILE_INIT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nbytes</name> <operator>&lt;</operator> <name>FULLPAGE_SEGMENT_SIZE</name></expr>;</condition> <incr><expr><name>nbytes</name> <operator>+=</operator> <name>ONE_MB</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>     <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>polar_pwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aligned_data</name></expr></argument>, <argument><expr><name>ONE_MB</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>ONE_MB</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we fail to make the file, delete it to release disk space
			 */</comment>
			<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new FULLPAGE file segment, or open a pre-existing one.
 */</comment>
<function><type><name>int</name></type>
<name>polar_fullpage_file_init</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>fullpage_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>installed_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>max_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>polar_tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FULLPAGE_FILE_NAME</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to use existent file (polar worker maker may have created it already)
	 */</comment>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name> <operator>|</operator> <call><name>get_sync_bit</name><argument_list>(<argument><expr><name>sync_method</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>fd</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Initialize an empty (all zeroes) segment.  NOTE: it is possible that
	 * another process is doing the same thing.  If so, we will end up
	 * pre-creating an extra log segment.  That seems OK, and better than
	 * holding the lock throughout this lengthy process.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"creating and filling new FULLPAGE file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>polar_tmppath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/fullpagetemp.%d"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>polar_tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not use get_sync_bit() here --- want to fsync only at end of fill */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR: File allocate, juse change file metadata once */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_fallocate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FULLPAGE_SEGMENT_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"polar_fallocate fail in polar_fullpage_file_init"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fill_fullpage_file_zero_pages</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now move the segment into place with its final name.
	 *
	 * If caller didn't want to use a pre-existing file, get rid of any
	 * pre-existing file.  Otherwise, cope with possibility that someone else
	 * has created the file while we were filling ours: if so, use ours to
	 * pre-create a future log segment.
	 */</comment>
	<expr_stmt><expr><name>installed_segno</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>max_segno</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>polar_fullpage_keep_segments</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>install_fullpage_file_segment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>installed_segno</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>max_segno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No need for any more future segments, or install_fullpage_file_segment()
		 * failed to rename the file into place. If the rename failed, opening
		 * the file below will fail.
		 */</comment>
		<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now open original target segment (might not be file I just made) */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name> <operator>|</operator> <call><name>get_sync_bit</name><argument_list>(<argument><expr><name>sync_method</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"done creating and filling new FULLPAGE file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Open a fullpage file segment for read or write.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fullpage_file_open</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>fullpage_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FULLPAGE_FILE_NAME</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>fd</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* unexpected failure? */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>polar_fullpage_file_init</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>polar_log_fullpage_begin</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * fullpage_no must keep the same order with lsn.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FULLPAGE_FILE_LOCK</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_log_fullpage_end</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LOG_INDEX_FULLPAGE_FILE_LOCK</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: write old version page to fullpage file
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_write_fullpage</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>fullpage_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>open_fullpage_file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>open_fullpage_file</name> <operator>=</operator> <call><name>fullpage_file_open</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>open_fullpage_file_seg_no</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>open_fullpage_file_seg_no</name> <operator>!=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>open_fullpage_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>open_fullpage_file</name> <operator>=</operator> <call><name>fullpage_file_open</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>open_fullpage_file_seg_no</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_pwrite</name><argument_list>(<argument><expr><name>open_fullpage_file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><call><name>FULLPAGE_FILE_OFFSET</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: read old version page from fullpage file
 */</comment>
<function><type><name>void</name></type>
<name>polar_read_fullpage</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>fullpage_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>open_fullpage_file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>open_fullpage_file</name> <operator>=</operator> <call><name>fullpage_file_open</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>open_fullpage_file_seg_no</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>open_fullpage_file_seg_no</name> <operator>!=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>open_fullpage_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>open_fullpage_file</name> <operator>=</operator> <call><name>fullpage_file_open</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>open_fullpage_file_seg_no</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_pread</name><argument_list>(<argument><expr><name>open_fullpage_file</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><call><name>FULLPAGE_FILE_OFFSET</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Preallocate fullpage files
 */</comment>
<function><type><name>void</name></type>
<name>polar_prealloc_fullpage_files</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>max_fullpage_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>file</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctl</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>max_fullpage_no</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>polar_fullpage_file_init</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>max_fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_fullpage_no</name> <operator>+=</operator> <name>FULLPAGE_NUM_PER_FILE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Recycle or remove a fullpage file that's no longer needed.
 */</comment>
<function><type><name>void</name></type>
<name>polar_remove_old_fullpage_file</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>segname</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>min_fullpage_seg_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>end_fullpage_seg_no</name> <init>= <expr><call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>max_fullpage_no</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>recycle_seg_no</name> <init>= <expr><name>min_fullpage_seg_no</name> <operator>+</operator> <name>polar_fullpage_keep_segments</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before deleting the file, see if it can be recycled as a future fullpage
	 * segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>end_fullpage_seg_no</name> <operator>&lt;=</operator> <name>recycle_seg_no</name> <operator>&amp;&amp;</operator>
			<call><name>polar_lstat</name><argument_list>(<argument><expr><name>segname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>install_fullpage_file_segment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_fullpage_seg_no</name></expr></argument>, <argument><expr><name>segname</name></expr></argument>,
										  <argument><expr><name>recycle_seg_no</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: force log */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recycled fullpage file \"%s\""</literal></expr></argument>,
						<argument><expr><name>segname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No need for any more future segments... */</comment>
		<decl_stmt><decl><type><name>int</name></type>         <name>rc</name></decl>;</decl_stmt>

		<comment type="block">/* POLAR: force log */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing fullpage file \"%s\""</literal></expr></argument>,
						<argument><expr><name>segname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>durable_unlink</name><argument_list>(<argument><expr><name>segname</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Message already logged by durable_unlink() */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recycle or remove all fullpage files older to passed segno.
 * It's a extern function
 */</comment>
<function><type><name>void</name></type>
<name>polar_remove_old_fullpage_files</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>min_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_logindex_truncate</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>min_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>remove_old_fullpage_files</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>polar_xlog_read_fullpage_no</name><parameter_list>(<parameter><decl><type><name>logindex_snapshot_t</name></type> <name>logindex_snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>fullpage_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlogreader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_local_xlog_page</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read fullpage wal state from WAL at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetRmid</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RM_XLOG_ID</name> <operator>||</operator>
			<operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name><operator>)</operator> <operator>!=</operator> <name>XLOG_FPSI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected fullpage wal state data is not present in WAL at %X/%X"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get fullpage_no from record */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fullpage_no</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogReaderFree</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>fullpage_no</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recycle or remove all fullpage files older to passed segno.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_old_fullpage_files</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>min_fullpage_seg_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullpage_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>   <name>xlog_seg_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>min_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>min_lsn</name> <operator>=</operator> <call><name>polar_get_logindex_snapshot_storage_min_lsn</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check wal file is exist or not */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>min_lsn</name></expr></argument>, <argument><expr><name>xlog_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>xlog_seg_no</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* wal file has been removed already, we cannot get fullpage_no by lsn */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fullpage_no</name> <operator>=</operator> <call><name>polar_xlog_read_fullpage_no</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>min_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>min_fullpage_seg_no</name> <operator>=</operator> <call><name>FULLPAGE_FILE_SEG_NO</name><argument_list>(<argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>min_fullpage_seg_no</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must remove segments older than min_fullpage_seg_no */</comment>
		<expr_stmt><expr><name>min_fullpage_seg_no</name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FULLPAGE_SEG_FILE_NAME</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>min_fullpage_seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* File has been removed already */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove FULLPAGE segments older than log file %s"</literal></expr></argument>,
			 <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_remove_old_fullpage_file</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>min_fullpage_seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: write a WAL record containing a full snapshot image of a page. Caller is
 * responsible for writing the page to disk after calling this routine.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>polar_log_fullpage_snapshot_image</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>oldest_apply_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>smgr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>  <name>forkNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferDesc</name> <modifier>*</modifier></type><name>buf_hdr</name> <init>= <expr><call><name>GetBufferDescriptor</name><argument_list>(<argument><expr><name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullpage_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fullpage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We allocate the old page space once and use it over on each subsequent
	 * call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fullpage</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fullpage</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_NO_IMAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forkNum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have copy buffer, and copy buffer can be flushed,
	 * just treat copy buffer as fullpage, so we can avoid reading
	 * older page from storage
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>copy_buffer</name></name> <operator>&amp;&amp;</operator>
			<call><name>polar_copy_buffer_get_lsn</name><argument_list>(<argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>oldest_apply_lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fullpage</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>CopyBufHdrGetBlock</name><argument_list>(<argument><expr><name><name>buf_hdr</name><operator>-&gt;</operator><name>copy_buffer</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Find smgr relation for buffer */</comment>
		<expr_stmt><expr><name>smgr</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>smgrread</name><argument_list>(<argument><expr><name>smgr</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fullpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check for garbage data, decrypt page if it has beed encrypted */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerified</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>fullpage</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>smgr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s"</literal></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>,
							<argument><expr><call><name>relpath</name><argument_list>(<argument><expr><name><name>smgr</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * POLAR: get fullpage write lock, only one process can
	 * write fullpage wal record at the same time, we expected
	 * that fullpage_no keep the same order with lsn, it's used
	 * for easily cleaning fullpage file
	 * NOTE: we assume that XLogInsert is more faster then smgrread
	 * and polar_write_fullpage
	 */</comment>
	<expr_stmt><expr><name>fullpage_no</name> <operator>=</operator> <call><name>polar_log_fullpage_begin</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>fullpage_no</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XLOG_ID</name></expr></argument>, <argument><expr><name>XLOG_FPSI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: release fullpage write lock */</comment>
	<expr_stmt><expr><call><name>polar_log_fullpage_end</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_write_fullpage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>fullpage</name></expr></argument>, <argument><expr><name>fullpage_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: this function is only used for polar worker pop record from queue
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecord</name> <modifier>*</modifier></type>
<name>polar_fullpage_bgworker_xlog_recv_queue_pop</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_ringbuf_ref_t</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,
											<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>pktlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>xlog_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>read_rec_ptr</name></decl>, <decl><type ref="prev"/><name>end_rec_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>pop_storage</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>errormsg_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Fullpage redo start from %lX"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>  <name>pkt_type</name> <init>= <expr><name>POLAR_RINGBUF_PKT_INVALID_TYPE</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pop_storage</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_ringbuf_avail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pkt_type</name> <operator>=</operator> <call><name>polar_ringbuf_next_ready_pkt</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pktlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>pkt_type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>POLAR_RINGBUF_PKT_WAL_META</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_rec_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlog_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>read_rec_ptr</name> <operator>=</operator> <name>end_rec_ptr</name> <operator>-</operator> <name>xlog_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_len</name> <operator>=</operator> <name>pktlen</name> <operator>-</operator> <name>POLAR_XLOG_HEAD_SIZE</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>data_len</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readRecordBufSize</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>allocate_recordbuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>POLAR_COPY_QUEUE_CONTENT</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readLen</name></name> <operator>=</operator> <name>data_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>end_rec_ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>=</operator> <name>read_rec_ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>noPayload</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>readRecordBuf</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_xlog_queue_decode</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>POLAR_RINGBUF_PKT_WAL_STORAGE_BEGIN</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_ringbuf_update_ref</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pop_storage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
	while <condition>(<expr><operator>(</operator><name>record</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&lt;=</operator> <call><name>polar_get_logindex_snapshot_max_lsn</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>)</argument_list></call>
					   <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>ReadRecPtr</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>currRecPtr</name></name><operator>)</operator><operator>)</operator> <operator>||</operator> <name>pop_storage</name></expr>)</condition>;</do>

	<return>return <expr><name>record</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: polar worker replay fullpage wal record, only replica
 * can do this
 */</comment>
<function><type><name>void</name></type>
<name>polar_bgworker_fullpage_snapshot_replay</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>errormsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_load_logindex_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>polar_ringbuf_ref_t</name></type> <name>ref</name> <init>= <expr><block>{ <expr><operator>.</operator><name>slot</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl> ;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogReaderState</name> <modifier>*</modifier></type><name>xlogreader</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* wait util reach consistency mode */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HotStandbyActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>ref</name><operator>.</operator><name>slot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>polar_fullpage_online_promote</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>POLAR_XLOG_QUEUE_NEW_REF</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"polar_fullpage_xlog_queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set up XLOG reader facility */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xlogreader</name> <operator>=</operator> <call><name>XLogReaderAllocate</name><argument_list>(<argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*no cover begin*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlogreader</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed while allocating a WAL reading processor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*no cover end*/</comment>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>polar_fullpage_bgworker_xlog_recv_queue_pop</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>==</operator> <name>RM_XLOG_ID</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>==</operator> <name>XLOG_FPSI</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POLAR_LOG_INDEX_ADD_LSN</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>xlogreader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_replay_end_ptr</name> <init>= <expr><call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>polar_fullpage_get_online_promote</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_ringbuf_release_ref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ref</name><operator>.</operator><name>slot</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>errormsg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Failed to read xlog for fullpage, errmsg=%s"</literal></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We load logindex from storage in following cases:
			 * 1. read from file instead of queue
			 * 2. wal receiver hang or lost for a long time(1s?)
			 * 3. periodly load logindex from storage(1s)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(
						<argument><expr><call><name>polar_get_walrcv_last_msg_receipt_time</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>TimestampDifferenceExceeds</name><argument_list>(
						<argument><expr><name>last_load_logindex_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>last_load_logindex_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_load_logindex_snapshot_from_storage</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>logindex_snapshot</name></name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * POLAR: when read from wal file instead of queue maybe very slow.
			 * we use replay_lsn for polar worker catch up with starup replay
			 * when replay fullpage wal, because polar worker don't need to
			 * replay wal lsn less then replay_lsn, the future page fullpage
			 * snapshot wal lsn must be bigger then replay_lsn
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>xlogreader</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>&lt;</operator> <name>last_replay_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlogreader</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>=</operator> <name>last_replay_end_ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_fullpage_bgworker_wait_notify</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ctl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>procno</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_fullpage_bgworker_wakeup</name><parameter_list>(<parameter><decl><type><name>polar_fullpage_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>procno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctl</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>procno</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>procno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>procno</name> <operator>!=</operator> <name>INVALID_PGPROCNO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>procno</name></name></expr></argument>, <argument><expr><name>INVALID_PGPROCNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * Not acquiring ProcArrayLock here which is slightly icky. It's
			 * actually fine because procLatch isn't ever freed, so we just can
			 * potentially set the wrong process' (or no process') latch.
			 */</comment>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>procno</name></expr>]</index></name><operator>.</operator><name>procLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_fullpage_set_online_promote</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>online_promote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>polar_fullpage_online_promote</name> <operator>=</operator> <name>online_promote</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_fullpage_get_online_promote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>polar_fullpage_online_promote</name></expr>;</return>
</block_content>}</block></function>

</unit>
