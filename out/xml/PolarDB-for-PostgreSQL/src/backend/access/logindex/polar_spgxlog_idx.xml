<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_spgxlog_idx.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_spgxlog_idx.c
 *    WAL redo parse logic for spg index.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *           src/backend/access/logindex/polar_spgxlog_idx.c
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_spg_redo_add_node_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_spg_redo_add_node_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update parent downlink (if we didn't do it as part of the source or
		 * destination page update already).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_spg_redo_pick_split_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_spg_redo_pick_split_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>src_tag</name></decl>, <decl><type ref="prev"/><name>dst_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>src_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>,
					  <decl><type ref="prev"/><name>dst_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>    <name>src_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>,
			  <decl><type ref="prev"/><name>dst_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src_tag</name></expr></argument>, <argument><expr><name>src_lock</name></expr></argument>, <argument><expr><name>src_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dst_tag</name></expr></argument>, <argument><expr><name>dst_lock</name></expr></argument>, <argument><expr><name>dst_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>src_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>src_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>src_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>dst_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>dst_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>dst_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_spg_redo_vacuum_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If any redirection tuples are being removed, make sure there are no
	 * live Hot Standby transactions that might need to see them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>spgxlogVacuumRedirect</name> <modifier>*</modifier></type><name>xldata</name> <init>=
			<expr><operator>(</operator><name>spgxlogVacuumRedirect</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>newestRedirectXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelFileNode</name></type> <name>node</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>newestRedirectXid</name></name></expr></argument>,
												<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_create_index</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>meta_tag</name></decl>, <decl><type ref="prev"/><name>leaf_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitMetapage</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>SPGIST_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_NULL_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <name>SPGIST_NULLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_add_leaf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogAddLeaf</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogAddLeaf</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leafTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistLeafTupleData</name></type> <name>leafTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>leaf_tag</name></decl>, <decl><type ref="prev"/><name>parent_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>spgxlogAddLeaf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the leaf tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leafTupleHdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In normal operation we would have both current and parent pages locked
		 * simultaneously; but in WAL replay it should be safe to update the leaf
		 * page before updating the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
							 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert new tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumHeadLeaf</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* normal cases, tuple was added by SpGistPageAddNewItem */</comment>
				<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
								  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* update head tuple's chain link if needed */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumHeadLeaf</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>head</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
														 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumHeadLeaf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name><name>leafTupleHdr</name><operator>.</operator><name>nextOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* replacing a DEAD tuple */</comment>
				<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
								<argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
								<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
						 <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* update parent downlink if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoLeaf</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
													   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
								  <argument><expr><name>blknoLeaf</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_move_leafs</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name>  <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogMoveLeafs</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogMoveLeafs</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>nInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoDst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>leaf_tag</name></decl>, <decl><type ref="prev"/><name>src_tag</name></decl>, <decl><type ref="prev"/><name>parent_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoDst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nInsert</name> <operator>=</operator> <ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>replaceDead</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>xldata</name><operator>-&gt;</operator><name>nMoves</name></name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfSpgxlogMoveLeafs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMoves</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toInsert</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nInsert</name></expr>;</expr_stmt>

	<comment type="block">/* now ptr points to the list of leaf tuples */</comment>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>leaf_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In normal operation we would have all three pages (source, dest, and
		 * parent) locked simultaneously; but in WAL replay it should be safe to
		 * update them one at a time, as long as we do it in the right order.
		 */</comment>

		<comment type="block">/* Insert tuples on the dest page (do first, so redirect is valid) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
							 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nInsert</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leafTuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SpGistLeafTupleData</name></type> <name>leafTupleHdr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * the tuples are not aligned, so must copy to access the size
				 * field.
				 */</comment>
				<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leafTupleHdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>,
								  <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>toInsert</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>src_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>src_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Delete tuples from the source page, inserting a redirection pointer */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nMoves</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr> ?</condition><then> <expr><name>SPGIST_PLACEHOLDER</name></expr> </then><else>: <expr><name>SPGIST_REDIRECT</name></expr></else></ternary></expr></argument>,
									<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
									<argument><expr><name>blknoDst</name></expr></argument>,
									<argument><expr><name><name>toInsert</name><index>[<expr><name>nInsert</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* And update the parent downlink */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
												   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
							  <argument><expr><name>blknoDst</name></expr></argument>, <argument><expr><name><name>toInsert</name><index>[<expr><name>nInsert</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_add_node</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogAddNode</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogAddNode</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>innerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>innerTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>old_tag</name></decl>, <decl><type ref="prev"/><name>new_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>spgxlogAddNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>innerTupleHdr</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* update in place */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
								<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
						 <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>

		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In normal operation we would have all three pages (source, dest,
		 * and parent) locked simultaneously; but in WAL replay it should be
		 * safe to update them one at a time, as long as we do it in the right
		 * order. We must insert the new tuple before replacing the old tuple
		 * with the redirect tuple.
		 */</comment>

		<comment type="block">/* Install new tuple first so redirect is valid */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* AddNode is not used for nulls pages */</comment>
				<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>,
								  <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If parent is in this same page, update it now.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parentTuple</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>parentTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
																 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parentTuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
									  <argument><expr><name><name>new_tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Delete old tuple, replacing it with redirect or placeholder tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dt</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										  <argument><expr><name>InvalidBlockNumber</name></expr></argument>,
										  <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>dt</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>SPGIST_REDIRECT</name></expr></argument>,
										  <argument><expr><name><name>new_tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>,
										  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>dt</name></expr></argument>, <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
								<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
						 <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nRedirection</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * If parent is in this same page, update it now.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parentTuple</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>parentTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
																 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parentTuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
									  <argument><expr><name><name>new_tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Update parent downlink (if we didn't do it as part of the source or
		 * destination page update already).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BufferTag</name></type> <name>parent_tag</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parentTuple</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>parentTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
																 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parentTuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
									  <argument><expr><name><name>new_tag</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_split_tuple</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogSplitTuple</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogSplitTuple</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>prefixTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>prefixTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>postfixTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>postfixTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>update_tag</name></decl>, <decl><type ref="prev"/><name>orig_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>spgxlogSplitTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>prefixTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the prefix tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixTupleHdr</name></expr></argument>, <argument><expr><name>prefixTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>prefixTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>postfixTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* postfix tuple is also unaligned */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>postfixTupleHdr</name></expr></argument>, <argument><expr><name>postfixTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In normal operation we would have both pages locked simultaneously; but
	 * in WAL replay it should be safe to update them one at a time, as long
	 * as we do it in the right order.
	 */</comment>

	<comment type="block">/* insert postfix tuple first to avoid dangling link */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xldata</name><operator>-&gt;</operator><name>postfixBlkSame</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>update_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>update_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* SplitTuple is not used for nulls pages */</comment>
				<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>postfixTuple</name></expr></argument>,
								  <argument><expr><name><name>postfixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPostfix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>orig_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>orig_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* now handle the original page */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPrefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>prefixTuple</name></expr></argument>, <argument><expr><name><name>prefixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPrefix</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumPrefix</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
					 <argument><expr><name><name>prefixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>postfixBlkSame</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>postfixTuple</name></expr></argument>,
								  <argument><expr><name><name>postfixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
								  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPostfix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_pick_split</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogPickSplit</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogPickSplit</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>innerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>innerTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>      <modifier>*</modifier></type><name>leafPageSelect</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>srcPage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>destPage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoInner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>src_tag</name></decl>, <decl><type ref="prev"/><name>dst_tag</name></decl>, <decl><type ref="prev"/><name>inner_tag</name></decl>, <decl><type ref="prev"/><name>parent_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoInner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfSpgxlogPickSplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toInsert</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nInsert</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafPageSelect</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nInsert</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the inner tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>innerTupleHdr</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>src_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>src_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* now ptr points to the list of leaf tuples */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>isRootSplit</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* when splitting root, we touch it only in the guise of new inner */</comment>
				<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>initSrc</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* just re-init the source page */</comment>
				<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
								 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* don't update LSN etc till we're done with it */</comment>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Delete the specified tuples from source page.  (In case we're in
				 * Hot Standby, we need to hold lock on the page till we're done
				 * inserting leaf tuples and the new inner tuple, else the added
				 * redirect tuple will be a dangling link.)
				 */</comment>
				<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We have it a bit easier here than in doPickSplit(), because we
					 * know the inner tuple's location already, so we can inject the
					 * correct redirection tuple now.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>srcPage</name></expr></argument>,
												<argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr></argument>,
												<argument><expr><name>SPGIST_REDIRECT</name></expr></argument>,
												<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
												<argument><expr><name>blknoInner</name></expr></argument>,
												<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>srcPage</name></expr></argument>,
												<argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr></argument>,
												<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
												<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
												<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
												<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/* don't update LSN etc till we're done with it */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* try to access dest page if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>destPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>dst_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>dst_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>initDest</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* just re-init the dest page */</comment>
				<expr_stmt><expr><name>destPage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
								 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* don't update LSN etc till we're done with it */</comment>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We could probably release the page lock immediately in the
				 * full-page-image case, but for safety let's hold it till later.
				 */</comment>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>destPage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>destPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* don't do any page updates */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>srcPage</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>destPage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* restore leaf tuples to src and/or dest page */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nInsert</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>leafTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SpGistLeafTupleData</name></type> <name>leafTupleHdr</name></decl>;</decl_stmt>

			<comment type="block">/* the tuples are not aligned, so must copy to access the size field. */</comment>
			<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leafTupleHdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <ternary><condition><expr><name><name>leafPageSelect</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name>destPage</name></expr> </then><else>: <expr><name>srcPage</name></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>           <comment type="block">/* no need to touch this page */</comment>

			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							  <argument><expr><name><name>toInsert</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>srcPage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>srcPage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>destPage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>destPage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>inner_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>inner_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* restore new inner tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>initInner</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if inner is also parent, update link while we're here */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>innerIsParent</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parent</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
														<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
								  <argument><expr><name>blknoInner</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* update parent downlink, unless we did it above */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>parent_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parent</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
														<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
								  <argument><expr><name>blknoInner</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>innerIsParent</name></name> <operator>||</operator> <name><name>xldata</name><operator>-&gt;</operator><name>isRootSplit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_vacuum_leaf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumLeaf</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogVacuumLeaf</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toPlaceholder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>moveSrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>moveDest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>chainSrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>chainDest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>  <name>vacuum_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>vacuum_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>vacuum_tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfSpgxlogVacuumLeaf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDead</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nDead</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toPlaceholder</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nPlaceholder</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>moveSrc</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>moveDest</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chainSrc</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nChain</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chainDest</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
								<argument><expr><name>toDead</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDead</name></name></expr></argument>,
								<argument><expr><name>SPGIST_DEAD</name></expr></argument>, <argument><expr><name>SPGIST_DEAD</name></expr></argument>,
								<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
								<argument><expr><name>toPlaceholder</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nPlaceholder</name></name></expr></argument>,
								<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
								<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* see comments in vacuumLeafPage() */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>      <name>idSrc</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>moveSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>      <name>idDest</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>moveDest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemIdData</name></type>  <name>tmp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>idSrc</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>idSrc</name> <operator>=</operator> <operator>*</operator><name>idDest</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>idDest</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
								<argument><expr><name>moveSrc</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr></argument>,
								<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
								<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nChain</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>lt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>chainSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name><name>chainDest</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_vacuum_root</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumRoot</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogVacuumRoot</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type>  <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>del_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offsets</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The tuple numbers are in order */</comment>
		<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_spg_redo_vacuum_redirect</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumRedirect</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogVacuumRedirect</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>itemToPlaceholder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>vacuum_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>vacuum_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>vacuum_tag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>itemToPlaceholder</name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offsets</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpGistPageOpaque</name></type> <name>opaque</name> <init>= <expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Convert redirect pointers to plain placeholders */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>dt</name> <operator>=</operator> <operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>itemToPlaceholder</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>=</operator> <name>SPGIST_PLACEHOLDER</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name> <operator>&gt;=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name> <operator>-=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>+=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr>;</expr_stmt>

		<comment type="block">/* Remove placeholder tuples at end of page */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>         <name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>i</name> <operator>-</operator> <name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <name>max</name> <operator>-</operator> <name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>&gt;=</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>

			<comment type="block">/* The array is sorted, so can use PageIndexMultiDelete */</comment>
			<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>toDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_spg_idx_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_SPGIST_CREATE_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_ADD_LEAF</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_MOVE_LEAFS</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_ADD_NODE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_spg_redo_add_node_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_SPLIT_TUPLE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_PICKSPLIT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_spg_redo_pick_split_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_VACUUM_LEAF</name></expr>:</case>
		<case>case <expr><name>XLOG_SPGIST_VACUUM_ROOT</name></expr>:</case>
		<case>case <expr><name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_spg_idx_save: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_spg_idx_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_SPGIST_CREATE_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_ADD_LEAF</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_MOVE_LEAFS</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_ADD_NODE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_spg_redo_add_node_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_SPLIT_TUPLE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_PICKSPLIT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_spg_redo_pick_split_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_VACUUM_LEAF</name></expr>:</case>
		<case>case <expr><name>XLOG_SPGIST_VACUUM_ROOT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_spg_redo_vacuum_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_spg_idx_parse: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRedoAction</name></type>
<name>polar_spg_idx_redo</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,  <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_ctx</name></decl>, <decl><type ref="prev"/><name>redo_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>redo_ctx</name> <operator>=</operator> <call><name>polar_get_redo_context</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_ctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>redo_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_SPGIST_CREATE_INDEX</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_create_index</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_ADD_LEAF</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_add_leaf</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_MOVE_LEAFS</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_move_leafs</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_ADD_NODE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_add_node</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_SPLIT_TUPLE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_split_tuple</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_PICKSPLIT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_pick_split</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_VACUUM_LEAF</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_vacuum_leaf</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_VACUUM_ROOT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_vacuum_root</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_spg_redo_vacuum_redirect</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_spg_idx_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>redo_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>
</unit>
