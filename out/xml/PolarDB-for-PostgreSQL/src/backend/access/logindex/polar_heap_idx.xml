<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_heap_idx.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_heap2_idx.c
 *   Implementation of parse heap2 records.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *   src/backend/access/logindex/polar_heap2_idx.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_clear_vm</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rnode</name></decl></parameter>,
					<parameter><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>    <name>reln</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><operator>*</operator><name>rnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>mapByte</name> <init>= <expr><call><name>HEAPBLK_TO_MAPBYTE</name><argument_list>(<argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>mapOffset</name> <init>= <expr><call><name>HEAPBLK_TO_OFFSET</name><argument_list>(<argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>mask</name> <init>= <expr><name>flags</name> <operator>&lt;&lt;</operator> <name>mapOffset</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>PageGetContents</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>map</name><index>[<expr><name>mapByte</name></expr>]</index></name> <operator>&amp;</operator> <name>mask</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>map</name><index>[<expr><name>mapByte</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_vm_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>heap_block</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>vm_block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>heap_tag</name></decl>, <decl><type ref="prev"/><name>vm_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>vm_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>heap_tag</name></expr></argument>, <argument><expr><name>heap_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>vm_tag</name></expr></argument>, <argument><expr><name>vm_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name><name>heap_tag</name><operator>.</operator><name>rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vm_lock</name> <operator>=</operator> <call><name>polar_logindex_mini_trans_lock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vm_tag</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>polar_logindex_outdate_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heap_tag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vm_lock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>vm_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_insert_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_insert</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_insert_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_insert</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_multi_insert_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_clean_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_clean</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_clean</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're about to remove tuples. In Hot Standby mode, ensure that there's
	 * no queries running for which the removed tuples are still visible.
	 *
	 * Not all HEAP2_CLEAN records remove tuples with xids, so we only want to
	 * conflict on the records that cause MVCC failures for user queries. If
	 * latestRemovedXid is invalid, skip conflict processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name> <operator>&amp;&amp;</operator> <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_cleanup_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_freeze_page_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * In Hot Standby mode, ensure that there's no queries running which still
	 * consider the frozen xids as running.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_freeze_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_freeze_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name> <init>= <expr><name><name>xlrec</name><operator>-&gt;</operator><name>cutoff_xid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>cutoff_xid</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_cleanup_info_parse</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_cleanup_info</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_cleanup_info</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Actual operation is a no-op. Record type exists to provide a means for
	 * conflict processing to occur before we begin index vacuum actions. see
	 * vacuumlazy.c and also comments in btvacuumpage()
	 */</comment>

	<comment type="block">/* Backup blocks are not used in cleanup_info records */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_visible_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If there are any Hot Standby transactions running that have an xmin
	 * horizon old enough that this page isn't all-visible for them, they
	 * might incorrectly decide that an index-only scan can skip a heap fetch.
	 *
	 * NB: It might be better to throw some kind of "soft" conflict here that
	 * forces any index-only scan that is in flight to perform heap fetches,
	 * rather than killing the transaction outright.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_resolve_conflict</name> <operator>&amp;&amp;</operator> <name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_visible</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_visible</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cutoff_xid</name></name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_multi_insert_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_delete_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_delete</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_delete_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_delete</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_lock_update_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_lock_updated</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock_updated</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_lock_update_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_lock_updated</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock_updated</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_lock_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_lock</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_lock_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_lock</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock</name> <operator>*</operator><operator>)</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_xlog_update_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hotupdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>oldblk</name></decl>, <decl><type ref="prev"/><name>newblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>old_cleared_vm</name></decl>, <decl><type ref="prev"/><name>new_cleared_vm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_update</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_update</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>old_cleared_vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>new_cleared_vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldblk</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* HOT updates are never done across pages */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>hotupdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name>newblk</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type> <name>vm_block</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>vm_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_cleared_vm</name></expr></argument>, <argument><expr><name>vm_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldblk</name> <operator>!=</operator> <name>newblk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Avoid add the same vm page to logindex twice with the same lsn value */</comment>
			<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>new_cleared_vm</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name>old_cleared_vm</name></expr></argument>, <argument><expr><name>new_cleared_vm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_heap_xlog_update_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hotupdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>old_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>old_cleared_vm</name></decl>, <decl><type ref="prev"/><name>new_cleared_vm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>oldblk</name></decl>, <decl><type ref="prev"/><name>newblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>new_page_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>old_page_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>nbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>, <decl><type ref="prev"/><name>obuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_update</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_update</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>main_data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>old_cleared_vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>new_cleared_vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newblk</name> <operator>=</operator> <name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>hotupdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name><name>tag1</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name>newblk</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type> <name>heap_block</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type> <name>vm_block</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>heap_block</name></expr></argument>, <argument><expr><name>vm_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_cleared_vm</name></expr></argument>, <argument><expr><name>vm_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>old_tag</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>tag0</name></expr> </then><else>: <expr><operator>&amp;</operator><name>tag1</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_page_lock</name> <operator>=</operator> <call><name>polar_logindex_mini_trans_lock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>obuffer</name> <operator>=</operator> <call><name>polar_logindex_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldblk</name> <operator>!=</operator> <name>newblk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><name>new_page_lock</name></expr></argument>, <argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Avoid add the same vm page to logindex twice with the same lsn value */</comment>
			<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>new_cleared_vm</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name>old_cleared_vm</name></expr></argument>, <argument><expr><name>new_cleared_vm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_heap_vm_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nbuffer</name> <operator>!=</operator> <name>obuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldblk</name> <operator>!=</operator> <name>newblk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>new_page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>obuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>obuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>old_page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handles HEAP2_CLEAN record type
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_clean</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_clean</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_clean</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have a full-page image, restore it (using a cleanup lock) and
	 * we're done.
	 */</comment>
	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>redirected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowdead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowunused</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>nredirected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>ndead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>nunused</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>redirected</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nredirected</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nredirected</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndead</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ndead</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>redirected</name> <operator>+</operator> <name>datalen</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nowdead</name> <operator>=</operator> <name>redirected</name> <operator>+</operator> <operator>(</operator><name>nredirected</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nowunused</name> <operator>=</operator> <name>nowdead</name> <operator>+</operator> <name>ndead</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nunused</name> <operator>=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>nowunused</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nunused</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update all item pointers per the record, and repair fragmentation */</comment>
		<expr_stmt><expr><call><name>heap_page_prune_execute</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
								<argument><expr><name>redirected</name></expr></argument>, <argument><expr><name>nredirected</name></expr></argument>,
								<argument><expr><name>nowdead</name></expr></argument>, <argument><expr><name>ndead</name></expr></argument>,
								<argument><expr><name>nowunused</name></expr></argument>, <argument><expr><name>nunused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: we don't worry about updating the page's prunability hints.
		 * At worst this will cause an extra prune cycle to occur soon.
		 */</comment>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replay XLOG_HEAP2_VISIBLE record.
 *
 * The critical integrity requirement here is that we must never end up with
 * a situation where the visibility map bit is set, and the page-level
 * PD_ALL_VISIBLE bit is clear.  If that were to occur, then a subsequent
 * page modification would fail to clear the visibility map bit.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_visible</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_visible</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_visible</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Read the heap page, if it still exists. If the heap file has dropped or
		 * truncated later in recovery, we don't need to update the page, but we'd
		 * better still update the visibility map.
		 */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We don't bump the LSN of the heap page when setting the visibility
			 * map bit (unless checksums or wal_hint_bits is enabled, in which
			 * case we must), because that would generate an unworkable volume of
			 * full-page writes.  This exposes us to torn page hazards, but since
			 * we're not inspecting the existing page contents in any way, we
			 * don't care.
			 *
			 * However, all operations that clear the visibility map bit *do* bump
			 * the LSN, and those operations will only be replayed if the XLOG LSN
			 * follows the page LSN.  Thus, if the page LSN has advanced past our
			 * XLOG record's LSN, we mustn't mark the page all-visible, because
			 * the subsequent update won't be replayed to clear the flag.
			 */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Update lsn otherwise we would not mark buffer dirty during online promote */</comment>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_RESTORED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If heap block was backed up, we already restored it and there's
			 * nothing more to do. (This can only happen with checksums or
			 * wal_log_hints enabled.)
			 */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReadBufferMode</name></type> <name>mode</name> <init>= <expr><ternary><condition><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>RBM_NORMAL_VALID</name></expr> </then><else>: <expr><name>RBM_ZERO_ON_ERROR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Even if we skipped the heap page update due to the LSN interlock, it's
		 * still safe to update the visibility map.  Any WAL record that clears
		 * the visibility map bit does so before checking the page LSN, so any
		 * bits that need to be cleared will still be cleared.
		 */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>vmpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* initialize the page if it was read as zeros */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>vmpage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>vmpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Don't set the bit if replay has already passed this point.
			 *
			 * It might be safe to do this unconditionally; if replay has passed
			 * this point, we'll replay at least as far this time as we did
			 * before, and if this bit needs to be cleared, the record responsible
			 * for doing so should be again replayed, and clear it.  For right
			 * now, out of an abundance of conservatism, we use the same test here
			 * we did for the heap page.  If this results in a dropped bit, no
			 * real harm is done; and the next VACUUM will fix it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>vmpage</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_visibilitymap_set</name><argument_list>(<argument><expr><name><name>tag1</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>vmpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_freeze_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_freeze_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_freeze_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>ntup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>        <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>tuples</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuples</name> <operator>=</operator> <operator>(</operator><name>xl_heap_freeze_tuple</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now execute freeze plan for each frozen tuple */</comment>
		<for>for <control>(<init><expr><name>ntup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ntup</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>ntup</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>xlrec_tp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>xlrec_tp</name> <operator>=</operator> <operator>&amp;</operator><name><name>tuples</name><index>[<expr><name>ntup</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xlrec_tp</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* offsets are one-based */</comment>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_execute_freeze_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>xlrec_tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handles MULTI_INSERT record type.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_multi_insert</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HeapTupleHeaderData</name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>data</name><index>[<expr><name>MaxHeapTupleSize</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>           <decl><name>tbuf</name></decl>;</union>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>isinit</name> <init>= <expr><operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_INIT_PAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Insertion doesn't overwrite MVCC data, so no conflict processing is
	 * required.
	 */</comment>
	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>, <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map may need to be fixed even if the heap page is
		 * already up-to-date.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
										 <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><name>tag0</name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isinit</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tupdata</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

			<comment type="block">/* Tuples are stored as block data */</comment>
			<expr_stmt><expr><name>tupdata</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>tupdata</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>xl_multi_insert_tuple</name> <modifier>*</modifier></type><name>xlhdr</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we're reinitializing the page, the tuples are stored in
				 * order from FirstOffsetNumber. Otherwise there's an array of
				 * offsets in the WAL record, and the tuples come after that.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>isinit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>offnum</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid max offset number, page_max_off=%ld, offnum=%d"</literal></expr></argument>,
						 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>xlhdr</name> <operator>=</operator> <operator>(</operator><name>xl_multi_insert_tuple</name> <operator>*</operator><operator>)</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>tupdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tupdata</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlhdr</name><operator>)</operator> <operator>+</operator> <name>SizeOfMultiInsertTuple</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>datalen</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newlen</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbuf</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* PG73FORMAT: get bitmap [+ padding] [+ oid] + data */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tupdata</name></expr></argument>,
					   <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tupdata</name> <operator>+=</operator> <name>newlen</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>newlen</name> <operator>+=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>tupdata</name> <operator>!=</operator> <name>endptr</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"total tuple length mismatch, gap=%ld"</literal></expr></argument>, <argument><expr><name>endptr</name> <operator>-</operator> <name>tupdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_lock_updated</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_lock_updated</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>, <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_lock_updated</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map may need to be fixed even if the heap page is
		 * already up-to-date.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
										 <argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><name>lp</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp: page_max_off=%ld, offnum=%d, lp=%d"</literal></expr></argument>,
					 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>lp</name></expr> ?</condition><then> <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>infobits_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_insert</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HeapTupleHeaderData</name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>data</name><index>[<expr><name>MaxHeapTupleSize</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>           <decl><name>tbuf</name></decl>;</union>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>target_tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>, <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map may need to be fixed even if the heap page is
		 * already up-to-date.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
										 <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we inserted the first and only tuple on the page, re-initialize the
		 * page from scratch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid max offset number: page_max_off=%ld, offnum=%d"</literal></expr></argument>,
					 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>datalen</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datalen</name> <operator>&gt;</operator> <name>SizeOfHeapHeader</name> <operator>&amp;&amp;</operator> <name>newlen</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbuf</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* PG73FORMAT: get bitmap [+ padding] [+ oid] + data */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
				   <argument><expr><name>data</name></expr></argument>,
				   <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newlen</name> <operator>+=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>target_tid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_delete</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>target_tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>, <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map may need to be fixed even if the heap page is
		 * already up-to-date.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
										 <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name> <operator>||</operator> <operator>!</operator><name>lp</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp: page_max_off=%ld, offnum=%d, lp=%d"</literal></expr></argument>,
					 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>lp</name></expr> ?</condition><then> <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>infobits_set</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_IS_SUPER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Mark the page as a candidate for pruning */</comment>
			<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Make sure t_ctid is set correctly */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_IS_PARTITION_MOVE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetMovedPartitions</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>target_tid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_update</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hotupdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>orig_old_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_update</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_update</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>oldblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>newblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>newtid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>      <name>prefixlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>suffixlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newp</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HeapTupleHeaderData</name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>data</name><index>[<expr><name>MaxHeapTupleSize</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>           <decl><name>tbuf</name></decl>;</union>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>, <decl><type ref="prev"/><name>tag2</name></decl>, <decl><type ref="prev"/><name>tag3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name>   <modifier>*</modifier></type><name>old_tag</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				 <decl><type ref="prev"><modifier>*</modifier></type><name>new_tag</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				  <decl><type ref="prev"><modifier>*</modifier></type><name>old_vm_tag</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>new_vm_tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialize to keep the compiler quiet */</comment>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newblk</name> <operator>=</operator> <name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tag</name> <operator>=</operator> <operator>&amp;</operator><name>tag0</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLEAR_BUFFERTAG</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* HOT updates are never done across pages */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>hotupdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name><name>tag1</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_tag</name> <operator>=</operator> <operator>&amp;</operator><name>tag1</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name>newblk</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_tag</name> <operator>=</operator> <operator>&amp;</operator><name>tag0</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldblk</name> <operator>!=</operator> <name>newblk</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag3</name></expr></argument>, <argument><expr><name><name>tag1</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>,
						   <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag1</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>old_vm_tag</name> <operator>=</operator> <operator>&amp;</operator><name>tag3</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag2</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>,
						   <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_vm_tag</name> <operator>=</operator> <operator>&amp;</operator><name>tag2</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag2</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>,
						   <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_vm_tag</name> <operator>=</operator> <operator>&amp;</operator><name>tag2</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newtid</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_vm_tag</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>old_vm_tag</name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map may need to be fixed even if the heap page is
		 * already up-to-date.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>old_tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>,
										 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_vm_tag</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>new_vm_tag</name></expr></argument>, <argument><expr><operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map may need to be fixed even if the heap page is
		 * already up-to-date.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>new_tag</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>new_tag</name><operator>-&gt;</operator><name>blockNum</name></name></expr></argument>,
										 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><operator>*</operator><name>old_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In normal operation, it is important to lock the two pages in
		 * page-number order, to avoid possible deadlocks against other update
		 * operations going the other way.  However, during WAL replay there can
		 * be no other update happening, so we don't need to worry about that. But
		 * we *do* need to worry that we don't expose an inconsistent state to Hot
		 * Standby queries --- so the original page can't be unlocked before we've
		 * added the new tuple to the new page.
		 */</comment>

		<comment type="block">/* Deal with old tuple version */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>old_offnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>orig_old_lsn</name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><name>lp</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp: page_max_off=%ld, offnum=%d, lp=%d"</literal></expr></argument>,
					 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>lp</name></expr> ?</condition><then> <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>htup</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>hotupdate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HeapTupleHeaderSetHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>old_infobits_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>old_xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set forward chain link in t_ctid */</comment>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>newtid</name></expr>;</expr_stmt>

			<comment type="block">/* Mark the page as a candidate for pruning */</comment>
			<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Maybe old and new tuple all in the same page  */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><operator>*</operator><name>new_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Read the page the new tuple goes into, if different from old.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldblk</name> <operator>!=</operator> <name>newblk</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Deal with new tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>recdata</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>recdata_end</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>tuplen</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>recdata</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata_end</name> <operator>=</operator> <name>recdata</name> <operator>+</operator> <name>datalen</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>new_offnum</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>offnum</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Original old page lsn is %lX"</literal></expr></argument>, <argument><expr><name>orig_old_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid max offset number: page_max_off=%ld, offnum=%d"</literal></expr></argument>,
					 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_PREFIX_FROM_OLD</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* pageTag-&gt;blockNum must equal oldblk, see function log_heap_update */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newblk</name> <operator>==</operator> <name>oldblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixlen</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_SUFFIX_FROM_OLD</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* pageTag-&gt;blockNum must equal oldblk, see function log_heap_update */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newblk</name> <operator>==</operator> <name>oldblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>suffixlen</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <name>recdata_end</name> <operator>-</operator> <name>recdata</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbuf</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Reconstruct the new tuple using the prefix and/or suffix from the
			 * old tuple, and the data stored in the WAL record.
			 */</comment>
			<expr_stmt><expr><name>newp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>         <name>len</name></decl>;</decl_stmt>

				<comment type="block">/* copy bitmap [+ padding] [+ oid] from WAL record */</comment>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Original old page lsn is %lX"</literal></expr></argument>, <argument><expr><name>orig_old_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Old tuple data is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* copy prefix from old tuple */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>+</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>prefixlen</name></expr>;</expr_stmt>

				<comment type="block">/* copy new tuple data from WAL record */</comment>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tuplen</name> <operator>-</operator> <operator>(</operator><name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * copy bitmap [+ padding] [+ oid] + data from record, all in one
				 * go
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>tuplen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>tuplen</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>recdata</name> <operator>!=</operator> <name>recdata_end</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Original old page lsn is %lX"</literal></expr></argument>, <argument><expr><name>orig_old_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Failed to decode tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* copy suffix from old tuple */</comment>
			<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Original old page lsn is %lX"</literal></expr></argument>, <argument><expr><name>orig_old_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Old tuple data is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>+</operator> <name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>-</operator> <name>suffixlen</name></expr></argument>, <argument><expr><name>suffixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name> <operator>+</operator> <name>tuplen</name> <operator>+</operator> <name>prefixlen</name> <operator>+</operator> <name>suffixlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure there is no forward chain link in t_ctid */</comment>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>newtid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Original old page lsn is %lX"</literal></expr></argument>, <argument><expr><name>orig_old_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_confirm</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_confirm</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_confirm</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>tag0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><name>lp</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp: page_max_off=%ld, offnum=%d, lp=%d"</literal></expr></argument>,
				 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>lp</name></expr> ?</condition><then> <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Confirm tuple as actually inserted
		 */</comment>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_lock</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_lock</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>, <decl><type ref="prev"/><name>tag1</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT_BUFFERTAG</name><argument_list>(<argument><expr><name>tag1</name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>VISIBILITYMAP_FORKNUM</name></expr></argument>, <argument><expr><call><name>HEAPBLK_TO_MAPBLOCK</name><argument_list>(<argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>polar_heap_clear_vm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tag0</name><operator>.</operator><name>rnode</name></name></expr></argument>, <argument><expr><name><name>tag0</name><operator>.</operator><name>blockNum</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
										 <argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><name>lp</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp: page_max_off=%ld, offnum=%d, lp=%d"</literal></expr></argument>,
					 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>lp</name></expr> ?</condition><then> <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>infobits_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Clear relevant update flags, but only if the modified infomask says
			 * there's no update.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Make sure there is no forward chain link in t_ctid */</comment>
				<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>,
							   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>locking_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_heap_xlog_inplace</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_inplace</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_inplace</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>      <name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>oldlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>tag0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>tag0</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>action</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newtup</name> <init>= <expr><call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>newlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><name>lp</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp: page_max_off=%ld, offnum=%d, lp=%d"</literal></expr></argument>,
				 <argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>lp</name></expr> ?</condition><then> <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_flags</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldlen</name> <operator>!=</operator> <name>newlen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"wrong tuple length: oldlen=%u, newlen=%ld"</literal></expr></argument>, <argument><expr><name>oldlen</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_heap2_idx_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
			<comment type="block">/* don't modify buffer, nothing to do for parse, just do it */</comment>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_multi_insert_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_lock_update_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_NEW_CID</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_REWRITE</name></expr>:</case>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_heap2_idx_save: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_heap2_idx_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_clean_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_freeze_page_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_cleanup_info_parse</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_visible_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_multi_insert_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_lock_update_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_NEW_CID</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_REWRITE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_logical_rewrite</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_heap2_idx_parse: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRedoAction</name></type>
<name>polar_heap2_idx_redo</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_clean</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_freeze_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
			<comment type="block">/* nothing to do, don't modify buffer, never here*/</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_visible</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_multi_insert</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_lock_updated</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_heap2_idx_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_heap_idx_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_insert_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_delete_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_xlog_update_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_TRUNCATE</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_xlog_update_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_CONFIRM</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_lock_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_INPLACE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_heap_idx_save: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_heap_idx_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_insert_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_delete_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_xlog_update_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_TRUNCATE</name></expr>:</case>

			<comment type="block">/*
			 * TRUNCATE is a no-op because the actions are already logged as
			 * SMGR WAL records.  TRUNCATE WAL record only exists for logical
			 * decoding.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_xlog_update_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_CONFIRM</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_heap_lock_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_INPLACE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_heap_idx_parse: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRedoAction</name></type>
<name>polar_heap_idx_redo</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_insert</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_delete</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_update</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_TRUNCATE</name></expr>:</case>

			<comment type="block">/*
			 * TRUNCATE is a no-op because the actions are already logged as
			 * SMGR WAL records.  TRUNCATE WAL record only exists for logical
			 * decoding.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_update</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_CONFIRM</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_confirm</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_lock</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HEAP_INPLACE</name></expr>:</case>
			<return>return <expr><call><name>polar_heap_xlog_inplace</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_heap_idx_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
</unit>
