<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/logindex/polar_hash_xlog_idx.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_hash_xlog_idx.c
 *   Implementation of parse hash records.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 * src/backend/access/logindex/polar_hash_xlog_idx.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_logindex_redo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_add_ovfl_page_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_add_ovfl_page_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>ovfl_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type>    <name>ovfl_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>    <name>ovfl_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ovfl_tag</name></expr></argument>, <argument><expr><name>ovfl_lock</name></expr></argument>, <argument><expr><name>ovfl_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>ovfl_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>ovfl_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>ovfl_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_split_allocate_page_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_split_allocate_page_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>old_tag</name></decl>, <decl><type ref="prev"/><name>new_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>old_page_lock</name></decl>, <decl><type ref="prev"/><name>new_page_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>old_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>new_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><name>old_page_lock</name></expr></argument>, <argument><expr><name>old_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>, <argument><expr><name>new_page_lock</name></expr></argument>, <argument><expr><name>new_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>old_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>old_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>old_page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>new_page_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_move_page_contents_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_move_page_contents_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>write_tag</name></decl>, <decl><type ref="prev"/><name>bucket_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>write_lock</name></decl>, <decl><type ref="prev"/><name>bucket_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>write_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>,
		   <decl><type ref="prev"/><name>bucket_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><name>bucket_lock</name></expr></argument>, <argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>, <argument><expr><name>write_lock</name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>, <argument><expr><name>write_lock</name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>write_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>bucket_lock</name> <operator>!=</operator> <name>POLAR_INVALID_PAGE_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>bucket_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_squeeze_page_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_squeeze_page_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>write_tag</name></decl>, <decl><type ref="prev"/><name>bucket_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>write_lock</name></decl>, <decl><type ref="prev"/><name>bucket_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>write_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>,
		   <decl><type ref="prev"/><name>bucket_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><name>bucket_lock</name></expr></argument>, <argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>, <argument><expr><name>write_lock</name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>, <argument><expr><name>write_lock</name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>write_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>write_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>bucket_lock</name> <operator>!=</operator> <name>POLAR_INVALID_PAGE_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>bucket_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_vacuum_one_page_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we have any conflict processing to do, it must happen before we
	 * update the page.
	 *
	 * Hash index records that are marked as LP_DEAD and being removed during
	 * hash index tuple insertion can conflict with standby queries. You might
	 * think that vacuum records would conflict as well, but we've handled
	 * that already.  XLOG_HEAP2_CLEANUP_INFO records provide the highest xid
	 * cleaned by the vacuum of the heap and so we can resolve any conflicts
	 * just once when that arrives.  After that we know that no conflicts
	 * exist from individual hash index vacuum records on that index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reachedConsistency</name> <operator>&amp;&amp;</operator> <name>InHotStandby</name> <operator>&amp;&amp;</operator> <name>polar_enable_resolve_conflict</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>=
			<expr><call><name>hash_xlog_vacuum_get_latestRemovedXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_cleanup_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_delete_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_hash_xlog_delete_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>bucket_tag</name></decl>, <decl><type ref="prev"/><name>del_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_page_lock_t</name></type> <name>bucket_lock</name> <init>= <expr><name>POLAR_INVALID_PAGE_LOCK</name></expr></init></decl>, <decl><type ref="prev"/><name>del_lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>bucket_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>, <decl><type ref="prev"/><name>del_buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><name>bucket_lock</name></expr></argument>, <argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_REDO_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><name>del_lock</name></expr></argument>, <argument><expr><name>del_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POLAR_MINI_TRANS_CLEANUP_PARSE</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><name>del_lock</name></expr></argument>, <argument><expr><name>del_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>del_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>del_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>del_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_logindex_mini_trans_unlock</name><argument_list>(<argument><expr><name><name>instance</name><operator>-&gt;</operator><name>mini_trans</name></name></expr></argument>, <argument><expr><name>bucket_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * replay a hash index meta page
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_init_meta_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_init_meta_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_hash_init_meta_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>      <name>meta_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create the index' metapage */</comment>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_hash_init_metabuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>num_tuples</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>procid</name></name></expr></argument>,
							  <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>ffactor</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force the on-disk state of init forks to always be in sync with the
		 * state in shared buffers.  See XLogReadBufferForRedoExtended.  We need
		 * special handling for init forks as create index operations don't log a
		 * full page image of the metapage.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>meta_tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FlushOneBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay a hash index bitmap page
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_init_bitmap_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_init_bitmap_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_hash_init_bitmap_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>num_buckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>bitmap_tag</name></decl>, <decl><type ref="prev"/><name>meta_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>bitmap_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>bitmap_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize bitmap page
		 */</comment>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_hash_initbitmapbuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>bmsize</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force the on-disk state of init forks to always be in sync with the
		 * state in shared buffers.  See XLogReadBufferForRedoExtended.  We need
		 * special handling for init forks as create index operations don't log a
		 * full page image of the metapage.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bitmap_tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FlushOneBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add the new bitmap page to the metapage's list of bitmaps */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: in normal operation, we'd update the metapage while still
			 * holding lock on the bitmap page.  But during replay it's not
			 * necessary to hold that lock, since nobody can see it yet; the
			 * creating transaction hasn't yet committed.
			 */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>num_buckets</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_mapp</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name></expr>]</index></name> <operator>=</operator> <name>num_buckets</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>meta_tag</name><operator>.</operator><name>forkNum</name></name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FlushOneBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay a hash index insert without split
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_insert</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_hash_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>insert_tag</name></decl>, <decl><type ref="prev"/><name>meta_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>insert_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>insert_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>datapos</name> <init>= <expr><call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>datapos</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_hash_xlog_insert: failed to add item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: in normal operation, we'd update the metapage while still
			 * holding lock on the page we inserted into.  But during replay it's
			 * not necessary to hold that lock, since no other index updates can
			 * be happening concurrently.
			 */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay addition of overflow page for hash index
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_add_ovfl_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_add_ovfl_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_hash_add_ovfl_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>ovflpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>ovflopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>num_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name>        <name>datalen</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>new_bmpage</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>newmapblk</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>meta_tag</name></decl>, <decl><type ref="prev"/><name>left_tag</name></decl>, <decl><type ref="prev"/><name>newmap_tag</name></decl>, <decl><type ref="prev"/><name>ovfl_tag</name></decl>, <decl><type ref="prev"/><name>map_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>ovfl_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>left_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>ovfl_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_bucket</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datalen</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_hash_initbuf</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>, <argument><expr><operator>*</operator><name>num_bucket</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>,
					  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* update backlink */</comment>
		<expr_stmt><expr><name>ovflpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ovflopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>ovflpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name><name>left_tag</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>ovflpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>left_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>leftpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>leftopaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>leftpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>leftopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>leftopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name><name>ovfl_tag</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note: in normal operation, we'd update the bitmap and meta page while
	 * still holding lock on the overflow pages.  But during replay it's not
	 * necessary to hold those locks, since no other index updates can be
	 * happening concurrently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>map_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>map_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Page</name></type>        <name>mappage</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>freep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>bitmap_page_bit</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>freep</name> <operator>=</operator> <call><name>HashPageGetBitmap</name><argument_list>(<argument><expr><name>mappage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmap_page_bit</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SETBIT</name><argument_list>(<argument><expr><name>freep</name></expr></argument>, <argument><expr><operator>*</operator><name>bitmap_page_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>mappage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>newmap_tag</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_bmpage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newmapblk</name> <operator>=</operator> <name><name>newmap_tag</name><operator>.</operator><name>blockNum</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>newmap_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_hash_initbitmapbuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>bmsize</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>firstfree_ovflpage</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>firstfree_ovflpage</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_firstfree</name></name> <operator>=</operator> <operator>*</operator><name>firstfree_ovflpage</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xlrec</name><operator>-&gt;</operator><name>bmpage_found</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>new_bmpage</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>newmapblk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_mapp</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name></expr>]</index></name> <operator>=</operator> <name>newmapblk</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_nmaps</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay allocation of page for split operation
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_split_allocate_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_split_allocate_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_hash_split_allocate_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name>        <name>datalen</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>  <name>old_tag</name></decl>, <decl><type ref="prev"/><name>new_tag</name></decl>, <decl><type ref="prev"/><name>meta_tag</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To be consistent with normal operation, here we take cleanup locks on
	 * both the old and new buckets even though there can't be any concurrent
	 * inserts.
	 */</comment>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for old bucket */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we still update the page even if it was restored from a full
		 * page image, because the special space is not included in the image.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>BLK_RESTORED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>oldpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>oldopaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>oldopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>old_bucket_flag</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oldopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>new_bucket</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for new bucket */</comment>
		<expr_stmt><expr><call><name>POLAR_INIT_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_hash_initbuf</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_bucket</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_bucket</name></name></expr></argument>,
					  <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_bucket_flag</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>BLK_NEEDS_REDO</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Note: in normal operation, we'd update the meta page while still
		 * holding lock on the old and new bucket pages.  But during replay it's
		 * not necessary to hold those locks, since no other bucket splits can be
		 * happening concurrently.
		 */</comment>

		<comment type="block">/* replay the record for metapage changes */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>new_bucket</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_SPLIT_META_UPDATE_MASKS</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>      <name>lowmask</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>highmask</name></decl>;</decl_stmt>

				<comment type="block">/* extract low and high masks. */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lowmask</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>highmask</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/* update metapage */</comment>
				<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name> <operator>=</operator> <name>lowmask</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_highmask</name></name> <operator>=</operator> <operator>*</operator><name>highmask</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_SPLIT_META_UPDATE_SPLITPOINT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>      <name>ovflpoint</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>ovflpages</name></decl>;</decl_stmt>

				<comment type="block">/* extract information of overflow pages. */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ovflpoint</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ovflpages</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/* update metapage */</comment>
				<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_spares</name><index>[<expr><name>ovflpoint</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ovflpages</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ovflpoint</name></name> <operator>=</operator> <name>ovflpoint</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_split_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay completion of split operation
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_split_complete</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_split_complete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_hash_split_complete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>old_tag</name></decl>, <decl><type ref="prev"/><name>new_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>old_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for old bucket */</comment>

		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we still update the page even if it was restored from a full
		 * page image, because the bucket flag is not included in the image.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>BLK_RESTORED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>oldpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>oldopaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>oldopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>old_bucket_flag</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>new_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for new bucket */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we still update the page even if it was restored from a full
		 * page image, because the bucket flag is not included in the image.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>BLK_RESTORED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>newpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>nopaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>new_bucket_flag</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>newpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay move of page contents for squeeze operation of hash index
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_move_page_contents</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_move_page_contents</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>xl_hash_move_page_contents</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>bucket_tag</name></decl>, <decl><type ref="prev"/><name>write_tag</name></decl>, <decl><type ref="prev"/><name>del_tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xldata</name><operator>-&gt;</operator><name>is_prim_bucket_same_wrt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we don't care for return value as the purpose of reading bucketbuf
			 * is to ensure a cleanup lock on primary bucket page.
			 */</comment>
			<return>return <expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
												 <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure we have a cleanup lock on primary bucket page before we start
		 * with the actual replay operation.  This is to ensure that neither a
		 * scan can start nor a scan can be already-in-progress during the replay
		 * of this operation.  If we allow scans during this operation, then they
		 * can miss some records or show the same record multiple times.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>is_prim_bucket_same_wrt</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
												   <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* replay the record for adding entries in overflow buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>writepage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>begin</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>      <name>ninserted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <name>begin</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>writepage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>ntups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>towrite</name> <init>= <expr><operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>ntups</name></name></expr>;</expr_stmt>

				<while>while <condition>(<expr><name>data</name> <operator>-</operator> <name>begin</name> <operator>&lt;</operator> <name>datalen</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>l</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name><name>towrite</name><index>[<expr><name>ninserted</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"polar_hash_xlog_move_page_contents: failed to add item to hash index page, size %d bytes"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>ninserted</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * number of tuples inserted must be same as requested in REDO record.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ninserted</name> <operator>==</operator> <name><name>xldata</name><operator>-&gt;</operator><name>ntups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for deleting entries from overflow buffer */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unend</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>unend</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unend</name> <operator>-</operator> <name>unused</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name>unend</name> <operator>-</operator> <name>unused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay squeeze page operation of hash index
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_squeeze_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_squeeze_page</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>xl_hash_squeeze_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>bucket_tag</name></decl>, <decl><type ref="prev"/><name>write_tag</name></decl>, <decl><type ref="prev"/><name>ovfl_tag</name></decl>, <decl><type ref="prev"/><name>prev_tag</name></decl>, <decl><type ref="prev"/><name>next_tag</name></decl>, <decl><type ref="prev"/><name>map_tag</name></decl>, <decl><type ref="prev"/><name>meta_tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xldata</name><operator>-&gt;</operator><name>is_prim_bucket_same_wrt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we don't care for return value as the purpose of reading bucketbuf
			 * is to ensure a cleanup lock on primary bucket page.
			 */</comment>
			<return>return <expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>write_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure we have a cleanup lock on primary bucket page before we start
		 * with the actual replay operation.  This is to ensure that neither a
		 * scan can start nor a scan can be already-in-progress during the replay
		 * of this operation.  If we allow scans during this operation, then they
		 * can miss some records or show the same record multiple times.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>is_prim_bucket_same_wrt</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
												   <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* replay the record for adding entries in overflow buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>writepage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>begin</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>      <name>ninserted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <name>begin</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>writepage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>ntups</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>towrite</name> <init>= <expr><operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>ntups</name></name></expr>;</expr_stmt>

				<while>while <condition>(<expr><name>data</name> <operator>-</operator> <name>begin</name> <operator>&lt;</operator> <name>datalen</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Size</name></type>        <name>itemsz</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>l</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name><name>towrite</name><index>[<expr><name>ninserted</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>POLAR_LOG_REDO_INFO</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"polar_hash_xlog_squeeze_page: failed to add item to hash index page, size %d bytes"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>ninserted</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * number of tuples inserted must be same as requested in REDO record.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ninserted</name> <operator>==</operator> <name><name>xldata</name><operator>-&gt;</operator><name>ntups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if the page on which are adding tuples is a page previous to freed
			 * overflow page, then update its nextblno.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>is_prev_bucket_same_wrt</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>writeopaque</name> <init>= <expr><operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>writeopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nextblkno</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>writepage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>ovfl_tag</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>ovfl_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for initializing overflow buffer */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>ovflpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>ovflopaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ovflpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_hash_pageinit</name><argument_list>(<argument><expr><name>ovflpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ovflopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>ovflpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>=</operator> <name>LH_UNUSED_PAGE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ovflopaque</name><operator>-&gt;</operator><name>hasho_page_id</name></name> <operator>=</operator> <name>HASHO_PAGE_ID</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>ovflpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xldata</name><operator>-&gt;</operator><name>is_prev_bucket_same_wrt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>prev_tag</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>prev_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* replay the record for page previous to the freed overflow page */</comment>
			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Page</name></type>        <name>prevpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>prevopaque</name> <init>= <expr><operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>prevpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>prevopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nextblkno</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>prevpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>next_tag</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>next_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
			<comment type="block">/* replay the record for page next to the freed overflow page */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Page</name></type>        <name>nextpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>nextopaque</name> <init>= <expr><operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>nextpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>nextopaque</name><operator>-&gt;</operator><name>hasho_prevblkno</name></name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>prevblkno</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>nextpage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>action</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>map_tag</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>map_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Note: in normal operation, we'd update the bitmap and meta page while
		 * still holding lock on the primary bucket page and overflow pages.  But
		 * during replay it's not necessary to hold those locks, since no other
		 * index updates can be happening concurrently.
		 */</comment>
		<comment type="block">/* replay the record for bitmap page */</comment>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>mappage</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>freep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>bitmap_page_bit</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>freep</name> <operator>=</operator> <call><name>HashPageGetBitmap</name><argument_list>(<argument><expr><name>mappage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitmap_page_bit</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CLRBIT</name><argument_list>(<argument><expr><name>freep</name></expr></argument>, <argument><expr><operator>*</operator><name>bitmap_page_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>mappage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replay the record for meta page */</comment>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name>     <modifier>*</modifier></type><name>firstfree_ovflpage</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>        <name>datalen</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>firstfree_ovflpage</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_firstfree</name></name> <operator>=</operator> <operator>*</operator><name>firstfree_ovflpage</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay delete operation of hash index
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_delete</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_delete</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>xl_hash_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>bucket_tag</name></decl>, <decl><type ref="prev"/><name>del_tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xldata</name><operator>-&gt;</operator><name>is_primary_bucket_page</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we don't care for return value as the purpose of reading bucketbuf
			 * is to ensure a cleanup lock on primary bucket page.
			 */</comment>
			<return>return <expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>
												 , <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure we have a cleanup lock on primary bucket page before we start
		 * with the actual replay operation.  This is to ensure that neither a
		 * scan can start nor a scan can be already-in-progress during the replay
		 * of this operation.  If we allow scans during this operation, then they
		 * can miss some records or show the same record multiple times.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>is_primary_bucket_page</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* replay the record for deleting entries in bucket page */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>len</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unend</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>unend</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unend</name> <operator>-</operator> <name>unused</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name>unend</name> <operator>-</operator> <name>unused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Mark the page as not containing any LP_DEAD items only if
			 * clear_dead_marking flag is set to true. See comments in
			 * hashbucketcleanup() for details.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>clear_dead_marking</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>pageopaque</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LH_PAGE_HAS_DEAD_TUPLES</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay split cleanup flag operation for primary bucket page.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_split_cleanup</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>bucket_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>bucket_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>bucket_opaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bucket_opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bucket_opaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LH_BUCKET_NEEDS_SPLIT_CLEANUP</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay for update meta page
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_update_meta_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_update_meta_page</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>xl_hash_update_meta_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type>   <name>meta_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * replay delete operation in hash index to remove
 * tuples marked as DEAD during index tuple insertion.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRedoAction</name></type>
<name>polar_hash_xlog_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_hash_vacuum_one_page</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>xl_hash_vacuum_one_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name> <init>= <expr><name>BLK_NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>        <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>pageopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferTag</name></type> <name>del_tag</name></decl>, <decl><type ref="prev"/><name>meta_tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>del_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>POLAR_READ_MODE</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>SizeOfHashVacuumOnePage</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>unused</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>unused</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xldata</name> <operator>+</operator> <name>SizeOfHashVacuumOnePage</name><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Mark the page as not containing any LP_DEAD items. See comments in
			 * _hash_vacuum_one_page() for details.
			 */</comment>
			<expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LH_PAGE_HAS_DEAD_TUPLES</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>action</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>POLAR_GET_LOG_TAG</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BUFFERTAGS_EQUAL</name><argument_list>(<argument><expr><operator>*</operator><name>tag</name></expr></argument>, <argument><expr><name>meta_tag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>POLAR_READ_BUFFER_FOR_REDO</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>        <name>metapage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>-=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>action</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_hash_idx_save</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HASH_INIT_META_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_INIT_BITMAP_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_ADD_OVFL_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_add_ovfl_page_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_ALLOCATE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_split_allocate_page_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_COMPLETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_MOVE_PAGE_CONTENTS</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_move_page_contents_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SQUEEZE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_squeeze_page_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_delete_save</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_CLEANUP</name></expr>:</case>
		<case>case <expr><name>XLOG_HASH_UPDATE_META_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_VACUUM_ONE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_save_block</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_hash_idx_save: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>polar_hash_idx_parse</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HASH_INIT_META_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_INIT_BITMAP_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_ADD_OVFL_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_add_ovfl_page_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_ALLOCATE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_split_allocate_page_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_COMPLETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_MOVE_PAGE_CONTENTS</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_move_page_contents_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SQUEEZE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_squeeze_page_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_delete_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_SPLIT_CLEANUP</name></expr>:</case>
		<case>case <expr><name>XLOG_HASH_UPDATE_META_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_logindex_redo_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>XLOG_HASH_VACUUM_ONE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>polar_hash_xlog_vacuum_one_page_parse</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_hash_idx_parse: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XLogRedoAction</name></type>
<name>polar_hash_idx_redo</name><parameter_list>(<parameter><decl><type><name>polar_logindex_redo_ctl_t</name></type> <name>instance</name></decl></parameter>, <parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>,  <parameter><decl><type><name>BufferTag</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>       <name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HASH_INIT_META_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_init_meta_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_INIT_BITMAP_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_init_bitmap_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_INSERT</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_insert</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_ADD_OVFL_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_add_ovfl_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_SPLIT_ALLOCATE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_split_allocate_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_SPLIT_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_split_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_SPLIT_COMPLETE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_split_complete</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_MOVE_PAGE_CONTENTS</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_move_page_contents</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_SQUEEZE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_squeeze_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_DELETE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_delete</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_SPLIT_CLEANUP</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_split_cleanup</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_UPDATE_META_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_update_meta_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>XLOG_HASH_VACUUM_ONE_PAGE</name></expr>:</case>
			<return>return <expr><call><name>polar_hash_xlog_vacuum_one_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"polar_hash_idx_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>BLK_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
</unit>
