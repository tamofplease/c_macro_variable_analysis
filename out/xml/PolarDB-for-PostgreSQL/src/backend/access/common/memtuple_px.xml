<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/common/memtuple_px.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * memtuple.c
 * 
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * IDENTIFICATION
 *	    src/backend/access/common/memtuple.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/memtup_px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupmacs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandeddatum.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Memory tuple format:
 * 4 byte _mt_len,
 * 	highest bit always 1.  (if 0, means it is a heaptuple).
 * 	bit 2-29th is memtuple length, in bytes.  It is always 8
 * 	bytes aligned.
 * 	bit 30 is unused.
 *   	bit 31 is set if the memtuple is longer than 64K.
 *	bit 32 is if has null.
 *
 * Followed by optional 4 byte for Oid (depends on if mtbind_has_oid)
 * 
 * Followed by optional null bitmaps.  
 *
 * Align to bind.column_align, either 4 or 8.
 *
 * Non-Null attribute:
 * 	Fixed len Attributes.
 *		The attributes are not in logical order.  First we put 8 bytes 
 * 		aligned native or native_ptr types.  The 4 bytes aligned natives
 * 		then 2 bytes aligned and varlena, then 1 bytes aligned natives.
 *		Varlena occupy 2bytes in the fixed len area.
 *
 * 	Varlena attributes.
 *
 * The end is again padded to 8 bytes aligned.
 *
 * Null attributes only occupy one bit in the nullbit map.  The non null
 * attributes is located from the binding offset/len.  If there is null attr,
 * we use the null_saves in the binding to figure out how many columns that is
 * physically precedes the attribute is null and how much space we have saved,
 * then we use off minus saved bytes to find the attribute.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compute_null_bitmap_extra_size</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col_align</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nbytes</name> <init>= <expr><operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>avail_bytes</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>||</operator> <name>col_align</name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>col_align</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>col_align</name> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;=</operator> <name>avail_bytes</name></expr>)</condition><block type="pseudo"><block_content> 
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>col_align</name></expr></argument>, <argument><expr><operator>(</operator><name>nbytes</name> <operator>-</operator> <name>avail_bytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></function>

<function><type><name>void</name></type> <name>destroy_memtuple_binding</name><parameter_list>(<parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>pbind</name><operator>-&gt;</operator><name>bind</name><operator>.</operator><name>null_saves</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>bind</name><operator>.</operator><name>null_saves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>pbind</name><operator>-&gt;</operator><name>bind</name><operator>.</operator><name>null_saves_aligned</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>bind</name><operator>.</operator><name>null_saves_aligned</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>pbind</name><operator>-&gt;</operator><name>bind</name><operator>.</operator><name>bindings</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>bind</name><operator>.</operator><name>bindings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name><operator>.</operator><name>null_saves</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name><operator>.</operator><name>null_saves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name><operator>.</operator><name>null_saves_aligned</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name><operator>.</operator><name>null_saves_aligned</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name><operator>.</operator><name>bindings</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name><operator>.</operator><name>bindings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Manage the space saved by not storing nulls.  
 * Attr are rearranged in the order of 8 bytes aligned, then 4,
 * then 2, then 1.  A bit in the null bitmap is set for each 
 * null attribute.  For all possible combinations of 4 null bit,
 * we index into a short[16] array to get how many space is saved
 * by the nulls.
 */</comment>

<comment type="block">/* 
 * Compute how much space to store the null save entries.
 * The null save entries are stored in the binding, not per tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>compute_null_save_entries</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">7</literal><operator>)</operator><operator>/</operator><literal type="number">8</literal><operator>)</operator> <operator>*</operator> <literal type="number">32</literal></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/* Add null save space into the entries */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_null_save</name><parameter_list>(<parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>null_save</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>short</name><modifier>*</modifier></type> <name>first</name> <init>= <expr><name>null_save</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>i</name><operator>/</operator><literal type="number">4</literal><operator>)</operator> <operator>*</operator> <literal type="number">16</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bit</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>%</operator><literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">16</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if<condition>( <expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <name>bit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Sets the binding length according to the following binding's alignment.
 * Adds the aligned length into the array holding the space saved from null attributes.
 * Returns true if the binding length is aligned to the following binding's alignment.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>add_null_save_aligned</name><parameter_list>(<parameter><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name></decl></parameter>, <parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>null_save_aligned</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>next_attr_align</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_save_aligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>len_aligned</name></name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>next_attr_align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_null_save</name><argument_list>(<argument><expr><name>null_save_aligned</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len_aligned</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>bind</name><operator>-&gt;</operator><name>len_aligned</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute how much bytes are saved by one byte in the null bit map */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>short</name></type> <name>compute_null_save_b</name><parameter_list>(<parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>null_saves</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>blow</name> <init>= <expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0xF</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bhigh</name> <init>= <expr><operator>(</operator><name>b</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>null_saves</name><index>[<expr><name>blow</name></expr>]</index></name> <operator>+</operator> <name><name>null_saves</name><index>[<expr><literal type="number">16</literal><operator>+</operator><name>bhigh</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute the null saved bytes by the whole null bit map, by the attribute
 * physically precedes the one.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>compute_null_save</name><parameter_list>(<parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>null_saves</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nullbitmaps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbyte</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>nbit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>curr_byte</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<while>while<condition>(<expr><name>curr_byte</name> <operator>&lt;</operator> <name>nbyte</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>compute_null_save_b</name><argument_list>(<argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name><name>nullbitmaps</name><index>[<expr><name>curr_byte</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>null_saves</name> <operator>+=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>curr_byte</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>compute_null_save_b</name><argument_list>(<argument><expr><name>null_saves</name></expr></argument>, <argument><expr><operator>(</operator><name><name>nullbitmaps</name><index>[<expr><name>nbyte</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name>nbit</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
		
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MEMTUPLE_INLINE_CHARTYPE</name></cpp:undef>
<comment type="block">/* Determine if an attr should be treated as offset_len in memtuple */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>att_bind_as_varoffset</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMTUPLE_INLINE_CHARTYPE</name></cpp:ifdef> 
	<return>return <expr><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <comment type="block">/* Varlen type */</comment>
	        <operator>&amp;&amp;</operator> <operator>(</operator>
	               <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>BPCHAROID</name> <comment type="block">/* Any varlen type except char(N) */</comment>
		       <operator>||</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>&lt;=</operator> <literal type="number">4</literal>     <comment type="block">/* char(0)?  ever happend? */</comment>
		       <operator>||</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>&gt;=</operator> <literal type="number">127</literal>   <comment type="block">/* char(N) that cannot be shorted */</comment>
		       <operator>)</operator>
		<operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/*
	 * XXX
	 * As optimization, one want to make some char(X) type inline, which
	 * will save 2 bytes.  However, postgres tupdesc is totally messed up
	 * the lenght of a (var)char(N) type (in typmod).  It just get randomly 
	 * set to the right thing or -1.  It is really stupid, but it just 
	 * took too much effort to fix everywhere.
	 *
	 * It is a shame.  Disable this for now.
	 */</comment>

	<return>return <expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* Create columns binding, depends on islarge, using 2 or 4 bytes for offset_len */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>create_col_bind</name><parameter_list>(<parameter><decl><type><name>MemTupleBindingCols</name> <modifier>*</modifier></type><name>colbind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>islarge</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col_align</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>physical_col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>previous_bind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>cur_offset</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>||</operator> <name>col_align</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>null_save_entries</name> <init>= <expr><call><name>compute_null_save_entries</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* alloc null save entries.  Zero it */</comment>
	<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name> <operator>=</operator> <operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>null_save_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name> <operator>=</operator> <operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>null_save_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_null_saves_alignment_mismatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_dropped_attr_alignment_mismatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* alloc bindings, no need to zero because we will fill them out  */</comment>
	<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name></name> <operator>=</operator> <operator>(</operator><name>MemTupleAttrBinding</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemTupleAttrBinding</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The length of each binding is determined according to the alignment
	 * of the physically following binding. Use this pointer to keep track
	 * of the previously processed binding.
	 */</comment>
	<expr_stmt><expr><name>previous_bind</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * First pass, do 8 bytes aligned, native type.
	 * Sencond pass, do 4 bytes aligned, native type.
	 * Third pass, do 2 bytes aligned, native type. 
	 * Finall, do 1 bytes aligned native type.
	 * 
	 * depends on islarge, varlena types are either handled in the
	 * second pass (is large, varoffset using 4 bytes), or in the 
	 * third pass (not large, varoffset using 2 bytes).
	 */</comment>
	<for>for<control>(<init><expr><name>pass</name> <operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><operator>++</operator><name>pass</name></expr></incr>)</control>
	<block>{<block_content>
		<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><operator>&amp;</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if<condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>cur_offset</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>add_null_save</name><argument_list>(<argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name></expr></argument>, <argument><expr><name>physical_col</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>physical_col</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set the aligned length of the previous binding according to current alignment. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>add_null_save_aligned</name><argument_list>(<argument><expr><name>previous_bind</name></expr></argument>, <argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr></argument>, <argument><expr><name>physical_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_null_saves_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_dropped_attr_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr> ?</condition><then> <expr><name>MTB_ByVal_Native</name></expr> </then><else>: <expr><name>MTB_ByVal_Ptr</name></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>=</operator> <name>physical_col</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_mask</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>physical_col</name><operator>-</operator><operator>(</operator><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>physical_col</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_offset</name> <operator>=</operator> <name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>previous_bind</name> <operator>=</operator> <name>bind</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator><operator>(</operator> <operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'i'</literal><operator>)</operator>
				              <operator>||</operator> <operator>(</operator> <name>islarge</name> <operator>&amp;&amp;</operator> <call><name>att_bind_as_varoffset</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call><operator>)</operator>
					      <operator>)</operator></expr>
				)</condition> 
			<block>{<block_content>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>cur_offset</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt> 
				<expr_stmt><expr><call><name>add_null_save</name><argument_list>(<argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name></expr></argument>, <argument><expr><name>physical_col</name></expr></argument>, <argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>physical_col</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set the aligned length of the previous binding according to current alignment. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>add_null_save_aligned</name><argument_list>(<argument><expr><name>previous_bind</name></expr></argument>, <argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr></argument>, <argument><expr><name>physical_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_null_saves_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_dropped_attr_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr> ?</condition><then> <expr><name>MTB_ByVal_Native</name></expr> </then><else>: <expr><name>MTB_ByVal_Ptr</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>MTB_ByRef</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>MTB_ByRef_CStr</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>=</operator> <name>physical_col</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_mask</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>physical_col</name><operator>-</operator><operator>(</operator><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>physical_col</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_offset</name> <operator>=</operator> <name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>previous_bind</name> <operator>=</operator> <name>bind</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator> <operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'s'</literal><operator>)</operator> 
						<operator>||</operator> <operator>(</operator> <operator>!</operator><name>islarge</name> <operator>&amp;&amp;</operator> <call><name>att_bind_as_varoffset</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call><operator>)</operator>
						<operator>)</operator></expr>
				)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>cur_offset</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt> 
				<expr_stmt><expr><call><name>add_null_save</name><argument_list>(<argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name></expr></argument>, <argument><expr><name>physical_col</name></expr></argument>, <argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>physical_col</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set the aligned length of the previous binding according to current alignment. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>add_null_save_aligned</name><argument_list>(<argument><expr><name>previous_bind</name></expr></argument>, <argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr></argument>, <argument><expr><name>physical_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_null_saves_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_dropped_attr_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr> ?</condition><then> <expr><name>MTB_ByVal_Native</name></expr> </then><else>: <expr><name>MTB_ByVal_Ptr</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>MTB_ByRef</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>MTB_ByRef_CStr</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>=</operator> <name>physical_col</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_mask</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>physical_col</name><operator>-</operator><operator>(</operator><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>physical_col</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_offset</name> <operator>=</operator> <name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>previous_bind</name> <operator>=</operator> <name>bind</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>pass</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>(</operator>
						<operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'c'</literal><operator>)</operator> 
						<operator>||</operator> <operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>att_bind_as_varoffset</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call><operator>)</operator>
						<operator>)</operator></expr>
					)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>cur_offset</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MEMTUPLE_INLINE_CHARTYPE</name></cpp:ifdef> 
				<comment type="block">/* Inline CHAR(N) disabled.  See att_bind_as_varoffset */</comment>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr> </then><else>: <expr><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<expr_stmt><expr><call><name>add_null_save</name><argument_list>(<argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name></expr></argument>, <argument><expr><name>physical_col</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>physical_col</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set the aligned length of the previous binding according to current alignment. */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>add_null_save_aligned</name><argument_list>(<argument><expr><name>previous_bind</name></expr></argument>, <argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr></argument>, <argument><expr><name>physical_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_null_saves_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>has_dropped_attr_alignment_mismatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>MTB_ByVal_Native</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>MTB_ByVal_Ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>=</operator> <name>physical_col</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>null_mask</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>physical_col</name><operator>-</operator><operator>(</operator><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>physical_col</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>cur_offset</name> <operator>=</operator> <name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>previous_bind</name> <operator>=</operator> <name>bind</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>physical_col</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No extra alignment required for the last binding */</comment>
		<expr_stmt><expr><call><name>add_null_save_aligned</name><argument_list>(<argument><expr><name>previous_bind</name></expr></argument>, <argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr></argument>, <argument><expr><name>physical_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>colbind</name><operator>-&gt;</operator><name>has_null_saves_alignment_mismatch</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DEBUG_ASSERT</name></cpp:ifdef>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><operator>&amp;</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if<condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>var_start</name></name> <operator>=</operator> <name>cur_offset</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colbind</name><operator>-&gt;</operator><name>var_start</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name>physical_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a memtuple binding from the tupdesc.  Note we store
 * a ref to the tupdesc in the binding, so we assumed the life
 * span of the tupdesc is no shorter than the binding.
 */</comment>
<function><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>create_memtuple_binding</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_is_executing</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pbind</name> <operator>=</operator> <operator>(</operator><name>MemTupleBinding</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MemTupleBinding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pbind</name><operator>-&gt;</operator><name>column_align</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pbind</name><operator>-&gt;</operator><name>column_align</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>pbind</name><operator>-&gt;</operator><name>null_bitmap_extra_size</name></name> <operator>=</operator> <call><name>compute_null_bitmap_extra_size</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>column_align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

	<expr_stmt><expr><call><name>create_col_bind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>bind</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>column_align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>create_col_bind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>column_align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pbind</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type> <name>compute_memtuple_size_using_bind</name><parameter_list>(
		<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
		<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
		<parameter><decl><type><name>bool</name></type> <name>hasnull</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>nullbit_extra</name></decl></parameter>,
		<parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>nullsaves</name></decl></parameter>,
		<parameter><decl><type><name>MemTupleBindingCols</name> <modifier>*</modifier></type><name>colbind</name></decl></parameter>,
		<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>data_length</name> <init>= <expr><name><name>colbind</name><operator>-&gt;</operator><name>var_start</name></name></expr></init></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>nullsaves</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>hasnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name>nullbit_extra</name></expr>;</expr_stmt>

		<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><operator>&amp;</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len_aligned</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len_aligned</name></name> <operator>&gt;=</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>bind</name><operator>-&gt;</operator><name>len_aligned</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>nullsaves</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_length</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><operator>&amp;</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>==</operator> <name>MTB_ByVal_Native</name> <operator>||</operator> <name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>==</operator> <name>MTB_ByVal_Ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Varlen stuff */</comment>
		<comment type="block">/* We plan to convert to short varlena even if it is not currently */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>==</operator> <name>MTB_ByRef</name> <operator>&amp;&amp;</operator>
			<name><name>attr</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator>
			<call><name>value_type_could_short</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>==</operator> <name>MTB_ByRef</name> <operator>&amp;&amp;</operator>
				 <call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we want to flatten the expanded value so that the constructed
			 * tuple doesn't depend on it
			 */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><call><name>MEMTUP_ALIGN</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the memtuple size. 
 * nullsave is an output param
 */</comment>
<function><type><name>uint32</name></type> <name>compute_memtuple_size</name><parameter_list>(<parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasnull</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>nullsaves</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>ret_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>ret_len</name> <operator>=</operator> <call><name>compute_memtuple_size_using_bind</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>hasnull</name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>null_bitmap_extra_size</name></name></expr></argument>, <argument><expr><name>nullsaves</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>bind</name></name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>ret_len</name> <operator>&lt;=</operator> <name>MEMTUPLE_LEN_FITSHORT</name></expr>)</condition><block type="pseudo"><block_content> 
		<return>return <expr><name>ret_len</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ret_len</name> <operator>=</operator> <call><name>compute_memtuple_size_using_bind</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>hasnull</name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>null_bitmap_extra_size</name></name></expr></argument>, <argument><expr><name>nullsaves</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name></name></expr></argument>, <argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret_len</name> <operator>&gt;</operator> <name>MEMTUPLE_LEN_FITSHORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret_len</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name><modifier>*</modifier></type> <name>memtuple_get_attr_ptr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name></decl></parameter>, <parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>null_saves</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nullp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>nullp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ns</name> <operator>=</operator> <call><name>compute_null_save</name><argument_list>(<argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>, <argument><expr><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name></expr></argument>, <argument><expr><name><name>bind</name><operator>-&gt;</operator><name>null_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>start</name> <operator>+</operator> <name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name>ns</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name><modifier>*</modifier></type> <name>memtuple_get_attr_data_ptr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name></decl></parameter>, <parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>null_saves</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>nullp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>==</operator> <name>MTB_ByVal_Native</name> <operator>||</operator> <name><name>bind</name><operator>-&gt;</operator><name>flag</name></name> <operator>==</operator> <name>MTB_ByVal_Ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>start</name> <operator>+</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>start</name> <operator>+</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>memtuple_get_nullp</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>mtup</name><operator>-&gt;</operator><name>PRIVATE_mt_bits</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>mtbind_has_oid</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>memtuple_attisnull</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemTupleBindingCols</name> <modifier>*</modifier></type><name>colbind</name> <init>= <expr><ternary><condition><expr><call><name>memtuple_get_islarge</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr> 
									?</condition><then> <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name></name></expr> 
									</then><else>: <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>bind</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> 		<modifier>*</modifier></type><name>nullp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>attrbind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mtup</name> <operator>&amp;&amp;</operator> <name>pbind</name> <operator>&amp;&amp;</operator> <name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * This used to be an Assert. However, we follow the logic of
	 * heap_attisnull() and treat attnums &gt; lastatt as NULL. This
	 * is currently used in ALTER ADD COLUMN NOT NULL.
	 * 
	 * Unfortunately this also means that the caller needs to be
	 * extra careful passing in the correct attnum argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/*
	 * is there a NULL value in any of the attributes?
	 */</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>memtuple_get_hasnull</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>nullp</name> <operator>=</operator> <call><name>memtuple_get_nullp</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrbind</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name><name>nullp</name><index>[<expr><name><name>attrbind</name><operator>-&gt;</operator><name>null_byte</name></name></expr>]</index></name> <operator>&amp;</operator> <name><name>attrbind</name><operator>-&gt;</operator><name>null_mask</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* form a memtuple from values and isnull, to a prespecified buffer */</comment>
<function><type><name>MemTuple</name></type> <name>memtuple_form_to</name><parameter_list>(
		<parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>,
		<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
		<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
		<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>,
		<parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>destlen</name></decl></parameter>,
		<parameter><decl><type><name>bool</name></type> <name>inline_toast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasext</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nullp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varlen_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>null_save_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleBindingCols</name> <modifier>*</modifier></type><name>colbind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>old_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for nulls and embedded tuples; expand any toasted attributes in
	 * embedded tuples.  This preserves the invariant that toasting can only
	 * go one level deep.
	 *
	 * We can skip calling toast_flatten_tuple_attribute() if the attribute
	 * couldn't possibly be of composite type.  All composite datums are
	 * varlena and have alignment 'd'; furthermore they aren't arrays. Also,
	 * if an attribute is already toasted, it must have been sent to disk
	 * already and so cannot contain toasted attributes.
	 */</comment>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHK_TYPE_SANE</name></cpp:ifdef>
		<expr_stmt><expr><call><name>check_type_sanity</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* treat dropped attibutes as null */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>inline_toast</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>old_values</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>old_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* compute needed length */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compute_memtuple_size</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>hasnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_save_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>colbind</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len</name> <operator>&lt;=</operator> <name>MEMTUPLE_LEN_FITSHORT</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>bind</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name></name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>destlen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mtup</name> <operator>=</operator> <operator>(</operator><name>MemTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><operator>*</operator><name>destlen</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>destlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set values to their old values if we have changed their values
		 * during de-toasting, and release the space allocated during
		 * de-toasting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_values</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>destlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set mtlen, this set the lead bit, len, and clears hasnull bit 
	 * because the len returned from compute size is always max aligned
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <call><name>MEMTUP_ALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memtuple_set_mtlen</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><operator>(</operator><name>len</name> <operator>|</operator> <name>MEMTUP_LEAD_BIT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>len</name> <operator>&gt;</operator> <name>MEMTUPLE_LEN_FITSHORT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memtuple_set_islarge</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>hasext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memtuple_set_hasext</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clear Oid */</comment> 
	<if_stmt><if>if<condition>(<expr><call><name>mtbind_has_oid</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemTupleSetOid</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nullp</name> <operator>=</operator> <call><name>memtuple_get_nullp</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>varlen_start</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>+</operator> <name><name>colbind</name><operator>-&gt;</operator><name>var_start</name></name> <operator>-</operator> <name>null_save_len</name></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>hasnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memtuple_set_hasnull</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if null bitmap is more than 4 bytes, add needed space */</comment>
		<expr_stmt><expr><name>start</name> <operator>+=</operator> <name><name>pbind</name><operator>-&gt;</operator><name>null_bitmap_extra_size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>varlen_start</name> <operator>+=</operator> <name><name>pbind</name><operator>-&gt;</operator><name>null_bitmap_extra_size</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* It is very important to setup the null bitmap first before we 
	 * really put the values into place.  Where is the value in the 
	 * memtuple is determined by space saved from nulls, so the bitmap
	 * is used in the next loop. 
	 * NOTE: We cannot set the bitmap in the next loop (even at very
	 * beginning of next loop), because physical col order is different
	 * from logical. 
	 */</comment>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hasnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nullp</name><index>[<expr><name><name>bind</name><operator>-&gt;</operator><name>null_byte</name></name></expr>]</index></name> <operator>|=</operator> <name><name>bind</name><operator>-&gt;</operator><name>null_mask</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Null bitmap is set up correctly, we can put in values now */</comment>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>bind</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>attr_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>short</name> <modifier>*</modifier></type><name>null_saves</name></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>null_saves</name> <operator>=</operator> <name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_saves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Not null */</comment>
		<switch>switch<condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>MTB_ByVal_Native</name></expr>:</case>
				<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>
					       )</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>MTB_ByVal_Ptr</name></expr>:</case>
				<if_stmt><if>if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>BPCHAROID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>
					      )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if<condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attr_len</name> <operator>&lt;=</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>attr_len</name></expr></argument>
						      )</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name> <operator>+</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attr_len</name> <operator>&lt;=</operator> <name><name>bind</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>VARATT_LEN_1B</name><argument_list>(<argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_len</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>MTB_ByRef</name></expr>:</case>
				<if_stmt><if>if<condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>varlen_start</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>varlen_start</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name> <init>= <expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><name>varlen_start</name></expr></argument>, <argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>VARSIZE_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varlen_start</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>+</operator> <name>attr_len</name> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>varlen_start</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varlen_start</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>+</operator> <name>attr_len</name> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>varlen_start</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator>
						<call><name>value_type_could_short</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name> <operator>+</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>varlen_start</name> <operator>=</operator> <call><name>VARATT_LEN_1B</name><argument_list>(<argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varlen_start</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>+</operator> <name>attr_len</name> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>varlen_start</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_len</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Must be 4 byte header aligned varlena */</comment>
					<expr_stmt><expr><name>varlen_start</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>varlen_start</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varlen_start</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>+</operator> <name>attr_len</name> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>varlen_start</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <operator>(</operator><name>varlen_start</name> <operator>-</operator> <name>start</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>varlen_start</name> <operator>-</operator> <name>start</name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>varlen_start</name> <operator>+=</operator> <name>attr_len</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>MTB_ByRef_CStr</name></expr>:</case>
				<expr_stmt><expr><name>varlen_start</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>varlen_start</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attr_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varlen_start</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>+</operator> <name>attr_len</name> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>varlen_start</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <operator>(</operator><name>varlen_start</name> <operator>-</operator> <name>start</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bind</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <call><name>memtuple_get_attr_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>varlen_start</name> <operator>-</operator> <name>start</name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>varlen_start</name> <operator>+=</operator> <name>attr_len</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"Not valid binding type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varlen_start</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set values to their old values if we have changed their values
	 * during de-toasting, and release the space allocated during
	 * de-toasting.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>old_values</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>old_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>mtup</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type> <name>memtuple_getattr_by_alignment</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_null_saves_aligned</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasnull</name> <init>= <expr><call><name>memtuple_get_hasnull</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nullp</name> <init>= <expr><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><call><name>memtuple_get_nullp</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><name><name>pbind</name><operator>-&gt;</operator><name>null_bitmap_extra_size</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name> <modifier>*</modifier></type><name>null_saves</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleBindingCols</name> <modifier>*</modifier></type><name>colbind</name> <init>= <expr><ternary><condition><expr><call><name>memtuple_get_islarge</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>large_bind</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>bind</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleAttrBinding</name> <modifier>*</modifier></type><name>attrbind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mtup</name> <operator>&amp;&amp;</operator> <name>pbind</name> <operator>&amp;&amp;</operator> <name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* input attnum is 1 based.  Make it 0 based */</comment>
	<expr_stmt><expr><operator>--</operator><name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrbind</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>colbind</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* null check */</comment>
	<if_stmt><if>if<condition>(<expr><name>hasnull</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>nullp</name><index>[<expr><name><name>attrbind</name><operator>-&gt;</operator><name>null_byte</name></name></expr>]</index></name> <operator>&amp;</operator> <name><name>attrbind</name><operator>-&gt;</operator><name>null_mask</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>null_saves</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>use_null_saves_aligned</name></expr> ?</condition><then> <expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves_aligned</name></name></expr> </then><else>: <expr><name><name>colbind</name><operator>-&gt;</operator><name>null_saves</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_saves</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>memtuple_get_attr_data_ptr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>attrbind</name></expr></argument>, <argument><expr><name>null_saves</name></expr></argument>, <argument><expr><name>nullp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>memtuple_getattr</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>memtuple_getattr_by_alignment</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* aligned */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MemTuple</name></type> <name>mem_copytuple</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>len</name> <init>= <expr><call><name>memtuple_get_size</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type> <name>dest</name> <init>= <expr><operator>(</operator><name>MemTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mtup</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>memtuple_get_values</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_null_saves_aligned</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>datum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>memtuple_getattr_by_alignment</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>use_null_saves_aligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>memtuple_deform</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memtuple_get_values</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* aligned */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>MemTupleSetOid</name><argument_list>(<argument><expr><name>MemTuple</name> <name>mtup</name></expr></argument>, <argument><expr><name>MemTupleBinding</name> <operator>*</operator><name>pbind</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Oid</name> <name>oid</name></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pbind</name> <operator>&amp;&amp;</operator> <call><name>mtbind_has_oid</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>oid</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Get the Oid assigned to this tuple (when WITH OIDS is used).
 *
 * Note that similarly to HeapTupleGetOid this function will 
 * sometimes get called when no oid is assigned, in which case
 * we return InvalidOid. It is possible to make the check earlier
 * and avoid this call but for simplicity and compatibility with
 * the HeapTuple interface we keep it the same. 
 */</comment>
<function><type><name>Oid</name></type> <name>MemTupleGetOid</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>mtbind_has_oid</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>mtup</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr>;</return>
</block_content>}</block></function></unit>
