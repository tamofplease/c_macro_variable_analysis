<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/commands/explain_px.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * explain_px.c
 *	  Functions supporting the PolarDB PX extensions to EXPLAIN ANALYZE
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * IDENTIFICATION
 *	    src/backend/commands/explain_px.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>		<comment type="block">/* SegmentDatabaseDescriptor */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>                <comment type="block">/* CheckDispatchResult() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>	<comment type="block">/* PxDispatchResults */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_explain.h"</cpp:file></cpp:include>		<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>		<comment type="block">/* pq_beginmessage() etc. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>		<comment type="block">/* MemoryContextGetPeakSpace() */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_explain.h"</cpp:file></cpp:include>             <comment type="block">/* pxexplain_recvExecStats */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_SORT_METHOD</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOP_N_HEAP_SORT_STR</name></cpp:macro> <cpp:value>"top-N heapsort"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUICK_SORT_STR</name></cpp:macro> <cpp:value>"quicksort"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERNAL_SORT_STR</name></cpp:macro> <cpp:value>"external sort"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERNAL_MERGE_STR</name></cpp:macro> <cpp:value>"external merge"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_PROGRESS_SORT_STR</name></cpp:macro> <cpp:value>"sort still in progress"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_SORT_SPACE_TYPE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEMORY_STR_SORT_SPACE_TYPE</name></cpp:macro> <cpp:value>"Memory"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISK_STR_SORT_SPACE_TYPE</name></cpp:macro> <cpp:value>"Disk"</cpp:value></cpp:define>

<comment type="block">/* Convert bytes into kilobytes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(floor((x + 1023.0) / 1024.0))</cpp:value></cpp:define>

<comment type="block">/*
 * Different sort method in POLAR PX.
 *
 * Make sure to update NUM_SORT_METHOD when this enum changes.
 * This enum value is used an index in the array sortSpaceUsed
 * in struct PxExplain_NodeSummary.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>UNINITIALIZED_SORT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>TOP_N_HEAP_SORT</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>QUICK_SORT</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>EXTERNAL_SORT</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
	<decl><name>EXTERNAL_MERGE</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
	<decl><name>IN_PROGRESS_SORT</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>
}</block></enum></type> <name>ExplainSortMethod</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>UNINITIALIZED_SORT_SPACE_TYPE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>MEMORY_SORT_SPACE_TYPE</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>DISK_SORT_SPACE_TYPE</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block></enum></type> <name>ExplainSortSpaceType</name>;</typedef>

<comment type="block">/*
 * Convert the above enum `ExplainSortMethod` to printable string for
 * Explain Analyze.
 * Note : No conversion available for `UNINITALIZED_SORT`. Caller has to index
 * this array by subtracting 1 from origin enum value.
 *
 * E.g. sort_method_enum_str[TOP_N_HEAP_SORT-1]
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>sort_method_enum_str</name><index>[]</index></name> <init>= <expr><block>{
	<expr><name>TOP_N_HEAP_SORT_STR</name></expr>,
	<expr><name>QUICK_SORT_STR</name></expr>,
	<expr><name>EXTERNAL_SORT_STR</name></expr>,
	<expr><name>EXTERNAL_MERGE_STR</name></expr>,
	<expr><name>IN_PROGRESS_SORT_STR</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* EXPLAIN ANALYZE statistics for one plan node of a slice */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_StatInst</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>pstype</name></decl>;</decl_stmt>			<comment type="block">/* PlanState node type */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>		<comment type="block">/* Start time of current iteration of node */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>counter</name></decl>;</decl_stmt>		<comment type="block">/* Accumulated runtime for this node */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>firsttuple</name></decl>;</decl_stmt>		<comment type="block">/* Time for first tuple of this cycle */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>startup</name></decl>;</decl_stmt>		<comment type="block">/* Total startup time (in seconds) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>total</name></decl>;</decl_stmt>			<comment type="block">/* Total total time (in seconds) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name></decl>;</decl_stmt>		<comment type="block">/* Total tuples produced */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>nloops</name></decl>;</decl_stmt>			<comment type="block">/* # of run cycles for this node */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>execmemused</name></decl>;</decl_stmt>	<comment type="block">/* executor memory used (bytes) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused</name></decl>;</decl_stmt>	<comment type="block">/* work_mem actually used (bytes) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted</name></decl>;</decl_stmt>	<comment type="block">/* work_mem to avoid workfile i/o (bytes) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>workfileCreated</name></decl>;</decl_stmt>	<comment type="block">/* workfile created in this node */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>firststart</name></decl>;</decl_stmt>		<comment type="block">/* Start time of first iteration of node */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>peakMemBalance</name></decl>;</decl_stmt> <comment type="block">/* Max mem account balance */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPartScanned</name></decl>;</decl_stmt> <comment type="block">/* Number of part tables scanned */</comment>
	<decl_stmt><decl><type><name>ExplainSortMethod</name></type> <name>sortMethod</name></decl>;</decl_stmt>	<comment type="block">/* Type of sort */</comment>
	<decl_stmt><decl><type><name>ExplainSortSpaceType</name></type> <name>sortSpaceType</name></decl>;</decl_stmt> <comment type="block">/* Sort space type */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>sortSpaceUsed</name></decl>;</decl_stmt>	<comment type="block">/* Memory / Disk used by sort(KBytes) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bnotes</name></decl>;</decl_stmt>			<comment type="block">/* Offset to beginning of node's extra text */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>enotes</name></decl>;</decl_stmt>			<comment type="block">/* Offset to end of node's extra text */</comment>
}</block></struct></type> <name>PxExplain_StatInst</name>;</typedef>


<comment type="block">/* EXPLAIN ANALYZE statistics for one process working on one slice */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_SliceWorker</name>
<block>{
	<decl_stmt><decl><type><name>double</name></type>		<name>peakmemused</name></decl>;</decl_stmt>	<comment type="block">/* bytes alloc in per-query mem context tree */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>vmem_reserved</name></decl>;</decl_stmt>	<comment type="block">/* vmem reserved by a QE */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>memory_accounting_global_peak</name></decl>;</decl_stmt>	<comment type="block">/* peak memory observed during
												 * memory accounting */</comment>
}</block></struct></type> <name>PxExplain_SliceWorker</name>;</typedef>


<comment type="block">/* Header of EXPLAIN ANALYZE statistics message sent from qExec to qDisp */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_StatHdr</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>			<comment type="block">/* T_PxExplain_StatHdr */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex</name></decl>;</decl_stmt>		<comment type="block">/* segment id */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nInst</name></decl>;</decl_stmt>			<comment type="block">/* num of StatInst entries following StatHdr */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bnotes</name></decl>;</decl_stmt>			<comment type="block">/* offset to extra text area */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>enotes</name></decl>;</decl_stmt>			<comment type="block">/* offset to end of extra text area */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>memAccountCount</name></decl>;</decl_stmt>	<comment type="block">/* How many mem account we serialized */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>memAccountStartOffset</name></decl>;</decl_stmt>	<comment type="block">/* Where in the header our memory
										 * account array is serialized */</comment>

	<decl_stmt><decl><type><name>PxExplain_SliceWorker</name></type> <name>worker</name></decl>;</decl_stmt>	<comment type="block">/* qExec's overall stats for slice */</comment>

	<comment type="block">/*
	 * During serialization, we use this as a temporary StatInst and save
	 * "one-at-a-time" StatInst into this variable. We then write this
	 * variable into buffer (serialize it) and then "recycle" the same inst
	 * for next plan node's StatInst. During deserialization, an Array
	 * [0..nInst-1] of StatInst entries is appended starting here.
	 */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name></type> <name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* extra text is appended after that */</comment>
}</block></struct></type> <name>PxExplain_StatHdr</name>;</typedef>


<comment type="block">/* Dispatch status summarized over workers in a slice */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_DispatchSummary</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nOk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nError</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nCanceled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nNotDispatched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nIgnorableError</name></decl>;</decl_stmt>
}</block></struct></type> <name>PxExplain_DispatchSummary</name>;</typedef>


<comment type="block">/* One node's EXPLAIN ANALYZE statistics for all the workers of its segworker group */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_NodeSummary</name>
<block>{
	<comment type="block">/* Summary over all the node's workers */</comment>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>ntuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>execmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>workmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>workmemwanted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>totalWorkfileCreated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>peakMemBalance</name></decl>;</decl_stmt>
	<comment type="block">/* Used for DynamicSeqScan, DynamicIndexScan and DynamicBitmapHeapScan */</comment>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>totalPartTableScanned</name></decl>;</decl_stmt>
	<comment type="block">/* Summary of space used by sort */</comment>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name><name>sortSpaceUsed</name><index>[<expr><name>NUM_SORT_SPACE_TYPE</name></expr>]</index><index>[<expr><name>NUM_SORT_METHOD</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* insts array info */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex0</name></decl>;</decl_stmt>		<comment type="block">/* segment id of insts[0] */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ninst</name></decl>;</decl_stmt>			<comment type="block">/* num of StatInst entries in inst array */</comment>

	<comment type="block">/* Array [0..ninst-1] of StatInst entries is appended starting here */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name></type> <name><name>insts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* variable size - must be last */</comment>
}</block></struct></type> <name>PxExplain_NodeSummary</name>;</typedef>


<comment type="block">/* One slice's statistics for all the workers of its segworker group */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_SliceSummary</name>
<block>{
	<decl_stmt><decl><type><name>ExecSlice</name>	   <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>

	<comment type="block">/* worker array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nworker</name></decl>;</decl_stmt>		<comment type="block">/* num of SliceWorker slots in worker array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex0</name></decl>;</decl_stmt>		<comment type="block">/* segment id of workers[0] */</comment>
	<decl_stmt><decl><type><name>PxExplain_SliceWorker</name> <modifier>*</modifier></type><name>workers</name></decl>;</decl_stmt>	<comment type="block">/* -&gt; array [0..nworker-1] of
										 * SliceWorker */</comment>

	<comment type="block">/*
	 * We use void ** as we don't have access to MemoryAccount struct, which
	 * is private to memory accounting framework
	 */</comment>
	<decl_stmt><decl><type><name>void</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>memoryAccounts</name></decl>;</decl_stmt> <comment type="block">/* Array of pointers to serialized memory
								 * accounts array, one array per worker
								 * [0...nworker-1]. */</comment>
	<comment type="line">// MemoryAccountIdType *memoryAccountCount;	/* Array of memory account</comment>
	<comment type="line">// 											 * counts, one per slice */</comment>

	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>peakmemused</name></decl>;</decl_stmt> <comment type="block">/* Summary of SliceWorker stats over all of
								 * the slice's workers */</comment>

	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>vmem_reserved</name></decl>;</decl_stmt>	<comment type="block">/* vmem reserved by QEs */</comment>

	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>memory_accounting_global_peak</name></decl>;</decl_stmt>	<comment type="block">/* Peak memory accounting
													 * balance by QEs */</comment>

	<comment type="block">/* Rollup of per-node stats over all of the slice's workers and nodes */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted_max</name></decl>;</decl_stmt>

	<comment type="block">/* How many workers were dispatched and returned results? (0 if local) */</comment>
	<decl_stmt><decl><type><name>PxExplain_DispatchSummary</name></type> <name>dispatchSummary</name></decl>;</decl_stmt>
}</block></struct></type> <name>PxExplain_SliceSummary</name>;</typedef>


<comment type="block">/* State for pxexplain_showExecStats() */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_ShowStatCtx</name>
<block>{
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>extratextbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>querystarttime</name></decl>;</decl_stmt>

	<comment type="block">/* Rollup of per-node stats over the entire query plan */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted_max</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>stats_gathered</name></decl>;</decl_stmt>
	<comment type="block">/* Per-slice statistics are deposited in this SliceSummary array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nslice</name></decl>;</decl_stmt>			<comment type="block">/* num of slots in slices array */</comment>
	<decl_stmt><decl><type><name>PxExplain_SliceSummary</name> <modifier>*</modifier></type><name>slices</name></decl>;</decl_stmt>	<comment type="block">/* -&gt; array[0..nslice-1] of
										 * SliceSummary */</comment>
}</block></struct></type> <name>PxExplain_ShowStatCtx</name>;</typedef>


<comment type="block">/* State for pxexplain_sendStatWalker() and pxexplain_collectStatsFromNode() */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_SendStatCtx</name>
<block>{
	<decl_stmt><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>notebuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_StatHdr</name></type> <name>hdr</name></decl>;</decl_stmt>
}</block></struct></type> <name>PxExplain_SendStatCtx</name>;</typedef>


<comment type="block">/* State for pxexplain_recvStatWalker() and pxexplain_depositStatsToNode() */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_RecvStatCtx</name>
<block>{
	<comment type="block">/*
	 * iStatInst is the current StatInst serial during the depositing process
	 * for a slice. We walk the plan tree, and for each node we deposit stat
	 * from all the QEs of the segworker group for current slice. After we
	 * finish one node, we increase iStatInst, which means we are done with
	 * one plan node's stat across all segments and now moving forward to the
	 * next one. Once we are done processing all the plan node of a PARTICULAR
	 * slice, then we switch to the next slice, read the messages from all the
	 * QEs of the next slice (another segworker group) store them in the
	 * msgptrs, reset the iStatInst and then start parsing these messages and
	 * depositing them in the nodes of the new slice.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>iStatInst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * nStatInst is the total number of StatInst for current slice. Typically
	 * this is the number of plan nodes in the current slice.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nStatInst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * segIndexMin is the min of segment index from which we collected message
	 * (i.e., saved msgptrs)
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindexMin</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * segIndexMax is the max of segment index from which we collected message
	 * (i.e., saved msgptrs)
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindexMax</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We deposit stat for one slice at a time. sliceIndex saves the current
	 * slice
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The number of msgptrs that we have saved for current slice. This is
	 * typically the number of QE processes
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmsgptr</name></decl>;</decl_stmt>
	<comment type="block">/* The actual messages. Contains an array of StatInst too */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier><modifier>*</modifier></type><name>msgptrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>dispatchResults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>extratextbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_ShowStatCtx</name> <modifier>*</modifier></type><name>showstatctx</name></decl>;</decl_stmt>

	<comment type="block">/* Rollup of per-node stats over all of the slice's workers and nodes */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted_max</name></decl>;</decl_stmt>
}</block></struct></type> <name>PxExplain_RecvStatCtx</name>;</typedef>


<comment type="block">/* State for pxexplain_localStatWalker() */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_LocalStatCtx</name>
<block>{
	<decl_stmt><decl><type><name>PxExplain_SendStatCtx</name></type> <name>send</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_RecvStatCtx</name></type> <name>recv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name><name>msgptrs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PxExplain_LocalStatCtx</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>PxVisitOpt</name></type> <name>pxexplain_localStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PxVisitOpt</name></type> <name>pxexplain_sendStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PxVisitOpt</name></type> <name>pxexplain_recvStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxexplain_depositSliceStats</name><parameter_list>(<parameter><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>,
										 <parameter><decl><type><name>PxExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>recvstatctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxexplain_collectStatsFromNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											<parameter><decl><type><name>PxExplain_SendStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxexplain_depositStatsToNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
										  <parameter><decl><type><name>PxExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pxexplain_collectExtraText</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									   <parameter><decl><type><name>StringInfo</name></type> <name>notebuf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_motion_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
							 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keycols</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * PxExplain_DepStatAcc
 *	  Segment statistic accumulator used by pxexplain_depositStatsToNode().
 */</comment>
<typedef>typedef <type><struct>struct <name>PxExplain_DepStatAcc</name>
<block>{
	<comment type="block">/* vmax, vsum, vcnt, segmax */</comment>
	<decl_stmt><decl><type><name>PxExplain_Agg</name></type> <name>agg</name></decl>;</decl_stmt>
	<comment type="block">/* max's received StatHdr */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>rshmax</name></decl>;</decl_stmt>
	<comment type="block">/* max's received inst in StatHdr */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>rsimax</name></decl>;</decl_stmt>
	<comment type="block">/* max's inst in NodeSummary */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>nsimax</name></decl>;</decl_stmt>
	<comment type="block">/* max run-time of all the segments */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>max_total</name></decl>;</decl_stmt>
	<comment type="block">/* start time of the first iteration for node with maximum runtime */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>firststart_of_max_total</name></decl>;</decl_stmt>
}</block></struct></type> <name>PxExplain_DepStatAcc</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxexplain_depStatAcc_init0</name><parameter_list>(<parameter><decl><type><name>PxExplain_DepStatAcc</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pxexplain_agg_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>acc</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rshmax</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rsimax</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>nsimax</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>max_total</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>acc</name><operator>-&gt;</operator><name>firststart_of_max_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_depStatAcc_init0 */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>pxexplain_depStatAcc_upd</name><parameter_list>(<parameter><decl><type><name>PxExplain_DepStatAcc</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>,
						  <parameter><decl><type><name>double</name></type> <name>v</name></decl></parameter>,
						  <parameter><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>rsh</name></decl></parameter>,
						  <parameter><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>rsi</name></decl></parameter>,
						  <parameter><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pxexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>acc</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rshmax</name></name> <operator>=</operator> <name>rsh</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rsimax</name></name> <operator>=</operator> <name>rsi</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>nsimax</name></name> <operator>=</operator> <name>nsi</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>max_total</name></name> <operator>&lt;</operator> <name><name>nsi</name><operator>-&gt;</operator><name>total</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>max_total</name></name> <operator>=</operator> <name><name>nsi</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_ASSIGN</name><argument_list>(<argument><expr><name><name>acc</name><operator>-&gt;</operator><name>firststart_of_max_total</name></name></expr></argument>, <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>firststart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_depStatAcc_upd */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxexplain_depStatAcc_saveText</name><parameter_list>(<parameter><decl><type><name>PxExplain_DepStatAcc</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>,
							   <parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>extratextbuf</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>saved_inout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>rsh</name> <init>= <expr><name><name>acc</name><operator>-&gt;</operator><name>rshmax</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>acc</name><operator>-&gt;</operator><name>rsimax</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name> <init>= <expr><name><name>acc</name><operator>-&gt;</operator><name>nsimax</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>agg</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>==</operator> <name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>&amp;&amp;</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>&lt;</operator> <name><name>rsi</name><operator>-&gt;</operator><name>enotes</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Locate extra message text in dispatch result buffer. */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>notelen</name> <init>= <expr><name><name>rsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>-</operator> <name><name>rsi</name><operator>-&gt;</operator><name>bnotes</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>notes</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>rsh</name> <operator>+</operator> <name><name>rsh</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>+</operator> <name><name>rsi</name><operator>-&gt;</operator><name>bnotes</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>+</operator> <name><name>rsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>&lt;</operator> <name><name>rsh</name><operator>-&gt;</operator><name>enotes</name></name> <operator>&amp;&amp;</operator>
			   <name><name>notes</name><index>[<expr><name>notelen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append to extratextbuf. */</comment>
		<expr_stmt><expr><name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>=</operator> <name><name>extratextbuf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>extratextbuf</name></expr></argument>, <argument><expr><name>notes</name></expr></argument>, <argument><expr><name>notelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>=</operator> <name><name>extratextbuf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

		<comment type="block">/* Tell caller that some extra text has been saved. */</comment>
		<if_stmt><if>if <condition>(<expr><name>saved_inout</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>saved_inout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_depStatAcc_saveText */</comment>

<comment type="block">/*
 * pxexplain_localExecStats
 *	  Called by qDisp to build NodeSummary and SliceSummary blocks
 *	  containing EXPLAIN ANALYZE statistics for a root slice that
 *	  has been executed locally in the qDisp process.  Attaches these
 *	  structures to the PlanState nodes' Instrumentation objects for
 *	  later use by pxexplain_showExecStats().
 *
 * 'planstate' is the top PlanState node of the slice.
 * 'showstatctx' is a PxExplain_ShowStatCtx object which was created by
 *		calling pxexplain_showExecStatsBegin().
 */</comment>
<function><type><name>void</name></type>
<name>pxexplain_localExecStats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						  <parameter><decl><type><name><name>struct</name> <name>PxExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_LocalStatCtx</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>!=</operator> <name>PX_ROLE_PX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>planstate</name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name>showstatctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up send context area. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>notebuf</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up a temporary StatHdr for both collecting and depositing stats. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>segindex</name></name> <operator>=</operator> <name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>nInst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Set up receive context area referencing our temp StatHdr. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>nStatInst</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>nInst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>segindexMin</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>segindexMax</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>segindex</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>sliceIndex</name></name> <operator>=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>msgptrs</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>msgptrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>nmsgptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>dispatchResults</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>extratextbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>showstatctx</name></name> <operator>=</operator> <name>showstatctx</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect and redeposit statistics from each PlanState node in this
	 * slice. Any extra message text will be appended directly to
	 * extratextbuf.
	 */</comment>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>pxexplain_localStatWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Obtain per-slice stats and put them in SliceSummary. */</comment>
	<expr_stmt><expr><call><name>pxexplain_depositSliceStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_localExecStats */</comment>

<comment type="block">/*
 * pxexplain_localStatWalker
 */</comment>
<function><type><specifier>static</specifier> <name>PxVisitOpt</name></type>
<name>pxexplain_localStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_LocalStatCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>PxExplain_LocalStatCtx</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Collect stats into our temporary StatInst and caller's extratextbuf. */</comment>
	<expr_stmt><expr><call><name>pxexplain_collectStatsFromNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>send</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Redeposit stats back into Instrumentation, and attach a NodeSummary. */</comment>
	<expr_stmt><expr><call><name>pxexplain_depositStatsToNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't descend across a slice boundary. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PxVisit_Skip</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>PxVisit_Walk</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* pxexplain_localStatWalker */</comment>

<comment type="block">/*
 * pxexplain_sendExecStats
 *	  Called by qExec process to send EXPLAIN ANALYZE statistics to qDisp.
 *	  On the qDisp, libpq will recognize our special message type ('Y') and
 *	  attach the message to the current command's PGresult object.
 */</comment>
<function><type><name>void</name></type>
<name>pxexplain_sendExecStats</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_SendStatCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>notebuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>memoryAccountTreeBuffer</name></decl>;</decl_stmt>

	<comment type="block">/* Header offset (where header begins in the message buffer) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>hoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queryDesc</name> <operator>||</operator>
		<operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If executing a root slice (UPD/DEL/INS), start at top of plan tree. */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>planstate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/* Non-root slice: Start at child of our sending Motion node. */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>planstate</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ps</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>planstate</name> <operator>&amp;&amp;</operator>
			   <call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>planstate</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Start building the message header in our context area. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_PxExplain_StatHdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>segindex</name></name> <operator>=</operator> <name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>nInst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Allocate a separate buffer where nodes can append extra message text. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>notebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>notebuf</name></name> <operator>=</operator> <operator>&amp;</operator><name>notebuf</name></expr>;</expr_stmt>

	<comment type="block">/* Reserve buffer space for the message header (excluding 'inst' array). */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Where the actual StatHdr begins */</comment>
	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write everything until inst member including "PxExplain_SliceWorker
	 * worker"
	 */</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>inst</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append statistics from each PlanState node in this slice. */</comment>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>pxexplain_sendStatWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append MemoryAccount Tree */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>memAccountStartOffset</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memoryAccountTreeBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// uint		totalSerialized = MemoryAccounting_Serialize(&amp;memoryAccountTreeBuffer);</comment>

	<comment type="line">// ctx.hdr.memAccountCount = totalSerialized;</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>memoryAccountTreeBuffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>memoryAccountTreeBuffer</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>memoryAccountTreeBuffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append the extra message text. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>bnotes</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>notebuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>notebuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>enotes</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>notebuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Move the message header into the buffer. Rewrite the updated header
	 * (with bnotes, enotes, nInst etc.) Note: this is the second time we are
	 * writing the header. The first write merely reserves space for the
	 * header
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>hoff</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>inst</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send message to qDisp process. */</comment>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_sendExecStats */</comment>


<comment type="block">/*
 * pxexplain_sendStatWalker
 */</comment>
<function><type><specifier>static</specifier> <name>PxVisitOpt</name></type>
<name>pxexplain_sendStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_SendStatCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>PxExplain_SendStatCtx</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Stuff stats into our temporary StatInst.  Add extra text to notebuf. */</comment>
	<expr_stmt><expr><call><name>pxexplain_collectStatsFromNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append StatInst instance to message. */</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nInst</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Don't descend across a slice boundary. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PxVisit_Skip</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>PxVisit_Walk</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* pxexplain_sendStatWalker */</comment>

<comment type="block">/*
 * pxexplain_recvExecStats
 *	  Called by qDisp to transfer a slice's EXPLAIN ANALYZE statistics
 *	  from the PxDispatchResults structures to the PlanState tree.
 *	  Recursively does the same for slices that are descendants of the
 *	  one specified.
 *
 * 'showstatctx' is a PxExplain_ShowStatCtx object which was created by
 *		calling pxexplain_showExecStatsBegin().
 */</comment>
<function><type><name>void</name></type>
<name>pxexplain_recvExecStats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>PxDispatchResults</name></name> <modifier>*</modifier></type><name>dispatchResults</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>PxExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResultBeg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResultEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_RecvStatCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DispatchSummary</name></type> <name>ds</name></decl>;</decl_stmt>
    <comment type="line">//TODO</comment>
	<comment type="line">// int			gpsegmentCount = getgpsegmentCount();</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>iDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>imsgptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>planstate</name> <operator>||</operator>
		<operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>||</operator>
		<operator>!</operator><name>showstatctx</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note that the caller may free the PxDispatchResults upon return, maybe
	 * before EXPLAIN ANALYZE examines the PlanState tree.  Consequently we
	 * must not return ptrs into the dispatch result buffers, but must copy
	 * any needed information into a sufficiently long-lived memory context.
	 */</comment>

	<comment type="block">/* Initialize treewalk context. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>dispatchResults</name></name> <operator>=</operator> <name>dispatchResults</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>extratextbuf</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>showstatctx</name></name> <operator>=</operator> <name>showstatctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>sliceIndex</name></name> <operator>=</operator> <name>sliceIndex</name></expr>;</expr_stmt>

	<comment type="block">/* Find the slice's PxDispatchResult objects. */</comment>
	<expr_stmt><expr><name>dispatchResultBeg</name> <operator>=</operator> <call><name>pxdisp_resultBegin</name><argument_list>(<argument><expr><name>dispatchResults</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dispatchResultEnd</name> <operator>=</operator> <call><name>pxdisp_resultEnd</name><argument_list>(<argument><expr><name>dispatchResults</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDispatch</name> <operator>=</operator> <name>dispatchResultEnd</name> <operator>-</operator> <name>dispatchResultBeg</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize worker counts. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nResult</name></name> <operator>=</operator> <name>nDispatch</name></expr>;</expr_stmt>

	<comment type="block">/* Find and validate the statistics returned from each qExec. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nDispatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name></name> <operator>=</operator> <operator>(</operator><name>PxExplain_StatHdr</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nDispatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>iDispatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iDispatch</name> <operator>&lt;</operator> <name>nDispatch</name></expr>;</condition> <incr><expr><name>iDispatch</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><operator>&amp;</operator><name><name>dispatchResultBeg</name><index>[<expr><name>iDispatch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgPxStatCell</name> <modifier>*</modifier></type><name>statcell</name></decl>;</decl_stmt>

		<comment type="block">/* Update worker counts. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>hasDispatched</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nNotDispatched</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nCanceled</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nError</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nOk</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>			<comment type="block">/* qExec returned successful completion */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nIgnorableError</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* qExec returned an error that's likely a
									 * side-effect of another qExec's failure,
									 * e.g. an interconnect error */</comment>

		<comment type="block">/* Find this qExec's last PGresult.  If none, skip to next qExec. */</comment>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>pxdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgresult</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Find our statistics in list of response messages.  If none, skip. */</comment>
		<for>for <control>(<init><expr><name>statcell</name> <operator>=</operator> <name><name>pgresult</name><operator>-&gt;</operator><name>pxstats</name></name></expr>;</init> <condition><expr><name>statcell</name></expr>;</condition> <incr><expr><name>statcell</name> <operator>=</operator> <name><name>statcell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>statcell</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PxExplain_StatHdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>statcell</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Validate the message header. */</comment>
		<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>PxExplain_StatHdr</name> <operator>*</operator><operator>)</operator> <name><name>statcell</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

		<comment type="block">/* Slice should have same number of plan nodes on every qExec. */</comment>
		<if_stmt><if>if <condition>(<expr><name>iDispatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* MPP-2140: what causes this ? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name> <operator>!=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid execution statistics "</literal>
									   <literal type="string">"received stats node-count mismatch: pxexplain_recvExecStats() ctx.nStatInst %d hdr-&gt;nInst %d"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please verify that all instances are using "</literal>
										<literal type="string">"the correct %s software version."</literal></expr></argument>,
										<argument><expr><name>PACKAGE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name> <operator>==</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Save lowest and highest segment id for which we have stats. */</comment>
		<if_stmt><if>if <condition>(<expr><name>iDispatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>segindexMin</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>segindexMax</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>segindexMax</name></name> <operator>&lt;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>segindexMax</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>segindexMin</name></name> <operator>&gt;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>segindexMin</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Save message ptr for easy reference. */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><name><name>ctx</name><operator>.</operator><name>nmsgptr</name></name></expr>]</index></name> <operator>=</operator> <name>hdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nmsgptr</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Attach NodeSummary to each PlanState node's Instrumentation node. */</comment>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>pxexplain_recvStatWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we visited the right number of PlanState nodes. */</comment>
	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>iStatInst</name></name> <operator>==</operator> <name><name>ctx</name><operator>.</operator><name>nStatInst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transfer per-slice stats from message headers to the SliceSummary. */</comment>
	<for>for <control>(<init><expr><name>imsgptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>imsgptr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>.</operator><name>nmsgptr</name></name></expr>;</condition> <incr><expr><name>imsgptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pxexplain_depositSliceStats</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><name>imsgptr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Transfer worker counts to SliceSummary. */</comment>
	<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name><operator>.</operator><name>dispatchSummary</name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>

	<comment type="block">/* Signal that we've gathered all the statistics
	 * For some query, which has initplan on top of the plan,
	 * its `ANALYZE EXPLAIN` invoke `pxexplain_recvExecStats`
	 * multi-times in different recursive routine to collect
	 * metrics on both initplan and plan. Thus, this variable
	 * should only assign on slice 0 after gather result done
	 * to promise all slices information have been collected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>stats_gathered</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_recvExecStats */</comment>


<comment type="block">/*
 * pxexplain_recvStatWalker
 *	  Update the given PlanState node's Instrument node with statistics
 *	  received from qExecs.  Attach a PxExplain_NodeSummary block to
 *	  the Instrument node.  At a MotionState node, descend to child slice.
 */</comment>
<function><type><specifier>static</specifier> <name>PxVisitOpt</name></type>
<name>pxexplain_recvStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>PxExplain_RecvStatCtx</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If slice was dispatched to qExecs, and stats came back, grab 'em. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Transfer received stats to Instrumentation, NodeSummary, etc. */</comment>
		<expr_stmt><expr><call><name>pxexplain_depositStatsToNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Advance to next node's entry in all of the StatInst arrays. */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Motion operator?  Descend to next slice. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pxexplain_recvExecStats</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
								 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dispatchResults</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>motionID</name></expr></argument>,
								 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>showstatctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PxVisit_Skip</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>PxVisit_Walk</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* pxexplain_recvStatWalker */</comment>


<comment type="block">/*
 * pxexplain_depositStatsToNode
 *
 * Called by recvStatWalker and localStatWalker to update the given
 * PlanState node's Instrument node with statistics received from
 * workers or collected locally.  Attaches a PxExplain_NodeSummary
 * block to the Instrument node.  If top node of slice, per-slice
 * statistics are transferred from the StatHdr to the SliceSummary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxexplain_depositStatsToNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>PxExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>rsh</name></decl>;</decl_stmt>	<comment type="block">/* The header (which includes StatInst) */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>	<comment type="block">/* The current StatInst */</comment>

	<comment type="block">/*
	 * Points to the insts array of node summary (PxExplain_NodeSummary).
	 * Used for saving every rsi in the node summary (in addition to saving
	 * the max/avg).
	 */</comment>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ns is the node summary across all QEs of the segworker group. It also
	 * contains detailed "unsummarized" raw stat for a node across all QEs in
	 * current segworker group (in the insts array)
	 */</comment>
	<decl_stmt><decl><type><name>PxExplain_NodeSummary</name> <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>ntuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>execmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>workmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>workmemwanted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>totalWorkfileCreated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>peakmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>vmem_reserved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>memory_accounting_global_peak</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>peakMemBalance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name>totalPartTableScanned</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_DepStatAcc</name></type> <name><name>sortSpaceUsed</name><index>[<expr><name>NUM_SORT_SPACE_TYPE</name></expr>]</index><index>[<expr><name>NUM_SORT_METHOD</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>imsgptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nInst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>instr</name> <operator>&amp;&amp;</operator>
		   <name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nStatInst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate NodeSummary block. */</comment>
	<expr_stmt><expr><name>nInst</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>segindexMax</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>segindexMin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ns</name> <operator>=</operator> <operator>(</operator><name>PxExplain_NodeSummary</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ns</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>insts</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
											<name>nInst</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>insts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>segindexMin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name> <operator>=</operator> <name>nInst</name></expr>;</expr_stmt>

	<comment type="block">/* Attach our new NodeSummary to the Instrumentation node. */</comment>
	<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>pxNodeSummary</name></name> <operator>=</operator> <name>ns</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize per-node accumulators. */</comment>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>execmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemwanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalWorkfileCreated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakMemBalance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalPartTableScanned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>NUM_SORT_METHOD</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sortSpaceUsed</name><index>[<expr><name>MEMORY_SORT_SPACE_TYPE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sortSpaceUsed</name><index>[<expr><name>DISK_SORT_SPACE_TYPE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Initialize per-slice accumulators. */</comment>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vmem_reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memory_accounting_global_peak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Examine the statistics from each qExec. */</comment>
	<for>for <control>(<init><expr><name>imsgptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>imsgptr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name></expr>;</condition> <incr><expr><name>imsgptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Locate PlanState node's StatInst received from this qExec. */</comment>
		<expr_stmt><expr><name>rsh</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>msgptrs</name><index>[<expr><name>imsgptr</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>&amp;</operator><name><name>rsh</name><operator>-&gt;</operator><name>inst</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>pstype</name></name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator>
			   <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>&lt;=</operator> <name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&amp;&amp;</operator>
			   <name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&lt;</operator> <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>+</operator> <name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Locate this qExec's StatInst slot in node's NodeSummary block. */</comment>
		<expr_stmt><expr><name>nsi</name> <operator>=</operator> <operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>insts</name><index>[<expr><name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name> <operator>-</operator> <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Copy the StatInst to NodeSummary from dispatch result buffer. */</comment>
		<expr_stmt><expr><operator>*</operator><name>nsi</name> <operator>=</operator> <operator>*</operator><name>rsi</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Drop qExec's extra text.  We rescue it below if qExec is a winner.
		 * For local qDisp slice, ctx-&gt;extratextbuf is NULL, which tells us to
		 * leave the extra text undisturbed in its existing buffer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>=</operator> <name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Update per-node accumulators. */</comment>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntuples</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>execmemused</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>execmemused</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemused</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>workmemused</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemwanted</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalWorkfileCreated</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>rsi</name><operator>-&gt;</operator><name>workfileCreated</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakMemBalance</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>peakMemBalance</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalPartTableScanned</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>numPartScanned</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rsi</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>&lt;</operator> <name>NUM_SORT_METHOD</name> <operator>&amp;&amp;</operator> <name><name>rsi</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>!=</operator> <name>UNINITIALIZED_SORT</name> <operator>&amp;&amp;</operator> <name><name>rsi</name><operator>-&gt;</operator><name>sortSpaceType</name></name> <operator>!=</operator> <name>UNINITIALIZED_SORT_SPACE_TYPE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>sortSpaceType</name></name> <operator>&lt;=</operator> <name>NUM_SORT_SPACE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sortSpaceUsed</name><index>[<expr><name><name>rsi</name><operator>-&gt;</operator><name>sortSpaceType</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name><name>rsi</name><operator>-&gt;</operator><name>sortMethod</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>rsi</name><operator>-&gt;</operator><name>sortSpaceUsed</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update per-slice accumulators. */</comment>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakmemused</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>peakmemused</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vmem_reserved</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>vmem_reserved</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memory_accounting_global_peak</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>memory_accounting_global_peak</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Save per-node accumulated stats in NodeSummary. */</comment>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <name><name>execmemused</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <name><name>workmemused</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator> <name><name>workmemwanted</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>totalWorkfileCreated</name></name> <operator>=</operator> <name><name>totalWorkfileCreated</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>peakMemBalance</name></name> <operator>=</operator> <name><name>peakMemBalance</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name></name> <operator>=</operator> <name><name>totalPartTableScanned</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>NUM_SORT_METHOD</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>sortSpaceUsed</name><index>[<expr><name>MEMORY_SORT_SPACE_TYPE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>sortSpaceUsed</name><index>[<expr><name>MEMORY_SORT_SPACE_TYPE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>agg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>sortSpaceUsed</name><index>[<expr><name>DISK_SORT_SPACE_TYPE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>sortSpaceUsed</name><index>[<expr><name>DISK_SORT_SPACE_TYPE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>agg</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Roll up summary over all nodes of slice into RecvStatCtx. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>, <argument><expr><name><name>workmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>, <argument><expr><name><name>workmemwanted</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>max_total</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ASSIGN</name><argument_list>(<argument><expr><name><name>instr</name><operator>-&gt;</operator><name>firststart</name></name></expr></argument>, <argument><expr><name><name>ntuples</name><operator>.</operator><name>firststart_of_max_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Put winner's stats into qDisp PlanState's Instrument node. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ntuples</name><operator>.</operator><name>agg</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>starttime</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>starttime</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>counter</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>firsttuple</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>firsttuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>startup</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>nloops</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>execmemused</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>workmemused</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workfileCreated</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>workfileCreated</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>firststart</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>firststart</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save extra message text for the most interesting winning qExecs. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>saved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* One worker which used or wanted the most work_mem */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>workmemwanted</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;=</operator> <name><name>workmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemwanted</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>workmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>pxexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workmemused</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemused</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Worker which used the most executor memory (this node's usage) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>execmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>pxexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>execmemused</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>execmemused</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For the worker which had the highest peak executor memory usage
		 * overall across the whole slice, we'll report the extra message text
		 * from all of the nodes in the slice.  But only if that worker stands
		 * out more than 5% above the average.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>peakmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>pxexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>peakmemused</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakmemused</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * One worker which produced the greatest number of output rows.
		 * (Always give at least one node a chance to have its extra message
		 * text seen.  In case no node stood out above the others, make a
		 * repeatable choice based on the number of output rows.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saved</name> <operator>||</operator>
			<name><name>ntuples</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>pxexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ntuples</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntuples</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_depositStatsToNode */</comment>


<comment type="block">/*
 * pxexplain_depositSliceStats
 *	  Transfer a worker's per-slice stats contribution from StatHdr into the
 *	  SliceSummary array in the ShowStatCtx.  Transfer the rollup of per-node
 *	  stats from the RecvStatCtx into the SliceSummary.
 *
 * Kludge: In a non-parallel plan, slice numbers haven't been assigned, so we
 * may be called more than once with sliceIndex == 0: once for the outermost
 * query and once for each InitPlan subquery.  In this case we dynamically
 * expand the SliceSummary array.  POLAR PX TODO: Always assign proper root slice
 * ids (in qDispSliceId field of SubPlan node); then remove this kludge.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxexplain_depositSliceStats</name><parameter_list>(<parameter><decl><type><name>PxExplain_StatHdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>,
							 <parameter><decl><type><name>PxExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>recvstatctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name> <init>= <expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_ShowStatCtx</name> <modifier>*</modifier></type><name>showstatctx</name> <init>= <expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>showstatctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_SliceSummary</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxExplain_SliceWorker</name> <modifier>*</modifier></type><name>ssw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iworker</name></decl>;</decl_stmt>
	<comment type="line">// const char *originalSerializedMemoryAccountingStartAddress = ((const char *) hdr) + hdr-&gt;memAccountStartOffset;</comment>

	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name>sliceIndex</name> <operator>&lt;</operator> <name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Kludge:	QD can have more than one 'Slice 0' if plan is non-parallel. */</comment>
	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>recvstatctx</name><operator>-&gt;</operator><name>dispatchResults</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>ss</name><operator>-&gt;</operator><name>workers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			   <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMin</name></name> <operator>==</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&amp;&amp;</operator>
			   <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMax</name></name> <operator>==</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expand the SliceSummary array to make room for InitPlan subquery. */</comment>
		<expr_stmt><expr><name>sliceIndex</name> <operator>=</operator> <name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <operator>(</operator><name>PxExplain_SliceSummary</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ss</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Slice's first worker? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ss</name><operator>-&gt;</operator><name>workers</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Allocate SliceWorker array and attach it to the SliceSummary. */</comment>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMax</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>ss</name><operator>-&gt;</operator><name>segindex0</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>workers</name></name> <operator>=</operator> <operator>(</operator><name>PxExplain_SliceWorker</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>workers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>memoryAccounts</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>memoryAccounts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save a copy of this SliceWorker instance in the worker array. */</comment>
	<expr_stmt><expr><name>iworker</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name> <operator>-</operator> <name><name>ss</name><operator>-&gt;</operator><name>segindex0</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ssw</name> <operator>=</operator> <operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>workers</name><index>[<expr><name>iworker</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>iworker</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iworker</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name><name>ssw</name><operator>-&gt;</operator><name>peakmemused</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* each worker should be seen just once */</comment>
	<expr_stmt><expr><operator>*</operator><name>ssw</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>worker</name></name></expr>;</expr_stmt>

	<comment type="block">/* Rollup of per-worker stats into SliceSummary */</comment>
	<expr_stmt><expr><call><name>pxexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>peakmemused</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>vmem_reserved</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>memory_accounting_global_peak</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>memory_accounting_global_peak</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Rollup of per-node stats over all nodes of the slice into SliceSummary */</comment>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr>;</expr_stmt>

	<comment type="block">/* Rollup of per-node stats over the whole query into ShowStatCtx. */</comment>
	<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>, <argument><expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>, <argument><expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_depositSliceStats */</comment>

<comment type="block">/*
 * pxexplain_collectStatsFromNode
 *
 * Called by sendStatWalker and localStatWalker to obtain a node's statistics
 * and transfer them into the temporary StatHdr and StatInst in the SendStatCtx.
 * Also obtains the node's extra message text, which it appends to the caller's
 * cxt-&gt;nodebuf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxexplain_collectStatsFromNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>PxExplain_SendStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_StatInst</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have to finalize statistics, since ExecutorEnd hasn't been called. */</comment>
	<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the StatInst slot in the temporary StatHdr. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>si</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>pstype</name></name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add this node's extra message text to notebuf.  Store final stats. */</comment>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>=</operator> <call><name>pxexplain_collectExtraText</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>notebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>enotes</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>notebuf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* Make sure there is a '\0' between this node's message and the next. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>&lt;</operator> <name><name>si</name><operator>-&gt;</operator><name>enotes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>notebuf</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transfer this node's statistics from Instrumentation into StatInst. */</comment>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>starttime</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>starttime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>counter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>firsttuple</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>firsttuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>startup</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>nloops</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>execmemused</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>workmemused</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>workfileCreated</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>workfileCreated</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>firststart</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>firststart</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>numPartScanned</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>numPartScanned</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>sortSpaceUsed</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>sortSpaceUsed</name></name></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* pxexplain_collectStatsFromNode */</comment>

<comment type="block">/*
 * pxexplain_collectExtraText
 *	  Allow a node to supply additional text for its EXPLAIN ANALYZE report.
 *
 * Returns the starting offset of the extra message text from notebuf-&gt;data.
 * The caller can compute the length as notebuf-&gt;len minus the starting offset.
 * If the node did not provide any extra message text, the length will be 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pxexplain_collectExtraText</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>notebuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bnotes</name> <init>= <expr><name><name>notebuf</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Invoke node's callback.  It may append to our notebuf and/or its own
	 * pxexplainbuf; and store final statistics in its Instrumentation node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>pxexplainfun</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>planstate</name><operator>-&gt;</operator><name>pxexplainfun</name></name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>notebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Append contents of node's extra message buffer.  This allows nodes to
	 * contribute EXPLAIN ANALYZE info without having to set up a callback.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>pxexplainbuf</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>pxexplainbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If callback added to notebuf, make sure text ends with a newline. */</comment>
		<if_stmt><if>if <condition>(<expr><name>bnotes</name> <operator>&lt;</operator> <name><name>notebuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator>
			<name><name>notebuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>notebuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>notebuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>notebuf</name></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>pxexplainbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>pxexplainbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>pxexplainbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>bnotes</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* pxexplain_collectExtraText */</comment>

<comment type="block">/*
 * pxexplain_showExecStatsBegin
 *	  Called by qDisp process to create a PxExplain_ShowStatCtx structure
 *	  in which to accumulate overall statistics for a query.
 *
 * 'querystarttime' is the timestamp of the start of the query, in a
 *		platform-dependent format.
 *
 * Note this function is called before ExecutorStart(), so there is no EState
 * or SliceTable yet.
 */</comment>
<function><type><name><name>struct</name> <name>PxExplain_ShowStatCtx</name></name> <modifier>*</modifier></type>
<name>pxexplain_showExecStatsBegin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
							  <parameter><decl><type><name>instr_time</name></type> <name>querystarttime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxExplain_ShowStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nslice</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>!=</operator> <name>PX_ROLE_PX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate and zero the ShowStatCtx */</comment>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>PxExplain_ShowStatCtx</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>querystarttime</name></name> <operator>=</operator> <name>querystarttime</name></expr>;</expr_stmt>

	<comment type="block">/* Determine number of slices.  (SliceTable hasn't been built yet.) */</comment>
	<expr_stmt><expr><name>nslice</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</expr_stmt>

	<comment type="block">/* Allocate and zero the SliceSummary array. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nslice</name></name> <operator>=</operator> <name>nslice</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <operator>(</operator><name>PxExplain_SliceSummary</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nslice</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate a buffer in which we can collect any extra message text. */</comment>
	<expr_stmt><expr><call><name>initStringInfoOfSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><literal type="number">4000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* pxexplain_showExecStatsBegin */</comment></unit>
