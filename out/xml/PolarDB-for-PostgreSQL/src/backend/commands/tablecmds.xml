<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/commands/tablecmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tablecmds.c
 *	  Commands for creating and altering table structures and settings
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/tablecmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * ON COMMIT action list
 */</comment>
<typedef>typedef <type><struct>struct <name>OnCommitItem</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>			<comment type="block">/* relid of relation */</comment>
	<decl_stmt><decl><type><name>OnCommitAction</name></type> <name>oncommit</name></decl>;</decl_stmt>	<comment type="block">/* what to do at end of xact */</comment>

	<comment type="block">/*
	 * If this entry was created during the current transaction,
	 * creating_subid is the ID of the creating subxact; if created in a prior
	 * transaction, creating_subid is zero.  If deleted during the current
	 * transaction, deleting_subid is the ID of the deleting subxact; if no
	 * deletion request is pending, deleting_subid is zero.
	 */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>creating_subid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>deleting_subid</name></decl>;</decl_stmt>
}</block></struct></type> <name>OnCommitItem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>on_commits</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * State information for ALTER TABLE
 *
 * The pending-work queue for an ALTER TABLE is a List of AlteredTableInfo
 * structs, one for each table modified by the operation (the named table
 * plus any child tables that are affected).  We save lists of subcommands
 * to apply to this table (possibly modified by parse transformation steps);
 * these lists will be executed in Phase 2.  If a Phase 3 step is needed,
 * necessary information is stored in the constraints and newvals lists.
 *
 * Phase 2 is divided into multiple passes; subcommands are executed in
 * a pass determined by subcommand type.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_UNSET</name></cpp:macro>			<cpp:value>-1</cpp:value></cpp:define>	<comment type="block">/* UNSET will cause ERROR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_DROP</name></cpp:macro>			<cpp:value>0</cpp:value></cpp:define>	<comment type="block">/* DROP (all flavors) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ALTER_TYPE</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* ALTER COLUMN TYPE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_OLD_INDEX</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* re-add existing indexes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_OLD_CONSTR</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>	<comment type="block">/* re-add existing constraints */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_COL_ATTRS</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* set other column attributes */</comment>
<comment type="block">/* We could support a RENAME COLUMN pass here, but not currently used */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ADD_COL</name></cpp:macro>			<cpp:value>5</cpp:value></cpp:define>	<comment type="block">/* ADD COLUMN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ADD_INDEX</name></cpp:macro>		<cpp:value>6</cpp:value></cpp:define>	<comment type="block">/* ADD indexes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_ADD_CONSTR</name></cpp:macro>		<cpp:value>7</cpp:value></cpp:define>	<comment type="block">/* ADD constraints, defaults */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_PASS_MISC</name></cpp:macro>			<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* other stuff */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_NUM_PASSES</name></cpp:macro>			<cpp:value>9</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>AlteredTableInfo</name>
<block>{
	<comment type="block">/* Information saved before any work commences: */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>			<comment type="block">/* Relation to work on */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>		<comment type="block">/* Its relkind */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>oldDesc</name></decl>;</decl_stmt>		<comment type="block">/* Pre-modification tuple descriptor */</comment>
	<comment type="block">/* Information saved by Phase 1 for Phase 2: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name><name>subcmds</name><index>[<expr><name>AT_NUM_PASSES</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Lists of AlterTableCmd */</comment>
	<comment type="block">/* Information saved by Phases 1/2 for Phase 3: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraints</name></decl>;</decl_stmt>	<comment type="block">/* List of NewConstraint */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newvals</name></decl>;</decl_stmt>		<comment type="block">/* List of NewColumnValue */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_notnull</name></decl>;</decl_stmt>	<comment type="block">/* T if we added new NOT NULL constraints */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rewrite</name></decl>;</decl_stmt>		<comment type="block">/* Reason for forced rewrite, if any */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newTableSpace</name></decl>;</decl_stmt>	<comment type="block">/* new tablespace; 0 means no change */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>chgPersistence</name></decl>;</decl_stmt> <comment type="block">/* T if SET LOGGED/UNLOGGED is used */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>newrelpersistence</name></decl>;</decl_stmt>	<comment type="block">/* if above is true */</comment>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partition_constraint</name></decl>;</decl_stmt>	<comment type="block">/* for attach partition validation */</comment>
	<comment type="block">/* true, if validating default due to some other attach/detach */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>validate_default</name></decl>;</decl_stmt>
	<comment type="block">/* Objects to rebuild after completing ALTER TYPE operations */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>changedConstraintOids</name></decl>;</decl_stmt>	<comment type="block">/* OIDs of constraints to rebuild */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>changedConstraintDefs</name></decl>;</decl_stmt>	<comment type="block">/* string definitions of same */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>changedIndexOids</name></decl>;</decl_stmt>	<comment type="block">/* OIDs of indexes to rebuild */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>changedIndexDefs</name></decl>;</decl_stmt>	<comment type="block">/* string definitions of same */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>replicaIdentityIndex</name></decl>;</decl_stmt>	<comment type="block">/* index to reset as REPLICA IDENTITY */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>clusterOnIndex</name></decl>;</decl_stmt>	<comment type="block">/* index to use for CLUSTER */</comment>
}</block></struct></type> <name>AlteredTableInfo</name>;</typedef>

<comment type="block">/* Struct describing one new constraint to check in Phase 3 scan */</comment>
<comment type="block">/* Note: new NOT NULL constraints are handled elsewhere */</comment>
<typedef>typedef <type><struct>struct <name>NewConstraint</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>			<comment type="block">/* Constraint name, or NULL if none */</comment>
	<decl_stmt><decl><type><name>ConstrType</name></type>	<name>contype</name></decl>;</decl_stmt>		<comment type="block">/* CHECK or FOREIGN */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>refrelid</name></decl>;</decl_stmt>		<comment type="block">/* PK rel, if FOREIGN */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>refindid</name></decl>;</decl_stmt>		<comment type="block">/* OID of PK's index, if FOREIGN */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>conid</name></decl>;</decl_stmt>			<comment type="block">/* OID of pg_constraint entry, if FOREIGN */</comment>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>			<comment type="block">/* Check expr or CONSTR_FOREIGN Constraint */</comment>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>qualstate</name></decl>;</decl_stmt>		<comment type="block">/* Execution state for CHECK expr */</comment>
}</block></struct></type> <name>NewConstraint</name>;</typedef>

<comment type="block">/*
 * Struct describing one new column value that needs to be computed during
 * Phase 3 copy (this could be either a new column with a non-null default, or
 * a column that we're changing the type of).  Columns without such an entry
 * are just copied from the old table during ATRewriteTable.  Note that the
 * expr is an expression over *old* table values.
 */</comment>
<typedef>typedef <type><struct>struct <name>NewColumnValue</name>
<block>{
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>			<comment type="block">/* which column */</comment>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>			<comment type="block">/* expression to compute */</comment>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>		<comment type="block">/* execution state */</comment>
}</block></struct></type> <name>NewColumnValue</name>;</typedef>

<comment type="block">/*
 * Error-reporting support for RemoveRelations
 */</comment>
<struct>struct <name>dropmsgstrings</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name>kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonexistent_code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nonexistent_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>skipping_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nota_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>drophint_msg</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name></type> <name><name>dropmsgstringarray</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>RELKIND_RELATION</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TABLE to remove a table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_SEQUENCE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP SEQUENCE to remove a sequence."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_VIEW</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP VIEW to remove a view."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_MATVIEW</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP MATERIALIZED VIEW to remove a materialized view."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_INDEX</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP INDEX to remove an index."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_COMPOSITE_TYPE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a type"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TYPE to remove a type."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_FOREIGN_TABLE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP FOREIGN TABLE to remove a foreign table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_PARTITIONED_TABLE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TABLE to remove a table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_PARTITIONED_INDEX</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP INDEX to remove an index."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><literal type="char">'\0'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>DropRelationCallbackState</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partParentOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>concurrent</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Alter table target-type flags for ATSimplePermissions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_TABLE</name></cpp:macro>				<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_VIEW</name></cpp:macro>				<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_MATVIEW</name></cpp:macro>				<cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_INDEX</name></cpp:macro>				<cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_COMPOSITE_TYPE</name></cpp:macro>		<cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_FOREIGN_TABLE</name></cpp:macro>		<cpp:value>0x0020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_PARTITIONED_INDEX</name></cpp:macro>	<cpp:value>0x0040</cpp:value></cpp:define>

<comment type="block">/*
 * Partition tables are expected to be dropped when the parent partitioned
 * table gets dropped. Hence for partitioning we use AUTO dependency.
 * Otherwise, for regular inheritance use NORMAL dependency.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>child_dependency_type</name><parameter_list>(<parameter><type><name>child_is_partition</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((child_is_partition) ? DEPENDENCY_AUTO : DEPENDENCY_NORMAL)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>truncate_check_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>MergeAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_partition</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supOids</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supconstr</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>supOidCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MergeCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeAttributesIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeConstraintsIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreCatalogInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreCatalogInheritance1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>,
						 <parameter><decl><type><name>int32</name></type> <name>seqNumber</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>inhRelation</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>findAttrByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterIndexNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterSeqNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecValidateConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
						 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>transformColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colList</name></decl></parameter>,
						<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>transformFkeyGetPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexOid</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
						   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>transformFkeyCheckAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkFkeyPermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CoercionPathType</name></type> <name>findFkeyCast</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>pkindOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATController</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
			 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteCatalogs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
		  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteTable</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type><name>ATGetQueueEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATSimplePermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATWrongRelkindError</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATSimpleRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATCheckPartitionsNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATTypedTableRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>find_typed_table_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
							  <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_view</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
				<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>colDef</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isOid</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_for_column_name_collision</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_column_datatype_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_column_collation_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddOids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
			  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecColumnDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newDefault</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReset</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIndex</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rebuild</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
					<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIndexConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATAddCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
					 <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
					 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATAddForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
						  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneFkReferencing</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_constraint</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>partRel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clone</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>cloned</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
					 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAlterColumnType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
					  <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ATColumnChangeRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterColumnType</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RememberConstraintForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RememberIndexForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterColumnGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPostAlterTypeCleanup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
					   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPostAlterTypeParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelId</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>rewrite</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RebuildConstraintComment</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>domname</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryReuseIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryReuseForeignKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>change_owner_fix_column_acls</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>oldOwnerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>change_owner_recurse_to_sequences</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecClusterOn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>,
				<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ATPrepChangePersistence</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toLogged</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetTableSpace</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecPartedIdxSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>,
					<parameter><decl><type><name>AlterTableType</name></type> <name>operation</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>,
						   <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
						<parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_parent_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
					   <parameter><decl><type><name>DependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDisableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecForceNoForceRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_rls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_relation_data</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>dst</name></decl></parameter>,
				   <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>storage_name</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForDropRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForAlterRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>transformPartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>partspec</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ComputePartitionAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partParams</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAttachPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AttachPartitionEnsureIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>attachrel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>QueuePartitionConstraintValidation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>validate_default</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneRowTriggersToPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropClonedTriggersFromPartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDetachPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAttachPartitionIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validatePartitionedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partedIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partedTbl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refuseDupeIndexAttach</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partIdx</name></decl></parameter>,
					  <parameter><decl><type><name>Relation</name></type> <name>partitionTbl</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR */</comment>
<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recursive_relopts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* List of reloptions to be set
								 * recursively for partitioned tables. 
								 * Resides in TopMemoryContext. */</comment>

<function_decl><type><name>void</name></type> <name>polar_px_btbuild_update_pg_class</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* ----------------------------------------------------------------
 *		DefineRelation
 *				Creates a new relation.
 *
 * stmt carries parsetree information from an ordinary CREATE TABLE statement.
 * The other arguments are used to extend the behavior for other cases:
 * relkind: relkind to assign to the new relation
 * ownerId: if not InvalidOid, use this as the new relation's owner.
 * typaddress: if not null, it's set to the pg_type entry's address.
 * queryString: for error reporting
 *
 * Note that permissions checks are done against current user regardless of
 * ownerId.  A nonzero ownerId is used when someone is creating a relation
 * "on behalf of" someone else, so we still want to see that the current user
 * has permissions to do it.
 *
 * If successful, returns the address of the new relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineRelation</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>,
			   <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>typaddress</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>relname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tablespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>descriptor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inheritOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>old_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>localHasOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parentOidCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rawDefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cookedDefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>listptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ofTypeId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Truncate relname to appropriate length (probably a waste of time, as
	 * parser should have done this already).
	 */</comment>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: change unlogged table to logged table, because unlogged table not support
	 * Master-Slave mode, it does not write xlog, we must do it before create table.
	 * we do it in DefineRelation() because not only create unlogged table but also
	 * select into XXX unlogged table, but they all call DefineRelation() function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_force_unlogged_to_logged_table</name> <operator>&amp;&amp;</operator>
			<name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"change unlogged table to logged table,"</literal>
				<literal type="string">"because unlogged table not supports Master-Slave mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Check consistency of arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>!=</operator> <name>ONCOMMIT_NOOP</name>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON COMMIT can only be used on temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up the namespace in which we are supposed to create the relation,
	 * check we have permission to create there, lock it against concurrent
	 * drop, and mark stmt-&gt;relation as RELPERSISTENCE_TEMP if a temporary
	 * namespace is selected.
	 */</comment>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator>
		<call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Security check: disallow creating temp tables from security-restricted
	 * code.  This is needed because calling code might not expect untrusted
	 * tables to appear in pg_temp at the front of its search path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name>
		<operator>&amp;&amp;</operator> <call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary table within security-restricted operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Select tablespace to use.  If not specified, use default tablespace
	 * (which may in turn default to database's default).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>GetDefaultTablespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* note InvalidOid is OK in this case */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Check permissions except when using database's default */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>,
						   <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* In all cases disallow placing user relations in pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>tablespaceId</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify user ID that will own the table */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Parse and validate reloptions, if any.
	 */</comment>
	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>view_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>ofTypeId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ofTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Look up inheritance ancestors and generate relation schema, including
	 * inherited attributes.  (Note that stmt-&gt;tableElts is destructively
	 * modified by MergeAttributes.)
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator>
		<call><name>MergeAttributes</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>inheritOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_constraints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentOidCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a tuple descriptor from the relation schema.  Note that this
	 * deals with column names, types, and NOT NULL constraints, but not
	 * default values or CHECK constraints; we handle those below.
	 */</comment>
	<expr_stmt><expr><name>descriptor</name> <operator>=</operator> <call><name>BuildDescForRelation</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Notice that we allow OIDs here only for plain tables and partitioned
	 * tables, even though some other relkinds can support them.  This is
	 * necessary because the default_with_oids GUC must apply only to plain
	 * tables and not any other relkind; doing otherwise would break existing
	 * pg_dump files.  We could allow explicit "WITH OIDS" while not allowing
	 * default_with_oids to affect other relkinds, but it would complicate
	 * interpretOidsOption().
	 */</comment>
	<expr_stmt><expr><name>localHasOids</name> <operator>=</operator> <call><name>interpretOidsOption</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
										<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>descriptor</name><operator>-&gt;</operator><name>tdhasoid</name></name> <operator>=</operator> <operator>(</operator><name>localHasOids</name> <operator>||</operator> <name>parentOidCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a partitioned table doesn't have the system OID column, then none of
	 * its partitions should have it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>&amp;&amp;</operator> <name>parentOidCount</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>localHasOids</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create table with OIDs as partition of table without OIDs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find columns with default values and prepare for insertion of the
	 * defaults.  Pre-cooked (that is, inherited) defaults go into a list of
	 * CookedConstraint structs that we'll pass to heap_create_with_catalog,
	 * while raw defaults go into a list of RawColumnDefault structs that will
	 * be processed by AddRelationNewConstraints.  (We can't deal with raw
	 * expressions until we can do transformExpr.)
	 *
	 * We can set the atthasdef flags now in the tuple descriptor; this just
	 * saves StoreAttrDefault from having to do an immediate update of the
	 * pg_attribute rows.
	 */</comment>
	<expr_stmt><expr><name>rawDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cookedDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>colDef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rawDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rawDefaults</name></expr></argument>, <argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* until created */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* not used for defaults */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* ditto */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cookedDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cookedDefaults</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create the relation.  Inherited defaults and constraints are passed in
	 * for immediate handling --- since they don't need parsing, they can be
	 * stored immediately.
	 */</comment>
	<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>heap_create_with_catalog</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
										  <argument><expr><name>namespaceId</name></expr></argument>,
										  <argument><expr><name>tablespaceId</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>ofTypeId</name></expr></argument>,
										  <argument><expr><name>ownerId</name></expr></argument>,
										  <argument><expr><name>descriptor</name></expr></argument>,
										  <argument><expr><call><name>list_concat</name><argument_list>(<argument><expr><name>cookedDefaults</name></expr></argument>,
													  <argument><expr><name>old_constraints</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>relkind</name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>localHasOids</name></expr></argument>,
										  <argument><expr><name>parentOidCount</name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name></expr></argument>,
										  <argument><expr><name>reloptions</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>allowSystemTableMods</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>typaddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must bump the command counter to make the newly-created relation
	 * tuple visible for opening.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the new relation and acquire exclusive lock on it.  This isn't
	 * really necessary for locking out other backends (since they can't see
	 * the new rel anyway until we commit), but it keeps the lock manager from
	 * complaining about deadlock risks.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process and store partition bound, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></init></decl>,
					<decl><type ref="prev"/><name>defaultPartOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>,
					<decl><type ref="prev"/><name>defaultRel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Already have strong enough lock on the parent */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are going to try to validate the partition bound specification
		 * against the partition key of parentRel, so it better have one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The partition constraint of the default partition depends on the
		 * partition bounds of every other partition. It is possible that
		 * another backend might be about to execute a query on the default
		 * partition table, and that the query relies on previously cached
		 * default partition constraints. We must therefore take a table lock
		 * strong enough to prevent all queries on the default partition from
		 * proceeding until we commit and send out a shared-cache-inval notice
		 * that will make them update their index lists.
		 *
		 * Order of locking: The relation being added won't be visible to
		 * other backends until it is committed, hence here in
		 * DefineRelation() the order of locking the default partition and the
		 * relation being added does not matter. But at all other places we
		 * need to lock the default relation before we lock the relation being
		 * added or removed i.e. we should take the lock in same order at all
		 * the places such that lock parent, lock default partition and then
		 * lock the partition so as to avoid a deadlock.
		 */</comment>
		<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
			<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defaultRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Tranform the bound values */</comment>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>bound</name> <operator>=</operator> <call><name>transformPartitionBound</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check first that the new partition's bound is valid and does not
		 * overlap with any of existing partitions of the parent.
		 */</comment>
		<expr_stmt><expr><call><name>check_new_partition_bound</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the default partition exists, its partition constraints will
		 * change after the addition of this new partition such that it won't
		 * allow any row that qualifies for this new partition. So, check that
		 * the existing data in the default partition satisfies the constraint
		 * as it will exist after adding this partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_default_partition_contents</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>defaultRel</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Keep the lock until commit. */</comment>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>defaultRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update the pg_class entry. */</comment>
		<expr_stmt><expr><call><name>StorePartitionBound</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store inheritance information for new rel. */</comment>
	<expr_stmt><expr><call><name>StoreCatalogInheritance</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process the partitioning specification (if any) and store the partition
	 * key information into the catalog.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>strategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>partattrs</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>partopclass</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>partcollation</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Protect fixed-size arrays here and in executor */</comment>
		<if_stmt><if>if <condition>(<expr><name>partnatts</name> <operator>&gt;</operator> <name>PARTITION_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot partition using more than %d columns"</literal></expr></argument>,
							<argument><expr><name>PARTITION_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We need to transform the raw parsetrees corresponding to partition
		 * expressions into executable expression trees.  Like column defaults
		 * and CHECK constraints, we could not have done the transformation
		 * earlier.
		 */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>=</operator> <call><name>transformPartitionSpec</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ComputePartitionAttrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>,
							  <argument><expr><name>partattrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partexprs</name></expr></argument>, <argument><expr><name>partopclass</name></expr></argument>,
							  <argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StorePartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partattrs</name></expr></argument>, <argument><expr><name>partexprs</name></expr></argument>,
						  <argument><expr><name>partopclass</name></expr></argument>, <argument><expr><name>partcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make it all visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're creating a partition, create now all the indexes, triggers,
	 * FKs defined in the parent.
	 *
	 * We can't do it earlier, because DefineIndex wants to know the partition
	 * key which we just stored.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<comment type="block">/* Already have strong enough lock on the parent */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idxlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For each index in the parent table, create one in the partition
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign partition of partitioned table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains indexes that are unique."</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>idxstmt</name> <operator>=</operator>
				<call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idxRel</name></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>idxstmt</name></expr></argument>,
						<argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>constraintOid</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>idxlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are any row-level triggers, clone them to the new
		 * partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloneRowTriggersToPartition</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * And foreign keys too.  Note that because we're freshly creating the
		 * table, there is no need to verify these new constraints.
		 */</comment>
		<expr_stmt><expr><call><name>CloneForeignKeyConstraints</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now add any newly specified column default values and CHECK constraints
	 * to the new relation.  These are passed to us in the form of raw
	 * parsetrees; we need to transform them to executable expression trees
	 * before they can be added. The most convenient way to do that is to
	 * apply the parser's transformExpr routine, but transformExpr doesn't
	 * work unless we have a pre-existing relation. So, the transformation has
	 * to be postponed to this final step of CREATE TABLE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rawDefaults</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rawDefaults</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up.  We keep lock on new relation (although it shouldn't be
	 * visible to anyone else anyway, until commit).
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the right error or warning message for a "DROP" command issued on a
 * non-existent relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropErrorMsgNonExistent</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>rightkind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>rentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rentry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>rightkind</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nonexistent_code</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nonexistent_msg</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>skipping_msg</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Should be impossible */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the right error message for a "DROP" command issued on a
 * relation of the wrong type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropErrorMsgWrongType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>wrongkind</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>rightkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>wentry</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>rentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rentry</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>rightkind</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>wentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>wentry</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>wrongkind</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<comment type="block">/* wrongkind could be something we don't have in our table... */</comment>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nota_msg</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>wentry</name><operator>-&gt;</operator><name>drophint_msg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveRelations
 *		Implements DROP TABLE, DROP INDEX, DROP SEQUENCE, DROP VIEW,
 *		DROP MATERIALIZED VIEW, DROP FOREIGN TABLE
 */</comment>
<function><type><name>void</name></type>
<name>RemoveRelations</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>drop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* DROP CONCURRENTLY uses a weaker lock, and has some restrictions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Note that for temporary relations this lock may get upgraded
		 * later on, but as no other session can access a temporary
		 * relation, this is actually fine.
		 */</comment>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support dropping multiple objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support CASCADE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First we identify all the relations, then we delete them in a single
	 * performMultipleDeletions() call.  This is to avoid unwanted DROP
	 * RESTRICT errors if one of the relations depends on another.
	 */</comment>

	<comment type="block">/* Determine required relkind */</comment>
	<switch>switch <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_MATVIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized drop object type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Lock and validate each relation; build a list of object addresses */</comment>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>drop-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * These next few steps are a great deal like relation_openrv, but we
		 * don't bother building a relcache entry since we don't need it.
		 *
		 * Check for shared-cache-inval messages before trying to access the
		 * relation.  This is needed to cover the case where the name
		 * identifies a rel that has been dropped and recreated since the
		 * start of our transaction: if we don't flush the old syscache entry,
		 * then we'll latch onto that entry and suffer an error later.
		 */</comment>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Look up the appropriate relation using namespace search. */</comment>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>concurrent</name></name> <operator>=</operator> <name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>RVR_MISSING_OK</name></expr></argument>,
										  <argument><expr><name>RangeVarCallbackForDropRelation</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Not there? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DropErrorMsgNonExistent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Decide if concurrent mode needs to be used here or not.  The
		 * relation persistence cannot be known without its OID.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>&amp;&amp;</operator>
			<call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				   <name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK, we're ready to delete this one */</comment>
		<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Before acquiring a table lock, check whether we have sufficient rights.
 * In the case of DROP INDEX, also try to lock the table before the index.
 * Also, if the table to be dropped is a partition, we try to lock the parent
 * first.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForDropRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>expected_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>heap_lockmode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>DropRelationCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>heap_lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then>
		<expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we previously locked some other index's heap, and the name we're
	 * looking up no longer refers to that relation, release the now-useless
	 * lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, if we previously locked some other partition's heap, and the
	 * name we're looking up no longer refers to that relation, release the
	 * now-useless lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped, so nothing to do */</comment>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_partition</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Both RELKIND_RELATION and RELKIND_PARTITIONED_TABLE are OBJECT_TABLE,
	 * but RemoveRelations() can only pass one relkind for a given relation.
	 * It chooses RELKIND_RELATION for both regular and partitioned tables.
	 * That means we must be careful before giving the wrong type error when
	 * the relation is RELKIND_PARTITIONED_TABLE.  An equivalent problem
	 * exists with indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>expected_relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DropErrorMsgWrongType</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allow DROP to either table owner or schema owner */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>pg_namespace_ownercheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In DROP INDEX, attempt to acquire lock on the parent table before
	 * locking the index.  index_drop() will need this anyway, and since
	 * regular queries lock tables before their indexes, we risk deadlock if
	 * we do it the other way around.  No error if we don't find a pg_index
	 * entry, though --- the relation may have been dropped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, if the relation is a partition, we must acquire lock on its
	 * parent before locking the partition.  That's because queries lock the
	 * parent before its partitions, so we risk deadlock it we do it the other
	 * way around.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator> <name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteTruncate
 *		Executes a TRUNCATE command.
 *
 * This is a multi-relation truncate.  We first open and grab exclusive
 * lock on all relations involved, checking permissions and otherwise
 * verifying that the relation is OK for truncation.  In CASCADE mode,
 * relations having FK references to the targeted relations are automatically
 * added to the group; in RESTRICT mode, we check that all FK references are
 * internal to the group that's being truncated.  Finally all the relations
 * are truncated and reindexed.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteTruncate</name><parameter_list>(<parameter><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids_logged</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open, exclusive-lock, and check all the explicitly-specified relations
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>recurse</name> <init>= <expr><name><name>rv</name><operator>-&gt;</operator><name>inh</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>myrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>myrelid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't throw error for "TRUNCATE foo, foo" */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Log this relation only if needed for logical decoding */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* find_all_inheritors already got lock */</comment>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * It is possible that the parent table has children that are
				 * temp tables of other backends.  We cannot safely access
				 * such tables (because of buffering issues), and the best
				 * thing to do is to silently ignore them.  Note that this
				 * check is the same as one of the checks done in
				 * truncate_check_rel() called below, still it is kept
				 * here for simplicity.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Log this relation only if needed for logical decoding */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate only a partitioned table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword, or use TRUNCATE ONLY on the partitions directly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecuteTruncateGuts</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relids_logged</name></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And close the rels */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteTruncateGuts
 *
 * Internal implementation of TRUNCATE.  This is called by the actual TRUNCATE
 * command (see above) as well as replication subscribers that execute a
 * replicated TRUNCATE action.
 *
 * explicit_rels is the list of Relations to truncate that the command
 * specified.  relids is the list of Oids corresponding to explicit_rels.
 * relids_logged is the list of Oids (a subset of relids) that require
 * WAL-logging.  This is all a bit redundant, but the existing callers have
 * this information handy in this form.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteTruncateGuts</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>explicit_rels</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids_logged</name></decl></parameter>,
					<parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restart_seqs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seq_relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>logrelids</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check the explicitly-specified relations.
	 *
	 * In CASCADE mode, suck in all referencing relations as well.  This
	 * requires multiple iterations to find indirectly-dependent relations. At
	 * each phase, we need to exclusive-lock new rels before looking for their
	 * dependencies, else we might miss something.  Also, we check each rel as
	 * soon as we open it, to avoid a faux pas such as holding lock for a long
	 * time on a rel we have no permissions for.
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>explicit_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newrelids</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newrelids</name> <operator>=</operator> <call><name>heap_truncate_find_FKs</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newrelids</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* nothing else to add */</comment>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>newrelids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"truncate cascades to table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Log this relation only if needed for logical decoding */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check foreign key references.  In CASCADE mode, this should be
	 * unnecessary since we just pulled in all the references; but as a
	 * cross-check, do it anyway if in an Assert-enabled build.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>heap_truncate_check_FKs</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_RESTRICT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_truncate_check_FKs</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we are asked to restart sequences, find all the sequences, lock them
	 * (we need AccessExclusiveLock for ResetSequence), and check permissions.
	 * We want to do this early since it's pointless to do all the truncation
	 * work only to fail on sequence permissions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>restart_seqs</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seqlist</name> <init>= <expr><call><name>getOwnedSequences</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>seqcell</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>seqcell</argument>, <argument>seqlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>seqcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>seq_rel</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>seq_rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* This check must match AlterSequence! */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>seq_relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>seq_relids</name></expr></argument>, <argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare to catch AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To fire triggers, we'll need an EState as well as a ResultRelInfo for
	 * each relation.  We don't need to call ExecOpenIndices, though.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
						  <argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* dummy rangetable index */</comment>
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process all BEFORE STATEMENT TRUNCATE triggers before we begin
	 * truncating (this is because one of them might throw an error). Also, if
	 * we were to allow them to prevent statement execution, that would need
	 * to be handled here.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecBSTruncateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * OK, truncate each table.
	 */</comment>
	<expr_stmt><expr><name>mySubid</name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip partitioned tables as there is nothing to do */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Normally, we need a transaction-safe truncation here.  However, if
		 * the table was either created in the current (sub)transaction or has
		 * a new relfilenode in the current (sub)transaction, then we can just
		 * truncate it in-place, because a rollback would cause the whole
		 * table or the current physical file to be thrown away anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>==</operator> <name>mySubid</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Immediate, non-rollbackable truncation is OK */</comment>
			<expr_stmt><expr><call><name>heap_truncate_one_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>heap_relid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>toast_relid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiXactId</name></type> <name>minmulti</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * This effectively deletes all rows in the table, and may be done
			 * in a serializable transaction.  In that case we must record a
			 * rw-conflict in to this transaction from each transaction
			 * holding a predicate lock on the table.
			 */</comment>
			<expr_stmt><expr><call><name>CheckTableForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>minmulti</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Need the full transaction-safe pushups.
			 *
			 * Create a new empty storage file for the relation, and assign it
			 * as the relfilenode value. The old storage file is scheduled for
			 * deletion at commit.
			 */</comment>
			<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
									<argument><expr><name>RecentXmin</name></expr></argument>, <argument><expr><name>minmulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_create_init_fork</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>heap_relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The same for the toast table, if any.
			 */</comment>
			<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>,
													 <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
										<argument><expr><name><name>toastrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
										<argument><expr><name>RecentXmin</name></expr></argument>, <argument><expr><name>minmulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>toastrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>heap_create_init_fork</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Reconstruct the indexes to match, and we're done.
			 */</comment>
			<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>heap_relid</name></expr></argument>, <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>pgstat_count_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Restart owned sequences if we were asked to.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>seq_relids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ResetSequence</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Write a WAL record to allow this set of actions to be logically
	 * decoded.
	 *
	 * Assemble an array of relids so we can write a single WAL record for the
	 * whole action.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_truncate</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* should only get here if wal_level &gt;= logical */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>logrelids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relids_logged</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>logrelids</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nrelids</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_TRUNCATE_CASCADE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>restart_seqs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_TRUNCATE_RESTART_SEQS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>logrelids</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process all AFTER STATEMENT TRUNCATE triggers.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecASTruncateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Handle queued AFTER triggers */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can clean up the EState now */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close any rels opened by CASCADE (can't do this while EState still
	 * holds refs)
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>list_difference_ptr</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>explicit_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a given rel is safe to truncate.  Subroutine for ExecuteTruncate
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>truncate_check_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only allow truncate on regular tables and partitioned tables (although,
	 * the latter are only being included here for the following checks; no
	 * physical truncation will occur in their case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
								  <argument><expr><name>ACL_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow truncate on temp tables of other backends ... their local
	 * buffer manager is not going to cope.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also check for active uses of the relation in the current transaction,
	 * including open scans and pending AFTER trigger events.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * storage_name
 *	  returns the name corresponding to a typstorage/attstorage enum value
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>storage_name</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'p'</literal></expr>:</case>
			<return>return <expr><literal type="string">"PLAIN"</literal></expr>;</return>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case>
			<return>return <expr><literal type="string">"MAIN"</literal></expr>;</return>
		<case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<return>return <expr><literal type="string">"EXTENDED"</literal></expr>;</return>
		<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<return>return <expr><literal type="string">"EXTERNAL"</literal></expr>;</return>
		<default>default:</default>
			<return>return <expr><literal type="string">"???"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*----------
 * MergeAttributes
 *		Returns new schema given initial schema and superclasses.
 *
 * Input arguments:
 * 'schema' is the column/attribute definition for the table. (It's a list
 *		of ColumnDef's.) It is destructively changed.
 * 'supers' is a list of names (as RangeVar nodes) of parent relations.
 * 'relpersistence' is a persistence type of the table.
 * 'is_partition' tells if the table is a partition
 *
 * Output arguments:
 * 'supOids' receives a list of the OIDs of the parent relations.
 * 'supconstr' receives a list of constraints belonging to the parents,
 *		updated as necessary to be valid for the child.
 * 'supOidCount' is set to the number of parents that have OID columns.
 *
 * Return value:
 * Completed schema list.
 *
 * Notes:
 *	  The order in which the attributes are inherited is very important.
 *	  Intuitively, the inherited attributes should come first. If a table
 *	  inherits from multiple parents, the order of those attributes are
 *	  according to the order of the parents specified in CREATE TABLE.
 *
 *	  Here's an example:
 *
 *		create table person (name text, age int4, location point);
 *		create table emp (salary int4, manager text) inherits(person);
 *		create table student (gpa float8) inherits (person);
 *		create table stud_emp (percent int4) inherits (emp, student);
 *
 *	  The order of the attributes of stud_emp is:
 *
 *							person {1:name, 2:age, 3:location}
 *							/	 \
 *			   {6:gpa}	student   emp {4:salary, 5:manager}
 *							\	 /
 *						   stud_emp {7:percent}
 *
 *	   If the same attribute name appears multiple times, then it appears
 *	   in the result table in the proper location for its first appearance.
 *
 *	   Constraints (including NOT NULL constraints) for the child table
 *	   are the union of all relevant constraints, from both the child schema
 *	   and parent tables.
 *
 *	   The default value for a child column is defined as:
 *		(1) If the child schema specifies a default, that value is used.
 *		(2) If neither the child nor any parent specifies a default, then
 *			the column will not have a default.
 *		(3) If conflicting defaults are inherited from different parents
 *			(and not overridden by the child), an error is raised.
 *		(4) Otherwise the inherited default is used.
 *		Rule (3) is new in Postgres 7.1; in earlier releases you got a
 *		rather arbitrary choice of which parent default to use.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>MergeAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_partition</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supOids</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supconstr</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>supOidCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhSchema</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parentOids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parentsWithOids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_bogus_defaults</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>child_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>Node</name></type> <name>bogus_marker</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* marks conflicting defaults */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>saved_schema</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for and reject tables with too many columns. We perform this
	 * check relatively early for two reasons: (a) we don't run the risk of
	 * overflowing an AttrNumber in subsequent code (b) an O(n^2) algorithm is
	 * okay if we're processing &lt;= 1600 columns, but could take minutes to
	 * execute if the user attempts to create a table with hundreds of
	 * thousands of columns.
	 *
	 * Note that we also need to check that we do not exceed this figure after
	 * including columns from inherited relations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
						<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for duplicate names in the explicit list of attributes.
	 *
	 * Although we might consider merging such entries in the same way that we
	 * handle name conflicts for inherited attributes, it seems to make more
	 * sense to assume such conflicts are errors.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rest</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>entry</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_partition</name> <operator>&amp;&amp;</operator> <name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Typed table column option that does not belong to a column from
			 * the type.  This works because the columns from the type come
			 * first in the list.  (We omit this check for partition column
			 * lists; those are processed separately below.)
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<while>while <condition>(<expr><name>rest</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>restdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* need to save it in case we
											 * delete it */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * merge the column options into the column from the type
					 */</comment>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>constraints</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
									<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>rest</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block>

	<comment type="block">/*
	 * In case of a partition, there are no new column definitions, only dummy
	 * ColumnDefs created for column constraints.  Set them aside for now and
	 * process them at the end.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_partition</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved_schema</name> <operator>=</operator> <name>schema</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>schema</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the parents left-to-right, and merge their attributes to form a
	 * list of inherited attributes (inhSchema).  Also check to see if we need
	 * to inherit an OID column.
	 */</comment>
	<expr_stmt><expr><name>child_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>supers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>parent</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>newattno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * A self-exclusive lock is needed here.  If two backends attempt to
		 * add children to the same parent simultaneously, and that parent has
		 * no pre-existing children, then both will attempt to update the
		 * parent's relhassubclass field, leading to a "tuple concurrently
		 * updated" error.  Also, this interlocks against a concurrent ANALYZE
		 * on the parent table, which might otherwise be attempting to clear
		 * the parent's relhassubclass field, if its previous children were
		 * recently dropped.
		 *
		 * If the child table is a partition, then we instead grab an
		 * exclusive lock on the parent because its partition descriptor will
		 * be changed by addition of the new partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Check for active uses of the parent partitioned table in the
		 * current transaction, such as being used in some manner by an
		 * enclosing command.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE .. PARTITION OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We do not allow partitioned tables and partitions to participate in
		 * regular inheritance.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partitioned table \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partition \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
							<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the parent is permanent, so must be all of its partitions.  Note
		 * that inheritance allows that case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create a temporary relation as partition of permanent relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Permanent rels cannot inherit from temporary ones */</comment>
		<if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>is_partition</name></expr>
							?</condition><then> <expr><literal type="string">"cannot inherit from temporary relation \"%s\""</literal></expr>
							</then><else>: <expr><literal type="string">"cannot create a permanent relation as partition of temporary relation \"%s\""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If existing rel is temp, it must belong to this session */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>is_partition</name></expr>
							?</condition><then> <expr><literal type="string">"cannot inherit from temporary relation of another session"</literal></expr>
							</then><else>: <expr><literal type="string">"cannot create as partition of temporary relation of another session"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We should have an UNDER permission flag for this, but for now,
		 * demand that creator of a child table own the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reject duplications in the list of parents.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>parentOids</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" would be inherited from more than once"</literal></expr></argument>,
							<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>parentOids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>parentOids</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parentsWithOids</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * newattno[] will contain the child-table attribute numbers for the
		 * attributes of this parent table.  (They are not the same for
		 * parents after the first one, nor if we have dropped columns.)
		 */</comment>
		<expr_stmt><expr><name>newattno</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
			 <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
														<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>exist_attno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore dropped columns in the parent.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* leave newattno entry as zero */</comment>

			<comment type="block">/*
			 * Does it conflict with some previously inherited column?
			 */</comment>
			<expr_stmt><expr><name>exist_attno</name> <operator>=</operator> <call><name>findAttrByName</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name>inhSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defTypeId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>deftypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defCollId</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Yes, try to merge the two column definitions. They must
				 * have the same type, typmod, and collation.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging multiple inherited definitions of column \"%s\""</literal></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>def</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>exist_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defTypeId</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
					<name>deftypmod</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a type conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>defTypeId</name></expr></argument>,
																<argument><expr><name>deftypmod</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
																<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>defCollId</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>defTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defCollId</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a collation conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>defCollId</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Copy storage parameter */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a storage parameter conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* Merge of NOT NULL constraints = OR 'em together */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
				<comment type="block">/* Default and other constraints are handled below */</comment>
				<expr_stmt><expr><name><name>newattno</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>exist_attno</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * No, create a new inherited column
				 */</comment>
				<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
													<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newattno</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>child_attno</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Copy default if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>this_default</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<comment type="block">/* Find default in constraint structure */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attrdef</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>==</operator> <name>parent_attno</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>this_default</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>this_default</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If default expr could contain any vars, we'd need to fix
				 * 'em, but it can't; so default is ready to apply to child.
				 *
				 * If we already had a default from some prior parent, check
				 * to see if they are the same.  If so, no problem; if not,
				 * mark the column as having a bogus default. Below, we will
				 * complain if the bogus default isn't overridden by the child
				 * schema.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>this_default</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></argument>, <argument><expr><name>this_default</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <operator>&amp;</operator><name>bogus_marker</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_bogus_defaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now copy the CHECK constraints of this parent, adjusting attnos
		 * using the completed newattno[] map.  Identically named constraints
		 * are merged if possible, else we throw error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<comment type="block">/* ignore if the constraint is non-inheritable */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>newattno</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * For the moment we have to reject whole-row variables. We
				 * could convert them, if we knew the new table's rowtype OID,
				 * but that hasn't been assigned yet.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Constraint \"%s\" contains a whole-row reference to table \"%s\"."</literal></expr></argument>,
									   <argument><expr><name>name</name></expr></argument>,
									   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* check for duplicate */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MergeCheckConstraint</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* nope, this is a new one */</comment>
					<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* until created */</comment>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not used for constraints */</comment>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close the parent rel, but keep our lock on it until xact commit.
		 * That will prevent someone else from deleting or ALTERing the parent
		 * before the child is committed.
		 */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we had no inherited attributes, the result schema is just the
	 * explicitly declared columns.  Otherwise, we need to merge the declared
	 * columns into the inherited schema list.  Although, we never have any
	 * explicitly declared columns if the table is a partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inhSchema</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>schema_attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>newdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><name><name>newdef</name><operator>-&gt;</operator><name>colname</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>exist_attno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>schema_attno</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Does it conflict with some previously inherited column?
			 */</comment>
			<expr_stmt><expr><name>exist_attno</name> <operator>=</operator> <call><name>findAttrByName</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name>inhSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defTypeId</name></decl>,
							<decl><type ref="prev"/><name>newTypeId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>deftypmod</name></decl>,
							<decl><type ref="prev"/><name>newtypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defcollid</name></decl>,
							<decl><type ref="prev"/><name>newcollid</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Partitions have only one parent and have no column
				 * definitions of their own, so conflict should never occur.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Yes, try to merge the two column definitions. They must
				 * have the same type, typmod, and collation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>==</operator> <name>schema_attno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging column \"%s\" with inherited definition"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving and merging column \"%s\" with inherited definition"</literal></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User-specified column moved to the position of the inherited column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>def</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>exist_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>newdef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defTypeId</name> <operator>!=</operator> <name>newTypeId</name> <operator>||</operator> <name>deftypmod</name> <operator>!=</operator> <name>newtypmod</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a type conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>defTypeId</name></expr></argument>,
																<argument><expr><name>deftypmod</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>newTypeId</name></expr></argument>,
																<argument><expr><name>newtypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>defcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>defTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>, <argument><expr><name>newTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defcollid</name> <operator>!=</operator> <name>newcollid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a collation conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>defcollid</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>newcollid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Identity is never inherited.  The new column can have an
				 * identity definition, so we always just take that one.
				 */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>

				<comment type="block">/* Copy storage parameter */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a storage parameter conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Mark the column as locally defined */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* Merge of NOT NULL constraints = OR 'em together */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
				<comment type="block">/* If new def has a default, override previous default */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>newdef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * No, attach new column to result schema
				 */</comment>
				<expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>schema</name> <operator>=</operator> <name>inhSchema</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that we haven't exceeded the legal # of columns after merging
		 * in inherited columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
							<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that we have the column definition list for a partition, we can
	 * check whether the columns referenced in the column constraint specs
	 * actually exist.  Also, we merge NOT NULL and defaults into each
	 * corresponding column definition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_partition</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>saved_schema</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>restdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>schema</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Override the parent's default value for this column
					 * (coldef-&gt;cooked_default) with the partition's local
					 * definition (restdef-&gt;raw_default), if there's one. It
					 * should be physically impossible to get a cooked default
					 * in the local definition or a raw default in the
					 * inherited definition, but make sure they're nulls, for
					 * future-proofing.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* complain for constraints on columns not in parent */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we found any conflicting parent default values, check to make sure
	 * they were overridden by the child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_bogus_defaults</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <operator>&amp;</operator><name>bogus_marker</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" inherits conflicting default values"</literal></expr></argument>,
								<argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To resolve the conflict, specify a default explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>supOids</name> <operator>=</operator> <name>parentOids</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>supconstr</name> <operator>=</operator> <name>constraints</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>supOidCount</name> <operator>=</operator> <name>parentsWithOids</name></expr>;</expr_stmt>
	<return>return <expr><name>schema</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MergeCheckConstraint
 *		Try to merge an inherited CHECK constraint with previous ones
 *
 * If we inherit identically-named constraints from multiple parents, we must
 * merge them, or throw an error if they don't have identical definitions.
 *
 * constraints is a list of CookedConstraint structs for previous constraints.
 *
 * Returns true if merged (constraint is a duplicate), or false if it's
 * got a so-far-unique name, or throws error if conflict.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MergeCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>ccon</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Non-matching names never conflict */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to merge */</comment>
			<expr_stmt><expr><name><name>ccon</name><operator>-&gt;</operator><name>inhcount</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint name \"%s\" appears multiple times but with different expressions"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreCatalogInheritance
 *		Updates the system catalogs with proper inheritance information.
 *
 * supers is a list of the OIDs of the new relation's direct ancestors.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreCatalogInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>seqNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>supers</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Store INHERITS information in pg_inherits using direct ancestors only.
	 * Also enter dependencies on the direct ancestors, and make sure they are
	 * marked with relhassubclass = true.
	 *
	 * (Once upon a time, both direct and indirect ancestors were found here
	 * and then entered into pg_ipl.  Since that catalog doesn't exist
	 * anymore, there's no need to look for indirect ancestors.)
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seqNumber</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>supers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>StoreCatalogInheritance1</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>seqNumber</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
								 <argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>seqNumber</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make catalog entries showing relationId as being an inheritance child
 * of parentOid.  inhRelation is the already-opened pg_inherits catalog.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreCatalogInheritance1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>,
						 <parameter><decl><type><name>int32</name></type> <name>seqNumber</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>inhRelation</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>childobject</name></decl>,
				<decl><type ref="prev"/><name>parentobject</name></decl>;</decl_stmt>

	<comment type="block">/* store the pg_inherits row */</comment>
	<expr_stmt><expr><call><name>StoreSingleInheritance</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>seqNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store a dependency too
	 */</comment>
	<expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>parentOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>childobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentobject</name></expr></argument>,
					   <argument><expr><call><name>child_dependency_type</name><argument_list>(<argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Post creation hook of this inheritance. Since object_access_hook
	 * doesn't take multiple object identifiers, we relay oid of parent
	 * relation using auxiliary_id argument.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>,
								 <argument><expr><name>relationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the parent as having subclasses.
	 */</comment>
	<expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look for an existing schema entry with the given name.
 *
 * Returns the index (starting with 1) if attribute already exists in schema,
 * 0 if it doesn't.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findAttrByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>s</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetRelationHasSubclass
 *		Set the value of the relation's relhassubclass field in pg_class.
 *
 * NOTE: caller must be holding an appropriate lock on the relation.
 * ShareUpdateExclusiveLock is sufficient.
 *
 * NOTE: an important side-effect of this operation is that an SI invalidation
 * message is sent out to all backends --- including me --- causing plans
 * referencing the relation to be rebuilt with the new list of children.
 * This must happen even if we find that no change is needed in the pg_class
 * row.
 */</comment>
<function><type><name>void</name></type>
<name>SetRelationHasSubclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>relhassubclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classtuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch a modifiable copy of the tuple, modify it, update pg_class.
	 */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>!=</operator> <name>relhassubclass</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>classtuple</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>=</operator> <name>relhassubclass</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no need to change tuple, but force relcache rebuild anyway */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renameatt_check			- basic sanity checks before attribute rename
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>renameatt_check</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename column of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Renaming the columns of sequences or toast tables doesn't actually
	 * break anything from the system's point of view, since internal
	 * references are by attnum.  But it doesn't seem right to allow users to
	 * change names that are hardcoded into the system, hence the following
	 * restriction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, composite type, index, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * permissions checking.  only the owner of a class can change its schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renameatt_internal		- workhorse for renameatt
 *
 * Return value is the attribute number in the 'myrelid' relation.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>renameatt_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldattname</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newattname</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>expected_parents</name></decl></parameter>,
				   <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, which we will NOT release
	 * until end of transaction.
	 */</comment>
	<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if the 'recurse' flag is set then we are supposed to rename this
	 * attribute in all classes that inherit from 'relname' (as well as in
	 * 'relname').
	 *
	 * any permissions or problems with duplicate attributes will cause the
	 * whole transaction to abort, which is what we want -- all or nothing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * we need the number of parents for each child so that the recursive
		 * calls to renameatt() can determine whether there are any parents
		 * outside the inheritance hierarchy being processed.
		 */</comment>
		<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * find_all_inheritors does the recursive search of the inheritance
		 * hierarchy, so all we have to do is process all of the relids in the
		 * list that it returns.
		 */</comment>
		<macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>myrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* note we need not recurse again */</comment>
			<expr_stmt><expr><call><name>renameatt_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>numparents</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we are told not to recurse, there had better not be any child
		 * tables; else the rename would put them out of step.
		 *
		 * expected_parents will only be 0 if we are not already recursing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>expected_parents</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" must be renamed in child tables too"</literal></expr></argument>,
							<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* rename attributes in typed tables of composite type */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_typed_table_dependencies</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
												   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>renameatt_internal</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>atttup</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if the attribute is inherited, forbid the renaming.  if this is a
	 * top-level call to renameatt(), then expected_parents will be 0, so the
	 * effect of this code will be to prohibit the renaming if the attribute
	 * is inherited at all.  if this is a recursive call to renameatt(),
	 * expected_parents will be the number of parents the current relation has
	 * within the inheritance hierarchy being processed, so we'll prohibit the
	 * renaming only if there are additional parents from elsewhere.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <name>expected_parents</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename inherited column \"%s\""</literal></expr></argument>,
						<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* new name should not already exist */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_for_column_name_collision</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* apply the update */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attform</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* close rel but keep lock */</comment>

	<return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform permissions and integrity checks before acquiring a relation lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForRenameAttribute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
								   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped */</comment>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renameatt		- changes the name of an attribute in a relation
 *
 * The returned ObjectAddress is that of the renamed column.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>renameatt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* lock level taken here should match renameatt_internal */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForRenameAttribute</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator>
		<call><name>renameatt_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,	<comment type="block">/* old att name */</comment>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,	<comment type="block">/* new att name */</comment>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <comment type="block">/* recursive? */</comment>
						   <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* recursing? */</comment>
						   <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* expected inhcount */</comment>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * same logic as renameatt_internal
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>rename_constraint_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>mytypid</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldconname</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newconname</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>expected_parents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><operator>!</operator><name>myrelid</name> <operator>||</operator> <operator>!</operator><name>mytypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mytypid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_domain_constraint_oid</name><argument_list>(<argument><expr><name>mytypid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * don't tell it whether we're recursing; we allow changing typed
		 * tables here
		 */</comment>
		<expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
			 <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>myrelid</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>myrelid</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>rename_constraint_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>expected_parents</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited constraint \"%s\" must be renamed in child tables too"</literal></expr></argument>,
								<argument><expr><name>oldconname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <name>expected_parents</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename inherited constraint \"%s\""</literal></expr></argument>,
							<argument><expr><name>oldconname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name>
		<operator>&amp;&amp;</operator> <operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name>
			<operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_UNIQUE</name>
			<operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_EXCLUSION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* rename the index; this renames the constraint as well */</comment>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RenameConstraintById</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetrelation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Invalidate relcache so as others can see the new constraint name.
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* close rel but keep lock */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ObjectAddress</name></type>
<name>RenameConstraint</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_DOMCONSTRAINT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* lock level taken here should match rename_constraint_internal */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
										 <argument><expr><name>RangeVarCallbackForRenameAttribute</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return
		<expr><call><name>rename_constraint_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>&amp;&amp;</operator>
									<name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name><operator>)</operator></expr></argument>,	<comment type="block">/* recursive? */</comment>
								   <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* recursing? */</comment>
								   <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* expected inhcount */</comment> )</argument_list></call></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE/INDEX/SEQUENCE/VIEW/MATERIALIZED VIEW/FOREIGN TABLE
 * RENAME
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>RenameRelation</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, index, sequence, view,
	 * materialized view, or foreign table, which we will NOT release until
	 * end of transaction.
	 *
	 * Lock level used here should match RenameRelationInternal, to avoid lock
	 * escalation.
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do the work */</comment>
	<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		RenameRelationInternal - change the name of a relation
 */</comment>
<function><type><name>void</name></type>
<name>RenameRelationInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newrelname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relrelation</name></decl>;</decl_stmt>	<comment type="block">/* for RELATION relation */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, index, sequence, view,
	 * materialized view, or foreign table, which we will NOT release until
	 * end of transaction.
	 */</comment>
	<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find relation's pg_class tuple, and make sure newrelname isn't in use.
	 */</comment>
	<expr_stmt><expr><name>relrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>newrelname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update pg_class tuple with new relname.  (Scribbling on reltup is OK
	 * because it's a copy...)
	 */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>relform</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also rename the associated type, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RenameTypeInternal</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
						   <argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also rename the associated constraint, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RenameConstraintById</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Close rel, but keep exclusive lock!
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Disallow ALTER TABLE (and similar commands) when the current backend has
 * any open reference to the target table besides the one just acquired by
 * the calling command; this implies there's an open cursor or active plan.
 * We need this check because our lock doesn't protect us against stomping
 * on our own foot, only other people's feet!
 *
 * For ALTER TABLE, the only case known to cause serious trouble is ALTER
 * COLUMN TYPE, and some changes are obviously pretty benign, so this could
 * possibly be relaxed to only error out for certain types of alterations.
 * But the use-case for allowing any of these things is not obvious, so we
 * won't work hard at it for now.
 *
 * We also reject these commands if there are any pending AFTER trigger events
 * for the rel.  This is certainly necessary for the rewriting variants of
 * ALTER TABLE, because they don't preserve tuple TIDs and so the pending
 * events would try to fetch the wrong tuples.  It might be overly cautious
 * in other cases, but again it seems better to err on the side of paranoia.
 *
 * REINDEX calls this with "rel" referencing the index to be rebuilt; here
 * we are worried about active indexscans on the index.  The trigger-event
 * check can be skipped, since we are doing no damage to the parent table.
 *
 * The statement name (eg, "ALTER TABLE") is passed for use in error messages.
 */</comment>
<function><type><name>void</name></type>
<name>CheckTableNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>expected_refcnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>expected_refcnt</name> <operator>=</operator> <ternary><condition><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>!=</operator> <name>expected_refcnt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: first %s is a SQL command, eg ALTER TABLE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s \"%s\" because it is being used by active queries in this session"</literal></expr></argument>,
						<argument><expr><name>stmt</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<call><name>AfterTriggerPendingOnRel</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: first %s is a SQL command, eg ALTER TABLE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s \"%s\" because it has pending trigger events"</literal></expr></argument>,
						<argument><expr><name>stmt</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableLookupRelation
 *		Look up, and lock, the OID for the relation named by an alter table
 *		statement.
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTableLookupRelation</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTable
 *		Execute ALTER TABLE, which can be a list of subcommands
 *
 * ALTER TABLE is performed in three phases:
 *		1. Examine subcommands and perform pre-transformation checking.
 *		2. Update system catalogs.
 *		3. Scan table(s) to check new constraints, and optionally recopy
 *		   the data into new table(s).
 * Phase 3 is not performed unless one or more of the subcommands requires
 * it.  The intention of this design is to allow multiple independent
 * updates of the table schema to be performed with only one pass over the
 * data.
 *
 * ATPrepCmd performs phase 1.  A "work queue" entry is created for
 * each table to be affected (there may be multiple affected tables if the
 * commands traverse a table inheritance hierarchy).  Also we do preliminary
 * validation of the subcommands, including parse transformation of those
 * expressions that need to be evaluated with respect to the old table
 * schema.
 *
 * ATRewriteCatalogs performs phase 2 for each affected table.  (Note that
 * phases 2 and 3 normally do no explicit recursion, since phase 1 already
 * did it --- although some subcommands have to recurse in phase 2 instead.)
 * Certain subcommands need to be performed before others to avoid
 * unnecessary conflicts; for example, DROP COLUMN should come before
 * ADD COLUMN.  Therefore phase 1 divides the subcommands into multiple
 * lists, one for each logical "pass" of phase 2.
 *
 * ATRewriteTables performs phase 3 for those tables that need it.
 *
 * Thanks to the magic of MVCC, an error anywhere along the way rolls back
 * the whole operation; we don't have to do anything special to clean up.
 *
 * The caller must lock the relation, with an appropriate lock level
 * for the subcommands requested, using AlterTableGetLockLevel(stmt-&gt;cmds)
 * or higher. We pass the lock level down
 * so that we can apply it recursively to inherited tables. Note that the
 * lock level we want as we recurse might well be higher than required for
 * that specific subcommand. So we pass down the overall lock requirement,
 * rather than reassess it at lower levels.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Caller is required to provide an adequate lock. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ATController</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableInternal
 *
 * ALTER TABLE with target specified by OID
 *
 * We do not reject if the relation is already open, because it's quite
 * likely that one or more layers of caller have it open.  That means it
 * is unsafe to use this entry point for alterations that could break
 * existing query plans.  On the assumption it's not used for such, we
 * don't have to reject pending AFTER triggers, either.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ATController</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableGetLockLevel
 *
 * Sets the overall lock level required for the supplied list of subcommands.
 * Policy for doing this set according to needs of AlterTable(), see
 * comments there for overall explanation.
 *
 * Function is called before and after parsing, so it must give same
 * answer each time it is called. Some subcommands are transformed
 * into other subcommand types, so the transform must never be made to a
 * lower lock level than previously assigned. All transforms are noted below.
 *
 * Since this is called before we lock the table we cannot use table metadata
 * to influence the type of lock we acquire.
 *
 * There should be no lockmodes hardcoded into the subcommand functions. All
 * lockmode decisions for ALTER TABLE are made here only. The one exception is
 * ALTER TABLE RENAME which is treated as a different statement type T_RenameStmt
 * and does not travel through this section of code and cannot be combined with
 * any of the subcommands given here.
 *
 * Note that Hot Standby only knows about AccessExclusiveLocks on the master
 * so any changes that might affect SELECTs running on standbys need to use
 * AccessExclusiveLocks even if you think a lesser lock would do, unless you
 * have a solution for that also.
 *
 * Also note that pg_dump uses only an AccessShareLock, meaning that anything
 * that takes a lock less than AccessExclusiveLock can change object definitions
 * while pg_dump is running. Be careful to check that the appropriate data is
 * derived by pg_dump using an MVCC snapshot, rather than syscache lookups,
 * otherwise we might end up with an inconsistent dump that can't restore.
 */</comment>
<function><type><name>LOCKMODE</name></type>
<name>AlterTableGetLockLevel</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This only works if we read catalog tables using MVCC snapshots.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>ShareUpdateExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>cmd_lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt> <comment type="block">/* default for compiler */</comment>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * These subcommands rewrite the heap, so require full locks.
				 */</comment>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>	<comment type="block">/* may rewrite heap, in some cases and visible
								 * to SELECT */</comment>
			<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>	<comment type="block">/* must rewrite heap */</comment>
			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>	<comment type="block">/* must rewrite heap */</comment>
			<case>case <expr><name>AT_AddOids</name></expr>:</case>	<comment type="block">/* must rewrite heap */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands may require addition of toast tables. If
				 * we add a toast table to a table currently being scanned, we
				 * might miss data added to the new toast table by concurrent
				 * insert transactions.
				 */</comment>
			<case>case <expr><name>AT_SetStorage</name></expr>:</case> <comment type="block">/* may add toast tables, see
								 * ATRewriteCatalogs() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Removing constraints can affect SELECTs that have been
				 * optimised assuming the constraint holds true.
				 */</comment>
			<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* as DROP INDEX */</comment>
			<case>case <expr><name>AT_DropNotNull</name></expr>:</case>	<comment type="block">/* may change some SQL plans */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Subcommands that may be visible to concurrent SELECTs
				 */</comment>
			<case>case <expr><name>AT_DropColumn</name></expr>:</case> <comment type="block">/* change visible to SELECT */</comment>
			<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>	<comment type="block">/* CREATE VIEW */</comment>
			<case>case <expr><name>AT_DropOids</name></expr>:</case>	<comment type="block">/* calls AT_DropColumn */</comment>
			<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>	<comment type="block">/* may change SELECT rules */</comment>
			<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>	<comment type="block">/* may change SELECT rules */</comment>
			<case>case <expr><name>AT_EnableRule</name></expr>:</case> <comment type="block">/* may change SELECT rules */</comment>
			<case>case <expr><name>AT_DisableRule</name></expr>:</case>	<comment type="block">/* may change SELECT rules */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Changing owner may remove implicit SELECT privileges
				 */</comment>
			<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>	<comment type="block">/* change visible to SELECT */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Changing foreign table options may affect optimization.
				 */</comment>
			<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect write operations only.
				 */</comment>
			<case>case <expr><name>AT_EnableTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
			<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrig</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect write operations only. XXX
				 * Theoretically, these could be ShareRowExclusiveLock.
				 */</comment>
			<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
			<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>
			<case>case <expr><name>AT_AddIndex</name></expr>:</case>	<comment type="block">/* from ADD CONSTRAINT */</comment>
			<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case>
			<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
			<case>case <expr><name>AT_SetNotNull</name></expr>:</case>
			<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
			<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
			<case>case <expr><name>AT_ProcessedConstraint</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
			<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
			<case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
			<case>case <expr><name>AT_ReAddDomainConstraint</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
						<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
						<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>

							<comment type="block">/*
							 * Cases essentially the same as CREATE INDEX. We
							 * could reduce the lock strength to ShareLock if
							 * we can work out how to allow concurrent catalog
							 * updates. XXX Might be set down to
							 * ShareRowExclusiveLock but requires further
							 * analysis.
							 */</comment>
							<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>

							<comment type="block">/*
							 * We add triggers to both tables when we add a
							 * Foreign Key, so the lock level must be at least
							 * as strong as CREATE TRIGGER.
							 */</comment>
							<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt>
							<break>break;</break>

						<default>default:</default>
							<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect inheritance behaviour. Queries
				 * started before us will continue to see the old inheritance
				 * behaviour, while queries started after we commit will see
				 * new behaviour. No need to prevent reads or writes to the
				 * subtable while we hook it up though. Changing the TupDesc
				 * may be a problem, so keep highest lock.
				 */</comment>
			<case>case <expr><name>AT_AddInherit</name></expr>:</case>
			<case>case <expr><name>AT_DropInherit</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect implicit row type conversion. They
				 * have affects similar to CREATE/DROP CAST on queries. don't
				 * provide for invalidating parse trees as a result of such
				 * changes, so we keep these at AccessExclusiveLock.
				 */</comment>
			<case>case <expr><name>AT_AddOf</name></expr>:</case>
			<case>case <expr><name>AT_DropOf</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Only used by CREATE OR REPLACE VIEW which must conflict
				 * with an SELECTs currently using the view.
				 */</comment>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect general strategies for performance
				 * and maintenance, though don't change the semantic results
				 * from normal data reads and writes. Delaying an ALTER TABLE
				 * behind currently active writes only delays the point where
				 * the new strategy begins to take effect, so there is no
				 * benefit in waiting. In this case the minimum restriction
				 * applies: we don't currently allow concurrent catalog
				 * updates.
				 */</comment>
			<case>case <expr><name>AT_SetStatistics</name></expr>:</case>	<comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
			<case>case <expr><name>AT_ClusterOn</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() */</comment>
			<case>case <expr><name>AT_DropCluster</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() */</comment>
			<case>case <expr><name>AT_SetOptions</name></expr>:</case> <comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
			<case>case <expr><name>AT_ResetOptions</name></expr>:</case>	<comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_SetLogged</name></expr>:</case>
			<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* Uses MVCC in getConstraints() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Rel options are more complex than first appears. Options
				 * are set here for tables, views and indexes; for historical
				 * reasons these can all be used with ALTER TABLE, so we can't
				 * decide between them using the basic grammar.
				 */</comment>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() and
									 * getTables() */</comment>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() and
										 * getTables() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <call><name>AlterTableGetRelOptionsLockLevel</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>			<comment type="block">/* oops */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Take the greatest lockmode from any subcommand
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmd_lockmode</name> <operator>&gt;</operator> <name>lockmode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>cmd_lockmode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>lockmode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ATController provides top level control over the phases.
 *
 * parsetree is passed in to allow it to be passed to event triggers
 * when requested.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATController</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
			 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wqueue</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

	<comment type="block">/* Phase 1: preliminary examination of commands, create work queue */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Close the relation, but keep lock until commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 2: update system catalogs */</comment>
	<expr_stmt><expr><call><name>ATRewriteCatalogs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 3: scan/rewrite tables as needed */</comment>
	<expr_stmt><expr><call><name>ATRewriteTables</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATPrepCmd
 *
 * Traffic cop for ALTER TABLE Phase 1 operations, including simple
 * recursion and permission checks.
 *
 * Caller must have acquired appropriate lock type on relation already.
 * This lock should be held until commit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pass</name> <init>= <expr><name>AT_PASS_UNSET</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find or create work queue entry for this table */</comment>
	<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the original subcommand for each table.  This avoids conflicts
	 * when different child tables need to make different parse
	 * transformations (for example, the same column may have different column
	 * numbers in different children).
	 */</comment>
	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do permissions checking, recursion to child tables if needed, and any
	 * additional phase-1 processing needed.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_AddColumn</name></expr>:</case>		<comment type="block">/* ADD COLUMN */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>	<comment type="block">/* add column via CREATE OR REPLACE VIEW */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DEFAULT */</comment>

			<comment type="block">/*
			 * We allow defaults on views so that INSERT into a view can have
			 * default-ish behavior.  This works because the rewriter
			 * substitutes default values into INSERTs before it expands
			 * rules.
			 */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <ternary><condition><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr> ?</condition><then> <expr><name>AT_PASS_ADD_CONSTR</name></expr> </then><else>: <expr><name>AT_PASS_DROP</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_COL_ATTRS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropNotNull</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DROP NOT NULL */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepDropNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetNotNull</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET NOT NULL */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepSetNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStatistics</name></expr>:</case>	<comment type="block">/* ALTER COLUMN SET STATISTICS */</comment>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Performs own permission checks */</comment>
			<expr_stmt><expr><call><name>ATPrepSetStatistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetOptions</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET ( options ) */</comment>
		<case>case <expr><name>AT_ResetOptions</name></expr>:</case>	<comment type="block">/* ALTER COLUMN RESET ( options ) */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStorage</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET STORAGE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumn</name></expr>:</case>		<comment type="block">/* DROP COLUMN */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndex</name></expr>:</case>		<comment type="block">/* ADD INDEX */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraint</name></expr>:</case>	<comment type="block">/* ADD CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case> <comment type="block">/* ADD CONSTRAINT USING INDEX */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* DROP CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATCheckPartitionsNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Other recursion occurs during execution phase */</comment>
			<comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>	<comment type="block">/* ALTER COLUMN TYPE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Performs own recursion */</comment>
			<expr_stmt><expr><call><name>ATPrepAlterColumnType</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ALTER_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>	<comment type="block">/* ALTER OWNER */</comment>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ClusterOn</name></expr>:</case>		<comment type="block">/* CLUSTER ON */</comment>
		<case>case <expr><name>AT_DropCluster</name></expr>:</case>	<comment type="block">/* SET WITHOUT CLUSTER */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* These commands never recurse */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetLogged</name></expr>:</case>		<comment type="block">/* SET LOGGED */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <call><name>ATPrepChangePersistence</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* force rewrite if necessary; see comment in ATRewriteTables */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_PERSISTENCE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>	<comment type="block">/* SET UNLOGGED */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <call><name>ATPrepChangePersistence</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* force rewrite if necessary; see comment in ATRewriteTables */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_PERSISTENCE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddOids</name></expr>:</case>		<comment type="block">/* SET WITH OIDS */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>||</operator> <name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATPrepAddOids</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropOids</name></expr>:</case>		<comment type="block">/* SET WITHOUT OIDS */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Performs own recursion */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>dropCmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>dropCmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropColumn</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dropCmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dropCmd</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>dropCmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>	<comment type="block">/* SET TABLESPACE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator>
								<name>ATT_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><call><name>ATPrepSetTableSpace</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>	<comment type="block">/* doesn't actually matter */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>	<comment type="block">/* SET (...) */</comment>
		<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>	<comment type="block">/* RESET (...) */</comment>
		<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>	<comment type="block">/* reset them all, then set just these */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddInherit</name></expr>:</case>		<comment type="block">/* INHERIT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><call><name>ATPrepAddInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropInherit</name></expr>:</case>	<comment type="block">/* NO INHERIT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>	<comment type="block">/* ALTER CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* VALIDATE CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ValidateConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>	<comment type="block">/* REPLICA IDENTITY ... */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>		<comment type="block">/* ENABLE TRIGGER variants */</comment>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>	<comment type="block">/* DISABLE TRIGGER variants */</comment>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableRule</name></expr>:</case>		<comment type="block">/* ENABLE/DISABLE RULE variants */</comment>
		<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>
		<case>case <expr><name>AT_DisableRule</name></expr>:</case>
		<case>case <expr><name>AT_AddOf</name></expr>:</case>			<comment type="block">/* OF */</comment>
		<case>case <expr><name>AT_DropOf</name></expr>:</case>			<comment type="block">/* NOT OF */</comment>
		<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* These commands never recurse */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>				<comment type="block">/* oops */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_UNSET</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pass</name> <operator>&gt;</operator> <name>AT_PASS_UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the subcommand to the appropriate list for phase 2 */</comment>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteCatalogs
 *
 * Traffic cop for ALTER TABLE Phase 2 operations.  Subcommands are
 * dispatched in a "safe" execution order (designed to avoid unnecessary
 * conflicts).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteCatalogs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We process all the tables "in parallel", one pass at a time.  This is
	 * needed because we may have to propagate work from one table to another
	 * (specifically, ALTER TYPE on a foreign key's PK has to dispatch the
	 * re-adding of the foreign key constraint to the other table).  Work can
	 * only be propagated into later passes, however.
	 */</comment>
	<for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Go through each table that needs to be processed */</comment>
		<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subcmds</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>subcmds</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Appropriate lock was obtained by phase 1, needn't get it again
			 */</comment>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>subcmds</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>ATExecCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * After the ALTER TYPE pass, do cleanup work (this is not done in
			 * ATExecAlterColumnType since it should be done only once if
			 * multiple columns of a table are altered).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <name>AT_PASS_ALTER_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATPostAlterTypeCleanup</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<comment type="block">/* Check to see if a toast table must be added. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the table is source table of ATTACH PARTITION command, we did
		 * not modify anything about it that will change its toasting
		 * requirement, so no need to check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			  <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
			<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AlterTableCreateToastTable</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ATExecCmd: dispatch a subcommand to appropriate execution routine
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
		  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_AddColumn</name></expr>:</case>		<comment type="block">/* ADD COLUMN */</comment>
		<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>	<comment type="block">/* add column via CREATE OR REPLACE VIEW */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DEFAULT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecColumnDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropNotNull</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DROP NOT NULL */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetNotNull</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET NOT NULL */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetNotNull</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStatistics</name></expr>:</case>	<comment type="block">/* ALTER COLUMN SET STATISTICS */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetStatistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetOptions</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET ( options ) */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ResetOptions</name></expr>:</case>	<comment type="block">/* ALTER COLUMN RESET ( options ) */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStorage</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET STORAGE */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumn</name></expr>:</case>		<comment type="block">/* DROP COLUMN */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>	<comment type="block">/* DROP COLUMN with recursion */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndex</name></expr>:</case>		<comment type="block">/* ADD INDEX */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndex</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddIndex</name></expr>:</case>		<comment type="block">/* ADD INDEX */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndex</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraint</name></expr>:</case>	<comment type="block">/* ADD CONSTRAINT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>	<comment type="block">/* ADD CONSTRAINT with recursion */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>	<comment type="block">/* Re-add pre-existing check constraint */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddDomainConstraint</name></expr>:</case>	<comment type="block">/* Re-add pre-existing domain check
										 * constraint */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>AlterDomainAddConstraint</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>typeName</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>def</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddComment</name></expr>:</case>	<comment type="block">/* Re-add existing comment */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CommentObject</name><argument_list>(<argument><expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case> <comment type="block">/* ADD CONSTRAINT USING INDEX */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndexConstraint</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>	<comment type="block">/* ALTER CONSTRAINT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAlterConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* VALIDATE CONSTRAINT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraintRecurse</name></expr>:</case>	<comment type="block">/* VALIDATE CONSTRAINT with
											 * recursion */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* DROP CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>	<comment type="block">/* DROP CONSTRAINT with recursion */</comment>
			<expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>	<comment type="block">/* ALTER COLUMN TYPE */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAlterColumnType</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>	<comment type="block">/* ALTER COLUMN OPTIONS */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAlterColumnGenericOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
												<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>	<comment type="block">/* ALTER OWNER */</comment>
			<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>newowner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ClusterOn</name></expr>:</case>		<comment type="block">/* CLUSTER ON */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecClusterOn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropCluster</name></expr>:</case>	<comment type="block">/* SET WITHOUT CLUSTER */</comment>
			<expr_stmt><expr><call><name>ATExecDropCluster</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetLogged</name></expr>:</case>		<comment type="block">/* SET LOGGED */</comment>
		<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>	<comment type="block">/* SET UNLOGGED */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_AddOids</name></expr>:</case>		<comment type="block">/* SET WITH OIDS */</comment>
			<comment type="block">/* Use the ADD COLUMN code, unless prep decided to do nothing */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>address</name> <operator>=</operator>
					<call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddOidsRecurse</name></expr>:</case> <comment type="block">/* SET WITH OIDS */</comment>
			<comment type="block">/* Use the ADD COLUMN code, unless prep decided to do nothing */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>address</name> <operator>=</operator>
					<call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropOids</name></expr>:</case>		<comment type="block">/* SET WITHOUT OIDS */</comment>

			<comment type="block">/*
			 * Nothing to do here; we'll have generated a DropColumn
			 * subcommand to do the real work
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>	<comment type="block">/* SET TABLESPACE */</comment>
			<comment type="block">/*
			 * Only do this for partitioned indexes, for which this is just
			 * a catalog change.  Other relation types are handled by Phase 3.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecPartedIdxSetTableSpace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>	<comment type="block">/* SET (...) */</comment>
		<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>	<comment type="block">/* RESET (...) */</comment>
		<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>	<comment type="block">/* replace entire option list */</comment>
			<expr_stmt><expr><call><name>ATExecSetRelOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>		<comment type="block">/* ENABLE TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>	<comment type="block">/* ENABLE ALWAYS TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ALWAYS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>	<comment type="block">/* ENABLE REPLICA TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_REPLICA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>	<comment type="block">/* DISABLE TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>	<comment type="block">/* ENABLE TRIGGER ALL */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case> <comment type="block">/* DISABLE TRIGGER ALL */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case> <comment type="block">/* ENABLE TRIGGER USER */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>	<comment type="block">/* DISABLE TRIGGER USER */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_EnableRule</name></expr>:</case>		<comment type="block">/* ENABLE RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>	<comment type="block">/* ENABLE ALWAYS RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_FIRES_ALWAYS</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>	<comment type="block">/* ENABLE REPLICA RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_FIRES_ON_REPLICA</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableRule</name></expr>:</case>	<comment type="block">/* DISABLE RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_DISABLED</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_AddInherit</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropInherit</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddOf</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddOf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropOf</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecDropOf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecReplicaIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ReplicaIdentityStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecEnableRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecDisableRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecForceNoForceRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecForceNoForceRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecGenericOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecAttachPartition</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecAttachPartitionIdx</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
			<comment type="block">/* ATPrepCmd ensures it must be a table */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATExecDetachPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>				<comment type="block">/* oops */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Report the subcommand to interested event triggers.
	 */</comment>
	<expr_stmt><expr><call><name>EventTriggerCollectAlterTableSubcmd</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmd</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Bump the command counter to ensure the next subcommand in the sequence
	 * can see the changes so far
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteTables: ALTER TABLE phase 3
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

	<comment type="block">/* Go through each table that needs to be checked or rewritten */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Foreign tables have no storage, nor do partitioned tables and
		 * indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we change column data types or add/remove OIDs, the operation
		 * has to be propagated to tables that use this table's rowtype as a
		 * column type.  tab-&gt;newvals will also be non-NULL in the case where
		 * we're adding a column with a default.  We choose to forbid that
		 * case as well, since composite types might eventually support
		 * defaults.
		 *
		 * (Eventually we'll probably need to check for composite type
		 * dependencies even when we're just scanning the table without a
		 * rewrite, but at the moment a composite type does not enforce any
		 * constraints, so it's not necessary/appropriate to enforce them just
		 * during ALTER.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We only need to rewrite the table if at least one column needs to
		 * be recomputed, we are adding/removing the OID column, or we are
		 * changing its persistence.
		 *
		 * There are two reasons for requiring a rewrite when changing
		 * persistence: on one hand, we need to ensure that the buffers
		 * belonging to each of the two relations are marked with or without
		 * BM_PERMANENT properly.  On the other hand, since rewriting creates
		 * and assigns a new relfilenode, we automatically create or drop an
		 * init fork for the relation as appropriate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Build a temporary relation and copy data */</comment>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>OldHeap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>OIDNewHeap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>NewTableSpace</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>persistence</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We don't support rewriting of system catalogs; there are too
			 * many corner cases and too little benefit.  In particular this
			 * is certainly not going to work for mapped catalogs.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite system relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationIsUsedAsCatalogTable</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite table \"%s\" used as a catalog table"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Don't allow rewrite on temp tables of other backends ... their
			 * local buffer manager is not going to cope.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Select destination tablespace (same as original unless user
			 * requested a change)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>NewTableSpace</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>NewTableSpace</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Select persistence of transient table (same as original unless
			 * user requested a change)
			 */</comment>
			<expr_stmt><expr><name>persistence</name> <operator>=</operator> <ternary><condition><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr> ?</condition><then>
				<expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name></expr> </then><else>: <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fire off an Event Trigger now, before actually rewriting the
			 * table.
			 *
			 * We don't support Event Trigger for nested commands anywhere,
			 * here included, and parsetree is given NULL when coming from
			 * AlterTableInternal.
			 *
			 * And fire it only once.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>parsetree</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EventTriggerTableRewrite</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										 <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										 <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Create transient table that will receive the modified data.
			 *
			 * Ensure it is marked correctly as logged or unlogged.  We have
			 * to do this here so that buffers for the new relfilenode will
			 * have the right persistence set, and at the same time ensure
			 * that the original filenode's buffers will get read in with the
			 * correct setting (i.e. the original one).  Otherwise a rollback
			 * after the rewrite would possibly result with buffers for the
			 * original filenode having the wrong persistence setting.
			 *
			 * NB: This relies on swap_relation_files() also swapping the
			 * persistence. That wouldn't work for pg_class, but that can't be
			 * unlogged anyway.
			 */</comment>
			<expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>make_new_heap</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NewTableSpace</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>,
									   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Copy the heap data into the new table with the desired
			 * modifications, and test the current data within the table
			 * against new constraints generated by ALTER TABLE commands.
			 */</comment>
			<expr_stmt><expr><call><name>ATRewriteTable</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Swap the physical files of the old and new heaps, then rebuild
			 * indexes and discard the old heap.  We can use RecentXmin for
			 * the table's new relfrozenxid because we rewrote all the tuples
			 * in ATRewriteTable, so no older Xid remains in the table.  Also,
			 * we never try to swap toast tables by content, since we have no
			 * interest in letting this code work on system catalogs.
			 */</comment>
			<expr_stmt><expr><call><name>finish_heap_swap</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>RecentXmin</name></expr></argument>,
							<argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><name>persistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Test the current data within the table against new constraints
			 * generated by ALTER TABLE commands, but don't rebuild data.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name> <operator>||</operator>
				<name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATRewriteTable</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we had SET TABLESPACE but no reason to reconstruct tuples,
			 * just do a block-by-block copy.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Foreign key constraints are checked in a final pass, since (a) it's
	 * generally best to examine each one separately, and (b) it's at least
	 * theoretically possible that we have changed both relations of the
	 * foreign key, and we'd better have finished both rewrites before we try
	 * to read the tables.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcon</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Foreign tables have no storage, nor do partitioned tables and
		 * indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lcon</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>refrel</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Long since locked, no need for another */</comment>
					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>refrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>refrelid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>validateForeignKeyConstraint</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>refrel</name></expr></argument>,
											 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>refindid</name></name></expr></argument>,
											 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * No need to mark the constraint row as validated, we did
				 * that when we inserted the row earlier.
				 */</comment>

				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>refrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteTable: scan or rewrite one table
 *
 * OIDNewHeap is InvalidOid if we don't need to rewrite
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteTable</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>oldrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>newrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>oldTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>newTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needscan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>notnull_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>mycid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hi_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>partqualstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open the relation(s).  We have surely already locked the existing
	 * table.
	 */</comment>
	<expr_stmt><expr><name>oldrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldTupDesc</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* includes all mods */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Prepare a BulkInsertState and options for heap_insert. Because we're
	 * building a new heap, we can skip WAL-logging and fsync it to disk at
	 * the end instead (unless WAL-logging is required for archiving or
	 * streaming replication). The FSM is empty too, so don't bother using it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mycid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hi_options</name> <operator>=</operator> <name>HEAP_INSERT_SKIP_FSM</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi_options</name> <operator>|=</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* keep compiler quiet about using these uninitialized */</comment>
		<expr_stmt><expr><name>mycid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bistate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hi_options</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Generate the constraint and default execution states
	 */</comment>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the needed expression execution states */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
				<comment type="block">/* Nothing to do here */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/* Build expression execution states for partition check quals */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partqualstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* expr already planned */</comment>
		<expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>ex</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>notnull_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are rebuilding the tuples OR if we added any new NOT NULL
		 * constraints, check all not-null constraints.  This is a bit of
		 * overkill but it minimizes risk of bugs, and heap_attisnull is a
		 * pretty cheap test anyway.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>notnull_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>notnull_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>notnull_attrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>||</operator> <name>needscan</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dropped_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rewriting table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"verifying table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * All predicate locks on the tuples or pages are about to be made
			 * invalid, because we move tuples around.  Promote them to
			 * relation locks.
			 */</comment>
			<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make tuple slots for old and new tuples.  Note that even when the
		 * tuples are the same, the tupDescs might not be (consider ADD COLUMN
		 * without a default).
		 */</comment>
		<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Preallocate values/isnull arrays */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name><name>oldTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Any attributes that are dropped according to the new tuple
		 * descriptor can be set to NULL. We precompute the list of dropped
		 * attributes to avoid needing to do so in the per-tuple loop.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dropped_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>dropped_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Scan through the rows, generating a new row if needed and then
		 * checking all the constraints.
		 */</comment>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch to per-tuple memory context and reset it for each tuple
		 * produced, so we don't leak memory.
		 */</comment>
		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>tupOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Extract data from old tuple */</comment>
				<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>oldTupDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tupOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Set dropped attributes to null in new tuple */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dropped_attrs</argument>)</argument_list></macro>
					<expr_stmt><expr><name><name>isnull</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Process supplied expressions to replace selected columns.
				 * Expression inputs come from the old tuple.
				 */</comment>
				<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>values</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
														  <argument><expr><name>econtext</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * Form the new tuple. Note that we don't explicitly pfree it,
				 * since the per-tuple memory context will be reset shortly.
				 */</comment>
				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Preserve OID, if any */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Constraints might reference the tableoid column, so
				 * initialize t_tableOid before evaluating them.
				 */</comment>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Now check any constraints on the possibly-changed tuple */</comment>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>notnull_attrs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attn</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>newTupDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>attn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" contains null values"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtablecol</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>attn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" is violated by some row"</literal></expr></argument>,
											<argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
						<comment type="block">/* Nothing to do here */</comment>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>partqualstate</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>partqualstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition would be violated by some row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint is violated by some row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Write the tuple out to the new relation */</comment>
			<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>, <argument><expr><name>hi_options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we skipped writing WAL, then we need to sync the heap. */</comment>
		<if_stmt><if>if <condition>(<expr><name>hi_options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATGetQueueEntry: find or create an entry in the ALTER TABLE work queue
 */</comment>
<function><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type>
<name>ATGetQueueEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tab</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Not there, so add it.  Note that we make a copy of the relation's
	 * existing descriptor before anything interesting can happen to it.
	 */</comment>
	<expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AlteredTableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>wqueue</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ATSimplePermissions
 *
 * - Ensure that it is a relation (or possibly a view)
 * - Ensure this user is the owner
 * - Ensure that it is not a system table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATSimplePermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>actual_target</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_MATVIEW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_PARTITIONED_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_COMPOSITE_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Wrong target type? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>actual_target</name> <operator>&amp;</operator> <name>allowed_targets</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATWrongRelkindError</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>allowed_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATWrongRelkindError
 *
 * Throw an error when a relation has been determined to be of the wrong
 * type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATWrongRelkindError</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>allowed_targets</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ATT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, or index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, or index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, composite type, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, index, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* shouldn't get here, add all necessary cases above */</comment>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is of the wrong type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATSimpleRecursion
 *
 * Simple table recursion sufficient for most ALTER TABLE operations.
 * All direct and indirect children are processed in an unspecified order.
 * Note that if a child inherits from the original table via multiple
 * inheritance paths, it will be visited just once.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATSimpleRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Propagate to children if desired.  Only plain tables, foreign tables
	 * and partitioned tables have children, so no need to search for other
	 * relkinds.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * find_all_inheritors does the recursive search of the inheritance
		 * hierarchy, so all we have to do is process all of the relids in the
		 * list that it returns.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain list of partitions of the given table, locking them all at the given
 * lockmode and ensuring that they all pass CheckTableNotInUse.
 *
 * This function is a no-op if the given relation is not a partitioned table;
 * in particular, nothing is done if it's a legacy inheritance parent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATCheckPartitionsNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inh</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>inh</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* first element is the parent rel; must ignore it */</comment>
		<macro><name>for_each_cell</name><argument_list>(<argument>cell</argument>, <argument>lnext(list_head(inh))</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATTypedTableRecursion
 *
 * Propagate ALTER TYPE operations to the typed tables of that type.
 * Also check the RESTRICT/CASCADE behavior.  Given CASCADE, also permit
 * recursion to inheritance children of the typed tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATTypedTableRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_typed_table_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
											 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * find_composite_type_dependencies
 *
 * Check to see if the type "typeOid" is being used as a column in some table
 * (possibly nested several levels deep in composite types, arrays, etc!).
 * Eventually, we'd like to propagate the check or rewrite operation
 * into such tables, but for now, just error out if we find any.
 *
 * Caller should provide either the associated relation of a rowtype,
 * or a type name (not both) for use in the error message, if any.
 *
 * Note that "typeOid" is not necessarily a composite type; it could also be
 * another container type such as an array or range, or a domain over one of
 * these things.  The name of this function is therefore somewhat historical,
 * but it's not worth changing.
 *
 * We assume that functions and views depending on the type are not reasons
 * to reject the ALTER.  (How safe is this really?)
 */</comment>
<function><type><name>void</name></type>
<name>find_composite_type_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>origRelation</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origTypeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTup</name></decl>;</decl_stmt>

	<comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We scan pg_depend to find those things that depend on the given type.
	 * (We assume we can ignore refobjsubid for a type.)
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>depScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<comment type="block">/* Check for directly dependent types */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>TypeRelationId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This must be an array, domain, or range containing the given
			 * type, so recursively check for uses of this type.  Note that
			 * any error message will mention the original type not the
			 * container; this is intentional.
			 */</comment>
			<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
											 <argument><expr><name>origRelation</name></expr></argument>, <argument><expr><name>origTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Else, ignore dependees that aren't user columns of relations */</comment>
		<comment type="block">/* (we assume system columns are never of interesting types) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>origTypeName</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because column \"%s.%s\" uses it"</literal></expr></argument>,
								<argument><expr><name>origTypeName</name></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>origRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because column \"%s.%s\" uses it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>origRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter foreign table \"%s\" because column \"%s.%s\" uses its row type"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter table \"%s\" because column \"%s.%s\" uses its row type"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * A view or composite type itself isn't a problem, but we must
			 * recursively check for indirect dependencies via its rowtype.
			 */</comment>
			<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
											 <argument><expr><name>origRelation</name></expr></argument>, <argument><expr><name>origTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * find_typed_table_dependencies
 *
 * Check to see if a composite type is being used as the type of a
 * typed table.  Abort if any are found and behavior is RESTRICT.
 * Else return the list of tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>find_typed_table_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_reloftype</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_RESTRICT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because it is the type of a typed table"</literal></expr></argument>,
							<argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER ... CASCADE to alter the typed tables too."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * check_of_type
 *
 * Check whether a type is suitable for CREATE TABLE OF/ALTER TABLE OF.  If it
 * isn't suitable, throw an error.  Currently, we require that the type
 * originated with CREATE TYPE AS.  We could support any row type, but doing so
 * would require handling a number of extra corner cases in the DDL commands.
 * (Also, allowing domain-over-composite would open up a can of worms about
 * whether and how the domain's constraints should apply to derived tables.)
 */</comment>
<function><type><name>void</name></type>
<name>check_of_type</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typetuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typ</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typeOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>typeRelation</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeRelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeOk</name> <operator>=</operator> <operator>(</operator><name><name>typeRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close the parent rel, but keep our AccessShareLock on it until xact
		 * commit.  That will prevent someone else from deleting or ALTERing
		 * the type before the typed table creation/conversion commits.
		 */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>typeRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>typeOk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not a composite type"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE ADD COLUMN
 *
 * Adds an additional attribute to a relation making the assumption that
 * CHECK, NOT NULL, and FOREIGN KEY constraints will be removed from the
 * AT_AddColumn AlterTableCmd by parse_utilcmd.c and added as independent
 * AlterTableCmd's.
 *
 * ADD COLUMN cannot use the normal ALTER TABLE recursion mechanism, because we
 * have to decide at runtime whether to recurse or not depending on whether we
 * actually add a column or merely merge with an existing column.  (We can't
 * check this in a static pre-pass because it won't handle multiple inheritance
 * situations correctly.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_view</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column to typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_view</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddColumnRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a column to a table; this handles the AT_AddOids cases as well.  The
 * return value is the address of the new column in the parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				<parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>colDef</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isOid</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>myrelid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgclass</name></decl>,
				<decl><type ref="prev"/><name>attrdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_attribute</name></type> <name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newattnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>tform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>defval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column to a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attrdesc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Are we adding the column to a recursion child?  If so, check whether to
	 * merge with an existing definition for the column.  If we do merge, we
	 * must not recurse.  Children will already have the column, and recursing
	 * into them would mess up attinhcount.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* Does child already have a column by this name? */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ctypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>ctypmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ccollid</name></decl>;</decl_stmt>

			<comment type="block">/* Child column must match on type, typmod, and collation */</comment>
			<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ctypeId</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
				<name>ctypmod</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>ccollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>ctypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ccollid</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different collation for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>ccollid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If it's OID, child column must actually be OID */</comment>
			<if_stmt><if>if <condition>(<expr><name>isOid</name> <operator>&amp;&amp;</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has a conflicting \"%s\" column"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Bump the existing child att's inhcount */</comment>
			<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Inform the user about the merge */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging definition of column \"%s\" for child \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cannot add identity column if table has children, because identity does
	 * not inherit.  (Adding column and identity separately will work.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name> <operator>&amp;&amp;</operator>
		<name>recurse</name> <operator>&amp;&amp;</operator>
		<call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot recursively add identity column to table that has child tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* skip if the name already exists and if_not_exists is true */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_for_column_name_collision</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Determine the new attribute's number */</comment>
	<if_stmt><if>if <condition>(<expr><name>isOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newattnum</name> <operator>=</operator> <name>ObjectIdAttributeNumber</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>newattnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newattnum</name> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
							<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>collOid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure datatype is legal for a column */</comment>
	<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>collOid</name></expr></argument>,
					   <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* construct new attribute's pg_attribute entry */</comment>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attrelid</name></name> <operator>=</operator> <name>myrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attribute</name><operator>.</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atttypid</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attstattarget</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newattnum</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attlen</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>newattnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attbyval</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attndims</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attstorage</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attalign</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attnotnull</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attidentity</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attisdropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attislocal</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_local</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attinhcount</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attcollation</name></name> <operator>=</operator> <name>collOid</name></expr>;</expr_stmt>
	<comment type="block">/* attribute.attacl is handled by InsertPgAttributeTuple */</comment>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InsertPgAttributeTuple</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attribute</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update pg_class tuple as appropriate
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relhasoids</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name> <operator>=</operator> <name>newattnum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Post creation hook for new attribute */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the attribute's catalog entry visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the DEFAULT, if any, in the catalogs
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Attempt to skip a complete table rewrite by storing the specified
		 * DEFAULT value outside of the heap.  This may be disabled inside
		 * AddRelationNewConstraints if the optimization cannot be applied.
		 */</comment>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * This function is intended for CREATE TABLE, so it processes a
		 * _list_ of defaults, but we just do one.
		 */</comment>
		<expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make the additional catalog changes visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Did the request for a missing value work? If not we'll have to do a
		 * rewrite
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Tell Phase 3 to fill in the default expression, if there is one.
	 *
	 * If there is no default, Phase 3 doesn't have to do anything, because
	 * that effectively means that the default is NULL.  The heap tuple access
	 * routines always check for attnum &gt; # of attributes in tuple, and return
	 * NULL if so, so without any modification of the tuple data we will get
	 * the effect of NULL values in the new column.
	 *
	 * An exception occurs when the new column is of a domain type: the domain
	 * might have a NOT NULL constraint, or a check constraint that indirectly
	 * rejects nulls.  If there are any domain constraints then we construct
	 * an explicit NULL default value that will be passed through
	 * CoerceToDomain processing.  (This is a tad inefficient, since it causes
	 * rewriting the table which we really don't have to do, but the present
	 * design of domain processing doesn't offer any simple way of checking
	 * the constraints more directly.)
	 *
	 * Note: we use build_column_default, and not just the cooked default
	 * returned by AddRelationNewConstraints, so that the right thing happens
	 * when a datatype's default applies.
	 *
	 * We skip this step completely for views and foreign tables.  For a view,
	 * we can only get here from CREATE OR REPLACE VIEW, which historically
	 * doesn't set up defaults, not even for domain-typed columns.  And in any
	 * case we mustn't invoke Phase 3 on a view or foreign table, since they
	 * have no storage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name>
		<operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For an identity column, we can't use build_column_default(),
		 * because the sequence ownership isn't set yet.  So do it manually.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>identitySequence</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>nve</name></expr>;</expr_stmt>

			<comment type="block">/* must do a rewrite for identity columns */</comment>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>defval</name> <operator>&amp;&amp;</operator> <call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>baseTypeMod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeColl</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseTypeColl</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>, <argument><expr><name>baseTypeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
													<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>defval</name></expr></argument>,
													<argument><expr><name>baseTypeId</name></expr></argument>,
													<argument><expr><name>typeOid</name></expr></argument>,
													<argument><expr><name>typmod</name></expr></argument>,
													<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
													<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
													<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>defval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to coerce base type to domain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>defval</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atthasmissing</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the new column is NOT NULL, and there is no missing value,
			 * tell Phase 3 it needs to test that. (Note we don't do this for
			 * an OID column.  OID will be marked not null, but since it's
			 * filled specially, there's no need to test anything.)
			 */</comment>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name> <operator>|=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are adding an OID column, we have to tell Phase 3 to rewrite the
	 * table to fix that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add needed dependency entries for the new column.
	 */</comment>
	<expr_stmt><expr><call><name>add_column_datatype_dependency</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_collation_dependency</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are told not to recurse, there had better not be any child
	 * tables; else the addition would put them out of step.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>children</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Children should see column as singly inherited */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>colDef</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>colDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

		<comment type="block">/* find_inheritance_children already got lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find or create work queue entry for this table */</comment>
		<expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recurse to child; return value is ignored */</comment>
		<expr_stmt><expr><call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
						<argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>isOid</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						<argument><expr><name>if_not_exists</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If a new or renamed column will collide with the name of an existing
 * column and if_not_exists is false then error out, else do nothing.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_for_column_name_collision</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * this test is deliberately not attisdropped-aware, since if one tries to
	 * add a column matching a dropped column name, it's gonna fail anyway.
	 */</comment>
	<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We throw a different error message for conflicts with system column
	 * names, since they are normally not shown and the user might otherwise
	 * be confused about the reason for the conflict.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" conflicts with a system column name"</literal></expr></argument>,
						<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>if_not_exists</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Install a column's dependency on its datatype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_column_datatype_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install a column's dependency on its collation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_column_collation_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<comment type="block">/* We know the default collation is pinned, so don't bother recording it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>CollationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>collid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET WITH OIDS
 *
 * Basically this is an ADD COLUMN for the special OID column.  We have
 * to cons up a ColumnDef node because the ADD COLUMN code needs one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddOids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If we're recursing to a child table, the ColumnDef is already set up */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>cdef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdef</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cdef</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddOidsRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN DROP NOT NULL
 *
 * Return the address of the modified column.  If the column was already
 * nullable, InvalidObjectAddress is returned.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the parent is a partitioned table, like check constraints, we do not
	 * support removing the NOT NULL while partitions exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partdesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove constraint from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lookup the attribute
	 */</comment>
	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_attidentity</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the attribute is not in a primary key
	 *
	 * Note: we'll throw error even if the pkey index is not valid.
	 */</comment>

	<comment type="block">/* Loop over all indexes on the relation */</comment>
	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the index is not a primary key, skip the check */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Loop over each attribute in the primary key and see if it
			 * matches the to-be-altered attribute
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is in a primary key"</literal></expr></argument>,
									<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If rel is partition, shouldn't drop NOT NULL if parent has the same */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>parent_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is marked NOT NULL in parent table"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay, actually perform the catalog change ... if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET NOT NULL
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the parent is a partitioned table, like check constraints, NOT NULL
	 * constraints must be added to the child tables.  Complain if requested
	 * otherwise and partitions exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>partdesc</name> <operator>&amp;&amp;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add constraint to only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the modified column.  If the column was already NOT
 * NULL, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lookup the attribute
	 */</comment>
	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Okay, actually perform the catalog change ... if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Tell Phase 3 it needs to test the constraint */</comment>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_notnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET/DROP DEFAULT
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecColumnDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newDefault</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get the number of the attribute
	 */</comment>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_attidentity</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>newDefault</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE ... ALTER COLUMN ... DROP IDENTITY instead."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remove any old default for the column.  We use RESTRICT here for
	 * safety, but at present we do not expect anything to depend on the
	 * default.
	 *
	 * We treat removing the existing default as an internal operation when it
	 * is preparatory to adding a new default, but as a user-initiated
	 * operation when the user asked for a drop.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveAttrDefault</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>newDefault</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newDefault</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* SET DEFAULT */</comment>
		<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>newDefault</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * This function is intended for CREATE TABLE, so it processes a
		 * _list_ of defaults, but we just do one.
		 */</comment>
		<expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN ADD IDENTITY
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>cdef</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Can't alter a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Creating a column as identity implies NOT NULL, so adding the identity
	 * to an existing column that is not NOT NULL would create a state that
	 * cannot be reproduced without contortions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" must be declared NOT NULL before identity can be added"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is already an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already has a default value"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <name><name>cdef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET { GENERATED or sequence options }
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>generatedEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>castNode(List, def)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"generated"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>generatedEl</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>generatedEl</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
				 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Even if there is nothing to change here, we run all the checks.  There
	 * will be a subsequent ALTER SEQUENCE that relies on everything being
	 * there.
	 */</comment>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>generatedEl</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>generatedEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN DROP IDENTITY
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>seqid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>seqaddress</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column, skipping"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* drop the internal sequence */</comment>
	<expr_stmt><expr><name>seqid</name> <operator>=</operator> <call><name>getOwnedSequence</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>seqid</name></expr></argument>,
									<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>seqid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqaddress</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET STATISTICS
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We do our own permission checking because (a) we want to allow SET
	 * STATISTICS on indexes (for expressional index columns), and (b) we want
	 * to allow SET STATISTICS on system catalogs without requiring
	 * allowSystemTableMods to be turned on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, index, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We allow referencing columns by numbers only for indexes, since table
	 * column numbers could contain gaps if columns are later dropped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>colName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to non-index column by number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newtarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtarget</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Limit target to a sane range
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newtarget</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics target %d is too low"</literal></expr></argument>,
						<argument><expr><name>newtarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>newtarget</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newtarget</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lowering statistics target to %d"</literal></expr></argument>,
						<argument><expr><name>newtarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>colName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttNum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column number %d of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colNum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter statistics on included column \"%s\" of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter statistics on non-expression column \"%s\" of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Alter statistics on table column instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>isReset</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>,
				<decl><type ref="prev"/><name>newOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Generate new proposed attoptions (text array) */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attoptions</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
									 <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Validate new options */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>attribute_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build new tuple. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update system catalog. */</comment>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET STORAGE
 *
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>storagemode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>newstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>storagemode</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"external"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"extended"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage type \"%s\""</literal></expr></argument>,
						<argument><expr><name>storagemode</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * safety check: do not allow toasted storage modes unless column datatype
	 * is TOAST-aware.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newstorage</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <call><name>TypeIsToastable</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name>newstorage</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column data type %s can only have storage PLAIN"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the change to indexes as well (only for simple index columns,
	 * matching behavior of index.c ConstructTupleDescriptor()).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>         <name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>    <name>indrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>indattnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>indrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indrel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>indrel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>indattnum</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>indattnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttNum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name>newstorage</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE DROP COLUMN
 *
 * DROP COLUMN cannot use the normal ALTER TABLE recursion mechanism,
 * because we have to decide at runtime whether to recurse or not depending
 * on whether attinhcount goes to zero or not.  (We can't check this in a
 * static pre-pass because it won't handle multiple inheritance situations
 * correctly.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column from typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropColumnRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the dropped column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>targetatt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_expr</name></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * get the number of the attribute
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>targetatt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>targetatt</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Can't drop a system attribute, except OID */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>!=</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't drop inherited columns, unless recursing (presumably from a drop
	 * of the parent column)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop inherited column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't drop columns used in the partition key, either.  (If we let this
	 * go through, the key column's dependencies would cause a cascaded drop
	 * of the whole table, which is surely not what the user expected.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>is_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column \"%s\" because it is part of the partition key of relation \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>children</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In case of a partitioned table, the column must be dropped from the
		 * partitions as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name></decl>;</decl_stmt>

			<comment type="block">/* find_inheritance_children already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute \"%s\" of relation %u"</literal></expr></argument>,
					 <argument><expr><name>colName</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>childatt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited attribute \"%s\""</literal></expr></argument>,
					 <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the child column has other definition sources, just
				 * decrement its inheritance count; if not, recurse to delete
				 * it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Time to delete this child column, too */</comment>
					<expr_stmt><expr><call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>,
									 <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Child column must survive my deletion */</comment>
					<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Make update visible */</comment>
					<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If we were told to drop ONLY in this table (no recursion),
				 * we need to mark the inheritors' attributes as locally
				 * defined rather than inherited.
				 */</comment>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make update visible */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform the actual column deletion
	 */</comment>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we dropped the OID column, must adjust pg_class.relhasoids and tell
	 * Phase 3 to physically get rid of the column.  We formerly left the
	 * column in place physically, but this caused subtle problems.  See
	 * http://archives.postgresql.org/pgsql-hackers/2009-02/msg00363.php
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>class_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>tuple_class</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tuple_class</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find or create work queue entry for this table */</comment>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Tell Phase 3 to physically remove the OID column */</comment>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_OID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>object</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD INDEX
 *
 * There is no such command in the grammar, but parse_utilcmd.c converts
 * UNIQUE and PRIMARY KEY constraints into AT_AddIndex subcommands.  This lets
 * us schedule creation of the index at the appropriate time during ALTER.
 *
 * Return value is the address of the new index.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIndex</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rebuild</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>check_rights</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_build</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>quiet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The IndexStmt has already been through transformIndexStmt */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* suppress schema rights check when rebuilding existing index */</comment>
	<expr_stmt><expr><name>check_rights</name> <operator>=</operator> <operator>!</operator><name>is_rebuild</name></expr>;</expr_stmt>
	<comment type="block">/* skip index build if phase 3 will do it or we're reusing an old one */</comment>
	<expr_stmt><expr><name>skip_build</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* suppress notices when rebuilding existing index */</comment>
	<expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>is_rebuild</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>stmt</name></expr></argument>,
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no predefined OID */</comment>
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent index */</comment>
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
						  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* is_alter_table */</comment>
						  <argument><expr><name>check_rights</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* check_not_in_use - we did it already */</comment>
						  <argument><expr><name>skip_build</name></expr></argument>,
						  <argument><expr><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If TryReuseIndex() stashed a relfilenode for us, we used it for the new
	 * index instead of building from scratch.  The DROP of the old edition of
	 * this index will have scheduled the storage for deletion at commit, so
	 * cancel that pending deletion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RelationPreserveStorage</name><argument_list>(<argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD CONSTRAINT USING INDEX
 *
 * Returns the address of the new constraint.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIndexConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>index_oid</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>indexOid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indexName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>constraintName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>constraintType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type>		<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Doing this on partitioned tables is not a simple feature to implement,
	 * so let's punt for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this should have been checked at parse time */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" is not unique"</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine name to assign to constraint.  We require a constraint to
	 * have the same name as the underlying index; therefore, use the index's
	 * existing name as the default constraint name, and if the user
	 * explicitly gives some other name for the constraint, rename the index
	 * to match.
	 */</comment>
	<expr_stmt><expr><name>constraintName</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>constraintName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constraintName</name> <operator>=</operator> <name>indexName</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index \"%s\" to \"%s\""</literal></expr></argument>,
						<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Extra checks needed if making primary key */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_check_primary_key</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note we currently don't support EXCLUSION constraints here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_PRIMARY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_UNIQUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Create the catalog entries for the constraint */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>INDEX_CONSTR_CREATE_UPDATE_INDEX</name> <operator>|</operator>
		<name>INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS</name> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>initdeferred</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_INIT_DEFERRED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>deferrable</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_DEFERRABLE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_MARK_AS_PRIMARY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>index_constraint_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
									  <argument><expr><name>index_oid</name></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
									  <argument><expr><name>indexInfo</name></expr></argument>,
									  <argument><expr><name>constraintName</name></expr></argument>,
									  <argument><expr><name>constraintType</name></expr></argument>,
									  <argument><expr><name>flags</name></expr></argument>,
									  <argument><expr><name>allowSystemTableMods</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD CONSTRAINT
 *
 * Return value is the address of the new constraint; if no constraint was
 * added, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we only expect to see CONSTR_CHECK and CONSTR_FOREIGN nodes
	 * arriving here (see the preprocessing done in parse_utilcmd.c).  Use a
	 * switch anyway to make it easier to add more code later.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>newConstraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
									 <argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>,
									 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>

			<comment type="block">/*
			 * Note that we currently never recurse for FK constraints, so the
			 * "recurse" flag is silently ignored.
			 *
			 * Assign or validate constraint name
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>,
										 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
									<argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator>
					<call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><literal type="string">"fkey"</literal></expr></argument>,
										 <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATAddForeignKeyConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
												<argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
												<argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>newConstraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a check constraint to a single table and its children.  Returns the
 * address of the constraint added to the parent relation, if one gets added,
 * or InvalidObjectAddress otherwise.
 *
 * Subroutine for ATExecAddConstraint.
 *
 * We must recurse to child tables during execution, rather than using
 * ALTER TABLE's normal prep-time recursion.  The reason is that all the
 * constraints *must* be given the same name, else they won't be seen as
 * related later.  If the user didn't explicitly specify a name, then
 * AddRelationNewConstraints would normally assign different names to the
 * child constraints.  To fix that, we must capture the name assigned at
 * the parent table and pass that down.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATAddCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcons</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call AddRelationNewConstraints to do the work, making sure it works on
	 * a copy of the Constraint so transformExpr can't modify the original. It
	 * returns a list of cooked constraints.
	 *
	 * If the constraint ends up getting merged with a pre-existing one, it's
	 * omitted from the returned list, which is what we want: we do not need
	 * to do any validation work.  That can only happen at child tables,
	 * though, since we disallow merging at the top level.
	 */</comment>
	<expr_stmt><expr><name>newcons</name> <operator>=</operator> <call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>recursing</name> <operator>|</operator> <name>is_readd</name></expr></argument>,	<comment type="block">/* allow_merge */</comment>
										<argument><expr><operator>!</operator><name>recursing</name></expr></argument>, <comment type="block">/* is_local */</comment>
										<argument><expr><name>is_readd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>

	<comment type="block">/* we don't expect more than one constraint here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>newcons</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add each to-be-validated constraint to Phase 3's queue */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcon</argument>, <argument>newcons</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>ccon</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ccon</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Save the actually assigned name if it was defaulted */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* At this point we must have a locked-down name to use */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Advance command counter in case same table is visited multiple times */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the constraint got merged with an existing constraint, we're done.
	 * We mustn't recurse to child tables in this case, because they've
	 * already got the constraint, and visiting them again would lead to an
	 * incorrect value for coninhcount.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newcons</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If adding a NO INHERIT constraint, no need to find our children.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if ONLY was specified with ALTER TABLE.  If so, allow the
	 * constraint creation only if there are no children currently.  Error out
	 * otherwise.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <name>children</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

		<comment type="block">/* find_inheritance_children already got lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find or create work queue entry for this table */</comment>
		<expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recurse to child */</comment>
		<expr_stmt><expr><call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
							 <argument><expr><name>constr</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a foreign-key constraint to a single table; return the new constraint's
 * address.
 *
 * Subroutine for ATExecAddConstraint.  Must already hold exclusive
 * lock on the rel, and have done appropriate validity checks for it.
 * We do permissions checks here, however.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATAddForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pkrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>pkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>fkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pktypoid</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>fktypoid</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>opclasses</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pfeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>ppeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>ffeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>connoinherit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numfks</name></decl>,
				<decl><type ref="prev"/><name>numpks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_check_ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>old_pfeqop_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab ShareRowExclusiveLock on the pk table, so that someone doesn't
	 * delete rows out from under us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_pktable_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_pktable_oid</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Validity checks (permission checks wait till we have the column
	 * numbers)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reference partitioned table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use ONLY for foreign key on partitioned table \"%s\" referencing relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add NOT VALID foreign key on partitioned table \"%s\" referencing relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This feature is not yet supported on partitioned tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referenced relation \"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * References from permanent or unlogged tables to temp tables, and from
	 * permanent tables to unlogged tables, are disallowed because the
	 * referenced data can vanish out from under us.  References from temp
	 * tables to any other table type are also disallowed, because other
	 * backends might need to run the RI triggers on the perm table, but they
	 * can't reliably see tuples in the local buffers of other backends.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on permanent tables may reference only permanent tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name>
				<operator>&amp;&amp;</operator> <name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on unlogged tables may reference only permanent or unlogged tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables may reference only temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pkrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>||</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables must involve temporary tables of this session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Look up the referencing attributes to make sure they exist, and record
	 * their attnums and type OIDs.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pkattnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fkattnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fkattnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pktypoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pktypoid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fktypoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fktypoid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opclasses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pfeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pfeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ppeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ppeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ffeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numfks</name> <operator>=</operator> <call><name>transformColumnNameList</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>,
									 <argument><expr><name>fkattnum</name></expr></argument>, <argument><expr><name>fktypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the attribute list for the referenced table was omitted, lookup the
	 * definition of the primary key and use it.  Otherwise, validate the
	 * supplied attribute list.  In either case, discover the index OID and
	 * index opclasses, and the attnums and type OIDs of the attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numpks</name> <operator>=</operator> <call><name>transformFkeyGetPrimaryKey</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexOid</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>,
											<argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>pktypoid</name></expr></argument>,
											<argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>numpks</name> <operator>=</operator> <call><name>transformColumnNameList</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>,
										 <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>pktypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Look for an index matching the column list */</comment>
		<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>transformFkeyCheckAttrs</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>numpks</name></expr></argument>, <argument><expr><name>pkattnum</name></expr></argument>,
										   <argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now we can check permissions.
	 */</comment>
	<expr_stmt><expr><call><name>checkFkeyPermissions</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>numpks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the equality operators to use in the constraint.
	 *
	 * Note that we have to be careful about the difference between the actual
	 * PK column type and the opclass' declared input type, which might be
	 * only binary-compatible with it.  The declared opcintype is the right
	 * thing to probe pg_amop with.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numfks</name> <operator>!=</operator> <name>numpks</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of referencing and referenced columns for foreign key disagree"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On the strength of a previous constraint, we might avoid scanning
	 * tables to validate this one.  See below.
	 */</comment>
	<expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>old_check_ok</name> <operator>||</operator> <name>numfks</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numpks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pktype</name> <init>= <expr><name><name>pktypoid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fktype</name> <init>= <expr><name><name>fktypoid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fktyped</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>cla_ht</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>amid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pfeqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ppeqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ffeqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>eqstrategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pfeqop_right</name></decl>;</decl_stmt>

		<comment type="block">/* We need several fields out of the pg_opclass entry */</comment>
		<expr_stmt><expr><name>cla_ht</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amid</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcmethod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check it's a btree; currently this can never fail since no other
		 * index AMs support unique indexes.  If we ever did have other types
		 * of unique indexes, we'd need a way to determine which operator
		 * strategy number is equality.  (Is it reasonable to insist that
		 * every such index AM use btree's number for equality?)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>amid</name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only b-tree indexes are supported for foreign keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>eqstrategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * There had better be a primary equality operator for the index.
		 * We'll use it for PK = PK comparisons.
		 */</comment>
		<expr_stmt><expr><name>ppeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>,
									 <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ppeqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name>eqstrategy</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Are there equality operators that take exactly the FK type? Assume
		 * we should look through any domain here.
		 */</comment>
		<expr_stmt><expr><name>fktyped</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>fktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pfeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>,
									 <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>fktyped</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ffeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>,
										 <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ffeqop</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ffeqop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, look for an implicit cast from the FK type to the
			 * opcintype, and if found, use the primary equality operator.
			 * This is a bit tricky because opcintype might be a polymorphic
			 * type such as ANYARRAY or ANYENUM; so what we have to test is
			 * whether the two actual column types can be concurrently cast to
			 * that type.  (Otherwise, we'd fail to reject combinations such
			 * as int[] and point[].)
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name><name>input_typeids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name><name>target_typeids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>input_typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pktype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>input_typeids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fktype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target_typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target_typeids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>input_typeids</name></expr></argument>, <argument><expr><name>target_typeids</name></expr></argument>,
								<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pfeqop</name> <operator>=</operator> <name>ffeqop</name> <operator>=</operator> <name>ppeqop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ffeqop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraint \"%s\" "</literal>
							<literal type="string">"cannot be implemented"</literal></expr></argument>,
							<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key columns \"%s\" and \"%s\" "</literal>
							   <literal type="string">"are of incompatible types: %s and %s."</literal></expr></argument>,
							   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>fktype</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>pktype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>old_check_ok</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When a pfeqop changes, revalidate the constraint.  We could
			 * permit intra-opfamily changes, but that adds subtle complexity
			 * without any concrete benefit for core types.  We need not
			 * assess ppeqop or ffeqop, which RI_Initial_Check() does not use.
			 */</comment>
			<expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name>pfeqop</name> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>old_pfeqop_item</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_pfeqop_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>old_pfeqop_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>old_check_ok</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>old_fktype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>new_fktype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>old_pathtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>new_pathtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>old_castfunc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>new_castfunc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr></argument>,
												   <argument><expr><name><name>fkattnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Identify coercion pathways from each of the old and new FK-side
			 * column types to the right (foreign) operand type of the pfeqop.
			 * We may assume that pg_constraint.conkey is not changing.
			 */</comment>
			<expr_stmt><expr><name>old_fktype</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_fktype</name> <operator>=</operator> <name>fktype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_pathtype</name> <operator>=</operator> <call><name>findFkeyCast</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>, <argument><expr><name>old_fktype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>old_castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <call><name>findFkeyCast</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>, <argument><expr><name>new_fktype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>new_castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Upon a change to the cast from the FK column to its pfeqop
			 * operand, revalidate the constraint.  For this evaluation, a
			 * binary coercion cast is equivalent to no cast at all.  While
			 * type implementors should design implicit casts with an eye
			 * toward consistency of operations like equality, we cannot
			 * assume here that they have done so.
			 *
			 * A function with a polymorphic argument could change behavior
			 * arbitrarily in response to get_fn_expr_argtype().  Therefore,
			 * when the cast destination is polymorphic, we only avoid
			 * revalidation if the input type has not changed at all.  Given
			 * just the core data types and operator classes, this requirement
			 * prevents no would-be optimizations.
			 *
			 * If the cast converts from a base type to a domain thereon, then
			 * that domain type must be the opcintype of the unique index.
			 * Necessarily, the primary key column must then be of the domain
			 * type.  Since the constraint was previously valid, all values on
			 * the foreign side necessarily exist on the primary side and in
			 * turn conform to the domain.  Consequently, we need not treat
			 * domains specially here.
			 *
			 * Since we require that all collations share the same notion of
			 * equality (which they do, because texteq reduces to bitwise
			 * equality), we don't compare collation here.
			 *
			 * We need not directly consider the PK type.  It's necessarily
			 * binary coercible to the opcintype of the unique index column,
			 * and ri_triggers.c will only deal with PK datums in terms of
			 * that opcintype.  Changing the opcintype also changes pfeqop.
			 */</comment>
			<expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name>new_pathtype</name> <operator>==</operator> <name>old_pathtype</name> <operator>&amp;&amp;</operator>
							<name>new_castfunc</name> <operator>==</operator> <name>old_castfunc</name> <operator>&amp;&amp;</operator>
							<operator>(</operator><operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>)</argument_list></call> <operator>||</operator>
							 <name>new_fktype</name> <operator>==</operator> <name>old_fktype</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>pfeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pfeqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ppeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ppeqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ffeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ffeqop</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * FKs always inherit for partitioned tables, and never for legacy
	 * inheritance.
	 */</comment>
	<expr_stmt><expr><name>connoinherit</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record the FK constraint in pg_constraint.
	 */</comment>
	<expr_stmt><expr><name>constrOid</name> <operator>=</operator> <call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
									  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name></expr></argument>,
									  <argument><expr><name>parentConstr</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>fkattnum</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* not a domain constraint */</comment>
									  <argument><expr><name>indexOid</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>pkattnum</name></expr></argument>,
									  <argument><expr><name>pfeqoperators</name></expr></argument>,
									  <argument><expr><name>ppeqoperators</name></expr></argument>,
									  <argument><expr><name>ffeqoperators</name></expr></argument>,
									  <argument><expr><name>numpks</name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no exclusion constraint */</comment>
									  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no check constraint */</comment>
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* islocal */</comment>
									  <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* inhcount */</comment>
									  <argument><expr><name>connoinherit</name></expr></argument>,	<comment type="block">/* conNoInherit */</comment>
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the triggers that will enforce the constraint.  We only want the
	 * action triggers to appear for the parent partitioned relation, even
	 * though the constraints also exist below.
	 */</comment>
	<expr_stmt><expr><call><name>createForeignKeyTriggers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>,
							 <argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><operator>!</operator><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Tell Phase 3 to check that the constraint is satisfied by existing
	 * rows. We can skip this during table creation, when requested explicitly
	 * by specifying NOT VALID in an ADD FOREIGN KEY command, and when we're
	 * recreating a constraint following a SET DATA TYPE operation that did
	 * not impugn its validity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_check_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_FOREIGN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <name>constrOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fkconstraint</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When called on a partitioned table, recurse to create the constraint on
	 * the partitions also.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_constraint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cloned</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>partitionId</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partition</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CloneFkReferencing</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>,
							   <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>cloned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>cloned</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ClonedConstraint</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>(</operator><name>ClonedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>    <name>partition</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

			<comment type="block">/* Find or create work queue entry for this partition */</comment>
			<expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>constraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_FOREIGN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>refrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>conid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fkconstraint</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>childtab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>childtab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Close pk table, but keep lock until we've committed.
	 */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CloneForeignKeyConstraints
 *		Clone foreign keys from a partitioned table to a newly acquired
 *		partition.
 *
 * relationId is a partition of parentId, so we can be certain that it has the
 * same columns with the same datatypes.  The columns may be in different
 * order, though.
 *
 * The *cloned list is appended ClonedConstraint elements describing what was
 * created, for the purposes of validating the constraint in ALTER TABLE's
 * Phase 3.
 */</comment>
<function><type><name>void</name></type>
<name>CloneForeignKeyConstraints</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>cloned</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_constraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parentRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clone</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>parentRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* already got lock */</comment>
	<comment type="block">/* see ATAddForeignKeyConstraint about lock level */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Obtain the list of constraints to clone or attach */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>		<name>oid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>clone</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the actual work, recursing to partitions as needed */</comment>
	<expr_stmt><expr><call><name>CloneFkReferencing</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>parentRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>clone</name></expr></argument>, <argument><expr><name>cloned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We're done.  Clean up */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep lock till commit */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CloneFkReferencing
 *		Recursive subroutine for CloneForeignKeyConstraints, referencing side
 *
 * Clone the given list of FK constraints when a partition is attached on the
 * referencing side of those constraints.
 *
 * When cloning foreign keys to a partition, it may happen that equivalent
 * constraints already exist in the partition for some of them.  We can skip
 * creating a clone in that case, and instead just attach the existing
 * constraint to the one in the parent.
 *
 * This function recurses to partitions, if the new partition is partitioned;
 * of course, only do this for FKs that were actually cloned.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneFkReferencing</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_constraint</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>partRel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clone</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>cloned</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partFKs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subclone</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The constraint key may differ, if the columns in the partition are
	 * different.  This map is used to convert them.
	 */</comment>
	<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partFKs</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>clone</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentConstrOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numfks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>conkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>mapped_conkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>confkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conpfeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conppeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conffeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attach_it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>parentAddr</name></decl>,
					<decl><type ref="prev"/><name>childAddr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
				 <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* only foreign keys */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>constrForm</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>parentAddr</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DeconstructFkConstraintRow</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numfks</name></expr></argument>, <argument><expr><name>conkey</name></expr></argument>, <argument><expr><name>confkey</name></expr></argument>,
								   <argument><expr><name>conpfeqop</name></expr></argument>, <argument><expr><name>conppeqop</name></expr></argument>, <argument><expr><name>conffeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mapped_conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attmap</name><index>[<expr><name><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * Before creating a new constraint, see whether any existing FKs are
		 * fit for the purpose.  If one is, attach the parent constraint to it,
		 * and don't clone anything.  This way we avoid the expensive
		 * verification step and don't end up with a duplicate FK.  This also
		 * means we don't consider this constraint when recursing to
		 * partitions.
		 */</comment>
		<expr_stmt><expr><name>attach_it</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>partFKs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>partConstr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>partcontup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>trigrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>trigtup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attach_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do some quick &amp; easy initial checks.  If any of these fail, we
			 * cannot use this constraint, but keep looking.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fk</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>!=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>||</operator> <name><name>fk</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>!=</operator> <name>numfks</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>attach_it</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>fk</name><operator>-&gt;</operator><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>mapped_conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
					<name><name>fk</name><operator>-&gt;</operator><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
					<name><name>fk</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>conpfeqop</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>attach_it</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attach_it</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Looks good so far; do some more extensive checks.  Presumably
			 * the check for 'convalidated' could be dropped, since we don't
			 * really care about that, but let's be careful for now.
			 */</comment>
			<expr_stmt><expr><name>partcontup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
					 <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>partConstr</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partConstr</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><name><name>partConstr</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>||</operator>
				<name><name>partConstr</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>||</operator>
				<name><name>partConstr</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>||</operator>
				<name><name>partConstr</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>!=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>||</operator>
				<name><name>partConstr</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>!=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>||</operator>
				<name><name>partConstr</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>!=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attach_it</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Looks good!  Attach this constraint.  The action triggers in
			 * the new partition become redundant -- the parent table already
			 * has equivalent ones, and those will be able to reach the
			 * partition.  Remove the ones in the partition.  We identify them
			 * because they have our constraint OID, as well as being on the
			 * referenced rel.
			 */</comment>
			<expr_stmt><expr><name>trigrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
						<argument><expr><name>Anum_pg_trigger_tgconstraint</name></expr></argument>,
						<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>trigrel</name></expr></argument>, <argument><expr><name>TriggerConstraintIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>trigtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_trigger</name></type>	<name>trgform</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>trigtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ObjectAddress</name></type>	<name>trigger</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>trgform</name><operator>-&gt;</operator><name>tgconstrrelid</name></name> <operator>!=</operator> <name><name>fk</name><operator>-&gt;</operator><name>conrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>trgform</name><operator>-&gt;</operator><name>tgrelid</name></name> <operator>!=</operator> <name><name>fk</name><operator>-&gt;</operator><name>confrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * The constraint is originally set up to contain this trigger
				 * as an implementation object, so there's a dependency record
				 * that links the two; however, since the trigger is no longer
				 * needed, we remove the dependency link in order to be able
				 * to drop the trigger while keeping the constraint intact.
				 */</comment>
				<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>,
										   <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>trigtup</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* make dependency deletion visible to performDeletion */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>,
								 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>trigtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trigger</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* make trigger drop visible, in case the loop iterates */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>trigrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attach_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<comment type="block">/*
		 * If we attached to an existing constraint, there is no need to
		 * create a new one.  In fact, there's no need to recurse for this
		 * constraint to partitions, either.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attach_it</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>constrOid</name> <operator>=</operator>
			<call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>connamespace</name></name></expr></argument>,
								  <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>condeferrable</name></name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>condeferred</name></name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>convalidated</name></name></expr></argument>,
								  <argument><expr><name>parentConstrOid</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>mapped_conkey</name></expr></argument>,
								  <argument><expr><name>numfks</name></expr></argument>,
								  <argument><expr><name>numfks</name></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* not a domain constraint */</comment>
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>, <comment type="block">/* same index */</comment>
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>,	<comment type="block">/* same foreign rel */</comment>
								  <argument><expr><name>confkey</name></expr></argument>,
								  <argument><expr><name>conpfeqop</name></expr></argument>,
								  <argument><expr><name>conppeqop</name></expr></argument>,
								  <argument><expr><name>conffeqop</name></expr></argument>,
								  <argument><expr><name>numfks</name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subclone</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>subclone</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>childAddr</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>childAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentAddr</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fkconstraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* for now this is all we need */</comment>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>createForeignKeyTriggers</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>,
								 <argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cloned</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ClonedConstraint</name> <modifier>*</modifier></type><name>newc</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Feed back caller about the constraints we created, so that they
			 * can set up constraint verification.
			 */</comment>
			<expr_stmt><expr><name>newc</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ClonedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>conindid</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <name>constrOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>constraint</name></name> <operator>=</operator> <name>fkconstraint</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>cloned</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>cloned</name></expr></argument>, <argument><expr><name>newc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>partFKs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the partition is partitioned, recurse to handle any constraints that
	 * were cloned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name>subclone</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childRel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>childRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloneFkReferencing</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>,
							   <argument><expr><name>partRel</name></expr></argument>,
							   <argument><expr><name>childRel</name></expr></argument>,
							   <argument><expr><name>subclone</name></expr></argument>,
							   <argument><expr><name>cloned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep lock till commit */</comment>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER CONSTRAINT
 *
 * Update the attributes of a constraint.
 *
 * Currently only works for Foreign Key constraints.
 * Foreign keys do not inherit, so we purposely ignore the
 * recursion bit here, but we keep the API the same for when
 * other constraint types are supported.
 *
 * If the constraint is modified, returns its address; otherwise, return
 * InvalidObjectAddress.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>cmdcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>contuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>currcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmdcon</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and check the target constraint
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>contuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>currcon</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>currcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" is not a foreign key constraint"</literal></expr></argument>,
						<argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>currcon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>||</operator>
		<name><name>currcon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tgtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>otherrelids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>tgkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Now update the catalog, while we have the door open.
		 */</comment>
		<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
								  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we need to update the multiple entries in pg_trigger that
		 * implement the constraint.
		 */</comment>
		<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgkey</name></expr></argument>,
					<argument><expr><name>Anum_pg_trigger_tgconstraint</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerConstraintIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tgkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tgtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>tgform</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>copy_tg</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Remember OIDs of other relation(s) involved in FK constraint.
			 * (Note: it's likely that we could skip forcing a relcache inval
			 * for other rels that don't have a trigger whose properties
			 * change, but let's be conservative.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tgform</name><operator>-&gt;</operator><name>tgrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>otherrelids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>otherrelids</name></expr></argument>,
													 <argument><expr><name><name>tgform</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Update deferrability of RI_FKey_noaction_del,
			 * RI_FKey_noaction_upd, RI_FKey_check_ins and RI_FKey_check_upd
			 * triggers, but not others; see createForeignKeyTriggers and
			 * CreateFKCheckTrigger.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_NOACTION_DEL</name> <operator>&amp;&amp;</operator>
				<name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_NOACTION_UPD</name> <operator>&amp;&amp;</operator>
				<name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_CHECK_INS</name> <operator>&amp;&amp;</operator>
				<name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_CHECK_UPD</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copy_tg</name> <operator>=</operator> <operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>copy_tg</name><operator>-&gt;</operator><name>tgdeferrable</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>copy_tg</name><operator>-&gt;</operator><name>tginitdeferred</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>,
									  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate relcache so that others see the new attributes.  We must
		 * inval both the named rel and any others having relevant triggers.
		 * (At present there should always be exactly one other rel, but
		 * there's no need to hard-wire such an assumption here.)
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>otherrelids</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>,
						 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE VALIDATE CONSTRAINT
 *
 * XXX The reason we handle recursion here rather than at Phase 1 is because
 * there's no good way to skip recursing when handling foreign keys: there is
 * no need to lock children in that case, yet we wouldn't be able to avoid
 * doing so at that level.
 *
 * Return value is the address of the validated constraint.  If the constraint
 * was already validated, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecValidateConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and check the target constraint
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" is not a foreign key or check constraint"</literal></expr></argument>,
						<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl>;</decl_stmt>

			<comment type="block">/* Queue validation for phase 3 */</comment>
			<expr_stmt><expr><name>fkconstraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* for now this is all we need */</comment>
			<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name>constrName</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>constrName</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_FOREIGN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fkconstraint</name></expr>;</expr_stmt>

			<comment type="block">/* Find or create work queue entry for this table */</comment>
			<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We disallow creating invalid foreign keys to or from
			 * partitioned tables, so ignoring the recursion bit is okay.
			 */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conbin</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we're recursing, the parent has already done this, so skip
			 * it.  Also, if the constraint is a NO INHERIT constraint, we
			 * shouldn't try to look for it in the children.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * For CHECK constraints, we must ensure that we only mark the
			 * constraint as validated on the parent if it's already validated
			 * on the children.
			 *
			 * We recurse before validating on the parent, to reduce risk of
			 * deadlocks.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>childoid</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If we are told not to recurse, there had better not be any
				 * child tables, because we can't mark the constraint on the
				 * parent valid unless it is valid for all child tables.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be validated on child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* find_all_inheritors already got lock */</comment>
				<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childoid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* Queue validation for phase 3 */</comment>
			<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>constrName</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>,
					 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>conbin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>conbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Find or create work queue entry for this table */</comment>
			<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Invalidate relcache so that others see the new validated
			 * constraint.
			 */</comment>
			<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now update the catalog, while we have the door open.
		 */</comment>
		<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
								  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>,
						 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* already validated */</comment>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformColumnNameList - transform list of column names
 *
 * Lookup each name and return its attnum and type OID
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>transformColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colList</name></decl></parameter>,
						<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>colList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" referenced in foreign key constraint does not exist"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;=</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than %d keys in a foreign key"</literal></expr></argument>,
							<argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atttypids</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFkeyGetPrimaryKey -
 *
 *	Look up the names, attnums, and types of the primary key attributes
 *	for the pkrel.  Also return the index OID and index opclasses of the
 *	index supporting the primary key.
 *
 *	All parameters except pkrel are output parameters.  Also, the function
 *	return value is the number of attributes in the primary key.
 *
 *	Used when the column list in the REFERENCES specification is omitted.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>transformFkeyGetPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexOid</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
						   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the list of index OIDs for the table from the relcache, and look up
	 * each one in the pg_index syscache until we find one marked primary key
	 * (hopefully there isn't more than one such).  Insist it's valid, too.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>&amp;&amp;</operator> <call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Refuse to use a deferrable primary key.  This is per SQL spec,
			 * and there would be a lot of interesting semantic problems if we
			 * tried to allow it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a deferrable primary key for referenced table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>indexOid</name> <operator>=</operator> <name>indexoid</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we found it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no primary key for referenced table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Must get indclass the hard way */</comment>
	<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now build the list of PK attributes from the indkey definition (we
	 * assume a primary key cannot have expressional elements)
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>attnamelist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pkattno</name> <init>= <expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pkattno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atttypids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>attnumTypeId</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>attnamelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>attnamelist</name></expr></argument>,
							   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>attnumAttName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFkeyCheckAttrs -
 *
 *	Make sure that the attributes of a referenced table belong to a unique
 *	(or primary key) constraint.  Return the OID of the index supporting
 *	the constraint, as well as the opclasses associated with the index
 *	columns.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>transformFkeyCheckAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list> <comment type="block">/* output parameter */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_deferrable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject duplicate appearances of columns in the referenced-columns list.
	 * Such a case is forbidden by the SQL standard, and even if we thought it
	 * useful to allow it, there would be ambiguity about how to match the
	 * list to unique indexes (in particular, it'd be unclear which index
	 * opclass goes with which FK column).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>attnums</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key referenced-columns list must not contain duplicates"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Get the list of index OIDs for the table from the relcache, and look up
	 * each one in the pg_index syscache, and match unique indexes to the list
	 * of attnums we are given.
	 */</comment>
	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must have the right number of columns; must be unique and not a
		 * partial index; forget it if there are any expressions, too. Invalid
		 * indexes are out as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name> <operator>==</operator> <name>numattrs</name> <operator>&amp;&amp;</operator>
			<name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
			<call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>heap_attisnull</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>heap_attisnull</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>

			<comment type="block">/* Must get indclass the hard way */</comment>
			<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
											<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The given attnum list may match the index columns in any order.
			 * Check for a match, and extract the appropriate opclasses while
			 * we're at it.
			 *
			 * We know that attnums[] is duplicate-free per the test at the
			 * start of this function, and we checked above that the number of
			 * index columns agrees, so if we find a match for each attnums[]
			 * entry then we must have a one-to-one match in some order.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Refuse to use a deferrable unique/primary key.  This is per SQL
			 * spec, and there would be a lot of interesting semantic problems
			 * if we tried to allow it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Remember that we found an otherwise matching index, so that
				 * we can generate a more appropriate error message.
				 */</comment>
				<expr_stmt><expr><name>found_deferrable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>found_deferrable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a deferrable unique constraint for referenced table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no unique constraint matching given keys for referenced table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>indexoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findFkeyCast -
 *
 *	Wrapper around find_coercion_pathway() for ATAddForeignKeyConstraint().
 *	Caller has equal regard for binary coercibility and for an exact match.
*/</comment>
<function><type><specifier>static</specifier> <name>CoercionPathType</name></type>
<name>findFkeyCast</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>sourceTypeId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>sourceTypeId</name></expr></argument>,
									<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>COERCION_PATH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* A previously-relied-upon cast is now gone. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find cast from %u to %u"</literal></expr></argument>,
				 <argument><expr><name>sourceTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Permissions checks on the referenced table for ADD FOREIGN KEY
 *
 * Note: we have already checked that the user owns the referencing table,
 * else we'd have failed much earlier; no additional checks are needed for it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkFkeyPermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Okay if we have relation-level REFERENCES permission */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
								  <argument><expr><name>ACL_REFERENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>==</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Else we must have REFERENCES on each column */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ACL_REFERENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the existing rows in a table to verify they meet a proposed FK
 * constraint.
 *
 * Caller must have opened and locked both relations appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>pkindOid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Trigger</name></type>		<name>trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"validating foreign key constraint \"%s\""</literal></expr></argument>, <argument><expr><name>conname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a trigger call structure; we'll need it either way.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgname</name></name> <operator>=</operator> <name>conname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgenabled</name></name> <operator>=</operator> <name>TRIGGER_FIRES_ON_ORIGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgisinternal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrindid</name></name> <operator>=</operator> <name>pkindOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstraint</name></name> <operator>=</operator> <name>constraintOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgdeferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tginitdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* we needn't fill in remaining fields */</comment>

	<comment type="block">/*
	 * See if we can do it with a single LEFT JOIN query.  A false result
	 * indicates we must proceed with the fire-the-trigger method.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RI_Initial_Check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan through each tuple, calling RI_FKey_check_ins (insert trigger) as
	 * if that tuple had just been inserted.  If any of those fail, it should
	 * ereport(ERROR) and that's that.
	 */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make a call to the trigger function
		 *
		 * No parameters are passed, but we do set a context
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume RI_FKey_check_ins won't look at flinfo...
		 */</comment>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>|</operator> <name>TRIGGER_EVENT_ROW</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <operator>&amp;</operator><name>trig</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigtuplebuf</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_newtuplebuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>.</operator><name>context</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>trigdata</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RI_FKey_check_ins</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateFKCheckTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>on_insert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>fk_trigger</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: for a self-referential FK (referencing and referenced tables are
	 * the same), it is important that the ON UPDATE action fires before the
	 * CHECK action, since both triggers will fire on the same row during an
	 * UPDATE event; otherwise the CHECK trigger will be checking a non-final
	 * state of the row.  Triggers fire in name order, so we ensure this by
	 * using names like "RI_ConstraintTrigger_a_NNNN" for the action triggers
	 * and "RI_ConstraintTrigger_c_NNNN" for the check triggers.
	 */</comment>
	<expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_c"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>

	<comment type="block">/* Either ON INSERT or ON UPDATE */</comment>
	<if_stmt><if>if <condition>(<expr><name>on_insert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_check_ins"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_INSERT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_check_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make changes-so-far visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * createForeignKeyActionTriggers
 *		Create the referenced-side "action" triggers that implement a foreign
 *		key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createForeignKeyActionTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>fk_trigger</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON
	 * DELETE action on the referenced table.
	 */</comment>
	<expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_a"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_DELETE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_noaction_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_restrict_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_cascade_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setnull_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setdefault_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized FK action type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make changes-so-far visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON
	 * UPDATE action on the referenced table.
	 */</comment>
	<expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_a"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_noaction_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_restrict_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_cascade_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setnull_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setdefault_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized FK action type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * createForeignKeyCheckTriggers
 *		Create the referencing-side "check" triggers that implement a foreign
 *		key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createForeignKeyCheckTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>,
							  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateFKCheckTrigger</name><argument_list>(<argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateFKCheckTrigger</name><argument_list>(<argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the triggers that implement an FK constraint.
 *
 * NB: if you change any trigger properties here, see also
 * ATExecAlterConstraint.
 */</comment>
<function><type><name>void</name></type>
<name>createForeignKeyTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For the referenced side, create action triggers, if requested.  (If the
	 * referencing side is partitioned, there is still only one trigger, which
	 * runs on the referenced side and points to the top of the referencing
	 * hierarchy.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_action</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>createForeignKeyActionTriggers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
									   <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For the referencing side, create the check triggers.  We only need
	 * these on the partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>createForeignKeyCheckTriggers</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>,
									  <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE DROP CONSTRAINT
 *
 * Like DROP COLUMN, we can't use the normal ALTER TABLE recursion mechanism.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
					 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_no_inherit_constraint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>contype</name></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and drop the target constraint
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>conobj</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Don't drop inherited constraints */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop inherited constraint \"%s\" of relation \"%s\""</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>is_no_inherit_constraint</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>contype</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a foreign-key constraint, we'd better lock the referenced
		 * table and check that that's not in use, just as we've already done
		 * for the constrained table (else we might, eg, be dropping a trigger
		 * that has unfired events).  But we can/must skip that in the
		 * self-referential case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
			<name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>frel</name></decl>;</decl_stmt>

			<comment type="block">/* Must match lock taken by RemoveTriggerById: */</comment>
			<expr_stmt><expr><name>frel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Perform the actual constraint deletion
		 */</comment>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conobj</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For partitioned tables, non-CHECK inherited constraints are dropped via
	 * the dependency mechanism, so we're done here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_no_inherit_constraint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>children</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For a partitioned table, if partitions exist and we are told not to
	 * recurse, it's a user error.  It doesn't make sense to have a constraint
	 * be defined only on the parent, especially if it's a partitioned table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name>children</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove constraint from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copy_tuple</name></decl>;</decl_stmt>

		<comment type="block">/* find_inheritance_children already got lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
					<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* There can be at most one matching row */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>copy_tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Right now only CHECK constraints can be inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inherited constraint is not a CHECK constraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited constraint \"%s\""</literal></expr></argument>,
				 <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the child constraint has other definition sources, just
			 * decrement its inheritance count; if not, recurse to delete it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Time to delete this child constraint, too */</comment>
				<expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Child constraint must survive my deletion */</comment>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make update visible */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we were told to drop ONLY in this table (no recursion), we
			 * need to mark the inheritors' constraints as locally defined
			 * rather than inherited.
			 */</comment>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make update visible */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN TYPE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAlterColumnType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
					  <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>transform</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>targettypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targetcollid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_expr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter column type of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* lookup the attribute so we can check inheritance status */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Can't alter a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't alter inherited columns.  At outer level, there had better not be
	 * any inherited definition; when recursing, we assume this was checked at
	 * the parent level (see below).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter inherited column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't alter columns used in the partition key */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>is_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter column \"%s\" because it is part of the partition key of relation \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look up the target type */</comment>
	<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And the collation */</comment>
	<expr_stmt><expr><name>targetcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure datatype is legal for a column */</comment>
	<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name>colName</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targetcollid</name></expr></argument>,
					   <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set up an expression to transform the old data value to the new
		 * type. If a USING option was given, use the expression as
		 * transformed by transformAlterTableStmt, else just take the old
		 * value and try to coerce it.  We do this first so that type
		 * incompatibility can be detected before we waste effort, and because
		 * we need the expression to be parsed against the original table row
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transform</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>transform</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
										 <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
										 <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>transform</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name>transform</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
										  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
										  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>transform</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* error text depends on whether USING was specified or not */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result of USING clause for column \"%s\""</literal>
								<literal type="string">" cannot be cast automatically to type %s"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to add an explicit cast."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: USING is SQL, don't translate it */</comment>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to specify \"USING %s::%s\"."</literal></expr></argument>,
								 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>,
														  <argument><expr><name>targettypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fix collations after all else */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Plan the expr now so we can accurately assess the need to rewrite. */</comment>
		<expr_stmt><expr><name>transform</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add a work queue item to make ATRewriteTable update the column
		 * contents.
		 */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>transform</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ATColumnChangeRequiresRewrite</name><argument_list>(<argument><expr><name>transform</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_COLUMN_REWRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>transform</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
		<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For composite types, do this check now.  Tables will check it later
		 * when the table is being rewritten.
		 */</comment>
		<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recurse manually by queueing a new command for each child, if
	 * necessary. We cannot apply ATSimpleRecursion here because we need to
	 * remap attribute numbers in the USING expression, if any.
	 *
	 * If we are told not to recurse, there had better not be any child
	 * tables; else the alter would put them out of step.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * find_all_inheritors does the recursive search of the inheritance
		 * hierarchy, so all we have to do is process all of the relids in the
		 * list that it returns.
		 */</comment>
		<macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>childtuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childattTup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Verify that the child doesn't have any inherited definitions of
			 * this column that came from outside this inheritance hierarchy.
			 * (renameatt makes a similar test, though in a different way
			 * because of its different recursion mechanism.)
			 */</comment>
			<expr_stmt><expr><name>childtuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>childtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>childattTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>childtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>childattTup</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <name>numparents</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter inherited column \"%s\" of relation \"%s\""</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>childtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remap the attribute numbers.  If no USING expression was
			 * specified, there is no need for this step.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<comment type="block">/* create a copy to scribble on */</comment>
				<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>cooked_default</name> <operator>=</operator>
					<call><name>map_variable_attnos</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></argument>,
										<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"USING expression contains a whole-row table reference."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
			 <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of inherited column \"%s\" must be changed in child tables too"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When the data type of a column is changed, a rewrite might not be required
 * if the new type is sufficiently identical to the old one, and the USING
 * clause isn't trying to insert some other value.  It's safe to skip the
 * rewrite if the old type is binary coercible to the new type, or if the
 * new type is an unconstrained domain over the old type.  In the case of a
 * constrained domain, we could get by with scanning the table and checking
 * the constraint rather than actually rewriting it, but we don't currently
 * try to do that.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ATColumnChangeRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* only one varno, so no need to check that */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>varattno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN .. SET DATA TYPE
 *
 * Return the address of the modified column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterColumnType</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>,
				<decl><type ref="prev"/><name>attOldTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>tform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>targettypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targetcollid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defaultexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Clear all the missing values if we're rewriting the table, since this
	 * renders them pointless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>    <name>newrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearMissing</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make sure we don't conflict with later attribute modifications */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the target column */</comment>
	<expr_stmt><expr><name>heapTup</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attOldTup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for multiple ALTER TYPE on same column --- can't cope */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>attOldTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
		<name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>attOldTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column \"%s\" twice"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look up the target type (should not fail, since prep found it) */</comment>
	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targettype</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And the collation */</comment>
	<expr_stmt><expr><name>targetcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a default expression for the column, get it and ensure we
	 * can coerce it to the new datatype.  (We must do this before changing
	 * the column type, because build_column_default itself will try to
	 * coerce, and will not issue the error message we want if it fails.)
	 *
	 * We remove any implicit coercion steps at the top level of the old
	 * default expression; this has been agreed to satisfy the principle of
	 * least surprise.  (The conversion to the new column type should act like
	 * it started from what the user sees as the stored expression, and the
	 * implicit coercions aren't going to be shown.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no UNKNOWN params */</comment>
											<argument><expr><name>defaultexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
											<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
											<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>defaultexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"default for column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Find everything that depends on the column (constraints, indexes, etc),
	 * and record enough information to let us recreate the objects.
	 *
	 * The actual recreation does not happen here, but only after we have
	 * performed all the individual ALTER TYPE operations.  We have to save
	 * the info before executing ALTER TYPE, though, else the deparser will
	 * get confused.
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>foundObject</name></decl>;</decl_stmt>

		<comment type="block">/* We don't expect any PIN dependencies on columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_PIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot alter type of a pinned column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
						<name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>RememberIndexForRebuilding</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * This must be a SERIAL column's sequence.  We need
						 * not do anything to it.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Not expecting any other direct dependencies... */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object depending on column: %s"</literal></expr></argument>,
							 <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>RememberConstraintForRebuilding</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_REWRITE</name></expr>:</case>
				<comment type="block">/* XXX someday see if we can cope with revising views */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used by a view or rule"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_TRIGGER</name></expr>:</case>

				<comment type="block">/*
				 * A trigger can depend on a column because the column is
				 * specified as an update target, or because the column is
				 * used in the trigger's WHEN condition.  The first case would
				 * not require any extra work, but the second case would
				 * require updating the WHEN expression, which will take a
				 * significant amount of new code.  Since we can't easily tell
				 * which case applies, we punt for both.  FIXME someday.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in a trigger definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_POLICY</name></expr>:</case>

				<comment type="block">/*
				 * A policy can depend on a column because the column is
				 * specified in the policy's USING or WITH CHECK qual
				 * expressions.  It might be possible to rewrite and recheck
				 * the policy expression, but punt for now.  It's certainly
				 * easy enough to remove and recreate the policy; still, FIXME
				 * someday.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in a policy definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_DEFAULT</name></expr>:</case>

				<comment type="block">/*
				 * Ignore the column's default expression, since we will fix
				 * it below.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_STATISTIC_EXT</name></expr>:</case>

				<comment type="block">/*
				 * Give the extended-stats machinery a chance to fix anything
				 * that this column type change would break.
				 */</comment>
				<expr_stmt><expr><call><name>UpdateStatisticsForTypeChange</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>,
											  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
											  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_PROC</name></expr>:</case>
			<case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
			<case>case <expr><name>OCLASS_CAST</name></expr>:</case>
			<case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
			<case>case <expr><name>OCLASS_CONVERSION</name></expr>:</case>
			<case>case <expr><name>OCLASS_LANGUAGE</name></expr>:</case>
			<case>case <expr><name>OCLASS_LARGEOBJECT</name></expr>:</case>
			<case>case <expr><name>OCLASS_OPERATOR</name></expr>:</case>
			<case>case <expr><name>OCLASS_OPCLASS</name></expr>:</case>
			<case>case <expr><name>OCLASS_OPFAMILY</name></expr>:</case>
			<case>case <expr><name>OCLASS_AM</name></expr>:</case>
			<case>case <expr><name>OCLASS_AMOP</name></expr>:</case>
			<case>case <expr><name>OCLASS_AMPROC</name></expr>:</case>
			<case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSPARSER</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSTEMPLATE</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
			<case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
			<case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
			<case>case <expr><name>OCLASS_TBLSPACE</name></expr>:</case>
			<case>case <expr><name>OCLASS_FDW</name></expr>:</case>
			<case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
			<case>case <expr><name>OCLASS_USER_MAPPING</name></expr>:</case>
			<case>case <expr><name>OCLASS_DEFACL</name></expr>:</case>
			<case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
			<case>case <expr><name>OCLASS_EVENT_TRIGGER</name></expr>:</case>
			<case>case <expr><name>OCLASS_PUBLICATION</name></expr>:</case>
			<case>case <expr><name>OCLASS_PUBLICATION_REL</name></expr>:</case>
			<case>case <expr><name>OCLASS_SUBSCRIPTION</name></expr>:</case>
			<case>case <expr><name>OCLASS_TRANSFORM</name></expr>:</case>

				<comment type="block">/*
				 * We don't expect any of these sorts of objects to depend on
				 * a column.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object depending on column: %s"</literal></expr></argument>,
					 <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * There's intentionally no default: case here; we want the
				 * compiler to warn if a new OCLASS hasn't been handled above.
				 */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan for dependencies of this column on other things.  The only
	 * thing we should find is the dependency on the column datatype, which we
	 * want to remove, and possibly a collation dependency.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_NORMAL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected dependency type '%c'"</literal></expr></argument>,
				 <argument><expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>TypeRelationId</name> <operator>&amp;&amp;</operator>
			  <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>CollationRelationId</name> <operator>&amp;&amp;</operator>
			  <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected dependency for column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>depTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here we go --- change the recorded column type and collation.  (Note
	 * heapTup is a copy of the syscache entry, so okay to scribble on.)
	 * First fix up the missing value if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>       <name>missingval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>        <name>missingNull</name></decl>;</decl_stmt>

		<comment type="block">/* if rewrite is true the missing value should already be cleared */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the missing value datum */</comment>
		<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>,
								  <argument><expr><name>Anum_pg_attribute_attmissingval</name></expr></argument>,
								  <argument><expr><name><name>attrelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>missingNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if it's a null array there is nothing to do */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>missingNull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Get the datum out of the array and repack it in a new array
			 * built with the new type data. We assume that since the table
			 * doesn't need rewriting, the actual Datum doesn't need to be
			 * changed, only the array metadata.
			 */</comment>

			<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>       <name><name>valuesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>        <name><name>nullsAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>        <name><name>replacesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>newTup</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><name>missingval</name></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>one</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
										   <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
										   <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
				<argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>missingval</name></expr></argument>,
								<argument><expr><literal type="number">1</literal></expr></argument>,
								<argument><expr><name>targettype</name></expr></argument>,
								<argument><expr><name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
								<argument><expr><name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
								<argument><expr><name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>missingval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nullsAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newTup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>heapTup</name> <operator>=</operator> <name>newTup</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>targettype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>targettypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>targetcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Install dependencies on new datatype and collation */</comment>
	<expr_stmt><expr><call><name>add_column_datatype_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_collation_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>targetcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop any pg_statistic entry for the column, since it's now wrong type
	 */</comment>
	<expr_stmt><expr><call><name>RemoveStatistics</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the default, if present, by brute force --- remove and re-add
	 * the default.  Probably unsafe to take shortcuts, since the new version
	 * may well have additional dependencies.  (It's okay to do this now,
	 * rather than after other ALTER TYPE commands, since the default won't
	 * depend on other column types.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>defaultexpr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must make new row visible since it will be updated again */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use RESTRICT here for safety, but at present we do not expect
		 * anything to depend on the default.
		 */</comment>
		<expr_stmt><expr><call><name>RemoveAttrDefault</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StoreAttrDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>defaultexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATExecAlterColumnType: remember that a replica identity
 * needs to be reset.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberReplicaIdentityForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_index_isreplident</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>replicaIdentityIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has multiple indexes marked as replica identity"</literal></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>replicaIdentityIndex</name></name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATExecAlterColumnType: remember any clustered index.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberClusterOnForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_index_isclustered</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>clusterOnIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has multiple clustered indexes"</literal></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>clusterOnIndex</name></name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATExecAlterColumnType: remember that a constraint needs
 * to be rebuilt (which we might already know).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberConstraintForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This de-duplication check is critical for two independent reasons: we
	 * mustn't try to recreate the same constraint twice, and if a constraint
	 * depends on more than one column whose type is to be altered, we must
	 * capture its definition string before applying any of the column type
	 * changes.  ruleutils.c will get confused if we ask again later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name></expr></argument>, <argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK, capture the constraint's existing definition string */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defstring</name> <init>= <expr><call><name>pg_get_constraintdef_command</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indoid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name></expr></argument>,
												 <argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name></expr></argument>,
											 <argument><expr><name>defstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For the index of a constraint, if any, remember if it is used for
		 * the table's replica identity or if it is a clustered index, so that
		 * ATPostAlterTypeCleanup() can queue up commands necessary to restore
		 * those properties.
		 */</comment>
		<expr_stmt><expr><name>indoid</name> <operator>=</operator> <call><name>get_constraint_index</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RememberReplicaIdentityForRebuilding</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RememberClusterOnForRebuilding</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATExecAlterColumnType: remember that an index needs
 * to be rebuilt (which we might already know).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberIndexForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This de-duplication check is critical for two independent reasons: we
	 * mustn't try to recreate the same index twice, and if an index depends
	 * on more than one column whose type is to be altered, we must capture
	 * its definition string before applying any of the column type changes.
	 * ruleutils.c will get confused if we ask again later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name></expr></argument>, <argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Before adding it as an index-to-rebuild, we'd better see if it
		 * belongs to a constraint, and if so rebuild the constraint instead.
		 * Typically this check fails, because constraint indexes normally
		 * have only dependencies on their constraint.  But it's possible for
		 * such an index to also have direct dependencies on table columns,
		 * for example with a partial exclusion constraint.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>conoid</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RememberConstraintForRebuilding</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* OK, capture the index's existing definition string */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defstring</name> <init>= <expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name></expr></argument>,
												<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexDefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexDefs</name></name></expr></argument>,
											<argument><expr><name>defstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remember if this index is used for the table's replica identity
			 * or if it is a clustered index, so that ATPostAlterTypeCleanup()
			 * can queue up commands necessary to restore those properties.
			 */</comment>
			<expr_stmt><expr><call><name>RememberReplicaIdentityForRebuilding</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RememberClusterOnForRebuilding</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterColumnGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
								<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ftrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_foreign_table</name></type> <name>fttableform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atttableform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* First, determine FDW validator associated to the foreign table. */</comment>
	<expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>fttableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>fttableform</name><operator>-&gt;</operator><name>ftserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<expr_stmt><expr><name>atttableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>atttableform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* Initialize buffers for new tuple values */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract the current options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
							<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_attribute_attfdwoptions</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transform the options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>transformGenericOptions</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>,
									<argument><expr><name>datum</name></expr></argument>,
									<argument><expr><name>options</name></expr></argument>,
									<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>,
									<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Everything looks good - update the tuple */</comment>

	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>atttableform</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup after we've finished all the ALTER TYPE operations for a
 * particular relation.  We have to drop and recreate all the indexes
 * and constraints that depend on the altered columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPostAlterTypeCleanup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>def_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>oid_item</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Collect all the constraints and indexes to drop so we can process them
	 * in a single call.  That way we don't have to worry about dependencies
	 * among them.
	 */</comment>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-parse the index and constraint definitions, and attach them to the
	 * appropriate work queue entries.  We do this before dropping because in
	 * the case of a FOREIGN KEY constraint, we might not yet have exclusive
	 * lock on the table the constraint is attached to, and we need to get
	 * that before reparsing/dropping.
	 *
	 * We can't rely on the output of deparsing to tell us which relation to
	 * operate on, because concurrent activity might have made the name
	 * resolve differently.  Instead, we've got to use the OID of the
	 * constraint or index we're processing to figure out which relation to
	 * operate on.
	 */</comment>
	<macro><name>forboth</name><argument_list>(<argument>oid_item</argument>, <argument>tab-&gt;changedConstraintOids</argument>,
			<argument>def_item</argument>, <argument>tab-&gt;changedConstraintDefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>confrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>contype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>conislocal</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must be a domain constraint */</comment>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_typ_typrelid</name><argument_list>(<argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>contypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not identify relation associated with constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>confrelid</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>contype</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>conislocal</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the constraint is inherited (only), we don't want to inject a
		 * new definition here; it'll get recreated when ATAddCheckConstraint
		 * recurses from adding the parent table's constraint.  But we had to
		 * carry the info this far so that we can drop the constraint below.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conislocal</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * When rebuilding an FK constraint that references the table we're
		 * modifying, we might not yet have any lock on the FK's table, so get
		 * one now.  We'll need AccessExclusiveLock for the DROP CONSTRAINT
		 * step, so there's no value in asking for anything weaker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator> <name>contype</name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ATPostAlterTypeParse</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>confrelid</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_item</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>forboth</name><argument_list>(<argument>oid_item</argument>, <argument>tab-&gt;changedIndexOids</argument>,
			<argument>def_item</argument>, <argument>tab-&gt;changedIndexDefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ATPostAlterTypeParse</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_item</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Queue up command to restore replica identity index marking
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>replicaIdentityIndex</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>subcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ReplicaIdentityStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>subcmd</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>=</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>replicaIdentityIndex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReplicaIdentity</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subcmd</name></expr>;</expr_stmt>

		<comment type="block">/* do it after indexes and constraints */</comment>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Queue up command to restore marking of index used for cluster.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>clusterOnIndex</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ClusterOn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>clusterOnIndex</name></name></expr>;</expr_stmt>

		<comment type="block">/* do it after indexes and constraints */</comment>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It should be okay to use DROP_RESTRICT here, since nothing else should
	 * be depending on these objects.
	 */</comment>
	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The objects will get recreated during subsequent passes over the work
	 * queue.
	 */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPostAlterTypeParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rewrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>list_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We expect that we will get only ALTER TABLE and CREATE INDEX
	 * statements. Hence, there is no need to pass them through
	 * parse_analyze() or the rewriter, but instead we need to pass them
	 * through parse_utilcmd.c to make them ready for execution.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>raw_parser</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name><name>rs</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
									 <argument><expr><call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>,
														<argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
														<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
										 <argument><expr><call><name>transformAlterTableStmt</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>,
																 <argument><expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
																 <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Caller should already have acquired whatever lock we need. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attach each generated command to the proper place in the work queue.
	 * Note this could result in creation of entirely new work-queue entries.
	 *
	 * Also note that we have to tweak the command subtypes, because it turns
	 * out that re-creation of indexes and constraints has to act a bit
	 * differently from initial creation.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>querytree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stm</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>TryReuseIndex</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* keep the index's comment */</comment>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddIndex</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddIndex</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>indstmt</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>indoid</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>indstmt</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>indoid</name> <operator>=</operator> <call><name>get_constraint_index</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>TryReuseIndex</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>indstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* keep any comment on the index */</comment>
					<expr_stmt><expr><name><name>indstmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>,
													 <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddIndex</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* recreate any comment on the constraint */</comment>
					<expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
											 <argument><expr><name>AT_PASS_OLD_INDEX</name></expr></argument>,
											 <argument><expr><name>oldId</name></expr></argument>,
											 <argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name><name>indstmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>old_pktable_oid</name></name> <operator>=</operator> <name>refRelId</name></expr>;</expr_stmt>
					<comment type="block">/* rewriting neither side of a FK */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><name>rewrite</name> <operator>&amp;&amp;</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>TryReuseForeignKey</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddConstraint</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* recreate any comment on the constraint */</comment>
					<expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
											 <argument><expr><name>AT_PASS_OLD_CONSTR</name></expr></argument>,
											 <argument><expr><name>oldId</name></expr></argument>,
											 <argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement subtype: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>AlterDomainStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterDomainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <literal type="char">'C'</literal></expr>)</condition>	<comment type="block">/* ADD CONSTRAINT */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddDomainConstraint</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* recreate any comment on the constraint */</comment>
				<expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
										 <argument><expr><name>AT_PASS_OLD_CONSTR</name></expr></argument>,
										 <argument><expr><name>oldId</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
										 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement subtype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse() to recreate any existing comment
 * for a table or domain constraint that is being rebuilt.
 *
 * objid is the OID of the constraint.
 * Pass "rel" for a table constraint, or "domname" (domain's qualified name
 * as a string list) for a domain constraint.
 * (We could dig that info, as well as the conname, out of the pg_constraint
 * entry; but callers already have them so might as well pass them.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RebuildConstraintComment</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>,
						 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>domname</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>

	<comment type="block">/* Look for comment for object wanted, and leave if none */</comment>
	<expr_stmt><expr><name>comment_str</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>comment_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Build CommentStmt node, copying all input data for safety */</comment>
	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABCONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_DOMCONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>domname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment_str</name></expr>;</expr_stmt>

	<comment type="block">/* Append it to list of commands */</comment>
	<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddComment</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse().  Calls out to CheckIndexCompatible()
 * for the real analysis, then mutates the IndexStmt based on that verdict.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryReuseIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CheckIndexCompatible</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If it's a partitioned index, there is no storage to share. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>irel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse().
 *
 * Stash the old P-F equality operator into the Constraint node, for possible
 * use by ATAddForeignKeyConstraint() in determining whether revalidation of
 * this constraint can be skipped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryReuseForeignKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>adatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>rawarr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* already prepared this node */</comment>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>adatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
							 <argument><expr><name>Anum_pg_constraint_conpfeqop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conpfeqop for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>adatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
	<expr_stmt><expr><name>numkeys</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<comment type="block">/* test follows the one in ri_FetchConstraintInfo() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"conpfeqop is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rawarr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stash a List of the operator Oids in our Constraint node */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>, <argument><expr><name><name>rawarr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE OWNER
 *
 * recursing is true if we are recursing from a table to its indexes,
 * sequences, or toast table.  We don't allow the ownership of those things to
 * be changed separately from the parent table.  Also, we can skip permission
 * checks (this is necessary not just an optimization, else we'd fail to
 * handle toast tables properly).
 *
 * recursing is also true if ALTER TYPE OWNER is calling us to fix up a
 * free-standing composite type.
 */</comment>
<function><type><name>void</name></type>
<name>ATExecChangeOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>target_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>class_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>tuple_class</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get exclusive lock till end of transaction on the target table. Use
	 * relation_open so that we can work on indexes and sequences.
	 */</comment>
	<expr_stmt><expr><name>target_rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get its pg_class tuple, too */</comment>
	<expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tuple_class</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can we change the ownership of this tuple? */</comment>
	<switch>switch <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* ok to change owner */</comment>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Because ALTER INDEX OWNER used to be allowed, and in fact
				 * is generated by old versions of pg_dump, we give a warning
				 * and do nothing rather than erroring out.  Also, to avoid
				 * unnecessary chatter while restoring those old dumps, say
				 * nothing at all if the command would be a no-op anyway.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of index \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Change the ownership of the index's table, instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* quick hack to exit via the no-op path */</comment>
				<expr_stmt><expr><name>newOwnerId</name> <operator>=</operator> <name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Change the ownership of the index's table, instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
				<name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if it's an owned sequence, disallow changing it by itself */</comment>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>tableId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>colId</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of sequence \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
									   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TYPE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, sequence, or foreign table"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If the new owner is the same as the existing owner, consider the
	 * command to have succeeded.  This is for dump restoration purposes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<comment type="block">/* skip permission checks when recursing to index or toast table */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Superusers can always do it */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceOid</name> <init>= <expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

				<comment type="block">/* Otherwise, must be owner of the existing object */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Must be able to become new owner */</comment>
				<expr_stmt><expr><call><name>check_is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* New owner must have CREATE privilege on namespace */</comment>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
												  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
								   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the modified ACL for the new owner.  This is only
		 * necessary when the ACL is non-null.
		 */</comment>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must similarly update any per-column ACLs to reflect the new
		 * owner; for neatness reasons that's split out as a subroutine.
		 */</comment>
		<expr_stmt><expr><call><name>change_owner_fix_column_acls</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>,
									 <argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
									 <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update owner dependency reference, if any.  A composite type has
		 * none, because it's tracked for the pg_type entry instead of here;
		 * indexes and TOAST tables don't have their own entries either.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>,
									<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also change the ownership of the table's row type, if it has one
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AlterTypeOwnerInternal</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we are operating on a table or materialized view, also change
		 * the ownership of any indexes and sequences that belong to the
		 * relation, as well as its toast table (if it has one).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>index_oid_list</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Find all the indexes belonging to this relation */</comment>
			<expr_stmt><expr><name>index_oid_list</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* For each index, recursively change its ownership */</comment>
			<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>index_oid_list</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>index_oid_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If it has a toast table, recurse to change its ownership */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If it has dependent sequences, recurse to change them too */</comment>
		<expr_stmt><expr><call><name>change_owner_recurse_to_sequences</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * change_owner_fix_column_acls
 *
 * Helper function for ATExecChangeOwner.  Scan the columns of the table
 * and fix any non-null column ACLs to reflect the new owner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_owner_fix_column_acls</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldOwnerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attributeTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Null ACLs do not require changes */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>oldOwnerId</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * change_owner_recurse_to_sequences
 *
 * Helper function for ATExecChangeOwner.  Examines pg_depend searching
 * for sequences that are dependent on serial columns, and changes their
 * ownership.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_owner_recurse_to_sequences</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SERIAL sequences are those having an auto dependency on one of the
	 * table's columns (we don't care *which* column, exactly).
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we leave refobjsubid unspecified */</comment>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>depForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>seqRel</name></decl>;</decl_stmt>

		<comment type="block">/* skip dependencies other than auto dependencies on columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>depForm</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Use relation_open just in case it's an index */</comment>
		<expr_stmt><expr><name>seqRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip non-sequence relations */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No need to keep the lock */</comment>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We don't need to close the sequence while we alter it. */</comment>
		<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can close it.  Keep the lock till end of transaction. */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE CLUSTER ON
 *
 * The only thing we have to do is to change the indisclustered bits.
 *
 * Return the address of the new clustering index.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecClusterOn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>indexName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check index is valid to cluster on */</comment>
	<expr_stmt><expr><call><name>check_index_is_clusterable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And do the work */</comment>
	<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
					 <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET WITHOUT CLUSTER
 *
 * We have to find any indexes on the table that have indisclustered bit
 * set and turn it off.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET TABLESPACE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetTableSpace</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tablespaceId</name></decl>;</decl_stmt>

	<comment type="block">/* Check that the tablespace exists */</comment>
	<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check permissions except when moving to database's default */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>, <argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save info for Phase 3 to do the real work */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have multiple SET TABLESPACE subcommands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name> <operator>=</operator> <name>tablespaceId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set, reset, or replace reloptions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>, <parameter><decl><type><name>AlterTableType</name></type> <name>operation</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>defList</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>operation</name> <operator>!=</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch heap tuple */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're supposed to replace the reloptions list, we just pretend
		 * there were none before.
		 */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Get the old reloptions */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Generate new proposed reloptions (text array) */</comment>
	<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
									 <argument><expr><name>defList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Validate */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * POLAR: recurse for all sub-partitions, if rel is a partitioned
		 * table, and the reloption should be set recursively.
		 */</comment>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>recurse_def_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>def_cell</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>relopt_cell</name></decl>;</decl_stmt>

				<comment type="block">/* 
				 * POLAR: build a new def list for sub-partitions,
				 *        containing only those to be set recursively.
				 */</comment>
				<macro><name>foreach</name> <argument_list>(<argument>def_cell</argument>, <argument>defList</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>		<modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name> <argument_list>(<argument>relopt_cell</argument>, <argument>recursive_relopts</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>recurse_opt</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator>
														<call><name>lfirst</name><argument_list>(<argument><expr><name>relopt_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>recurse_opt</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>recurse_def_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>recurse_def_list</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block>

				<comment type="block">/* recursively update reloptions of sub-partitions, if any */</comment>
				<if_stmt><if>if <condition>(<expr><name>recurse_def_list</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionDesc</name></type>	<name>part_desc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>		<name>child_rel</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>				<name>nparts</name> <init>= <expr><name><name>part_desc</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>part_desc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ATExecSetRelOptions</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>recurse_def_list</name></expr></argument>,
											<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>

					<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>recurse_def_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Fall to RELKIND_RELATION for partitioned table, don't break. */</comment>
			</block_content>}</block>
		<comment type="block">/* POLAR end */</comment>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>view_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_reloptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amoptions</name></name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, index, or TOAST table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Special-case validation of view options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>view_query</name> <init>= <expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>view_options</name> <init>= <expr><call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>check_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>view_options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"check_option"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>check_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If the check option is specified, look to see if the view is
		 * actually auto-updatable or not.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>check_option</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_updatable_error</name> <init>=
			<expr><call><name>view_query_is_auto_updatable</name><argument_list>(<argument><expr><name>view_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>view_updatable_error</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH CHECK OPTION is supported only on automatically updatable views"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>view_updatable_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All we need do here is update the pg_class row; the new options will be
	 * propagated into relcaches during post-commit cache inval.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* repeat the whole exercise for the toast table, if there's one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>toastid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch heap tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're supposed to replace the reloptions list, we just
			 * pretend there were none before.
			 */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Get the old reloptions */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
										 <argument><expr><name>defList</name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE SET TABLESPACE for cases where there is no tuple
 * rewriting to be done, so we just want to copy the data as fast as possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldTableSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reltoastrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newrelfilenode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>newrnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>dstrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>reltoastidxids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need lock here in case we are recursing to toast table or index
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No work if no change in tablespace.
	 */</comment>
	<expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>oldTableSpace</name> <operator>||</operator>
		<operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator> <name>oldTableSpace</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We cannot support moving mapped relations into different tablespaces.
	 * (In particular this eliminates all shared catalogs.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move system relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Can't move a non-shared relation into pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow moving temp tables of other backends ... their local buffer
	 * manager is not going to cope.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reltoastrelid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	<comment type="block">/* Fetch the list of indexes on toast relation if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastRel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>reltoastidxids</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get a modifiable copy of the relation's pg_class row */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we copy the file directly without looking at the shared buffers,
	 * we'd better first flush out any pages of the source relation that are
	 * in shared buffers.  We assume no new changes will be made while we are
	 * holding exclusive lock on the rel.
	 */</comment>
	<expr_stmt><expr><call><name>FlushRelationBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Relfilenodes are not unique in databases across tablespaces, so we need
	 * to allocate a new one in the new tablespace.
	 */</comment>
	<expr_stmt><expr><name>newrelfilenode</name> <operator>=</operator> <call><name>GetNewRelFileNode</name><argument_list>(<argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open old and new relation */</comment>
	<expr_stmt><expr><name>newrnode</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>newTableSpace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstrel</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create and copy all forks of the relation, and schedule unlinking of
	 * old physical files.
	 *
	 * NOTE: any conflict in relfilenode value will be caught in
	 * RelationCreateStorage().
	 */</comment>
	<expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy main fork */</comment>
	<expr_stmt><expr><call><name>copy_relation_data</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
					   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy those extra forks that exist */</comment>
	<for>for <control>(<init><expr><name>forkNum</name> <operator>=</operator> <name>MAIN_FORKNUM</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * WAL log creation if the relation is persistent, or this is the
			 * init fork of an unlogged relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator>
				<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
				 <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newrnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>copy_relation_data</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>,
							   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* drop old relation, and close new one */</comment>
	<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update the pg_class row */</comment>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>newTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the reltablespace change is visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move associated toast relation and/or indexes, too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>reltoastidxids</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>reltoastidxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Special handling of ALTER TABLE SET TABLESPACE for partitioned indexes,
 * which have no storage (so not handled in Phase 3 like other relation types)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecPartedIdxSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldTableSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't allow a non-shared relation in pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work if no change in tablespace.
	 */</comment>
	<expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>oldTableSpace</name> <operator>||</operator>
		<operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator> <name>oldTableSpace</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get a modifiable copy of the relation's pg_class row */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update the pg_class row */</comment>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>newTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the reltablespace change is visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Alter Table ALL ... SET TABLESPACE
 *
 * Allows a user to move all objects of some type in a given tablespace in the
 * current database to another tablespace.  Objects can be chosen based on the
 * owner of the object also, to allow users to move only their objects.
 * The user must have CREATE rights on the new tablespace, as usual.   The main
 * permissions handling is done by the lower-level table move function.
 *
 * All to-be-moved objects are locked first. If NOWAIT is specified and the
 * lock can't be acquired then we ereport(ERROR).
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTableMoveAll</name><parameter_list>(<parameter><decl><type><name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>orig_tablespaceoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_tablespaceoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>role_oids</name> <init>= <expr><call><name>roleSpecsToIds</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure we were not asked to move something we can't */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only tables, indexes, and materialized views exist in tablespaces"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the orig and new tablespace OIDs */</comment>
	<expr_stmt><expr><name>orig_tablespaceoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>orig_tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tablespaceoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>new_tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't move shared relations in to or out of pg_global */</comment>
	<comment type="block">/* This is also checked by ATExecSetTableSpace, but nice to stop earlier */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name> <operator>||</operator>
		<name>new_tablespaceoid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move relations in to or out of pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must have CREATE rights on the new tablespace, unless it is the
	 * database default tablespace (which all users implicitly have CREATE
	 * rights on).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>new_tablespaceoid</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>,
						   <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that the checks are done, check if we should set either to
	 * InvalidOid because it is our database's default tablespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>orig_tablespaceoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_tablespaceoid</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_tablespaceoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* no-op */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>new_tablespaceoid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>new_tablespaceoid</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Walk the list of objects in the tablespace and move them. This will
	 * only find objects in our database, of course.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_reltablespace</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>orig_tablespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do not move objects in pg_catalog as part of this, if an admin
		 * really wishes to do so, they can issue the individual ALTER
		 * commands directly.
		 *
		 * Also, explicitly avoid any shared tables, temp tables, or TOAST
		 * (TOAST will be moved with the main table).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsSystemNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>relForm</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>||</operator>
			<call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>PG_TOAST_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Only move the object type requested */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check if we are only moving objects owned by certain roles */</comment>
		<if_stmt><if>if <condition>(<expr><name>role_oids</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>role_oids</name></expr></argument>, <argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Handle permissions-checking here since we are locking the tables
		 * and also to avoid doing a bunch of work only to fail part-way. Note
		 * that permissions will also be checked by AlterTableInternal().
		 *
		 * Caller must be considered an owner on the table to move it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>nowait</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aborting because lock on relation \"%s.%s\" is not available"</literal></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Add to our list of objects to move */</comment>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relations</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relations</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no matching relations in tablespace \"%s\" found"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>InvalidOid</name></expr> ?</condition><then> <expr><literal type="string">"(database default)"</literal></expr> </then><else>:
						<expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>orig_tablespaceoid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Everything is locked, loop through and move all of the relations. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetTableSpace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>new_tablespacename</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* OID is set by AlterTableInternal */</comment>
		<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_tablespaceoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy data, block by block
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_relation_data</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>dst</name></decl></parameter>,
				   <parameter><decl><type><name>ForkNumber</name></type> <name>forkNum</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>copying_initfork</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The init fork for an unlogged relation in many respects has to be
	 * treated the same as normal relation, changes need to be WAL logged and
	 * it needs to be synced to disk.
	 */</comment>
	<expr_stmt><expr><name>copying_initfork</name> <operator>=</operator> <name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
		<name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to log the copied data in WAL iff WAL archiving/streaming is
	 * enabled AND it's a permanent relation.
	 */</comment>
	<expr_stmt><expr><name>use_wal</name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator> <name>copying_initfork</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>blkno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>nblocks</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* If we got a cancel signal during the copy of the data, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>smgrread</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsVerified</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid page in block %u of relation %s"</literal></expr></argument>,
							<argument><expr><name>blkno</name></expr></argument>,
							<argument><expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>,
										   <argument><expr><name><name>src</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>backend</name></name></expr></argument>,
										   <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * WAL-log the copied page. Unfortunately we don't know what kind of a
		 * page this is, so we have to log the full page including any unused
		 * space.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PageEncryptInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now write the page.  We say isTemp = true even if it's not a temp
		 * rel, because there's no need for smgr to schedule an fsync for this
		 * write; we'll do it ourselves below.
		 */</comment>
		<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the rel is WAL-logged, must fsync before commit.  We use heap_sync
	 * to ensure that the toast table gets fsync'd too.  (For a temp or
	 * unlogged rel we don't care since the data will be gone after a crash
	 * anyway.)
	 *
	 * It's obvious that we must do this when not WAL-logging the copy. It's
	 * less obvious that we have to do it even if we did WAL-log the copied
	 * pages. The reason is that since we're copying outside shared buffers, a
	 * CHECKPOINT occurring during the copy has no way to flush the previously
	 * written data to disk (indeed it won't know the new rel even exists).  A
	 * crash later on would replay WAL from the checkpoint, therefore it
	 * wouldn't replay our earlier WAL entries. If we do not fsync those pages
	 * here, they might still not be on disk when the crash occurs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator> <name>copying_initfork</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE TRIGGER
 *
 * We just pass this off to trigger.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>,
						   <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>trigname</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>, <argument><expr><name>skip_system</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE RULE
 *
 * We just pass this off to rewriteDefine.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
						<parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rulename</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE INHERIT
 *
 * Add a parent to the child's parents. This verifies that all the columns and
 * check constraints of the parent appear in the child and that they have the
 * same data types and expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the new parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigger_name</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A self-exclusive lock is needed here.  See the similar case in
	 * MergeAttributes() for a full explanation.
	 */</comment>
	<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be owner of both parent and child -- child was checked by
	 * ATSimplePermissions call in ATPrepCmd
	 */</comment>
	<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Permanent rels cannot inherit from temporary ones */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from temporary relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If parent rel is temp, it must belong to this session */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ditto for the child */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>child_rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit to temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent partitioned tables from becoming inheritance parents */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partitioned table \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Likewise for partitions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prevent circularity by seeing if proposed parent inherits from child.
	 * (In particular, this disallows making a rel inherit from itself.)
	 *
	 * This is not completely bulletproof because of race conditions: in
	 * multi-level inheritance trees, someone else could concurrently be
	 * making another inheritance link that closes the loop but does not join
	 * either of the rels we have locked.  Preventing that seems to require
	 * exclusive locks on the entire inheritance tree, which is a cure worse
	 * than the disease.  find_all_inheritors() will cope with circularity
	 * anyway, so don't sweat it too much.
	 *
	 * We use weakest lock we can on child's children, namely AccessShareLock.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular inheritance not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a child of \"%s\"."</literal></expr></argument>,
						   <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If parent has OIDs then child must have OIDs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" without OIDs cannot inherit from table \"%s\" with OIDs"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If child_rel has row-level triggers with transition tables, we
	 * currently don't allow it to become an inheritance child.  See also
	 * prohibitions in ATExecAttachPartition() and CreateTrigger().
	 */</comment>
	<expr_stmt><expr><name>trigger_name</name> <operator>=</operator> <call><name>FindTriggerIncompatibleWithInheritance</name><argument_list>(<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>trigger_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" prevents table \"%s\" from becoming an inheritance child"</literal></expr></argument>,
						<argument><expr><name>trigger_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported in inheritance hierarchies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK to create inheritance */</comment>
	<expr_stmt><expr><call><name>CreateInheritance</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock on the parent relation until commit */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateInheritance
 *		Catalog manipulation portion of creating inheritance between a child
 *		table and a parent table.
 *
 * Common to ATExecAddInherit() and ATExecAttachPartition().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inheritsTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>inhseqno</name></decl>;</decl_stmt>

	<comment type="block">/* Note: get RowExclusiveLock because we will write pg_inherits below. */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for duplicates in the list of parents, and determine the highest
	 * inhseqno already present; we'll use the next one for the new parent.
	 * Also, if proposed child is a partition, it cannot already be
	 * inheriting.
	 *
	 * Note: we do not reject the case where the child already inherits from
	 * the parent indirectly; CREATE TABLE doesn't reject comparable cases.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* inhseqno sequences start at 1 */</comment>
	<expr_stmt><expr><name>inhseqno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>inheritsTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inh</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inh</name><operator>-&gt;</operator><name>inhparent</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" would be inherited from more than once"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inh</name><operator>-&gt;</operator><name>inhseqno</name></name> <operator>&gt;</operator> <name>inhseqno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inhseqno</name> <operator>=</operator> <name><name>inh</name><operator>-&gt;</operator><name>inhseqno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Match up the columns and bump attinhcount as needed */</comment>
	<expr_stmt><expr><call><name>MergeAttributesIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Match up the constraints and bump coninhcount as needed */</comment>
	<expr_stmt><expr><call><name>MergeConstraintsIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, it looks valid.  Make the catalog entries that show inheritance.
	 */</comment>
	<expr_stmt><expr><call><name>StoreCatalogInheritance1</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>inhseqno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>catalogRelation</name></expr></argument>,
							 <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator>
							 <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we're done with pg_inherits */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain the source-text form of the constraint expression for a check
 * constraint, given its pg_constraint tuple
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>decompile_conbin</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>contup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>contup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether two check constraints are functionally equivalent
 *
 * The test we apply is to see whether they reverse-compile to the same
 * source string.  This insulates us from issues like whether attributes
 * have the same physical column numbers in parent and child relations.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>constraints_equivalent</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>acon</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>bcon</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>acon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>bcon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>||</operator>
		<name><name>acon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>bcon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>decompile_conbin</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>decompile_conbin</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check columns in child table match up with columns in parent, and increment
 * their attinhcount.
 *
 * Called by CreateInheritance
 *
 * Currently all parent columns must be found in child. Missing columns are an
 * error.  One day we might consider creating new columns like CREATE TABLE
 * does.  However, that is widely unpopular --- in the common use case of
 * partitioned tables it's a foot-gun.
 *
 * The data type must match exactly. If the parent column is NOT NULL then
 * the child must be as well. Defaults are not compared, however.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeAttributesIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parent_natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name>parent_natts</name></expr>;</condition> <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
													<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped columns in the parent. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Find same column in child (matching on column name). */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check they are same type, typmod, and collation */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
				<name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different collation for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check child doesn't discard NOT NULL property.  (Other
			 * constraints are checked elsewhere.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>childatt</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" in child table must be marked NOT NULL"</literal></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * OK, bump the child column's inheritance count.  (If we fail
			 * later on, this change will just roll back.)
			 */</comment>
			<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * In case of partitions, we must enforce that value of attislocal
			 * is same in all partitions. (Note: there are only inherited
			 * attributes in partitions)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing column \"%s\""</literal></expr></argument>,
							<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the parent has an OID column, so must the child, and we'd better
	 * update the child's attinhcount and attislocal the same as for normal
	 * columns.  We needn't check data type or not-nullness though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Here we match by column number not name; the match *must* be the
		 * system column, not some random column named "oid".
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* See comments above; these changes should be the same */</comment>
			<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing column \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check constraints in child table match up with constraints in parent,
 * and increment their coninhcount.
 *
 * Constraints that are marked ONLY in the parent are ignored.
 *
 * Called by CreateInheritance
 *
 * Currently all constraints in parent must be present in the child. One day we
 * may consider adding new constraints like CREATE TABLE does.
 *
 * XXX This is O(N^2) which may be an issue with tables with hundreds of
 * constraints. As long as tables have more like 10 constraints it shouldn't be
 * a problem though. Even 100 constraints ought not be the end of the world.
 *
 * XXX See MergeWithExistingConstraint too if you change this code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeConstraintsIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tuple_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>parent_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>parent_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>parent_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalog_relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Outer loop scans through the parent's constraint definitions */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_key</name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>parent_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>parent_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>parent_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>parent_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>child_scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>child_key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>child_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if the parent's constraint is marked NO INHERIT, it's not inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Search for a child constraint matching this one */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child_key</name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>child_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>child_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>child_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>child_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>child_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>child_copy</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>child_con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>constraints_equivalent</name><argument_list>(<argument><expr><name>parent_tuple</name></expr></argument>, <argument><expr><name>child_tuple</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different definition for check constraint \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If the child constraint is "no inherit" then cannot merge */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>child_con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with non-inherited constraint on child table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the child constraint is "not valid" then cannot merge with a
			 * valid parent constraint
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>child_con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with NOT VALID constraint on child table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * OK, bump the child constraint's inheritance count.  (If we fail
			 * later on, this change will just roll back.)
			 */</comment>
			<expr_stmt><expr><name>child_copy</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>child_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>child_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>child_con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * In case of partitions, an inherited constraint must be
			 * inherited only once since it cannot have multiple parents and
			 * it is never considered local.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>child_con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>child_copy</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>child_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing constraint \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>parent_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE NO INHERIT
 *
 * Return value is the address of the relation that is no longer parent.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * AccessShareLock on the parent is probably enough, seeing that DROP
	 * TABLE doesn't lock parent tables at all.  We need some lock since we'll
	 * be inspecting the parent's schema.
	 */</comment>
	<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't bother to check ownership of the parent table --- ownership of
	 * the child is presumed enough rights.
	 */</comment>

	<comment type="block">/* Off to RemoveInheritance() where most of the work happens */</comment>
	<expr_stmt><expr><call><name>RemoveInheritance</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock on the parent relation until commit */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveInheritance
 *
 * Drop a parent from the child's parents. This just adjusts the attinhcount
 * and attislocal of the columns and removes the pg_inherit and pg_depend
 * entries.
 *
 * If attinhcount goes to 0 then attislocal gets set to true. If it goes back
 * up attislocal stays true, which means if a child is ever removed from a
 * parent then its columns will never be automatically dropped which may
 * surprise. But at least we'll never surprise by dropping columns someone
 * isn't expecting to be dropped which would actually mean data loss.
 *
 * coninhcount and conislocal for inherited constraints are adjusted in
 * exactly the same way.
 *
 * Common to ATExecDropInherit() and ATExecDetachPartition().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attributeTuple</name></decl>,
				<decl><type ref="prev"/><name>constraintTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>connames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>DeleteInheritsTuple</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a partition of relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a parent of relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Search through child columns looking for ones matching parent rel
	 */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore if dropped or not inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExistsAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Decrement inhcount and possibly set islocal to true */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>copy_att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>copy_att</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>copy_att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>copy_att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise, find inherited check constraints and disinherit them. To do
	 * this, we first need a list of the names of the parent's check
	 * constraints.  (We cheat a bit by only checking for name matches,
	 * assuming that the expressions will match.)
	 */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>connames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constraintTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>connames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connames</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now scan the child's constraints */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constraintTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>connames</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Decrement inhcount and possibly set islocal to true */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited constraint \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>copy_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>child_dependency_type</name><argument_list>(<argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Post alter hook of this inherits. Since object_access_hook doesn't take
	 * multiple object identifiers, we relay oid of parent relation using
	 * auxiliary_id argument.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>,
								 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop the dependency created by StoreCatalogInheritance1 (CREATE TABLE
 * INHERITS/ALTER TABLE INHERIT -- refclassid will be RelationRelationId) or
 * heap_create_with_catalog (CREATE TABLE OF/ALTER TABLE OF -- refclassid will
 * be TypeRelationId).  There's no convenient way to do this, so go trawling
 * through pg_depend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_parent_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
					   <parameter><decl><type><name>DependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>dep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>refclassid</name> <operator>&amp;&amp;</operator>
			<name><name>dep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name>refobjid</name> <operator>&amp;&amp;</operator>
			<name><name>dep</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>dep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>deptype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>depTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE OF
 *
 * Attach a table to a composite type, as though it had been created with CREATE
 * TABLE OF.  All attname, atttypid, atttypmod and attcollation must match.  The
 * subject table must not have inheritance parents.  These restrictions ensure
 * that you cannot create a configuration impossible with CREATE TABLE OF alone.
 *
 * The address of the type is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Type</name></type>		<name>typetuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>inheritsRelation</name></decl>,
				<decl><type ref="prev"/><name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>table_attno</name></decl>,
				<decl><type ref="prev"/><name>type_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>typeTupleDesc</name></decl>,
				<decl><type ref="prev"/><name>tableTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>tableobj</name></decl>,
				<decl><type ref="prev"/><name>typeobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classtuple</name></decl>;</decl_stmt>

	<comment type="block">/* Validate the type. */</comment>
	<expr_stmt><expr><name>typetuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ofTypename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_of_type</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fail if the table has any inheritance parents. */</comment>
	<expr_stmt><expr><name>inheritsRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inheritsRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typed tables cannot inherit"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inheritsRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the tuple descriptors for compatibility.  Unlike inheritance, we
	 * require that the order also match.  However, attnotnull need not match.
	 * Also unlike inheritance, we do not require matching relhasoids.
	 */</comment>
	<expr_stmt><expr><name>typeTupleDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tableTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>type_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>type_attno</name> <operator>&lt;=</operator> <name><name>typeTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>type_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>type_attr</name></decl>,
					<decl><type ref="prev"/><name>table_attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_attname</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>table_attname</name></decl>;</decl_stmt>

		<comment type="block">/* Get the next non-dropped type attribute. */</comment>
		<expr_stmt><expr><name>type_attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>typeTupleDesc</name></expr></argument>, <argument><expr><name>type_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>type_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>type_attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>type_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the next non-dropped table attribute. */</comment>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>table_attno</name> <operator>&gt;</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table is missing column \"%s\""</literal></expr></argument>,
								<argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>table_attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tableTupleDesc</name></expr></argument>, <argument><expr><name>table_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>table_attno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name><name>table_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>;</do>
		<expr_stmt><expr><name>table_attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>table_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compare name. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>table_attname</name></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table has column \"%s\" where type requires \"%s\""</literal></expr></argument>,
							<argument><expr><name>table_attname</name></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Compare type. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>table_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
			<name><name>table_attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>||</operator>
			<name><name>table_attr</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>typeTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Any remaining columns at the end of the table had better be dropped. */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>table_attno</name> <operator>&lt;=</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>table_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>table_attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tableTupleDesc</name></expr></argument>,
													 <argument><expr><name>table_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>table_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table has extra column \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>table_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If the table was already typed, drop the existing dependency. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>,
							   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Record a dependency on the new type. */</comment>
	<expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableobj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeobj</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update pg_class.reloftype */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>classtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reloftype</name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>typeobj</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE NOT OF
 *
 * Detach a typed table from its originating type.  Just clear reloftype and
 * remove the dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a typed table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't bother to check ownership of the type --- ownership of the
	 * table is presumed enough rights.  No lock required on the type, either.
	 */</comment>

	<expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>,
						   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear pg_class.reloftype */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reloftype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * relation_mark_replica_identity: Update a table's replica identity
 *
 * Iff ri_type = REPLICA_IDENTITY_INDEX, indexOid must be the Oid of a suitable
 * index. Otherwise, it should be InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>relation_mark_replica_identity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ri_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_class_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_index_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>pg_index_form</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check whether relreplident has changed, and update it if so.
	 */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pg_class_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pg_class_form</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>!=</operator> <name>ri_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pg_class_form</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>ri_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether the correct index is marked indisreplident; if so, we're
	 * done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ri_type</name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pg_index_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clear the indisreplident flag from any index that had it previously,
	 * and set it for any index that should have it now.
	 */</comment>
	<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>index</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>thisIndexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_index_tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
											 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Unset the bit if set.  We know it's wrong because we checked this
		 * earlier.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>thisIndexOid</name> <operator>==</operator> <name>indexOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_index_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE &lt;name&gt; REPLICA IDENTITY ...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>key</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
	<block>{<block_content>
		 <comment type="block">/* fallthrough */</comment> <empty_stmt>;</empty_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected identity type %u"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<comment type="block">/* Check that the index exists */</comment>
	<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that the index is on the relation we're altering. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index for table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* The AM must support uniqueness, and the index must in fact be unique. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>||</operator>
		<operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use non-unique index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Deferred indexes are not guaranteed to be always unique. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use non-immediate index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Expression indexes aren't supported. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use expression index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Predicate indexes aren't supported. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use partial index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* And neither are invalid indexes. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use invalid index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check index for nullable columns. */</comment>
	<for>for <control>(<init><expr><name>key</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>key</name> <operator>&lt;</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>key</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type>		<name>attno</name> <init>= <expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<comment type="block">/* Allow OID column to be indexed; it's certainly not nullable */</comment>
		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reject any other system columns.  (Going forward, we'll disallow
		 * indexes containing such columns in the first place, but they might
		 * exist in older branches.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be used as replica identity because column %d is a system column"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be used as replica identity because column \"%s\" is nullable"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* This index is suitable for use as a replica identity. Mark it. */</comment>
	<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE ROW LEVEL SECURITY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relrowsecurity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDisableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pull the record for this relation and update it */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relrowsecurity</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE FORCE/NO FORCE ROW LEVEL SECURITY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecForceNoForceRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_rls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relforcerowsecurity</name> <operator>=</operator> <name>force_rls</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER FOREIGN TABLE &lt;name&gt; OPTIONS (...)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ftrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_foreign_table</name></type> <name>tableform</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>tableform</name><operator>-&gt;</operator><name>ftserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract the current options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>,
							<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_foreign_table_ftoptions</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transform the options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>transformGenericOptions</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>,
									<argument><expr><name>datum</name></expr></argument>,
									<argument><expr><name>options</name></expr></argument>,
									<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>,
									<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Everything looks good - update the tuple */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate relcache so that all sessions will refresh any cached plans
	 * that might depend on the old options.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Preparation phase for SET LOGGED/UNLOGGED
 *
 * This verifies that we're not trying to change a temp table.  Also,
 * existing foreign key constraints are checked to avoid ending up with
 * permanent tables referencing unlogged tables.
 *
 * Return value is false if the operation is a no-op (in which case the
 * checks are skipped), otherwise true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ATPrepChangePersistence</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toLogged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_constraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Disallow changing status for a temp table.  Also verify whether we can
	 * get away with doing nothing; in such cases we don't need to run the
	 * checks below, either.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change logged status of table \"%s\" because it is temporary"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>toLogged</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* nothing to do */</comment>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLogged</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* nothing to do */</comment>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Check that the table is not part any publication when changing to
	 * UNLOGGED as UNLOGGED tables can't be published.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLogged</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><call><name>GetRelationPublications</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change table \"%s\" to unlogged because it is part of a publication"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unlogged relations cannot be replicated."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check existing foreign key constraints to preserve the invariant that
	 * permanent tables cannot reference unlogged ones.  Self-referencing
	 * foreign keys can safely be ignored.
	 */</comment>
	<expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan conrelid if changing to permanent, else confrelid.  This also
	 * determines whether a useful index exists.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name>Anum_pg_constraint_conrelid</name></expr> </then><else>:
				<expr><name>Anum_pg_constraint_confrelid</name></expr></else></ternary></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name>ConstraintRelidTypidNameIndexId</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>foreignrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>foreignrel</name></decl>;</decl_stmt>

			<comment type="block">/* the opposite end of what we used as scankey */</comment>
			<expr_stmt><expr><name>foreignrelid</name> <operator>=</operator> <ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr> </then><else>: <expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* ignore if self-referencing */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>foreignrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>foreignrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>foreignrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>toLogged</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change table \"%s\" to logged because it references unlogged table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change table \"%s\" to unlogged because it references logged table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE SET SCHEMA
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterTableNamespace</name><parameter_list>(<parameter><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldschema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>newrv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's an owned sequence, disallow moving it by itself. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tableId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>colId</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move an owned sequence into another schema"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get and lock schema OID and check its permissions. */</comment>
	<expr_stmt><expr><name>newrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspOid</name> <operator>=</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name>newrv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* common checks on switching namespaces */</comment>
	<expr_stmt><expr><call><name>CheckSetNamespace</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>objsMoved</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AlterTableNamespaceInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldschema</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>oldschema</name> <operator>=</operator> <name>oldNspOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* close rel, but keep lock until commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The guts of relocating a table or materialized view to another namespace:
 * besides moving the relation itself, its dependent objects are relocated to
 * the new schema.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>,
							<parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>objsMoved</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, modify the pg_class row and pg_depend entry */</comment>
	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>,
								   <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix the table's row type too */</comment>
	<expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
							   <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix other dependent stuff */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AlterIndexNamespaces</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AlterSeqNamespaces</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
						   <argument><expr><name>objsMoved</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AlterConstraintNamespaces</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The guts of relocating a relation to another namespace: fix the pg_class
 * entry, and the pg_depend entry if any.  Caller must already have
 * opened and write-locked pg_class.
 */</comment>
<function><type><name>void</name></type>
<name>AlterRelationNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>hasDependEntry</name></decl></parameter>,
							   <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>already_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>classTup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>oldNspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the object has already been moved, don't move it again.  If it's
	 * already in the right place, don't move it, but still fire the object
	 * access hook.
	 */</comment>
	<expr_stmt><expr><name>already_done</name> <operator>=</operator> <call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_done</name> <operator>&amp;&amp;</operator> <name>oldNspOid</name> <operator>!=</operator> <name>newNspOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for duplicate name (more friendly than unique-index failure) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* classTup is a copy, so OK to scribble on */</comment>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>=</operator> <name>newNspOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update dependency on schema if caller said so */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasDependEntry</name> <operator>&amp;&amp;</operator>
			<call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								<argument><expr><name>relOid</name></expr></argument>,
								<argument><expr><name>NamespaceRelationId</name></expr></argument>,
								<argument><expr><name>oldNspOid</name></expr></argument>,
								<argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to change schema dependency for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_done</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move all indexes for the specified relation to another namespace.
 *
 * Note: we assume adequate permission checking was done by the caller,
 * and that the caller has a suitable lock on the owning relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterIndexNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexList</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: currently, the index will not have its own dependency on the
		 * namespace, so we don't need to do changeDependencyFor(). There's no
		 * row type in pg_type, either.
		 *
		 * XXX this objsMoved test may be pointless -- surely we have a single
		 * dependency link from a relation to each index?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>,
										   <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>newNspOid</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move all identity and SERIAL-column sequences of the specified relation to another
 * namespace.
 *
 * Note: we assume adequate permission checking was done by the caller,
 * and that the caller has a suitable lock on the owning relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterSeqNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SERIAL sequences are those having an auto dependency on one of the
	 * table's columns (we don't care *which* column, exactly).
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we leave refobjsubid unspecified */</comment>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>depForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>seqRel</name></decl>;</decl_stmt>

		<comment type="block">/* skip dependencies other than auto dependencies on columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>depForm</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Use relation_open just in case it's an index */</comment>
		<expr_stmt><expr><name>seqRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip non-sequence relations */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No need to keep the lock */</comment>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fix the pg_class and pg_depend entries */</comment>
		<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
									   <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>newNspOid</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sequences have entries in pg_type. We need to be careful to move
		 * them to the new namespace, too.
		 */</comment>
		<expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
								   <argument><expr><name>newNspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can close it.  Keep the lock till end of transaction. */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * This code supports
 *	CREATE TEMP TABLE ... ON COMMIT { DROP | PRESERVE ROWS | DELETE ROWS }
 *
 * Because we only support this for TEMP tables, it's sufficient to remember
 * the state in a backend-local data structure.
 */</comment>

<comment type="block">/*
 * Register a newly-created relation's ON COMMIT action.
 */</comment>
<function><type><name>void</name></type>
<name>register_on_commit_action</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>OnCommitAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We needn't bother registering the relation unless there is an ON COMMIT
	 * action we need to take.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>ONCOMMIT_NOOP</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>ONCOMMIT_PRESERVE_ROWS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oc</name> <operator>=</operator> <operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OnCommitItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>oc</name></expr></argument>, <argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unregister any ON COMMIT action when a relation is deleted.
 *
 * Actually, we only mark the OnCommitItem entry as to be deleted after commit.
 */</comment>
<function><type><name>void</name></type>
<name>remove_on_commit_action</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Perform ON COMMIT actions.
 *
 * This is invoked just before actually committing, since it's possible
 * to encounter errors.
 */</comment>
<function><type><name>void</name></type>
<name>PreCommit_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oids_to_truncate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oids_to_drop</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore entry if already dropped in this xact */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ONCOMMIT_NOOP</name></expr>:</case>
			<case>case <expr><name>ONCOMMIT_PRESERVE_ROWS</name></expr>:</case>
				<comment type="block">/* Do nothing (there shouldn't be such entries, actually) */</comment>
				<break>break;</break>
			<case>case <expr><name>ONCOMMIT_DELETE_ROWS</name></expr>:</case>

				<comment type="block">/*
				 * If this transaction hasn't accessed any temporary
				 * relations, we can skip truncating ON COMMIT DELETE ROWS
				 * tables, as they must still be empty.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>MyXactFlags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACCESSEDTEMPREL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>oids_to_truncate</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids_to_truncate</name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ONCOMMIT_DROP</name></expr>:</case>
				<expr_stmt><expr><name>oids_to_drop</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids_to_drop</name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * Truncate relations before dropping so that all dependencies between
	 * relations are removed after they are worked on.  Doing it like this
	 * might be a waste as it is possible that a relation being truncated will
	 * be dropped anyway due to its parent being dropped, but this makes the
	 * code more robust because of not having to re-check that the relation
	 * exists at truncation time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oids_to_truncate</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_truncate</name><argument_list>(<argument><expr><name>oids_to_truncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* XXX needed? */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oids_to_drop</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name> <init>= <expr><call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>oids_to_drop</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Since this is an automatic drop, rather than one directly initiated
		 * by the user, we pass the PERFORM_DELETION_INTERNAL flag.
		 */</comment>
		<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>,
								 <argument><expr><name>PERFORM_DELETION_INTERNAL</name> <operator>|</operator> <name>PERFORM_DELETION_QUIETLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

		<comment type="block">/*
		 * Note that table deletion will call remove_on_commit_action, so the
		 * entry should get marked as deleted.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>!=</operator> <name>ONCOMMIT_DROP</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Post-commit or post-abort cleanup for ON COMMIT management.
 *
 * All we do here is remove no-longer-needed OnCommitItem entries.
 *
 * During commit, remove entries that were deleted during this transaction;
 * during abort, remove those created during this transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr> </then><else>:
			<expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr></else></ternary></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* cur_item must be removed */</comment>
			<expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* cur_item must be preserved */</comment>
			<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Post-subcommit or post-subabort cleanup for ON COMMIT management.
 *
 * During subabort, we can immediately remove entries created during this
 * subtransaction.  During subcommit, just relabel entries marked during
 * this subtransaction as being the parent's responsibility.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
							  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* cur_item must be removed */</comment>
			<expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* cur_item must be preserved */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><name>parentSubid</name></expr> </then><else>: <expr><name>InvalidSubTransactionId</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * This is intended as a callback for RangeVarGetRelidExtended().  It allows
 * the relation to be locked only if (1) it's a plain table, materialized
 * view, or TOAST table and (2) the current user is the owner (or the
 * superuser).  This meets the permission-checking needs of CLUSTER, REINDEX
 * TABLE, and REFRESH MATERIALIZED VIEW; we expose it here so that it can be
 * used by all.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarCallbackOwnsTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if the relation was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the relation does exist, check whether it's an index.  But note that
	 * the relation might have been dropped between the time we did the name
	 * lookup and now.  In that case, there's nothing to do.
	 */</comment>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check permissions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to RangeVarGetRelidExtended(), similar to
 * RangeVarCallbackOwnsTable() but without checks on the type of the relation.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarCallbackOwnsRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if the relation was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator>
		<call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common RangeVarGetRelid callback for rename, set schema, and alter table
 * processing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForAlterRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>reltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped */</comment>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<comment type="block">/* Must own relation. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* No system table modifications unless explicitly allowed. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract the specified relation type from the statement parse tree.
	 *
	 * Also, for ALTER .. RENAME, check permissions: the user must (still)
	 * have CREATE rights on the containing namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>,
										  <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr>;</expr_stmt></block_content></block></if>

	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt> <comment type="block">/* placate compiler */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * For compatibility with prior releases, we allow ALTER TABLE to be used
	 * with most other types of relations (but not composite types). We allow
	 * similar flexibility for ALTER INDEX in the case of RENAME, but not
	 * otherwise.  Otherwise, the user must select the correct form of the
	 * command for the relation at issue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_SEQUENCE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_TYPE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a composite type"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow ALTER TABLE on composite types. We want people to use ALTER
	 * TYPE for that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>!=</operator> <name>OBJECT_TYPE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TYPE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow ALTER TABLE .. SET SCHEMA on relations that can't be moved
	 * to a different schema, such as indexes and TOAST tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, sequence, or foreign table"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform any expressions present in the partition key
 *
 * Returns a transformed PartitionSpec, as well as the strategy code
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type>
<name>transformPartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>partspec</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>newspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<comment type="block">/* Parse partitioning strategy name */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized partitioning strategy \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Check valid number of columns for strategy */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"list\" partition strategy with more than one column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create a dummy ParseState and insert the target relation as its sole
	 * rangetable entry.  We need a ParseState for transformExpr.
	 */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take care of any partition expressions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>partspec-&gt;partParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pelem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Copy, to avoid scribbling on the input */</comment>
			<expr_stmt><expr><name>pelem</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now do parse transformation of the expression */</comment>
			<expr_stmt><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										<argument><expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we have to fix its collations too */</comment>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>newspec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute per-partition-column information from a list of PartitionElems.
 * Expressions in the PartitionElems must be parse-analyzed already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ComputePartitionAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partParams</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>am_oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pelem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple attribute reference */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in partition key does not exist"</literal></expr></argument>,
								<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use system column \"%s\" in partition key"</literal></expr></argument>,
								<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expression */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The expression must be of a storable type (e.g., not RECORD).
			 * The test is the same as for whether a table column is of a safe
			 * type (which is why we needn't check for the non-expression
			 * case).
			 */</comment>
			<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><literal type="string">"partition key"</literal></expr></argument>,
							   <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Strip any top-level COLLATE clause.  This ensures that we treat
			 * "x COLLATE y" and "(x COLLATE y)" alike.
			 */</comment>
			<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * User wrote "(column)" or "(column COLLATE something)".
				 * Treat it like simple attribute anyway.
				 */</comment>
				<expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>expr_attrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* marks the column as expression */</comment>
				<expr_stmt><expr><operator>*</operator><name>partexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Try to simplify the expression before checking for
				 * mutability.  The main practical value of doing it in this
				 * order is that an inline-able SQL-language function will be
				 * accepted if its expansion is immutable, whether or not the
				 * function itself is marked immutable.
				 *
				 * Note that expression_planner does not change the passed in
				 * expression destructively and we have already saved the
				 * expression to be stored into the catalog above.
				 */</comment>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Partition expression cannot contain mutable functions,
				 * because a given row must always map to the same partition
				 * as long as there is no change in the partition boundary
				 * structure.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"functions in partition key expression must be marked IMMUTABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * transformPartitionSpec() should have already rejected
				 * subqueries, aggregates, window functions, and SRFs, based
				 * on the EXPR_KIND_ for partition expressions.
				 */</comment>

				<comment type="block">/*
				 * Cannot have expressions containing whole-row references or
				 * system column references.
				 */</comment>
				<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
								  <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition key expressions cannot contain whole-row references"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
									  <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition key expressions cannot contain system column references"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * While it is not exactly *wrong* for a partition expression
				 * to be a constant, it seems better to reject such keys.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use constant expression as partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Apply collation override if any
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check we have a collation iff it's a collatable type.  The only
		 * expected failures here are (1) COLLATE applied to a noncollatable
		 * type, or (2) partition expression had an unresolved collation. But
		 * we might as well code this to be a complete consistency check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for partition expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>partcollation</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>attcollation</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Identify the appropriate operator class.  For list and range
		 * partitioning, we use a btree operator class; hash partitioning uses
		 * a hash operator class.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>am_oid</name> <operator>=</operator> <name>HASH_AM_OID</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>am_oid</name> <operator>=</operator> <name>BTREE_AM_OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pelem</name><operator>-&gt;</operator><name>opclass</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>am_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default hash operator class"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify a hash operator class or define a default hash operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default btree operator class"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify a btree operator class or define a default btree operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>ResolveOpClass</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
											   <argument><expr><name>atttype</name></expr></argument>,
											   <argument><expr><ternary><condition><expr><name>am_oid</name> <operator>==</operator> <name>HASH_AM_OID</name></expr> ?</condition><then> <expr><literal type="string">"hash"</literal></expr> </then><else>: <expr><literal type="string">"btree"</literal></expr></else></ternary></expr></argument>,
											   <argument><expr><name>am_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * PartConstraintImpliedByRelConstraint
 *		Do scanrel's existing constraints imply the partition constraint?
 *
 * "Existing constraints" include its check constraints and column-level
 * NOT NULL constraints.  partConstraint describes the partition constraint,
 * in implicit-AND form.
 */</comment>
<function><type><name>bool</name></type>
<name>PartConstraintImpliedByRelConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>existConstraint</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_check</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>i</name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * argisrow=false is correct even for a composite column,
				 * because attnotnull does not represent a SQL-spec IS NOT
				 * NULL test in such a case, just IS DISTINCT FROM NULL.
				 */</comment>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>num_check</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_check</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this constraint hasn't been fully validated yet, we must ignore
		 * it here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run each expression through const-simplification and
		 * canonicalization.  It is necessary, because we will be comparing it
		 * to similarly-processed partition constraint expressions, and may
		 * fail to detect valid matches without this.
		 */</comment>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>,
									  <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Try to make the proof.  Since we are comparing CHECK constraints, we
	 * need to use weak implication, i.e., we assume existConstraint is
	 * not-false and try to prove the same for partConstraint.
	 *
	 * Note that predicate_implied_by assumes its first argument is known
	 * immutable.  That should always be true for partition constraints, so we
	 * don't test it here.
	 */</comment>
	<return>return <expr><call><name>predicate_implied_by</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><name>existConstraint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * QueuePartitionConstraintValidation
 *
 * Add an entry to wqueue to have the given partition constraint validated by
 * Phase 3, for the given relation, and all its children.
 *
 * We first verify whether the given constraint is implied by pre-existing
 * relation constraints; if it is, there's no need to scan the table to
 * validate, so don't queue in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>QueuePartitionConstraintValidation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>validate_default</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Based on the table's existing constraints, determine whether or not we
	 * may skip scanning the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>validate_default</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint for table \"%s\" is implied by existing constraints"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Constraints proved insufficient. For plain relations, queue a
	 * validation item now; for partitioned tables, recurse to process each
	 * partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

		<comment type="block">/* Grab a work queue entry. */</comment>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name> <operator>=</operator> <name>validate_default</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>part_rel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>thisPartConstraint</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * This is the minimum lock we need to prevent deadlocks.
			 */</comment>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Adjust the constraint for scanrel so that it matches this
			 * partition's attribute numbers.
			 */</comment>
			<expr_stmt><expr><name>thisPartConstraint</name> <operator>=</operator>
				<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There can never be a whole-row reference here */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in partition constraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>part_rel</name></expr></argument>,
											   <argument><expr><name>thisPartConstraint</name></expr></argument>,
											   <argument><expr><name>validate_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep lock till commit */</comment>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE &lt;name&gt; ATTACH PARTITION &lt;partition-name&gt; FOR VALUES
 *
 * Return the address of the newly attached partition.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAttachPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attachrel</name></decl>,
				<decl><type ref="prev"/><name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attachrel_children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partConstraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigger_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partBoundConstraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cloned</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must lock the default partition if one exists, because attaching a
	 * new partition will change its partition constraint.
	 */</comment>
	<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
		<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attachrel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX I think it'd be a good idea to grab locks on all tables referenced
	 * by FKs at this point also.
	 */</comment>

	<comment type="block">/*
	 * Must be owner of both parent and source table -- parent was checked by
	 * ATSimplePermissions call in ATPrepCmd
	 */</comment>
	<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A partition can only have one parent */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a partition"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a typed table as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Table being attached should not already be part of inheritance; either
	 * as a child table...
	 */</comment>
	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach inheritance child as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ...or as a parent table (except the case when it is partitioned) */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach inheritance parent as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent circularity by seeing if rel is a partition of attachrel. (In
	 * particular, this disallows making a rel a partition of itself.)
	 *
	 * We do that by checking if rel is a member of the list of attachrel's
	 * partitions provided the latter is partitioned at all.  We want to avoid
	 * having to construct this list again, so we request the strongest lock
	 * on all partitions.  We need the strongest lock, because we may decide
	 * to scan them if we find out that the table being attached (or its leaf
	 * partitions) may contain rows that violate the partition constraint. If
	 * the table has a constraint that would prevent such rows, which by
	 * definition is present in all the partitions, we need not scan the
	 * table, nor its partitions.  But we cannot risk a deadlock by taking a
	 * weaker lock now and the stronger one only when needed.
	 */</comment>
	<expr_stmt><expr><name>attachrel_children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>attachrel_children</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular inheritance not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a child of \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If the parent is permanent, so must be all of its partitions. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a temporary relation as partition of permanent relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Temp parent cannot have a partition that is itself not a temp */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a permanent relation as partition of temporary relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If the parent is temp, it must belong to this session */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach as partition of temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ditto for the partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>attachrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach temporary relation of another session as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If parent has OIDs then child must have OIDs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach table \"%s\" without OIDs as partition of"</literal>
						<literal type="string">" table \"%s\" with OIDs"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OTOH, if parent doesn't have them, do not allow in attachrel either */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach table \"%s\" with OIDs as partition of table"</literal>
						<literal type="string">" \"%s\" without OIDs"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check if there are any columns in attachrel that aren't in the parent */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Try to find the column in parent (matching on column name) */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" contains column \"%s\" not found in parent \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The new partition may contain only the columns present in parent."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If child_rel has row-level triggers with transition tables, we
	 * currently don't allow it to become a partition.  See also prohibitions
	 * in ATExecAddInherit() and CreateTrigger().
	 */</comment>
	<expr_stmt><expr><name>trigger_name</name> <operator>=</operator> <call><name>FindTriggerIncompatibleWithInheritance</name><argument_list>(<argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>trigger_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" prevents table \"%s\" from becoming a partition"</literal></expr></argument>,
						<argument><expr><name>trigger_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the new partition's bound is valid and does not overlap any
	 * of existing partitions of the parent - note that it does not return on
	 * error.
	 */</comment>
	<expr_stmt><expr><call><name>check_new_partition_bound</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK to create inheritance.  Rest of the checks performed there */</comment>
	<expr_stmt><expr><call><name>CreateInheritance</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the pg_class entry. */</comment>
	<expr_stmt><expr><call><name>StorePartitionBound</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure there exists a correct set of indexes in the partition. */</comment>
	<expr_stmt><expr><call><name>AttachPartitionEnsureIndexes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and triggers */</comment>
	<expr_stmt><expr><call><name>CloneRowTriggersToPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clone foreign key constraints, and setup for Phase 3 to verify them.
	 */</comment>
	<expr_stmt><expr><name>cloned</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloneForeignKeyConstraints</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>cloned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cloned</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ClonedConstraint</name> <modifier>*</modifier></type><name>clonedcon</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>clonedrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>parttab</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>clonedrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>clonedcon</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parttab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>clonedrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>clonedcon</name><operator>-&gt;</operator><name>constraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_FOREIGN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <name><name>clonedcon</name><operator>-&gt;</operator><name>refrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name><name>clonedcon</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <name><name>clonedcon</name><operator>-&gt;</operator><name>conid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>clonedcon</name><operator>-&gt;</operator><name>constraint</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>parttab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parttab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>clonedrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Generate partition constraint from the partition bound specification.
	 * If the parent itself is a partition, make sure to include its
	 * constraint as well.
	 */</comment>
	<expr_stmt><expr><name>partBoundConstraint</name> <operator>=</operator> <call><name>get_qual_from_partbound</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>partBoundConstraint</name></expr></argument>,
								 <argument><expr><call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Skip validation if there are no constraints to validate. */</comment>
	<if_stmt><if>if <condition>(<expr><name>partConstraint</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Run the partition quals through const-simplification similar to
		 * check constraints.  We skip canonicalize_qual, though, because
		 * partition quals should be in canonical form already.
		 */</comment>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator>
			<operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XXX this sure looks wrong */</comment>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Adjust the generated constraint to match this partition's attribute
		 * numbers.
		 */</comment>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>,
												 <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There can never be a whole-row reference here */</comment>
		<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unexpected whole-row reference found in partition key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Validate partition constraints against the table being attached. */</comment>
		<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're attaching a partition other than the default partition and a
	 * default one exists, then that partition's partition constraint changes,
	 * so add an entry to the work queue to validate it, too.  (We must not do
	 * this when the partition being attached is the default one; we already
	 * did it above!)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>defaultrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defPartConstraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>bound</name><operator>-&gt;</operator><name>is_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we already hold a lock on the default partition */</comment>
		<expr_stmt><expr><name>defaultrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator>
			<call><name>get_proposed_default_constraint</name><argument_list>(<argument><expr><name>partBoundConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Map the Vars in the constraint expression from rel's attnos to
		 * defaultrel's.
		 */</comment>
		<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator>
			<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>defPartConstraint</name></expr></argument>,
									<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>defaultrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>defaultrel</name></expr></argument>,
										   <argument><expr><name>defPartConstraint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* keep our lock until commit. */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>defaultrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock until commit */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AttachPartitionEnsureIndexes
 *		subroutine for ATExecAttachPartition to create/match indexes
 *
 * Enforce the indexing rule for partitioned tables during ALTER TABLE / ATTACH
 * PARTITION: every partition must have an index attached to each index on the
 * partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AttachPartitionEnsureIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>attachrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attachRelIdxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>attachrelIdxRels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>attachInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								<argument><expr><literal type="string">"AttachPartitionEnsureIndexes"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idxes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachRelIdxs</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachrelIdxRels</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachInfos</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build arrays of all existing indexes and their IndexInfos */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>attachRelIdxs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cldIdxId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>cldIdxId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attachInfos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we're attaching a foreign table, we must fail if any of the indexes
	 * is a constraint index; otherwise, there's nothing to do here.  Do this
	 * before starting work, to avoid wasting the effort of building a few
	 * non-unique indexes before coming across a unique one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>idx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator>
				<name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach foreign table \"%s\" as partition of partitioned table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains unique indexes."</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<goto>goto <name>out</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For each index on the partitioned table, find a matching one in the
	 * partition-to-be; if one is not found, create one.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>idx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore indexes in the partitioned table other than partitioned
		 * indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* construct an indexinfo to compare existing indexes against */</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan the list of existing indexes in the partition-to-be, and mark
		 * the first matching, unattached one we find, if any, as partition of
		 * the parent index.  If we find one, we're done.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>cldIdxId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>cldConstrOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* does this index have a parent?  if so, can't use it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name><name>attachInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
								 <argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_indcollation</name></expr></argument>,
								 <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
								 <argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_opfamily</name></expr></argument>,
								 <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
								 <argument><expr><name>attmap</name></expr></argument>,
								 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If this index is being created in the parent because of a
				 * constraint, then the child needs to have a constraint also,
				 * so look for one.  If there is no such constraint, this
				 * index is no good, so keep looking.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cldConstrOid</name> <operator>=</operator>
						<call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>cldIdxId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* no dice */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* bingo. */</comment>
				<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If no suitable index was found in the partition-to-be, create one
		 * now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>attmap</name></expr></argument>,
										   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>constraintOid</name></expr></argument>,
						<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

<label><name>out</name>:</label>
	<comment type="block">/* Clean up. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * isPartitionTrigger
 *		Subroutine for CloneRowTriggersToPartition: determine whether
 *		the given trigger has been cloned from another one.
 *
 * We use pg_depend as a proxy for this, since we don't have any direct
 * evidence.  This is an ugly hack to cope with a catalog deficiency.
 * Keep away from children.  Do not stare with naked eyes.  Do not propagate.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isPartitionTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>trigger_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_depend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_depend</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>trigger_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_depend</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type>	<name>dep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>TriggerRelationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_depend</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CloneRowTriggersToPartition
 *		subroutine for ATExecAttachPartition/DefineRelation to create row
 *		triggers on partitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneRowTriggersToPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_trigger</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>perTupCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_trigger</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>perTupCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"clone trig"</literal></expr></argument>, <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trigForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>trigStmt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>trigargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore statement-level triggers; those are not cloned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Internal triggers require careful examination.  Ideally, we don't
		 * clone them.
		 *
		 * However, if our parent is a partitioned relation, there might be
		 * internal triggers that need cloning.  In that case, we must
		 * skip clone it if the trigger on parent depends on another trigger.
		 *
		 * Note we dare not verify that the other trigger belongs to an
		 * ancestor relation of our parent, because that creates deadlock
		 * opportunities.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgisinternal</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>||</operator>
			 <operator>!</operator><call><name>isPartitionTrigger</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Complain if we find an unexpected trigger type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected trigger \"%s\" found"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Use short-lived context for CREATE TRIGGER */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there is a WHEN clause, generate a 'cooked' version of it that's
		 * appropriate for the partition.
		 */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgqual</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>,
													<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in trigger WHEN clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>,
													<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in trigger WHEN clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there is a column list, transform it to a list of column names.
		 * Note we don't need to map this list in any way ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>col</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
									<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cols</name></expr></argument>,
							   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reconstruct trigger arguments list. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgargs</name></expr></argument>,
								 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tgargs is null for trigger \"%s\" in partition \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>trigargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>trigargs</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>trigStmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* passed separately */</comment>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>trigargs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name> <operator>&amp;</operator> <name>TRIGGER_TYPE_TIMING_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name> <operator>&amp;</operator> <name>TRIGGER_TYPE_EVENT_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* passed separately */</comment>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> <comment type="block">/* not supported at present */</comment>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* passed separately */</comment>

		<expr_stmt><expr><call><name>CreateTrigger</name><argument_list>(<argument><expr><name>trigStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
					  <argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE DETACH PARTITION
 *
 * Return the address of the relation that is no longer a partition of rel.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDetachPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partRel</name></decl>,
				<decl><type ref="prev"/><name>classRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>new_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must lock the default partition, because detaching this partition
	 * will change its partition constraint.
	 */</comment>
	<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
		<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>partRel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All inheritance related checks are performed within the function */</comment>
	<expr_stmt><expr><call><name>RemoveInheritance</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update pg_class tuple */</comment>
	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear relpartbound and reset relispartition */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>new_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the relation being detached is the default partition itself,
		 * remove it from the parent's pg_partitioned_table entry.
		 *
		 * If not, we must invalidate default partition's relcache entry, as
		 * in StorePartitionBound: its partition constraint depends on every
		 * other partition's partition constraint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>defaultPartOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* detach indexes too */</comment>
	<expr_stmt><expr><name>indexes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>idxid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_superclass</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>IndexGetRelation</name><argument_list>(<argument><expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If there's a constraint associated with the index, detach it too */</comment>
		<expr_stmt><expr><name>constrOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Drop any triggers that were cloned on creation/attach. */</comment>
	<expr_stmt><expr><call><name>DropClonedTriggersFromPartition</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detach any foreign keys that are inherited.  This includes creating
	 * additional action triggers.
	 */</comment>
	<expr_stmt><expr><name>fks</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>fks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>contup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>contup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>conform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* consider only the inherited foreign keys */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conform</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name> <operator>||</operator>
			<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* unset conparentid and adjust conislocal, coninhcount, etc. */</comment>
		<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the action triggers on the referenced relation.  When this was
		 * a partition the action triggers pointed to the parent rel (they
		 * still do), but now we need separate ones of our own.
		 */</comment>
		<expr_stmt><expr><name>fkconstraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>createForeignKeyActionTriggers</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name><name>conform</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>,
									   <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>,
									   <argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>fks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate the parent's relcache so that the partition is no longer
	 * included in its partition descriptor.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock until commit */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DropClonedTriggersFromPartition
 *		subroutine for ATExecDetachPartition to remove any triggers that were
 *		cloned to the partition when it was created-as-partition or attached.
 *		This undoes what CloneRowTriggersToPartition did.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropClonedTriggersFromPartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>trigtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_trigger to search for all triggers on this rel.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>trigtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>trigoid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>trigtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>trig</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore triggers that weren't cloned */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isPartitionTrigger</name><argument_list>(<argument><expr><name>trigoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * This is ugly, but necessary: remove the dependency markings on the
		 * trigger so that it can be removed.
		 */</comment>
		<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>,
										<argument><expr><name>TriggerRelationId</name></expr></argument>,
										<argument><expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>,
										<argument><expr><name>RelationRelationId</name></expr></argument>,
										<argument><expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* remember this trigger to remove it below */</comment>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>trig</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* make the dependency removal visible to the deletion below */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done */</comment>
	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Before acquiring lock on an index, acquire the same lock on the owning
 * table.
 */</comment>
<struct>struct <name>AttachIndexCallbackState</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partitionOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentTblOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lockedParentTbl</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForAttachIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>AttachIndexCallbackState</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>AttachIndexCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>lockedParentTbl</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parentTblOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lockedParentTbl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we previously locked some other heap, and the name we're looking up
	 * no longer refers to an index on that relation, release the now-useless
	 * lock.  XXX maybe we should do *after* we verify whether the index does
	 * not actually belong to the same relation ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped, so nothing to do */</comment>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we need only examine the heap's tupledesc, an access share lock
	 * on it (preventing any DDL) is sufficient.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER INDEX i1 ATTACH PARTITION i2
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAttachPartitionIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partTbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parentTbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partIdxId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>currParent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>AttachIndexCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to obtain lock on the index 'name' to modify it, but we also
	 * need to read its owning table's tuple descriptor -- so we need to lock
	 * both.  To avoid deadlocks, obtain lock on the table before doing so on
	 * the index.  Furthermore, we need to examine the parent table of the
	 * partition, so lock that one too.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>partitionOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>parentTblOid</name></name> <operator>=</operator> <name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>lockedParentTbl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partIdxId</name> <operator>=</operator>
		<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>RangeVarCallbackForAttachIndex</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Not there? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>name</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* no deadlock risk: RangeVarGetRelidExtended already acquired the lock */</comment>
	<expr_stmt><expr><name>partIdx</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we already hold locks on both tables, so this is safe: */</comment>
	<expr_stmt><expr><name>parentTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Silently do nothing if already in the right state */</comment>
	<expr_stmt><expr><name>currParent</name> <operator>=</operator> <ternary><condition><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr> ?</condition><then>
		<expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currParent</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>childInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>parentInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>,
					<decl><type ref="prev"/><name>cldConstrId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this partition already has an index attached, refuse the
		 * operation.
		 */</comment>
		<expr_stmt><expr><call><name>refuseDupeIndexAttach</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>currParent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is already attached to another index."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure it indexes a partition of the other index's table */</comment>
		<expr_stmt><expr><name>partDesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partDesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>partDesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>state</name><operator>.</operator><name>partitionOid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is not an index on any partition of table \"%s\"."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Ensure the indexes are compatible */</comment>
		<expr_stmt><expr><name>childInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name>childInfo</name></expr></argument>, <argument><expr><name>parentInfo</name></expr></argument>,
							  <argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
							  <argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
							  <argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
							  <argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
							  <argument><expr><name>attmap</name></expr></argument>,
							  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index definitions do not match."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there is a constraint in the parent, make sure there is one in
		 * the child too.
		 */</comment>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cldConstrId</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cldConstrId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index \"%s\" belongs to a constraint in table \"%s\" but no constraint exists for index \"%s\"."</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* All good -- do it */</comment>
		<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrId</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>validatePartitionedIndex</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* keep these locks till commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether the given partition already contains an index attached
 * to the given partitioned index.  If so, raise an error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refuseDupeIndexAttach</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partitionTbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_inherits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_inherits</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inhForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tab</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>inhForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tab</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Another index is already attached for partition \"%s\"."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_inherits</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether the set of attached partition indexes to a parent index on
 * a partitioned table is complete.  If it is, mark the parent index valid.
 *
 * This should be called each time a partition index is attached.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validatePartitionedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partedIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partedTbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>inheritsRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inhTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_inherits for this parent index.  Count each valid index we find
	 * (verifying the pg_index entry for each), and if we reach the total
	 * amount we expect, we can mark this parent index as valid.
	 */</comment>
	<expr_stmt><expr><name>inheritsRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inheritsRel</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>inhTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inhForm</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inhTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Done with pg_inherits */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inheritsRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we found as many inherited indexes as the partitioned table has
	 * partitions, we're good; update pg_index to set indisvalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>==</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>partedTbl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nparts</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>idxRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>indisvalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>updated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this index is in turn a partition of a larger index, validating it
	 * might cause the parent to become valid also.  Try that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>updated</name> <operator>&amp;&amp;</operator> <name><name>partedIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentIdxId</name></decl>,
					<decl><type ref="prev"/><name>parentTblId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parentIdx</name></decl>,
					<decl><type ref="prev"/><name>parentTbl</name></decl>;</decl_stmt>

		<comment type="block">/* make sure we see the validation we just did */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>parentIdxId</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentTblId</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentIdx</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentIdxId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentTblId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>validatePartitionedIndex</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update pg_class for 'px_build' reloptions from 'on' to 'finish'.
 */</comment>
<function><type><name>void</name></type>
<name>polar_px_btbuild_update_pg_class</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_DefElem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>defnamespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name> <operator>=</operator> <literal type="string">"px_build"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>defaction</name></name> <operator>=</operator> <name>DEFELEM_SET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"finish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ATExecSetRelOptions</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>AT_SetRelOptions</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function></unit>
