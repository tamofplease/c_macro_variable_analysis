<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/commands/typecmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * typecmds.c
 *	  Routines for SQL commands that manipulate types (and domains).
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/typecmds.c
 *
 * DESCRIPTION
 *	  The "DefineFoo" routines take the parse tree and pick out the
 *	  appropriate arguments/flags, passing the results to the
 *	  corresponding "FooDefine" routines (in src/catalog) that do
 *	  the actual catalog-munging.  These routines also verify permission
 *	  of the user to execute the command.
 *
 * NOTES
 *	  These things must be defined and committed in the following order:
 *		"create function":
 *				input/output, recv/send functions
 *		"create type":
 *				type
 *		"create operator":
 *				operators
 *
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/binary_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* result structure for get_rels_with_domain() */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* opened and locked relation */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>			<comment type="block">/* number of attributes of interest */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>atts</name></decl>;</decl_stmt>			<comment type="block">/* attribute numbers */</comment>
	<comment type="block">/* atts[] is of allocated length RelationGetNumberOfAttributes(rel) */</comment>
}</block></struct></type> <name>RelToCheck</name>;</typedef>

<comment type="block">/* Potentially set by pg_upgrade_support functions */</comment>
<decl_stmt><decl><type><name>Oid</name></type>			<name>binary_upgrade_next_array_pg_type_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>makeRangeConstructors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespace</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>rangeOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeInputFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeOutputFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeReceiveFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeSendFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeTypmodinFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeTypmodoutFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findTypeAnalyzeFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findRangeSubOpclass</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opcname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findRangeCanonicalFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findRangeSubtypeDiffFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateDomainConstraint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>domainoid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ccbin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_rels_with_domain</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>domainOid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkEnumOwner</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>domainAddConstraint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>domainOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>domainNamespace</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>baseTypeOid</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>typMod</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domainName</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>constrAddr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_domain_constraint_value</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
								<parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * DefineType
 *		Registers a new base type.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineType</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameters</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typeName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>internalLength</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* default: variable-length */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inputName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outputName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>receiveName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sendName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>typmodinName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>typmodoutName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>analyzeName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>category</name> <init>= <expr><name>TYPCATEGORY_USER</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>preferred</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>delimiter</name> <init>= <expr><name>DEFAULT_TYPDELIM</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defaultValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>byValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>alignment</name> <init>= <expr><literal type="char">'i'</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* default alignment */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>storage</name> <init>= <expr><literal type="char">'p'</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* default TOAST storage method */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>likeTypeEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>internalLengthEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>inputNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>outputNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>receiveNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>sendNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>typmodinNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>typmodoutNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>analyzeNameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>categoryEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>preferredEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>delimiterEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>elemTypeEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defaultValueEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>byValueEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>alignmentEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>storageEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>collatableEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outputOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>receiveOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sendOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmodinOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmodoutOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>analyzeOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>array_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>array_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>resulttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As of Postgres 8.4, we require superuser privilege to create a base
	 * type.  This is simple paranoia: there are too many ways to mess up the
	 * system with an incorrect type definition (for instance, representation
	 * parameters that don't match what the C code expects).  In practice it
	 * takes superuser privilege to create the I/O functions, and so the
	 * former requirement that you own the I/O functions pretty much forced
	 * superuserness anyway.  We're just making doubly sure here.
	 *
	 * XXX re-enable NOT_USED code sections below if you remove this test.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create a base type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>typeNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Look to see if type already exists (presumably as a shell; if not,
	 * TypeCreate will complain).
	 */</comment>
	<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
							 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's not a shell, see if it's an autogenerated array type, and if so
	 * rename it out of the way.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>get_typisdefined</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>moveArrayTypeName</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>typoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it doesn't exist, create it as a shell, so that the OID is known for
	 * use in the I/O function definitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>TypeShellMake</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typoid</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
		<comment type="block">/* Make new shell type visible for modification below */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the command was a parameterless CREATE TYPE, we're done ---
		 * creating the shell type was all we're supposed to do.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>parameters</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Complain if dummy CREATE TYPE and entry already exists */</comment>
		<if_stmt><if>if <condition>(<expr><name>parameters</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Extract the parameters from the parameter list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>pl</argument>, <argument>parameters</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name>   <modifier>*</modifier><modifier>*</modifier></type><name>defelp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"like"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>likeTypeEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"internallength"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>internalLengthEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"input"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>inputNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"output"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>outputNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"receive"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>receiveNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"send"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>sendNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"typmod_in"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>typmodinNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"typmod_out"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>typmodoutNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyse"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>analyzeNameEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"category"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>categoryEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"preferred"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>preferredEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"delimiter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>delimiterEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"element"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>elemTypeEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>defaultValueEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"passedbyvalue"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>byValueEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"alignment"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>alignmentEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"storage"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>storageEl</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"collatable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defelp</name> <operator>=</operator> <operator>&amp;</operator><name>collatableEl</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* WARNING, not ERROR, for historical backwards-compatibility */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type attribute \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>defelp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>defelp</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now interpret the options; we do this separately so that LIKE can be
	 * overridden by other options regardless of the ordering in the parameter
	 * list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>likeTypeEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Type</name></type>		<name>likeType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>likeForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>likeType</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>defGetTypeName</name><argument_list>(<argument><expr><name>likeTypeEl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>likeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>likeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>internalLength</name> <operator>=</operator> <name><name>likeForm</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>byValue</name> <operator>=</operator> <name><name>likeForm</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>alignment</name> <operator>=</operator> <name><name>likeForm</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>storage</name> <operator>=</operator> <name><name>likeForm</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>likeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>internalLengthEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>internalLength</name> <operator>=</operator> <call><name>defGetTypeLength</name><argument_list>(<argument><expr><name>internalLengthEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inputNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inputName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>inputNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>outputNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outputName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>outputNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>receiveNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>receiveName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>receiveNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sendName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>sendNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodinNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typmodinName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>typmodinNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodoutNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typmodoutName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>typmodoutNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>analyzeNameEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>analyzeName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>analyzeNameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>categoryEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>categoryEl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>category</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* restrict to non-control ASCII */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>category</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">32</literal> <operator>||</operator> <name>category</name></expr></argument> &gt;</argument_list></name> <literal type="number">126</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid type category \"%s\": must be simple ASCII"</literal></expr></argument>,
							<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>preferredEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>preferred</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>preferredEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>delimiterEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>delimiterEl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>delimiter</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* XXX shouldn't we restrict the delimiter? */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>elemTypeEl</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>elemType</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>defGetTypeName</name><argument_list>(<argument><expr><name>elemTypeEl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* disallow arrays of pseudotypes */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>elemType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array element type cannot be %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elemType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>defaultValueEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>defaultValue</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defaultValueEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>byValueEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>byValue</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>byValueEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>alignmentEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>alignmentEl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: if argument was an unquoted identifier, parser will have
		 * applied translations to it, so be prepared to recognize translated
		 * type names as well as the nominal form.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"double"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"float8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.float8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignment</name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"int4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.int4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignment</name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"int2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.int2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignment</name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"char"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.bpchar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>alignment</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alignment \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>storageEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>storageEl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"external"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"extended"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"storage \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>collatableEl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collation</name> <operator>=</operator> <ternary><condition><expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>collatableEl</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DEFAULT_COLLATION_OID</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * make sure we have our required definitions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inputName</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type input function must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>outputName</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type output function must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmodinName</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>typmodoutName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type modifier output function is useless without a type modifier input function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert I/O proc names to OIDs
	 */</comment>
	<expr_stmt><expr><name>inputOid</name> <operator>=</operator> <call><name>findTypeInputFunction</name><argument_list>(<argument><expr><name>inputName</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outputOid</name> <operator>=</operator> <call><name>findTypeOutputFunction</name><argument_list>(<argument><expr><name>outputName</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>receiveName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>receiveOid</name> <operator>=</operator> <call><name>findTypeReceiveFunction</name><argument_list>(<argument><expr><name>receiveName</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sendOid</name> <operator>=</operator> <call><name>findTypeSendFunction</name><argument_list>(<argument><expr><name>sendName</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Verify that I/O procs return the expected thing.  If we see OPAQUE,
	 * complain and change it to the correct type-safe choice.
	 */</comment>
	<expr_stmt><expr><name>resulttype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>inputOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>resulttype</name> <operator>!=</operator> <name>typoid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>resulttype</name> <operator>==</operator> <name>OPAQUEOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* backwards-compatibility hack */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"changing return type of function %s from %s to %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>inputName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"opaque"</literal></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetFunctionReturnType</name><argument_list>(<argument><expr><name>inputOid</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type input function %s must return type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>inputName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>resulttype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>outputOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>resulttype</name> <operator>!=</operator> <name>CSTRINGOID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>resulttype</name> <operator>==</operator> <name>OPAQUEOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* backwards-compatibility hack */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"changing return type of function %s from %s to %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>outputName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"opaque"</literal></expr></argument>, <argument><expr><literal type="string">"cstring"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetFunctionReturnType</name><argument_list>(<argument><expr><name>outputOid</name></expr></argument>, <argument><expr><name>CSTRINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type output function %s must return type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>outputName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"cstring"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>receiveOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>resulttype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>receiveOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resulttype</name> <operator>!=</operator> <name>typoid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type receive function %s must return type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>receiveName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>resulttype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>sendOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resulttype</name> <operator>!=</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type send function %s must return type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>sendName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"bytea"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Convert typmodin/out function proc names to OIDs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typmodinName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typmodinOid</name> <operator>=</operator> <call><name>findTypeTypmodinFunction</name><argument_list>(<argument><expr><name>typmodinName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodoutName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typmodoutOid</name> <operator>=</operator> <call><name>findTypeTypmodoutFunction</name><argument_list>(<argument><expr><name>typmodoutName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert analysis function proc name to an OID. If no analysis function
	 * is specified, we'll use zero to select the built-in default algorithm.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>analyzeName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>analyzeOid</name> <operator>=</operator> <call><name>findTypeAnalyzeFunction</name><argument_list>(<argument><expr><name>analyzeName</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check permissions on functions.  We choose to require the creator/owner
	 * of a type to also own the underlying functions.  Since creating a type
	 * is tantamount to granting public execute access on the functions, the
	 * minimum sane check would be for execute-with-grant-option.  But we
	 * don't have a way to make the type go away if the grant option is
	 * revoked, so ownership seems better.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<comment type="block">/* XXX this is unnecessary given the superuser check above */</comment>
	<if_stmt><if>if <condition>(<expr><name>inputOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>inputOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>inputName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>outputOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>outputOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>outputName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>receiveOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>receiveOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>receiveName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>sendOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>sendName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodinOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>typmodinOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>typmodinName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodoutOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>typmodoutOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>typmodoutName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>analyzeOid</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_proc_ownercheck</name><argument_list>(<argument><expr><name>analyzeOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>analyzeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Print warnings if any of the type's I/O functions are marked volatile.
	 * There is a general assumption that I/O functions are stable or
	 * immutable; this allows us for example to mark record_in/record_out
	 * stable rather than volatile.  Ideally we would throw errors not just
	 * warnings here; but since this check is new as of 9.5, and since the
	 * volatility marking might be just an error-of-omission and not a true
	 * indication of how the function behaves, we'll let it pass as a warning
	 * for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inputOid</name> <operator>&amp;&amp;</operator> <call><name>func_volatile</name><argument_list>(<argument><expr><name>inputOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type input function %s should not be volatile"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>inputName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>outputOid</name> <operator>&amp;&amp;</operator> <call><name>func_volatile</name><argument_list>(<argument><expr><name>outputOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type output function %s should not be volatile"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>outputName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>receiveOid</name> <operator>&amp;&amp;</operator> <call><name>func_volatile</name><argument_list>(<argument><expr><name>receiveOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type receive function %s should not be volatile"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>receiveName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sendOid</name> <operator>&amp;&amp;</operator> <call><name>func_volatile</name><argument_list>(<argument><expr><name>sendOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type send function %s should not be volatile"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>sendName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodinOid</name> <operator>&amp;&amp;</operator> <call><name>func_volatile</name><argument_list>(<argument><expr><name>typmodinOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type modifier input function %s should not be volatile"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>typmodinName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmodoutOid</name> <operator>&amp;&amp;</operator> <call><name>func_volatile</name><argument_list>(<argument><expr><name>typmodoutOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type modifier output function %s should not be volatile"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>typmodoutName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK, we're done checking, time to make the type.  We must assign the
	 * array type OID ahead of calling TypeCreate, since the base type and
	 * array type each refer to the other.
	 */</comment>
	<expr_stmt><expr><name>array_oid</name> <operator>=</operator> <call><name>AssignTypeArrayOid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now have TypeCreate do all the real work.
	 *
	 * Note: the pg_type.oid is stored in user tables as array elements (base
	 * types) in ArrayType and in composite types in DatumTupleFields.  This
	 * oid must be preserved by binary upgrades.
	 */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator>
		<call><name>TypeCreate</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no predetermined type OID */</comment>
				   <argument><expr><name>typeName</name></expr></argument>,	<comment type="block">/* type name */</comment>
				   <argument><expr><name>typeNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* relation oid (n/a here) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* relation kind (ditto) */</comment>
				   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* owner's ID */</comment>
				   <argument><expr><name>internalLength</name></expr></argument>,	<comment type="block">/* internal size */</comment>
				   <argument><expr><name>TYPTYPE_BASE</name></expr></argument>,	<comment type="block">/* type-type (base type) */</comment>
				   <argument><expr><name>category</name></expr></argument>,	<comment type="block">/* type-category */</comment>
				   <argument><expr><name>preferred</name></expr></argument>,	<comment type="block">/* is it a preferred type? */</comment>
				   <argument><expr><name>delimiter</name></expr></argument>,	<comment type="block">/* array element delimiter */</comment>
				   <argument><expr><name>inputOid</name></expr></argument>,	<comment type="block">/* input procedure */</comment>
				   <argument><expr><name>outputOid</name></expr></argument>,	<comment type="block">/* output procedure */</comment>
				   <argument><expr><name>receiveOid</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
				   <argument><expr><name>sendOid</name></expr></argument>,		<comment type="block">/* send procedure */</comment>
				   <argument><expr><name>typmodinOid</name></expr></argument>, <comment type="block">/* typmodin procedure */</comment>
				   <argument><expr><name>typmodoutOid</name></expr></argument>,	<comment type="block">/* typmodout procedure */</comment>
				   <argument><expr><name>analyzeOid</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
				   <argument><expr><name>elemType</name></expr></argument>,	<comment type="block">/* element type ID */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* this is not an array type */</comment>
				   <argument><expr><name>array_oid</name></expr></argument>,	<comment type="block">/* array type we are about to create */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* base type ID (only for domains) */</comment>
				   <argument><expr><name>defaultValue</name></expr></argument>,	<comment type="block">/* default type value */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* no binary form available */</comment>
				   <argument><expr><name>byValue</name></expr></argument>,		<comment type="block">/* passed by value */</comment>
				   <argument><expr><name>alignment</name></expr></argument>,	<comment type="block">/* required alignment */</comment>
				   <argument><expr><name>storage</name></expr></argument>,		<comment type="block">/* TOAST strategy */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* typMod (Domains only) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* Array Dimensions of typbasetype */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* Type NOT NULL */</comment>
				   <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* type's collation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typoid</name> <operator>==</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the array type that goes with it.
	 */</comment>
	<expr_stmt><expr><name>array_type</name> <operator>=</operator> <call><name>makeArrayTypeName</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* alignment must be 'i' or 'd' for arrays */</comment>
	<expr_stmt><expr><name>alignment</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>alignment</name> <operator>==</operator> <literal type="char">'d'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'d'</literal></expr> </then><else>: <expr><literal type="char">'i'</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TypeCreate</name><argument_list>(<argument><expr><name>array_oid</name></expr></argument>,		<comment type="block">/* force assignment of this type OID */</comment>
			   <argument><expr><name>array_type</name></expr></argument>,		<comment type="block">/* type name */</comment>
			   <argument><expr><name>typeNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* relation oid (n/a here) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* relation kind (ditto) */</comment>
			   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,		<comment type="block">/* owner's ID */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* internal size (always varlena) */</comment>
			   <argument><expr><name>TYPTYPE_BASE</name></expr></argument>,	<comment type="block">/* type-type (base type) */</comment>
			   <argument><expr><name>TYPCATEGORY_ARRAY</name></expr></argument>,	<comment type="block">/* type-category (array) */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* array types are never preferred */</comment>
			   <argument><expr><name>delimiter</name></expr></argument>,		<comment type="block">/* array element delimiter */</comment>
			   <argument><expr><name>F_ARRAY_IN</name></expr></argument>,		<comment type="block">/* input procedure */</comment>
			   <argument><expr><name>F_ARRAY_OUT</name></expr></argument>,		<comment type="block">/* output procedure */</comment>
			   <argument><expr><name>F_ARRAY_RECV</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
			   <argument><expr><name>F_ARRAY_SEND</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
			   <argument><expr><name>typmodinOid</name></expr></argument>,		<comment type="block">/* typmodin procedure */</comment>
			   <argument><expr><name>typmodoutOid</name></expr></argument>,	<comment type="block">/* typmodout procedure */</comment>
			   <argument><expr><name>F_ARRAY_TYPANALYZE</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
			   <argument><expr><name>typoid</name></expr></argument>,			<comment type="block">/* element type ID */</comment>
			   <argument><expr><name>true</name></expr></argument>,			<comment type="block">/* yes this is an array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no further array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* base type ID */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* never a default type value */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* binary default isn't sent either */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* never passed by value */</comment>
			   <argument><expr><name>alignment</name></expr></argument>,		<comment type="block">/* see above */</comment>
			   <argument><expr><literal type="char">'x'</literal></expr></argument>,				<comment type="block">/* ARRAY is always toastable */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* typMod (Domains only) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* Array dimensions of typbasetype */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* Type NOT NULL */</comment>
			   <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* type's collation */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of type deletion.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveTypeById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it is an enum, delete the pg_enum entries too; we don't bother with
	 * making dependency entries for those, so it has to be done "by hand"
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EnumValuesDelete</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it is a range type, delete the pg_range entry too; we don't bother
	 * with making a dependency entry for that, so it has to be done "by hand"
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RangeDelete</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DefineDomain
 *		Registers a new domain.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineDomain</name><parameter_list>(<parameter><decl><type><name>CreateDomainStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>domainName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>domainArrayName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>internalLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputProcedure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outputProcedure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>receiveProcedure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sendProcedure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>analyzeProcedure</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>byValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>delimiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>alignment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>storage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defaultValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defaultValueBin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_default</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typNotNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nullDefined</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typNDims</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>schema</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>listptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>basetypeoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domaincoll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainArrayOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>baseType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>basetypeMod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>baseColl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>domainNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>domainname</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>domainName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>domainNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>domainNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for collision with an existing type name.  If there is one and
	 * it's an autogenerated array, we can rename it out of the way.
	 */</comment>
	<expr_stmt><expr><name>old_type_oid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>domainName</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>moveArrayTypeName</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>, <argument><expr><name>domainName</name></expr></argument>, <argument><expr><name>domainNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>domainName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up the base type.
	 */</comment>
	<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>basetypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>baseType</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>basetypeoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Base type must be a plain base type, a composite type, another domain,
	 * an enum or a range type.  Domains over pseudotypes would create a
	 * security hole.  (It would be shorter to code this to just check for
	 * pseudotypes; but it seems safer to call out the specific typtypes that
	 * are supported, rather than assume that all future typtypes would be
	 * automatically supported.)
	 */</comment>
	<expr_stmt><expr><name>typtype</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typtype</name> <operator>!=</operator> <name>TYPTYPE_BASE</name> <operator>&amp;&amp;</operator>
		<name>typtype</name> <operator>!=</operator> <name>TYPTYPE_COMPOSITE</name> <operator>&amp;&amp;</operator>
		<name>typtype</name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name> <operator>&amp;&amp;</operator>
		<name>typtype</name> <operator>!=</operator> <name>TYPTYPE_ENUM</name> <operator>&amp;&amp;</operator>
		<name>typtype</name> <operator>!=</operator> <name>TYPTYPE_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid base type for a domain"</literal></expr></argument>,
						<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>basetypeoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>basetypeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identify the collation if any
	 */</comment>
	<expr_stmt><expr><name>baseColl</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typcollation</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>collClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>domaincoll</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>domaincoll</name> <operator>=</operator> <name>baseColl</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Complain if COLLATE is applied to an uncollatable type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>domaincoll</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>baseColl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>basetypeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* passed by value */</comment>
	<expr_stmt><expr><name>byValue</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>

	<comment type="block">/* Required Alignment */</comment>
	<expr_stmt><expr><name>alignment</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/* TOAST Strategy */</comment>
	<expr_stmt><expr><name>storage</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>

	<comment type="block">/* Storage Length */</comment>
	<expr_stmt><expr><name>internalLength</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>

	<comment type="block">/* Type Category */</comment>
	<expr_stmt><expr><name>category</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typcategory</name></name></expr>;</expr_stmt>

	<comment type="block">/* Array element Delimiter */</comment>
	<expr_stmt><expr><name>delimiter</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typdelim</name></name></expr>;</expr_stmt>

	<comment type="block">/* I/O Functions */</comment>
	<expr_stmt><expr><name>inputProcedure</name> <operator>=</operator> <name>F_DOMAIN_IN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outputProcedure</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typoutput</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>receiveProcedure</name> <operator>=</operator> <name>F_DOMAIN_RECV</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendProcedure</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typsend</name></name></expr>;</expr_stmt>

	<comment type="block">/* Domains never accept typmods, so no typmodin/typmodout needed */</comment>

	<comment type="block">/* Analysis function */</comment>
	<expr_stmt><expr><name>analyzeProcedure</name> <operator>=</operator> <name><name>baseType</name><operator>-&gt;</operator><name>typanalyze</name></name></expr>;</expr_stmt>

	<comment type="block">/* Inherited default value */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>typeTup</name></expr></argument>,
							<argument><expr><name>Anum_pg_type_typdefault</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>defaultValue</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Inherited default binary value */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>typeTup</name></expr></argument>,
							<argument><expr><name>Anum_pg_type_typdefaultbin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>defaultValueBin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run through constraints manually to avoid the additional processing
	 * conducted by DefineRelation() and friends.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>constr</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<switch>switch <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>

				<comment type="block">/*
				 * The inherited default value may be overridden by the user
				 * with the DEFAULT &lt;expr&gt; clause ... but only once.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>saw_default</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple default expressions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_default</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>raw_expr</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defaultExpr</name></decl>;</decl_stmt>

					<comment type="block">/* Create a dummy ParseState for transformExpr */</comment>
					<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Cook the constr-&gt;raw_expr into an expression. Note:
					 * name is strictly for error message
					 */</comment>
					<expr_stmt><expr><name>defaultExpr</name> <operator>=</operator> <call><name>cookDefault</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>,
											  <argument><expr><name>basetypeoid</name></expr></argument>,
											  <argument><expr><name>basetypeMod</name></expr></argument>,
											  <argument><expr><name>domainName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the expression is just a NULL constant, we treat it
					 * like not having a default.
					 *
					 * Note that if the basetype is another domain, we'll see
					 * a CoerceToDomain expr here and not discard the default.
					 * This is critical because the domain default needs to be
					 * retained to override any default that the base domain
					 * might have.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>defaultExpr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>defaultExpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						 <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>defaultExpr</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>defaultValue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>defaultValueBin</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Expression must be stored as a nodeToString result,
						 * but we also require a valid textual representation
						 * (mainly to make life easier for pg_dump).
						 */</comment>
						<expr_stmt><expr><name>defaultValue</name> <operator>=</operator>
							<call><name>deparse_expression</name><argument_list>(<argument><expr><name>defaultExpr</name></expr></argument>,
											   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>defaultValueBin</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>defaultExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* No default (can this still happen?) */</comment>
					<expr_stmt><expr><name>defaultValue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>defaultValueBin</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>nullDefined</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>typNotNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL constraints"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typNotNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullDefined</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_NULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>nullDefined</name> <operator>&amp;&amp;</operator> <name>typNotNull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL constraints"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>typNotNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullDefined</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>

				<comment type="block">/*
				 * Check constraints are handled after domain creation, as
				 * they require the Oid of the domain; at this point we can
				 * only check that they're not marked NO INHERIT, because that
				 * would be bogus.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraints for domains cannot be marked NO INHERIT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * All else are error cases
				 */</comment>
			<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary key constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specifying constraint deferrability not supported for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint subtype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/* Allocate OID for array type */</comment>
	<expr_stmt><expr><name>domainArrayOid</name> <operator>=</operator> <call><name>AssignTypeArrayOid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have TypeCreate do all the real work.
	 */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator>
		<call><name>TypeCreate</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no predetermined type OID */</comment>
				   <argument><expr><name>domainName</name></expr></argument>,	<comment type="block">/* type name */</comment>
				   <argument><expr><name>domainNamespace</name></expr></argument>, <comment type="block">/* namespace */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* relation oid (n/a here) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* relation kind (ditto) */</comment>
				   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* owner's ID */</comment>
				   <argument><expr><name>internalLength</name></expr></argument>,	<comment type="block">/* internal size */</comment>
				   <argument><expr><name>TYPTYPE_DOMAIN</name></expr></argument>,	<comment type="block">/* type-type (domain type) */</comment>
				   <argument><expr><name>category</name></expr></argument>,	<comment type="block">/* type-category */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* domain types are never preferred */</comment>
				   <argument><expr><name>delimiter</name></expr></argument>,	<comment type="block">/* array element delimiter */</comment>
				   <argument><expr><name>inputProcedure</name></expr></argument>,	<comment type="block">/* input procedure */</comment>
				   <argument><expr><name>outputProcedure</name></expr></argument>, <comment type="block">/* output procedure */</comment>
				   <argument><expr><name>receiveProcedure</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
				   <argument><expr><name>sendProcedure</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodin procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodout procedure - none */</comment>
				   <argument><expr><name>analyzeProcedure</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no array element type */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* this isn't an array */</comment>
				   <argument><expr><name>domainArrayOid</name></expr></argument>,	<comment type="block">/* array type we are about to create */</comment>
				   <argument><expr><name>basetypeoid</name></expr></argument>, <comment type="block">/* base type ID */</comment>
				   <argument><expr><name>defaultValue</name></expr></argument>,	<comment type="block">/* default type value (text) */</comment>
				   <argument><expr><name>defaultValueBin</name></expr></argument>, <comment type="block">/* default type value (binary) */</comment>
				   <argument><expr><name>byValue</name></expr></argument>,		<comment type="block">/* passed by value */</comment>
				   <argument><expr><name>alignment</name></expr></argument>,	<comment type="block">/* required alignment */</comment>
				   <argument><expr><name>storage</name></expr></argument>,		<comment type="block">/* TOAST strategy */</comment>
				   <argument><expr><name>basetypeMod</name></expr></argument>, <comment type="block">/* typeMod value */</comment>
				   <argument><expr><name>typNDims</name></expr></argument>,	<comment type="block">/* Array dimensions for base type */</comment>
				   <argument><expr><name>typNotNull</name></expr></argument>,	<comment type="block">/* Type NOT NULL */</comment>
				   <argument><expr><name>domaincoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* type's collation */</comment>

	<comment type="block">/*
	 * Create the array type that goes with it.
	 */</comment>
	<expr_stmt><expr><name>domainArrayName</name> <operator>=</operator> <call><name>makeArrayTypeName</name><argument_list>(<argument><expr><name>domainName</name></expr></argument>, <argument><expr><name>domainNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* alignment must be 'i' or 'd' for arrays */</comment>
	<expr_stmt><expr><name>alignment</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>alignment</name> <operator>==</operator> <literal type="char">'d'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'d'</literal></expr> </then><else>: <expr><literal type="char">'i'</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TypeCreate</name><argument_list>(<argument><expr><name>domainArrayOid</name></expr></argument>,	<comment type="block">/* force assignment of this type OID */</comment>
			   <argument><expr><name>domainArrayName</name></expr></argument>, <comment type="block">/* type name */</comment>
			   <argument><expr><name>domainNamespace</name></expr></argument>, <comment type="block">/* namespace */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* relation oid (n/a here) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* relation kind (ditto) */</comment>
			   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,		<comment type="block">/* owner's ID */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* internal size (always varlena) */</comment>
			   <argument><expr><name>TYPTYPE_BASE</name></expr></argument>,	<comment type="block">/* type-type (base type) */</comment>
			   <argument><expr><name>TYPCATEGORY_ARRAY</name></expr></argument>,	<comment type="block">/* type-category (array) */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* array types are never preferred */</comment>
			   <argument><expr><name>delimiter</name></expr></argument>,		<comment type="block">/* array element delimiter */</comment>
			   <argument><expr><name>F_ARRAY_IN</name></expr></argument>,		<comment type="block">/* input procedure */</comment>
			   <argument><expr><name>F_ARRAY_OUT</name></expr></argument>,		<comment type="block">/* output procedure */</comment>
			   <argument><expr><name>F_ARRAY_RECV</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
			   <argument><expr><name>F_ARRAY_SEND</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* typmodin procedure - none */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* typmodout procedure - none */</comment>
			   <argument><expr><name>F_ARRAY_TYPANALYZE</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
			   <argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,	<comment type="block">/* element type ID */</comment>
			   <argument><expr><name>true</name></expr></argument>,			<comment type="block">/* yes this is an array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no further array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* base type ID */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* never a default type value */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* binary default isn't sent either */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* never passed by value */</comment>
			   <argument><expr><name>alignment</name></expr></argument>,		<comment type="block">/* see above */</comment>
			   <argument><expr><literal type="char">'x'</literal></expr></argument>,				<comment type="block">/* ARRAY is always toastable */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* typMod (Domains only) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* Array dimensions of typbasetype */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* Type NOT NULL */</comment>
			   <argument><expr><name>domaincoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* type's collation */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>domainArrayName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process constraints which refer to the domain ID returned by TypeCreate
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* it must be a Constraint, per check above */</comment>

		<switch>switch <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><call><name>domainAddConstraint</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>domainNamespace</name></expr></argument>,
									<argument><expr><name>basetypeoid</name></expr></argument>, <argument><expr><name>basetypeMod</name></expr></argument>,
									<argument><expr><name>constr</name></expr></argument>, <argument><expr><name>domainName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* Other constraint types were fully processed above */</comment>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* CCI so we can detect duplicate constraint names */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now we can clean up.
	 */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DefineEnum
 *		Registers a new enum.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineEnum</name><parameter_list>(<parameter><decl><type><name>CreateEnumStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>enumName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>enumArrayName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>enumNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>enumArrayOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>enumTypeAddr</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>enumNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>enumName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>enumNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>enumNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for collision with an existing type name.  If there is one and
	 * it's an autogenerated array, we can rename it out of the way.
	 */</comment>
	<expr_stmt><expr><name>old_type_oid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>enumName</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enumNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>moveArrayTypeName</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>, <argument><expr><name>enumName</name></expr></argument>, <argument><expr><name>enumNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>enumName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate OID for array type */</comment>
	<expr_stmt><expr><name>enumArrayOid</name> <operator>=</operator> <call><name>AssignTypeArrayOid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the pg_type entry */</comment>
	<expr_stmt><expr><name>enumTypeAddr</name> <operator>=</operator>
		<call><name>TypeCreate</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no predetermined type OID */</comment>
				   <argument><expr><name>enumName</name></expr></argument>,	<comment type="block">/* type name */</comment>
				   <argument><expr><name>enumNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* relation oid (n/a here) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* relation kind (ditto) */</comment>
				   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* owner's ID */</comment>
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <comment type="block">/* internal size */</comment>
				   <argument><expr><name>TYPTYPE_ENUM</name></expr></argument>,	<comment type="block">/* type-type (enum type) */</comment>
				   <argument><expr><name>TYPCATEGORY_ENUM</name></expr></argument>,	<comment type="block">/* type-category (enum type) */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* enum types are never preferred */</comment>
				   <argument><expr><name>DEFAULT_TYPDELIM</name></expr></argument>,	<comment type="block">/* array element delimiter */</comment>
				   <argument><expr><name>F_ENUM_IN</name></expr></argument>,	<comment type="block">/* input procedure */</comment>
				   <argument><expr><name>F_ENUM_OUT</name></expr></argument>,	<comment type="block">/* output procedure */</comment>
				   <argument><expr><name>F_ENUM_RECV</name></expr></argument>, <comment type="block">/* receive procedure */</comment>
				   <argument><expr><name>F_ENUM_SEND</name></expr></argument>, <comment type="block">/* send procedure */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodin procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodout procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* analyze procedure - default */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* element type ID */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* this is not an array type */</comment>
				   <argument><expr><name>enumArrayOid</name></expr></argument>,	<comment type="block">/* array type we are about to create */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* base type ID (only for domains) */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* never a default type value */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* binary default isn't sent either */</comment>
				   <argument><expr><name>true</name></expr></argument>,		<comment type="block">/* always passed by value */</comment>
				   <argument><expr><literal type="char">'i'</literal></expr></argument>,			<comment type="block">/* int alignment */</comment>
				   <argument><expr><literal type="char">'p'</literal></expr></argument>,			<comment type="block">/* TOAST strategy always plain */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* typMod (Domains only) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* Array dimensions of typbasetype */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* Type NOT NULL */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* type's collation */</comment>

	<comment type="block">/* Enter the enum's values into pg_enum */</comment>
	<expr_stmt><expr><call><name>EnumValuesCreate</name><argument_list>(<argument><expr><name><name>enumTypeAddr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>vals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the array type that goes with it.
	 */</comment>
	<expr_stmt><expr><name>enumArrayName</name> <operator>=</operator> <call><name>makeArrayTypeName</name><argument_list>(<argument><expr><name>enumName</name></expr></argument>, <argument><expr><name>enumNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TypeCreate</name><argument_list>(<argument><expr><name>enumArrayOid</name></expr></argument>,	<comment type="block">/* force assignment of this type OID */</comment>
			   <argument><expr><name>enumArrayName</name></expr></argument>,	<comment type="block">/* type name */</comment>
			   <argument><expr><name>enumNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* relation oid (n/a here) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* relation kind (ditto) */</comment>
			   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,		<comment type="block">/* owner's ID */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* internal size (always varlena) */</comment>
			   <argument><expr><name>TYPTYPE_BASE</name></expr></argument>,	<comment type="block">/* type-type (base type) */</comment>
			   <argument><expr><name>TYPCATEGORY_ARRAY</name></expr></argument>,	<comment type="block">/* type-category (array) */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* array types are never preferred */</comment>
			   <argument><expr><name>DEFAULT_TYPDELIM</name></expr></argument>,	<comment type="block">/* array element delimiter */</comment>
			   <argument><expr><name>F_ARRAY_IN</name></expr></argument>,		<comment type="block">/* input procedure */</comment>
			   <argument><expr><name>F_ARRAY_OUT</name></expr></argument>,		<comment type="block">/* output procedure */</comment>
			   <argument><expr><name>F_ARRAY_RECV</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
			   <argument><expr><name>F_ARRAY_SEND</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* typmodin procedure - none */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* typmodout procedure - none */</comment>
			   <argument><expr><name>F_ARRAY_TYPANALYZE</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
			   <argument><expr><name><name>enumTypeAddr</name><operator>.</operator><name>objectId</name></name></expr></argument>,	<comment type="block">/* element type ID */</comment>
			   <argument><expr><name>true</name></expr></argument>,			<comment type="block">/* yes this is an array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no further array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* base type ID */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* never a default type value */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* binary default isn't sent either */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* never passed by value */</comment>
			   <argument><expr><literal type="char">'i'</literal></expr></argument>,				<comment type="block">/* enums have align i, so do their arrays */</comment>
			   <argument><expr><literal type="char">'x'</literal></expr></argument>,				<comment type="block">/* ARRAY is always toastable */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* typMod (Domains only) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* Array dimensions of typbasetype */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* Type NOT NULL */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* type's collation */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>enumArrayName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>enumTypeAddr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterEnum
 *		ALTER TYPE on an enum.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterEnum</name><parameter_list>(<parameter><decl><type><name>AlterEnumStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>enum_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>enum_type_oid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>enum_type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>enum_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check it's an enum and check user has permission to ALTER the enum */</comment>
	<expr_stmt><expr><call><name>checkEnumOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>oldVal</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rename an existing label */</comment>
		<expr_stmt><expr><call><name>RenameEnumLabel</name><argument_list>(<argument><expr><name>enum_type_oid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldVal</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newVal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Add a new label */</comment>

		<comment type="block">/*
		 * Ordinarily we disallow adding values within transaction blocks,
		 * because we can't cope with enum OID values getting into indexes and
		 * then having their defining pg_enum entries go away.  However, it's
		 * okay if the enum type was created in the current transaction, since
		 * then there can be no such indexes that wouldn't themselves go away
		 * on rollback.  (We support this case because pg_dump
		 * --binary-upgrade needs it.)  We test this by seeing if the pg_type
		 * row has xmin == current XID and is not HEAP_UPDATED.  If it is
		 * HEAP_UPDATED, we can't be sure whether the type was created or only
		 * modified in this xact.  So we are disallowing some cases that could
		 * theoretically be safe; but fortunately pg_dump only needs the
		 * simplest case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_UPDATED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* safe to do inside transaction block */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE ... ADD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>AddEnumLabel</name><argument_list>(<argument><expr><name>enum_type_oid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newVal</name></name></expr></argument>,
					 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newValNeighbor</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newValIsAfter</name></name></expr></argument>,
					 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>skipIfNewValExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>enum_type_oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>enum_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * checkEnumOwner
 *
 * Check that the type is actually an enum and that the current user
 * has permission to do ALTER TYPE on it.  Throw an error if not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkEnumOwner</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check that this is actually an enum */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not an enum"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permission check: must own type */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DefineRange
 *		Registers a new range type.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineRange</name><parameter_list>(<parameter><decl><type><name>CreateRangeStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typeName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rangeArrayName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rangeArrayOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rangeSubtype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rangeSubOpclassName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rangeCollationName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rangeCanonicalName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rangeSubtypeDiffName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rangeSubOpclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rangeCollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regproc</name></type>		<name>rangeCanonical</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regproc</name></type>		<name>rangeSubtypeDiff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>subtyplen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>subtypbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>subtypalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>alignment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>typeNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look to see if type already exists.
	 */</comment>
	<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
							 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's not a shell, see if it's an autogenerated array type, and if so
	 * rename it out of the way.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>get_typisdefined</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>moveArrayTypeName</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>typoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it doesn't exist, create it as a shell, so that the OID is known for
	 * use in the range function definitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>TypeShellMake</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typoid</name> <operator>=</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
		<comment type="block">/* Make new shell type visible for modification below */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Extract the parameters from the parameter list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;params</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"subtype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* we can look up the subtype name immediately */</comment>
			<expr_stmt><expr><name>rangeSubtype</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"subtype_opclass"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rangeSubOpclassName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rangeSubOpclassName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"collation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rangeCollationName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rangeCollationName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"canonical"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rangeCanonicalName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rangeCanonicalName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"subtype_diff"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rangeSubtypeDiffName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rangeSubtypeDiffName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type attribute \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Must have a subtype */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type attribute \"subtype\" is required"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* disallow ranges of pseudotypes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range subtype cannot be %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify subopclass */</comment>
	<expr_stmt><expr><name>rangeSubOpclass</name> <operator>=</operator> <call><name>findRangeSubOpclass</name><argument_list>(<argument><expr><name>rangeSubOpclassName</name></expr></argument>, <argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify collation to use, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangeCollationName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangeCollation</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name>rangeCollationName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangeCollation</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangeCollationName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range collation specified but subtype does not support collation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rangeCollation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Identify support functions, if provided */</comment>
	<if_stmt><if>if <condition>(<expr><name>rangeCanonicalName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rangeCanonical</name> <operator>=</operator> <call><name>findRangeCanonicalFunction</name><argument_list>(<argument><expr><name>rangeCanonicalName</name></expr></argument>,
													<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rangeCanonical</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rangeSubtypeDiffName</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rangeSubtypeDiff</name> <operator>=</operator> <call><name>findRangeSubtypeDiffFunction</name><argument_list>(<argument><expr><name>rangeSubtypeDiffName</name></expr></argument>,
														<argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rangeSubtypeDiff</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>rangeSubtype</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>subtyplen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subtypbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subtypalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* alignment must be 'i' or 'd' for ranges */</comment>
	<expr_stmt><expr><name>alignment</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>subtypalign</name> <operator>==</operator> <literal type="char">'d'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'d'</literal></expr> </then><else>: <expr><literal type="char">'i'</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Allocate OID for array type */</comment>
	<expr_stmt><expr><name>rangeArrayOid</name> <operator>=</operator> <call><name>AssignTypeArrayOid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the pg_type entry */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator>
		<call><name>TypeCreate</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no predetermined type OID */</comment>
				   <argument><expr><name>typeName</name></expr></argument>,	<comment type="block">/* type name */</comment>
				   <argument><expr><name>typeNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* relation oid (n/a here) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* relation kind (ditto) */</comment>
				   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* owner's ID */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* internal size (always varlena) */</comment>
				   <argument><expr><name>TYPTYPE_RANGE</name></expr></argument>,	<comment type="block">/* type-type (range type) */</comment>
				   <argument><expr><name>TYPCATEGORY_RANGE</name></expr></argument>,	<comment type="block">/* type-category (range type) */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* range types are never preferred */</comment>
				   <argument><expr><name>DEFAULT_TYPDELIM</name></expr></argument>,	<comment type="block">/* array element delimiter */</comment>
				   <argument><expr><name>F_RANGE_IN</name></expr></argument>,	<comment type="block">/* input procedure */</comment>
				   <argument><expr><name>F_RANGE_OUT</name></expr></argument>, <comment type="block">/* output procedure */</comment>
				   <argument><expr><name>F_RANGE_RECV</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
				   <argument><expr><name>F_RANGE_SEND</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodin procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodout procedure - none */</comment>
				   <argument><expr><name>F_RANGE_TYPANALYZE</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* element type ID - none */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* this is not an array type */</comment>
				   <argument><expr><name>rangeArrayOid</name></expr></argument>,	<comment type="block">/* array type we are about to create */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* base type ID (only for domains) */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* never a default type value */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* no binary form available either */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* never passed by value */</comment>
				   <argument><expr><name>alignment</name></expr></argument>,	<comment type="block">/* alignment */</comment>
				   <argument><expr><literal type="char">'x'</literal></expr></argument>,			<comment type="block">/* TOAST strategy (always extended) */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* typMod (Domains only) */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* Array dimensions of typbasetype */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* Type NOT NULL */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* type's collation (ranges never have one) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typoid</name> <operator>==</operator> <name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the entry in pg_range */</comment>
	<expr_stmt><expr><call><name>RangeCreate</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>rangeSubtype</name></expr></argument>, <argument><expr><name>rangeCollation</name></expr></argument>, <argument><expr><name>rangeSubOpclass</name></expr></argument>,
				<argument><expr><name>rangeCanonical</name></expr></argument>, <argument><expr><name>rangeSubtypeDiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the array type that goes with it.
	 */</comment>
	<expr_stmt><expr><name>rangeArrayName</name> <operator>=</operator> <call><name>makeArrayTypeName</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TypeCreate</name><argument_list>(<argument><expr><name>rangeArrayOid</name></expr></argument>,	<comment type="block">/* force assignment of this type OID */</comment>
			   <argument><expr><name>rangeArrayName</name></expr></argument>,	<comment type="block">/* type name */</comment>
			   <argument><expr><name>typeNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* relation oid (n/a here) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* relation kind (ditto) */</comment>
			   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,		<comment type="block">/* owner's ID */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* internal size (always varlena) */</comment>
			   <argument><expr><name>TYPTYPE_BASE</name></expr></argument>,	<comment type="block">/* type-type (base type) */</comment>
			   <argument><expr><name>TYPCATEGORY_ARRAY</name></expr></argument>,	<comment type="block">/* type-category (array) */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* array types are never preferred */</comment>
			   <argument><expr><name>DEFAULT_TYPDELIM</name></expr></argument>,	<comment type="block">/* array element delimiter */</comment>
			   <argument><expr><name>F_ARRAY_IN</name></expr></argument>,		<comment type="block">/* input procedure */</comment>
			   <argument><expr><name>F_ARRAY_OUT</name></expr></argument>,		<comment type="block">/* output procedure */</comment>
			   <argument><expr><name>F_ARRAY_RECV</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
			   <argument><expr><name>F_ARRAY_SEND</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* typmodin procedure - none */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* typmodout procedure - none */</comment>
			   <argument><expr><name>F_ARRAY_TYPANALYZE</name></expr></argument>,	<comment type="block">/* analyze procedure */</comment>
			   <argument><expr><name>typoid</name></expr></argument>,			<comment type="block">/* element type ID */</comment>
			   <argument><expr><name>true</name></expr></argument>,			<comment type="block">/* yes this is an array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* no further array type */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>,		<comment type="block">/* base type ID */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* never a default type value */</comment>
			   <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* binary default isn't sent either */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* never passed by value */</comment>
			   <argument><expr><name>alignment</name></expr></argument>,		<comment type="block">/* alignment - same as range's */</comment>
			   <argument><expr><literal type="char">'x'</literal></expr></argument>,				<comment type="block">/* ARRAY is always toastable */</comment>
			   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,				<comment type="block">/* typMod (Domains only) */</comment>
			   <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* Array dimensions of typbasetype */</comment>
			   <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* Type NOT NULL */</comment>
			   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typcollation */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rangeArrayName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And create the constructor functions for this range type */</comment>
	<expr_stmt><expr><call><name>makeRangeConstructors</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>rangeSubtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Because there may exist several range types over the same subtype, the
 * range type can't be uniquely determined from the subtype.  So it's
 * impossible to define a polymorphic constructor; we have to generate new
 * constructor functions explicitly for each range type.
 *
 * We actually define 4 functions, with 0 through 3 arguments.  This is just
 * to offer more convenience for the user.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makeRangeConstructors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>namespace</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>rangeOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>prosrc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"range_constructor2"</literal></expr>,
	<expr><literal type="string">"range_constructor3"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>pronargs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>constructorArgTypes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>constructorArgTypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>subtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>constructorArgTypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>subtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>constructorArgTypes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>rangeOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>constructorArgTypesVector</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>constructorArgTypesVector</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>constructorArgTypes</name></expr></argument>,
												   <argument><expr><name><name>pronargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>myself</name> <operator>=</operator> <call><name>ProcedureCreate</name><argument_list>(<argument><expr><name>name</name></expr></argument>,	<comment type="block">/* name: same as range type */</comment>
								 <argument><expr><name>namespace</name></expr></argument>, <comment type="block">/* namespace */</comment>
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* replace */</comment>
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* returns set */</comment>
								 <argument><expr><name>rangeOid</name></expr></argument>,	<comment type="block">/* return type */</comment>
								 <argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>, <comment type="block">/* proowner */</comment>
								 <argument><expr><name>INTERNALlanguageId</name></expr></argument>,	<comment type="block">/* language */</comment>
								 <argument><expr><name>F_FMGR_INTERNAL_VALIDATOR</name></expr></argument>, <comment type="block">/* language validator */</comment>
								 <argument><expr><name><name>prosrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <comment type="block">/* prosrc */</comment>
								 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* probin */</comment>
								 <argument><expr><name>PROKIND_FUNCTION</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* security_definer */</comment>
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* leakproof */</comment>
								 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* isStrict */</comment>
								 <argument><expr><name>PROVOLATILE_IMMUTABLE</name></expr></argument>, <comment type="block">/* volatility */</comment>
								 <argument><expr><name>PROPARALLEL_SAFE</name></expr></argument>,	<comment type="block">/* parallel safety */</comment>
								 <argument><expr><name>constructorArgTypesVector</name></expr></argument>, <comment type="block">/* parameterTypes */</comment>
								 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* allParameterTypes */</comment>
								 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* parameterModes */</comment>
								 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* parameterNames */</comment>
								 <argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* parameterDefaults */</comment>
								 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* trftypes */</comment>
								 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* proconfig */</comment>
								 <argument><expr><literal type="number">1.0</literal></expr></argument>,	<comment type="block">/* procost */</comment>
								 <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* prorows */</comment>

		<comment type="block">/*
		 * Make the constructors internally-dependent on the range type so
		 * that they go away silently when the type is dropped.  Note that
		 * pg_dump depends on this choice to avoid dumping the constructors.
		 */</comment>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Find suitable I/O functions for a type.
 *
 * typeOid is the type's OID (which will already exist, if only as a shell
 * type).
 */</comment>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeInputFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid4</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Input functions can take a single argument of type CSTRING, or three
	 * arguments (string, typioparam OID, typmod).
	 *
	 * For backwards compatibility we allow OPAQUE in place of CSTRING; if we
	 * see this, we issue a warning and fix up the pg_proc entry.
	 *
	 * Whine about ambiguity if multiple forms exist.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procOid2</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OPAQUEOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid3</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid3</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procOid4</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid4</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmatches</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type input function %s has multiple matches"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>procOid</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>procOid2</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cases with OPAQUE need adjustment */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid3</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>procOid</name> <operator>=</operator> <name>procOid3</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>procOid</name> <operator>=</operator> <name>procOid4</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found, but must complain and fix the pg_proc entry */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"changing argument type of function %s from \"opaque\" to \"cstring\""</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetFunctionArgType</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>CSTRINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Need CommandCounterIncrement since DefineType will likely try to
		 * alter the pg_proc tuple again.
		 */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>procOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use CSTRING (preferred) in the error message */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
					<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeOutputFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Output functions can take a single argument of the type.
	 *
	 * For backwards compatibility we allow OPAQUE in place of the actual type
	 * name; if we see this, we issue a warning and fix up the pg_proc entry.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>procOid</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No luck, try it with OPAQUE */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OPAQUEOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found, but must complain and fix the pg_proc entry */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"changing argument type of function %s from \"opaque\" to %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetFunctionArgType</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Need CommandCounterIncrement since DefineType will likely try to
		 * alter the pg_proc tuple again.
		 */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>procOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use type name, not OPAQUE, in the failure message. */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
					<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeReceiveFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Receive functions can take a single argument of type INTERNAL, or three
	 * arguments (internal, typioparam OID, typmod).  Whine about ambiguity if
	 * both forms exist.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>procOid2</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type receive function %s has multiple matches"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>procOid</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>procOid2</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If not found, reference the 1-argument signature in error msg */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
					<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeSendFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Send functions can take a single argument of the type.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>procOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
					<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeTypmodinFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * typmodin functions always take one cstring[] argument and return int4.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CSTRINGARRAYOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typmod_in function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeTypmodoutFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * typmodout functions always take one int4 argument and return cstring.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typmod_out function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"cstring"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findTypeAnalyzeFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Analyze functions always take one INTERNAL argument and return bool.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type analyze function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find suitable support functions and opclasses for a range type.
 */</comment>

<comment type="block">/*
 * Find named btree opclass for subtype, or default btree opclass if
 * opcname is NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findRangeSubOpclass</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opcname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opInputType</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>opcname</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>opcid</name> <operator>=</operator> <call><name>get_opclass_oid</name><argument_list>(<argument><expr><name>BTREE_AM_OID</name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Verify that the operator class accepts this datatype. Note we will
		 * accept binary compatibility.
		 */</comment>
		<expr_stmt><expr><name>opInputType</name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>opInputType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" does not accept data type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>opcid</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We spell the error message identically to ResolveOpClass */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default operator class for access method \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"btree"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify an operator class for the range type or define a default operator class for the subtype."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>opcid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findRangeCanonicalFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Range canonical functions must take and return the range type, and must
	 * be immutable.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>typeOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range canonical function %s must return range type"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>func_volatile</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range canonical function %s must be immutable"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also, range type's creator must have permission to call function */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findRangeSubtypeDiffFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argList</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Range subtype diff functions must take two arguments of the subtype,
	 * must return float8, and must be immutable.
	 */</comment>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>subtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argList</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>subtype</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range subtype diff function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="string">"double precision"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>func_volatile</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range subtype diff function %s must be immutable"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also, range type's creator must have permission to call function */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>procOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	AssignTypeArrayOid
 *
 *	Pre-assign the type's array OID for use in pg_type.typarray
 */</comment>
<function><type><name>Oid</name></type>
<name>AssignTypeArrayOid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type_array_oid</name></decl>;</decl_stmt>

	<comment type="block">/* Use binary-upgrade override for pg_type.typarray? */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>binary_upgrade_next_array_pg_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_type array OID value not set when in binary upgrade mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>type_array_oid</name> <operator>=</operator> <name>binary_upgrade_next_array_pg_type_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>binary_upgrade_next_array_pg_type_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_type</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>type_array_oid</name> <operator>=</operator> <call><name>GetNewOid</name><argument_list>(<argument><expr><name>pg_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_type</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>type_array_oid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------
 * DefineCompositeType
 *
 * Create a Composite Type relation.
 * `DefineRelation' does all the work, we just provide the correct
 * arguments!
 *
 * If the relation already exists, then 'DefineRelation' will abort
 * the xact...
 *
 * Return type is the new type's object address.
 *-------------------------------------------------------------------
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineCompositeType</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>typevar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coldeflist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * now set the parameters for keys/inheritance etc. All of these are
	 * uninteresting for composite types...
	 */</comment>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>typevar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>coldeflist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for collision with an existing type name. If there is one and
	 * it's an autogenerated array, we can rename it out of the way.  This
	 * check is here mainly to get a better error message about a "type"
	 * instead of below about a "relation".
	 */</comment>
	<expr_stmt><expr><name>typeNamespace</name> <operator>=</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
														 <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RangeVarAdjustRelationPersistence</name><argument_list>(<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_type_oid</name> <operator>=</operator>
		<call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
						<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>moveArrayTypeName</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>, <argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>typeNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists"</literal></expr></argument>, <argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally create the relation.  This also creates the type.
	 */</comment>
	<expr_stmt><expr><call><name>DefineRelation</name><argument_list>(<argument><expr><name>createStmt</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>address</name></expr></argument>,
				   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterDomainDefault
 *
 * Routine implementing ALTER DOMAIN SET/DROP DEFAULT statements.
 *
 * Returns ObjectAddress of the modified domain.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterDomainDefault</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>defaultRaw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defaultValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defaultExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* NULL if no default specified */</comment>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>typacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_record</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_nulls</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_repl</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>domainoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the domain in the type table */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check it's a domain and check user has permission for ALTER DOMAIN */</comment>
	<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup new tuple */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the new default into the tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>defaultRaw</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Create a dummy ParseState for transformExpr */</comment>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Cook the colDef-&gt;raw_expr into an expression. Note: Name is
		 * strictly for error message
		 */</comment>
		<expr_stmt><expr><name>defaultExpr</name> <operator>=</operator> <call><name>cookDefault</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>defaultRaw</name></expr></argument>,
								  <argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr></argument>,
								  <argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typtypmod</name></name></expr></argument>,
								  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the expression is just a NULL constant, we treat the command
		 * like ALTER ... DROP DEFAULT.  (But see note for same test in
		 * DefineDomain.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>defaultExpr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>defaultExpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>defaultExpr</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Default is NULL, drop it */</comment>
			<expr_stmt><expr><name><name>new_record_nulls</name><index>[<expr><name>Anum_pg_type_typdefaultbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_type_typdefaultbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_record_nulls</name><index>[<expr><name>Anum_pg_type_typdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_type_typdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Expression must be stored as a nodeToString result, but we also
			 * require a valid textual representation (mainly to make life
			 * easier for pg_dump).
			 */</comment>
			<expr_stmt><expr><name>defaultValue</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><name>defaultExpr</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Form an updated tuple with the new default and write it back.
			 */</comment>
			<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_type_typdefaultbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>defaultExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_type_typdefaultbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pg_type_typdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>defaultValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_type_typdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ALTER ... DROP DEFAULT */</comment>
		<expr_stmt><expr><name><name>new_record_nulls</name><index>[<expr><name>Anum_pg_type_typdefaultbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_type_typdefaultbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_nulls</name><index>[<expr><name>Anum_pg_type_typdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_type_typdefault</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>new_record</name></expr></argument>, <argument><expr><name>new_record_nulls</name></expr></argument>,
								 <argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must extract ACL for use of GenerateTypeDependencies */</comment>
	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>Anum_pg_type_typacl</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typacl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typacl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Rebuild dependencies */</comment>
	<expr_stmt><expr><call><name>GenerateTypeDependencies</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>defaultExpr</name></expr></argument>,
							 <argument><expr><name>typacl</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* relation kind is n/a */</comment>
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* a domain isn't an implicit array */</comment>
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* nor is it any kind of dependent type */</comment>
							 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* We do need to rebuild dependencies */</comment>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterDomainNotNull
 *
 * Routine implementing ALTER DOMAIN SET/DROP NOT NULL statements.
 *
 * Returns ObjectAddress of the modified domain.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterDomainNotNull</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>notNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>typrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>domainoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the domain in the type table */</comment>
	<expr_stmt><expr><name>typrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check it's a domain and check user has permission for ALTER DOMAIN */</comment>
	<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is the domain already set to the desired constraint? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typnotnull</name></name> <operator>==</operator> <name>notNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>typrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>address</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Adding a NOT NULL constraint requires checking existing columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>notNull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>

		<comment type="block">/* Fetch relation list with attributes based on this domain */</comment>
		<comment type="block">/* ShareLock is sufficient to prevent concurrent data changes */</comment>

		<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>get_rels_with_domain</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelToCheck</name> <modifier>*</modifier></type><name>rtc</name> <init>= <expr><operator>(</operator><name>RelToCheck</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>testrel</name> <init>= <expr><name><name>rtc</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

			<comment type="block">/* Scan all tuples in this relation */</comment>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<comment type="block">/* Test attributes that are of the domain */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rtc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>rtc</name><operator>-&gt;</operator><name>atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * In principle the auxiliary information for this
						 * error should be errdatatype(), but errtablecol()
						 * seems considerably more useful in practice.  Since
						 * this code only executes in an ALTER DOMAIN command,
						 * the client should already know which domain is in
						 * question.
						 */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of table \"%s\" contains null values"</literal></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errtablecol</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close each rel after processing, but keep lock */</comment>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay to update pg_type row.  We can scribble on typTup because it's a
	 * copy.
	 */</comment>
	<expr_stmt><expr><name><name>typTup</name><operator>-&gt;</operator><name>typnotnull</name></name> <operator>=</operator> <name>notNull</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>typrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>typrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterDomainDropConstraint
 *
 * Implements the ALTER DOMAIN DROP CONSTRAINT statement
 *
 * Returns ObjectAddress of the modified domain.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterDomainDropConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
						  <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>conscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>contup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>domainoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the domain in the type table */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check it's a domain and check user has permission for ALTER DOMAIN */</comment>
	<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Grab an appropriate lock on the pg_constraint relation */</comment>
	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find and remove the target constraint */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>contup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>conobj</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conobj</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up after the scan */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of domain \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of domain \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterDomainAddConstraint
 *
 * Implements the ALTER DOMAIN .. ADD CONSTRAINT statement.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterDomainAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>constrAddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>typrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>domainoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the domain in the type table */</comment>
	<expr_stmt><expr><name>typrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check it's a domain and check user has permission for ALTER DOMAIN */</comment>
	<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>newConstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>constr</name> <operator>=</operator> <operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name>newConstraint</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<comment type="block">/* processed below */</comment>
			<break>break;</break>

		<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary key constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints not possible for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specifying constraint deferrability not supported for domains"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint subtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>constr</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Since all other constraint types throw errors, this must be a check
	 * constraint.  First, process the constraint expression and add an entry
	 * to pg_constraint.
	 */</comment>

	<expr_stmt><expr><name>ccbin</name> <operator>=</operator> <call><name>domainAddConstraint</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>, <argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>,
								<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr></argument>, <argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typtypmod</name></name></expr></argument>,
								<argument><expr><name>constr</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>constrAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If requested to validate the constraint, test all values stored in the
	 * attributes based on the domain the constraint is being added to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>validateDomainConstraint</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>, <argument><expr><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>typrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterDomainValidateConstraint
 *
 * Implements the ALTER DOMAIN .. VALIDATE CONSTRAINT statement.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterDomainValidateConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>domainoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>typrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>domainoid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the domain in the type table */</comment>
	<expr_stmt><expr><name>typrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check it's a domain and check user has permission for ALTER DOMAIN */</comment>
	<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and check the target constraint
	 */</comment>
	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of domain \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of domain \"%s\" is not a check constraint"</literal></expr></argument>,
						<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
						  <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>,
			 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>conbin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>validateDomainConstraint</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>, <argument><expr><name>conbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now update the catalog, while we have the door open.
	 */</comment>
	<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
							  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>domainoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>typrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateDomainConstraint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>domainoid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ccbin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>ccbin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>

	<comment type="block">/* Need an EState to run ExecEvalExpr */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build execution state for expr */</comment>
	<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch relation list with attributes based on this domain */</comment>
	<comment type="block">/* ShareLock is sufficient to prevent concurrent data changes */</comment>

	<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>get_rels_with_domain</name><argument_list>(<argument><expr><name>domainoid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelToCheck</name> <modifier>*</modifier></type><name>rtc</name> <init>= <expr><operator>(</operator><name>RelToCheck</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>testrel</name> <init>= <expr><name><name>rtc</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

		<comment type="block">/* Scan all tuples in this relation */</comment>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Test attributes that are of the domain */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rtc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>rtc</name><operator>-&gt;</operator><name>atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>conResult</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_datum</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>domainValue_isNull</name></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>conResult</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>,
													  <argument><expr><name>econtext</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>conResult</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * In principle the auxiliary information for this error
					 * should be errdomainconstraint(), but errtablecol()
					 * seems considerably more useful in practice.  Since this
					 * code only executes in an ALTER DOMAIN command, the
					 * client should already know which domain is in question,
					 * and which constraint too.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of table \"%s\" contains values that violate the new constraint"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtablecol</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Hold relation lock till commit (XXX bad for concurrency) */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>testrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rels_with_domain
 *
 * Fetch all relations / attributes which are using the domain
 *
 * The result is a list of RelToCheck structs, one for each distinct
 * relation, each containing one or more attribute numbers that are of
 * the domain type.  We have opened each rel and acquired the specified lock
 * type on it.
 *
 * We support nested domains by including attributes that are of derived
 * domain types.  Current callers do not need to distinguish between attributes
 * that are of exactly the given domain and those that are of derived domains.
 *
 * XXX this is completely broken because there is no way to lock the domain
 * to prevent columns from being added or dropped while our command runs.
 * We can partially protect against column drops by locking relations as we
 * come across them, but there is still a race condition (the window between
 * seeing a pg_depend entry and acquiring lock on the relation it references).
 * Also, holding locks on all these relations simultaneously creates a non-
 * trivial risk of deadlock.  We can minimize but not eliminate the deadlock
 * risk by using the weakest suitable lock (ShareLock for most callers).
 *
 * XXX the API for this is not sufficient to support checking domain values
 * that are inside container types, such as composite types, arrays, or
 * ranges.  Currently we just error out if a container type containing the
 * target domain is stored anywhere.
 *
 * Generally used for retrieving a list of tests when adding
 * new constraints to a domain.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_rels_with_domain</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>domainOid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>domainTypeName</name> <init>= <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>domainOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockmode</name> <operator>!=</operator> <name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We scan pg_depend to find those things that depend on the domain. (We
	 * assume we can ignore refobjsubid for a domain.)
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>domainOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>depScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelToCheck</name> <modifier>*</modifier></type><name>rtc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rellist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>pg_att</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ptr</name></decl>;</decl_stmt>

		<comment type="block">/* Check for directly dependent types */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>TypeRelationId</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This is a sub-domain, so recursively add dependent columns
				 * to the output list.  This is a bit inefficient since we may
				 * fail to combine RelToCheck entries when attributes of the
				 * same rel have different derived domain types, but it's
				 * probably not worth improving.
				 */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
									 <argument><expr><call><name>get_rels_with_domain</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
														  <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Otherwise, it is some container type using the domain, so
				 * fail if there are any columns of this type.
				 */</comment>
				<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><name>domainTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Else, ignore dependees that aren't user columns of relations */</comment>
		<comment type="block">/* (we assume system columns are never of domain types) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* See if we already have an entry for this relation */</comment>
		<macro><name>foreach</name><argument_list>(<argument>rellist</argument>, <argument>result</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelToCheck</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelToCheck</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rellist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rt</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rtc</name> <operator>=</operator> <name>rt</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>rtc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* First attribute found for this relation */</comment>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

			<comment type="block">/* Acquire requested lock on relation */</comment>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check to see if rowtype is stored anyplace as a composite-type
			 * column; if so we have to fail, for now anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><name>domainTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, we can ignore relations except those with both
			 * storage and user-chosen column types.
			 *
			 * XXX If an index-only scan could satisfy "col::some_domain" from
			 * a suitable expression index, this should also check expression
			 * index columns.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
				<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Build the RelToCheck entry with enough space for all atts */</comment>
			<expr_stmt><expr><name>rtc</name> <operator>=</operator> <operator>(</operator><name>RelToCheck</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelToCheck</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rtc</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rtc</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rtc</name><operator>-&gt;</operator><name>atts</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>rtc</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Confirm column has not been dropped, and is of the expected type.
		 * This defends against an ALTER DROP COLUMN occurring just before we
		 * acquired lock ... but if the whole table were dropped, we'd still
		 * have a problem.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>&gt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name><name>rtc</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rtc</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pg_att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator> <name><name>pg_att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>domainOid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Okay, add column to result.  We store the columns in column-number
		 * order; this is just a hack to improve predictability of regression
		 * test output ...
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rtc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name><name>rtc</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>rtc</name><operator>-&gt;</operator><name>natts</name></name><operator>++</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rtc</name><operator>-&gt;</operator><name>atts</name><index>[<expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rtc</name><operator>-&gt;</operator><name>atts</name><index>[<expr><name>ptr</name></expr>]</index></name> <operator>=</operator> <name><name>rtc</name><operator>-&gt;</operator><name>atts</name><index>[<expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>rtc</name><operator>-&gt;</operator><name>atts</name><index>[<expr><name>ptr</name></expr>]</index></name> <operator>=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkDomainOwner
 *
 * Check that the type is actually a domain and that the current user
 * has permission to do ALTER DOMAIN on it.  Throw an error if not.
 */</comment>
<function><type><name>void</name></type>
<name>checkDomainOwner</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check that this is actually a domain */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a domain"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permission check: must own type */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * domainAddConstraint - code shared between CREATE and ALTER DOMAIN
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>domainAddConstraint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>domainOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>domainNamespace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>baseTypeOid</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>typMod</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domainName</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>constrAddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccsrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>domVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ccoid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Assign or validate constraint name
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_DOMAIN</name></expr></argument>,
								 <argument><expr><name>domainOid</name></expr></argument>,
								 <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" for domain \"%s\" already exists"</literal></expr></argument>,
							<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><name>domainName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>ChooseConstraintName</name><argument_list>(<argument><expr><name>domainName</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><literal type="string">"check"</literal></expr></argument>,
											   <argument><expr><name>domainNamespace</name></expr></argument>,
											   <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Convert the A_EXPR in raw_expr into an EXPR
	 */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a CoerceToDomainValue to represent the occurrence of VALUE in
	 * the expression.  Note that it will appear to have the type of the base
	 * type, not the domain.  This seems correct since within the check
	 * expression, we should not assume the input value can be considered a
	 * member of the domain.
	 */</comment>
	<expr_stmt><expr><name>domVal</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceToDomainValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>domVal</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>baseTypeOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>domVal</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>typMod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>domVal</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>baseTypeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>domVal</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* will be set when/if used */</comment>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>=</operator> <name>replace_domain_constraint_value</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>domVal</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_DOMAIN_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure it yields a boolean result.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="string">"CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fix up collation information.
	 */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Domains don't allow variables (this is probably dead code now that
	 * add_missing_from is history, but let's be sure).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>contain_var_clause</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use table references in domain check constraint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert to string form for storage.
	 */</comment>
	<expr_stmt><expr><name>ccbin</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deparse it to produce text for consrc.
	 */</comment>
	<expr_stmt><expr><name>ccsrc</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the constraint in pg_constraint
	 */</comment>
	<expr_stmt><expr><name>ccoid</name> <operator>=</operator>
		<call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,	<comment type="block">/* Constraint Name */</comment>
							  <argument><expr><name>domainNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
							  <argument><expr><name>CONSTRAINT_CHECK</name></expr></argument>, <comment type="block">/* Constraint Type */</comment>
							  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* Is Deferrable */</comment>
							  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* Is Deferred */</comment>
							  <argument><expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>skip_validation</name></name></expr></argument>, <comment type="block">/* Is Validated */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* not a relation constraint */</comment>
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>domainOid</name></expr></argument>,	<comment type="block">/* domain constraint */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no associated index */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* Foreign key fields */</comment>
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><literal type="char">' '</literal></expr></argument>,
							  <argument><expr><literal type="char">' '</literal></expr></argument>,
							  <argument><expr><literal type="char">' '</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* not an exclusion constraint */</comment>
							  <argument><expr><name>expr</name></expr></argument>, <comment type="block">/* Tree form of check constraint */</comment>
							  <argument><expr><name>ccbin</name></expr></argument>,	<comment type="block">/* Binary form of check constraint */</comment>
							  <argument><expr><name>ccsrc</name></expr></argument>,	<comment type="block">/* Source form of check constraint */</comment>
							  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* is local */</comment>
							  <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* inhcount */</comment>
							  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* connoinherit */</comment>
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>
	<if_stmt><if>if <condition>(<expr><name>constrAddr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>constrAddr</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>ccoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return the compiled constraint expression so the calling routine can
	 * perform any additional required tests.
	 */</comment>
	<return>return <expr><name>ccbin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parser pre_columnref_hook for domain CHECK constraint parsing */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_domain_constraint_value</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Check for a reference to "value", and if that's what it is, replace
	 * with a CoerceToDomainValue as prepared for us by domainAddConstraint.
	 * (We handle VALUE as a name, not a keyword, to avoid breaking a lot of
	 * applications that have used VALUE as a column name in the past.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>domVal</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Propagate location knowledge, if any */</comment>
			<expr_stmt><expr><name><name>domVal</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>domVal</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Execute ALTER TYPE RENAME
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>RenameType</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newTypeName</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the type in the type table */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check permissions on type */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ALTER DOMAIN used on a non-domain? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_DOMAIN</name> <operator>&amp;&amp;</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a domain"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a composite type, we need to check that it really is a
	 * free-standing composite type, and not a table's rowtype. We want people
	 * to use ALTER TABLE not ALTER TYPE for that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>&amp;&amp;</operator>
		<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is a table's row type"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* don't allow direct alteration of array types, either */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>get_array_type</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>typeOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter array type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can alter type %s, which will alter the array type as well."</literal></expr></argument>,
						 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If type is composite we need to rename associated pg_class entry too.
	 * RenameRelationInternal will call RenameTypeInternal automatically.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>newTypeName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RenameTypeInternal</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>newTypeName</name></expr></argument>,
						   <argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change the owner of a type.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterTypeOwner</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>ObjectType</name></type> <name>objecttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use LookupTypeName here so that shell types can be processed */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>LookupTypeName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>typeTypeId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the syscache entry so we can scribble on it below */</comment>
	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't allow ALTER DOMAIN on a type */</comment>
	<if_stmt><if>if <condition>(<expr><name>objecttype</name> <operator>==</operator> <name>OBJECT_DOMAIN</name> <operator>&amp;&amp;</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a domain"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a composite type, we need to check that it really is a
	 * free-standing composite type, and not a table's rowtype. We want people
	 * to use ALTER TABLE not ALTER TYPE for that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>&amp;&amp;</operator>
		<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is a table's row type"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* don't allow direct alteration of array types, either */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>get_array_type</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>typeOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter array type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can alter type %s, which will alter the array type as well."</literal></expr></argument>,
						 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the new owner is the same as the existing owner, consider the
	 * command to have succeeded.  This is for dump restoration purposes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Superusers can always do it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Otherwise, must be owner of the existing object */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Must be able to become new owner */</comment>
			<expr_stmt><expr><call><name>check_is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* New owner must have CREATE privilege on namespace */</comment>
			<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>,
											  <argument><expr><name>newOwnerId</name></expr></argument>,
											  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
							   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AlterTypeOwner_oid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTypeOwner_oid - change type owner unconditionally
 *
 * This function recurses to handle a pg_class entry, if necessary.  It
 * invokes any necessary access object hooks.  If hasDependEntry is true, this
 * function modifies the pg_shdepend entry appropriately (this should be
 * passed as false only for table rowtypes and array types).
 *
 * This is used by ALTER TABLE/TYPE OWNER commands, as well as by REASSIGN
 * OWNED BY.  It assumes the caller has done all needed check.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTypeOwner_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasDependEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a composite type, invoke ATExecChangeOwner so that we fix up
	 * the pg_class entry properly.  That will call back to
	 * AlterTypeOwnerInternal to take care of the pg_type entry(s).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AlterTypeOwnerInternal</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Update owner dependency reference */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasDependEntry</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTypeOwnerInternal - bare-bones type owner change.
 *
 * This routine simply modifies the owner of a pg_type entry, and recurses
 * to handle a possible array type.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTypeOwnerInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_type_typowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_type_typowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>,
							<argument><expr><name>Anum_pg_type_typacl</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Null ACLs do not require changes */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typowner</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_type_typacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_type_typacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>,
							<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it has an array type, update that too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typarray</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AlterTypeOwnerInternal</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typarray</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TYPE SET SCHEMA
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterTypeNamespace</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newschema</name></decl></parameter>, <parameter><decl><type><name>ObjectType</name></type> <name>objecttype</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldschema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>

	<comment type="block">/* Make a TypeName so we can use standard type lookup machinery */</comment>
	<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't allow ALTER DOMAIN on a type */</comment>
	<if_stmt><if>if <condition>(<expr><name>objecttype</name> <operator>==</operator> <name>OBJECT_DOMAIN</name> <operator>&amp;&amp;</operator> <call><name>get_typtype</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a domain"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get schema OID and check its permissions */</comment>
	<expr_stmt><expr><name>nspOid</name> <operator>=</operator> <call><name>LookupCreationNamespace</name><argument_list>(<argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>objsMoved</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>AlterTypeNamespace_oid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldschema</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>oldschema</name> <operator>=</operator> <name>oldNspOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>AlterTypeNamespace_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemOid</name></decl>;</decl_stmt>

	<comment type="block">/* check permissions on type */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_type_ownercheck</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* don't allow direct alteration of array types */</comment>
	<expr_stmt><expr><name>elemOid</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elemOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>elemOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>typeOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter array type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can alter type %s, which will alter the array type as well."</literal></expr></argument>,
						 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>elemOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* and do the work */</comment>
	<return>return <expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Move specified type to new namespace.
 *
 * Caller must have already checked privileges.
 *
 * The function automatically recurses to process the type's array type,
 * if any.  isImplicitArray should be true only when doing this internal
 * recursion (outside callers must never try to move an array type directly).
 *
 * If errorOnTableType is true, the function errors out if the type is
 * a table type.  ALTER TABLE has to be used to move a table to a new
 * namespace.
 *
 * Returns the type's old namespace OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTypeNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>isImplicitArray</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>errorOnTableType</name></decl></parameter>,
						   <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>arrayOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompositeType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure we haven't moved this object previously.
	 */</comment>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <name><name>typform</name><operator>-&gt;</operator><name>typnamespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>arrayOid</name> <operator>=</operator> <name><name>typform</name><operator>-&gt;</operator><name>typarray</name></name></expr>;</expr_stmt>

	<comment type="block">/* If the type is already there, we scan skip these next few checks. */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldNspOid</name> <operator>!=</operator> <name>nspOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* common checks on switching namespaces */</comment>
		<expr_stmt><expr><call><name>CheckSetNamespace</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check for duplicate name (more friendly than unique-index failure) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
								  <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typform</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Detect whether type is a composite type (but not a table rowtype) */</comment>
	<expr_stmt><expr><name>isCompositeType</name> <operator>=</operator>
		<operator>(</operator><name><name>typform</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>&amp;&amp;</operator>
		 <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Enforce not-table-type if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typform</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCompositeType</name> <operator>&amp;&amp;</operator>
		<name>errorOnTableType</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is a table's row type"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldNspOid</name> <operator>!=</operator> <name>nspOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK, modify the pg_type row */</comment>

		<comment type="block">/* tup is a copy, so we can scribble directly on it */</comment>
		<expr_stmt><expr><name><name>typform</name><operator>-&gt;</operator><name>typnamespace</name></name> <operator>=</operator> <name>nspOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Composite types have pg_class entries.
	 *
	 * We need to modify the pg_class tuple as well to reflect the change of
	 * schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCompositeType</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>,
									   <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for constraints associated with the composite type (we don't
		 * currently support this, but probably will someday).
		 */</comment>
		<expr_stmt><expr><call><name>AlterConstraintNamespaces</name><argument_list>(<argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>,
								  <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If it's a domain, it might have constraints */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typform</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AlterConstraintNamespaces</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Update dependency on schema, if any --- a table rowtype has not got
	 * one, and neither does an implicit array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldNspOid</name> <operator>!=</operator> <name>nspOid</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>isCompositeType</name> <operator>||</operator> <name><name>typform</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_COMPOSITE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>isImplicitArray</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>,
								<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to change schema dependency for type %s"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Recursively alter the associated array type, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>arrayOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><name>arrayOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>oldNspOid</name></expr>;</return>
</block_content>}</block></function>
</unit>
