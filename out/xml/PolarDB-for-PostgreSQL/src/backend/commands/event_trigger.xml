<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/commands/event_trigger.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * event_trigger.c
 *	  PostgreSQL EVENT TRIGGER support code.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/commands/event_trigger.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/deparse_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/evtcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>EventTriggerQueryState</name>
<block>{
	<comment type="block">/* memory context for this state's objects */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>

	<comment type="block">/* sql_drop */</comment>
	<decl_stmt><decl><type><name>slist_head</name></type>	<name>SQLDropList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_sql_drop</name></decl>;</decl_stmt>

	<comment type="block">/* table_rewrite */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>table_rewrite_oid</name></decl>;</decl_stmt>	<comment type="block">/* InvalidOid, or set for table_rewrite
									 * event */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>table_rewrite_reason</name></decl>;</decl_stmt>	<comment type="block">/* AT_REWRITE reason */</comment>

	<comment type="block">/* Support for command collection */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>commandCollectionInhibited</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>currentCommand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>commandList</name></decl>;</decl_stmt>	<comment type="block">/* list of CollectedCommand; see
								 * deparse_utility.h */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>EventTriggerQueryState</name></name> <modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
}</block></struct></type> <name>EventTriggerQueryState</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>EventTriggerQueryState</name> <modifier>*</modifier></type><name>currentEventTriggerState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obtypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>supported</name></decl>;</decl_stmt>
}</block></struct></type> <name>event_trigger_support_data</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>EVENT_TRIGGER_COMMAND_TAG_OK</name></decl>,
	<decl><name>EVENT_TRIGGER_COMMAND_TAG_NOT_SUPPORTED</name></decl>,
	<decl><name>EVENT_TRIGGER_COMMAND_TAG_NOT_RECOGNIZED</name></decl>
}</block></enum></type> <name>event_trigger_command_tag_check_result</name>;</typedef>

<comment type="block">/* XXX merge this with ObjectTypeMap? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>event_trigger_support_data</name></type> <name><name>event_trigger_support</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"ACCESS METHOD"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"AGGREGATE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"CAST"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"CONSTRAINT"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"COLLATION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"CONVERSION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"DATABASE"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"DOMAIN"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"EXTENSION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"EVENT TRIGGER"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"FOREIGN TABLE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"FUNCTION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"INDEX"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"LANGUAGE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MATERIALIZED VIEW"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"OPERATOR"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"OPERATOR CLASS"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"OPERATOR FAMILY"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"POLICY"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"PROCEDURE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"PUBLICATION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ROLE"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ROUTINE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"RULE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"SCHEMA"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"SEQUENCE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"SERVER"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"STATISTICS"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"SUBSCRIPTION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TABLE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TABLESPACE"</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TRANSFORM"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TRIGGER"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TEXT SEARCH PARSER"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TYPE"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"USER MAPPING"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"VIEW"</literal></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Support for dropped objects */</comment>
<typedef>typedef <type><struct>struct <name>SQLDropObject</name>
<block>{
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objidentity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objecttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>addrnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>addrargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>original</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>normal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>istemp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slist_node</name></type>	<name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>SQLDropObject</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterEventTriggerOwner_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>event_trigger_command_tag_check_result</name></type> <name>check_ddl_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>event_trigger_command_tag_check_result</name></type> <name>check_table_rewrite_ddl_tag</name><parameter_list>(
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>error_duplicate_filter_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>filter_list_to_array</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>filterlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>insert_event_trigger_tuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eventname</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>evtOwner</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcoid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validate_ddl_tags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filtervar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taglist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validate_table_rewrite_tags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filtervar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taglist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EventTriggerInvoke</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fn_oid_list</name></decl></parameter>, <parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stringify_grant_objtype</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stringify_adefprivs_objtype</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create an event trigger.
 */</comment>
<function><type><name>Oid</name></type>
<name>CreateEventTrigger</name><parameter_list>(<parameter><decl><type><name>CreateEventTrigStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcrettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>fargtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* dummy */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>evtowner</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * It would be nice to allow database owners or even regular users to do
	 * this, but there are obvious privilege escalation risks which would have
	 * to somehow be plugged first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to create event trigger \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be superuser or polar_superuser to create an event trigger."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Validate event name. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"ddl_command_start"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"ddl_command_end"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"sql_drop"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"table_rewrite"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized event name \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Validate filter conditions. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stmt-&gt;whenclause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"tag"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>error_duplicate_filter_variable</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tags</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized filter variable \"%s\""</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Validate tag list, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"ddl_command_start"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"ddl_command_end"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"sql_drop"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
		<operator>&amp;&amp;</operator> <name>tags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>validate_ddl_tags</name><argument_list>(<argument><expr><literal type="string">"tag"</literal></expr></argument>, <argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>, <argument><expr><literal type="string">"table_rewrite"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
			 <operator>&amp;&amp;</operator> <name>tags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>validate_table_rewrite_tags</name><argument_list>(<argument><expr><literal type="string">"tag"</literal></expr></argument>, <argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Give user a nice error message if an event trigger of the same name
	 * already exists.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>EVENTTRIGGERNAME</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find and validate the trigger function. */</comment>
	<expr_stmt><expr><name>funcoid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fargtypes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: we check privileges for event trigger funcion */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR END */</comment>
	<expr_stmt><expr><name>funcrettype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcrettype</name> <operator>!=</operator> <name>EVTTRIGGEROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"event_trigger"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Insert catalog entries. */</comment>
	<return>return <expr><call><name>insert_event_trigger_tuple</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>eventname</name></name></expr></argument>,
									  <argument><expr><name>evtowner</name></expr></argument>, <argument><expr><name>funcoid</name></expr></argument>, <argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate DDL command tags.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_ddl_tags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filtervar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taglist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>taglist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>event_trigger_command_tag_check_result</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>check_ddl_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>EVENT_TRIGGER_COMMAND_TAG_NOT_RECOGNIZED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"filter value \"%s\" not recognized for filter variable \"%s\""</literal></expr></argument>,
							<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>filtervar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>EVENT_TRIGGER_COMMAND_TAG_NOT_SUPPORTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s represents an SQL statement name */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event triggers are not supported for %s"</literal></expr></argument>,
							<argument><expr><name>tag</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>event_trigger_command_tag_check_result</name></type>
<name>check_ddl_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obtypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>event_trigger_support_data</name> <modifier>*</modifier></type><name>etsd</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle some idiosyncratic special cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE AS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"SELECT INTO"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"REFRESH MATERIALIZED VIEW"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"ALTER DEFAULT PRIVILEGES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"ALTER LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"GRANT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"REVOKE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"DROP OWNED"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"IMPORT FOREIGN SCHEMA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, command should be CREATE, ALTER, or DROP.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"CREATE "</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obtypename</name> <operator>=</operator> <name>tag</name> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"ALTER "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obtypename</name> <operator>=</operator> <name>tag</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"DROP "</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obtypename</name> <operator>=</operator> <name>tag</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_NOT_RECOGNIZED</name></expr>;</return></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * ...and the object type should be something recognizable.
	 */</comment>
	<for>for <control>(<init><expr><name>etsd</name> <operator>=</operator> <name>event_trigger_support</name></expr>;</init> <condition><expr><name><name>etsd</name><operator>-&gt;</operator><name>obtypename</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>etsd</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>etsd</name><operator>-&gt;</operator><name>obtypename</name></name></expr></argument>, <argument><expr><name>obtypename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<if_stmt><if>if <condition>(<expr><name><name>etsd</name><operator>-&gt;</operator><name>obtypename</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_NOT_RECOGNIZED</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>etsd</name><operator>-&gt;</operator><name>supported</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_NOT_SUPPORTED</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate DDL command tags for event table_rewrite.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_table_rewrite_tags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filtervar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taglist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>taglist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>event_trigger_command_tag_check_result</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>check_table_rewrite_ddl_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>EVENT_TRIGGER_COMMAND_TAG_NOT_SUPPORTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s represents an SQL statement name */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event triggers are not supported for %s"</literal></expr></argument>,
							<argument><expr><name>tag</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>event_trigger_command_tag_check_result</name></type>
<name>check_table_rewrite_ddl_tag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>EVENT_TRIGGER_COMMAND_TAG_NOT_SUPPORTED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Complain about a duplicate filter variable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>error_duplicate_filter_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"filter variable \"%s\" specified more than once"</literal></expr></argument>,
					<argument><expr><name>defname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert the new pg_event_trigger row and record dependencies.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>insert_event_trigger_tuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eventname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>evtOwner</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>funcoid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taglist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>trigoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_trigger</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>evtnamedata</name></decl>,
				<decl><type ref="prev"/><name>evteventdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<comment type="block">/* Open pg_event_trigger. */</comment>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the new pg_trigger tuple. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>evtnamedata</name></expr></argument>, <argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_event_trigger_evtname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>evtnamedata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>evteventdata</name></expr></argument>, <argument><expr><name>eventname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_event_trigger_evtevent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>evteventdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_event_trigger_evtowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>evtOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_event_trigger_evtfoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_event_trigger_evtenabled</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>CharGetDatum</name><argument_list>(<argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>taglist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_event_trigger_evttags</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_event_trigger_evttags</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
			<call><name>filter_list_to_array</name><argument_list>(<argument><expr><name>taglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Insert heap tuple. */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trigoid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Depend on owner. */</comment>
	<expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>, <argument><expr><name>evtOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Depend on event trigger function. */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>EventTriggerRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>trigoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>funcoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Depend on extension, if any. */</comment>
	<expr_stmt><expr><call><name>recordDependencyOnCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Post creation hook for new event trigger */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>trigoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close pg_event_trigger. */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>trigoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * In the parser, a clause like WHEN tag IN ('cmd1', 'cmd2') is represented
 * by a DefElem whose value is a List of String nodes; in the catalog, we
 * store the list of strings as a text array.  This function transforms the
 * former representation into the latter one.
 *
 * For cleanliness, we store command tags in the catalog as text.  It's
 * possible (although not currently anticipated) that we might have
 * a case-sensitive filter variable in the future, in which case this would
 * need some further adjustment.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>filter_list_to_array</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>filterlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>l</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>filterlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>l</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>filterlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_ascii_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>data</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of event trigger deletion.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveEventTriggerById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>trigOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>EVENTTRIGGEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>trigOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for event trigger %u"</literal></expr></argument>, <argument><expr><name>trigOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER EVENT TRIGGER foo ENABLE|DISABLE|ENABLE ALWAYS|REPLICA
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterEventTrigger</name><parameter_list>(<parameter><decl><type><name>AlterEventTrigStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>trigoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_event_trigger</name></type> <name>evtForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>tgenabled</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>tgenabled</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>EVENTTRIGGERNAME</name></expr></argument>,
							  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>trigoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_event_trigger_ownercheck</name><argument_list>(<argument><expr><name>trigoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_EVENT_TRIGGER</name></expr></argument>,
					   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* tuple is a copy, so we can modify it below */</comment>
	<expr_stmt><expr><name>evtForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_event_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>evtForm</name><operator>-&gt;</operator><name>evtenabled</name></name> <operator>=</operator> <name>tgenabled</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>,
							  <argument><expr><name>trigoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>trigoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change event trigger's owner -- by name
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterEventTriggerOwner</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>evtOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>EVENTTRIGGERNAME</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>evtOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AlterEventTriggerOwner_internal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>evtOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Change event trigger owner, by OID
 */</comment>
<function><type><name>void</name></type>
<name>AlterEventTriggerOwner_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>trigOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>EVENTTRIGGEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>trigOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>trigOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AlterEventTriggerOwner_internal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal workhorse for changing an event trigger's owner
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterEventTriggerOwner_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_event_trigger</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_event_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>evtowner</name></name> <operator>==</operator> <name>newOwnerId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_event_trigger_ownercheck</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_EVENT_TRIGGER</name></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>evtname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* New owner must be a superuser or polar_superuser */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>polar_superuser_arg</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to change owner of event trigger \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>evtname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The owner of an event trigger must be a superuser or polar_superuser."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>form</name><operator>-&gt;</operator><name>evtowner</name></name> <operator>=</operator> <name>newOwnerId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update owner dependency reference */</comment>
	<expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>,
							<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>EventTriggerRelationId</name></expr></argument>,
							  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_event_trigger_oid - Look up an event trigger by name to find its OID.
 *
 * If missing_ok is false, throw an error if trigger not found.  If
 * true, just return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_event_trigger_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>GetSysCacheOid1</name><argument_list>(<argument><expr><name>EVENTTRIGGERNAME</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>trigname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true when we want to fire given Event Trigger and false otherwise,
 * filtering on the session replication role and the event trigger registered
 * tags matching.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>filter_event_trigger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tag</name></decl></parameter>, <parameter><decl><type><name>EventTriggerCacheItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * POLAR: If the current user is superuser, we filter out these functions that do not belong to superuser.
	 * You can control this behavior by controlling guc parameter polar_super_trigger_all_event.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_super_call_all_trigger_event</name> <operator>&amp;&amp;</operator> <call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>polar_evtowner</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"superuser don't call function \"%s\" ."</literal></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>fnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"It's filtered , you can trigger them by set polar_super_trigger_all_event = true"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR END */</comment>
	<comment type="block">/*
	 * Filter by session replication role, knowing that we never see disabled
	 * items down here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>SessionReplicationRole</name> <operator>==</operator> <name>SESSION_REPLICATION_ROLE_REPLICA</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>enabled</name></name> <operator>==</operator> <name>TRIGGER_FIRES_ON_ORIGIN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>enabled</name></name> <operator>==</operator> <name>TRIGGER_FIRES_ON_REPLICA</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Filter by tags, if any were specified. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>ntags</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>bsearch</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
									<argument><expr><name><name>item</name><operator>-&gt;</operator><name>ntags</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><name>pg_qsort_strcmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we reach that point, we're not filtering out this item */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setup for running triggers for the given event.  Return value is an OID list
 * of functions to run; if there are any, trigdata is filled with an
 * appropriate EventTriggerData for them to receive.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>EventTriggerCommonSetup</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
						<parameter><decl><type><name>EventTriggerEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eventstr</name></decl></parameter>,
						<parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cachelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>runlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want the list of command tags for which this procedure is actually
	 * invoked to match up exactly with the list that CREATE EVENT TRIGGER
	 * accepts.  This debugging cross-check will throw an error if this
	 * function is invoked for a command tag that CREATE EVENT TRIGGER won't
	 * accept.  (Unfortunately, there doesn't seem to be any simple, automated
	 * way to verify that CREATE EVENT TRIGGER doesn't accept extra stuff that
	 * never reaches this control point.)
	 *
	 * If this cross-check fails for you, you probably need to either adjust
	 * standard_ProcessUtility() not to invoke event triggers for the command
	 * type in question, or you need to adjust check_ddl_tag to accept the
	 * relevant command tag.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbgtag</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbgtag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>EVT_DDLCommandStart</name> <operator>||</operator>
			<name>event</name> <operator>==</operator> <name>EVT_DDLCommandEnd</name> <operator>||</operator>
			<name>event</name> <operator>==</operator> <name>EVT_SQLDrop</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>check_ddl_tag</name><argument_list>(<argument><expr><name>dbgtag</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EVENT_TRIGGER_COMMAND_TAG_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected command tag \"%s\""</literal></expr></argument>, <argument><expr><name>dbgtag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>event</name> <operator>==</operator> <name>EVT_TableRewrite</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>check_table_rewrite_ddl_tag</name><argument_list>(<argument><expr><name>dbgtag</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EVENT_TRIGGER_COMMAND_TAG_OK</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected command tag \"%s\""</literal></expr></argument>, <argument><expr><name>dbgtag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Use cache to find triggers for this event; fast exit if none. */</comment>
	<expr_stmt><expr><name>cachelist</name> <operator>=</operator> <call><name>EventCacheLookup</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cachelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get the command tag. */</comment>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>CreateCommandTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Filter list of event triggers by command tag, and copy them into our
	 * memory context.  Once we start running the command triggers, or indeed
	 * once we do anything at all that touches the catalogs, an invalidation
	 * might leave cachelist pointing at garbage, so we must do this before we
	 * can do much else.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cachelist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EventTriggerCacheItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>filter_event_trigger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We must plan to fire this trigger. */</comment>
			<expr_stmt><expr><name>runlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>fnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* don't spend any more time on this if no functions to run */</comment>
	<if_stmt><if>if <condition>(<expr><name>runlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>trigdata</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_EventTriggerData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdata</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name>eventstr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdata</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <name>parsetree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>

	<return>return <expr><name>runlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fire ddl_command_start triggers.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerDDLCommandStart</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>runlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Event Triggers are completely disabled in standalone mode.  There are
	 * (at least) two reasons for this:
	 *
	 * 1. A sufficiently broken event trigger might not only render the
	 * database unusable, but prevent disabling itself to fix the situation.
	 * In this scenario, restarting in standalone mode provides an escape
	 * hatch.
	 *
	 * 2. BuildEventTriggerCache relies on systable_beginscan_ordered, and
	 * therefore will malfunction if pg_event_trigger's indexes are damaged.
	 * To allow recovery from a damaged index, we need some operating mode
	 * wherein event triggers are disabled.  (Or we could implement
	 * heapscan-and-sort logic for that case, but having disaster recovery
	 * scenarios depend on code that's otherwise untested isn't appetizing.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>runlist</name> <operator>=</operator> <call><name>EventTriggerCommonSetup</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
									  <argument><expr><name>EVT_DDLCommandStart</name></expr></argument>,
									  <argument><expr><literal type="string">"ddl_command_start"</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>runlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Run the triggers. */</comment>
	<expr_stmt><expr><call><name>EventTriggerInvoke</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure anything the event triggers did will be visible to the main
	 * command.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fire ddl_command_end triggers.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerDDLCommandEnd</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>runlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See EventTriggerDDLCommandStart for a discussion about why event
	 * triggers are disabled in single user mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also do nothing if our state isn't set up, which it won't be if there
	 * weren't any relevant event triggers at the start of the current DDL
	 * command.  This test might therefore seem optional, but it's important
	 * because EventTriggerCommonSetup might find triggers that didn't exist
	 * at the time the command started.  Although this function itself
	 * wouldn't crash, the event trigger functions would presumably call
	 * pg_event_trigger_ddl_commands which would fail.  Better to do nothing
	 * until the next command.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>runlist</name> <operator>=</operator> <call><name>EventTriggerCommonSetup</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
									  <argument><expr><name>EVT_DDLCommandEnd</name></expr></argument>, <argument><expr><literal type="string">"ddl_command_end"</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>runlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure anything the main command did will be visible to the event
	 * triggers.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Run the triggers. */</comment>
	<expr_stmt><expr><call><name>EventTriggerInvoke</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fire sql_drop triggers.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerSQLDrop</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>runlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See EventTriggerDDLCommandStart for a discussion about why event
	 * triggers are disabled in single user mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use current state to determine whether this event fires at all.  If
	 * there are no triggers for the sql_drop event, then we don't have
	 * anything to do here.  Note that dropped object collection is disabled
	 * if this is the case, so even if we were to try to run, the list would
	 * be empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<call><name>slist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>SQLDropList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>runlist</name> <operator>=</operator> <call><name>EventTriggerCommonSetup</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
									  <argument><expr><name>EVT_SQLDrop</name></expr></argument>, <argument><expr><literal type="string">"sql_drop"</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Nothing to do if run list is empty.  Note this typically can't happen,
	 * because if there are no sql_drop events, then objects-to-drop wouldn't
	 * have been collected in the first place and we would have quit above.
	 * But it could occur if event triggers were dropped partway through.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>runlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure anything the main command did will be visible to the event
	 * triggers.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure pg_event_trigger_dropped_objects only works when running
	 * these triggers.  Use PG_TRY to ensure in_sql_drop is reset even when
	 * one trigger fails.  (This is perhaps not necessary, as the currentState
	 * variable will be removed shortly by our caller, but it seems better to
	 * play safe.)
	 */</comment>
	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>in_sql_drop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Run the triggers. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EventTriggerInvoke</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>in_sql_drop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>in_sql_drop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fire table_rewrite triggers.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerTableRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>runlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Event Triggers are completely disabled in standalone mode.  There are
	 * (at least) two reasons for this:
	 *
	 * 1. A sufficiently broken event trigger might not only render the
	 * database unusable, but prevent disabling itself to fix the situation.
	 * In this scenario, restarting in standalone mode provides an escape
	 * hatch.
	 *
	 * 2. BuildEventTriggerCache relies on systable_beginscan_ordered, and
	 * therefore will malfunction if pg_event_trigger's indexes are damaged.
	 * To allow recovery from a damaged index, we need some operating mode
	 * wherein event triggers are disabled.  (Or we could implement
	 * heapscan-and-sort logic for that case, but having disaster recovery
	 * scenarios depend on code that's otherwise untested isn't appetizing.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also do nothing if our state isn't set up, which it won't be if there
	 * weren't any relevant event triggers at the start of the current DDL
	 * command.  This test might therefore seem optional, but it's
	 * *necessary*, because EventTriggerCommonSetup might find triggers that
	 * didn't exist at the time the command started.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>runlist</name> <operator>=</operator> <call><name>EventTriggerCommonSetup</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
									  <argument><expr><name>EVT_TableRewrite</name></expr></argument>,
									  <argument><expr><literal type="string">"table_rewrite"</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>runlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make sure pg_event_trigger_table_rewrite_oid only works when running
	 * these triggers. Use PG_TRY to ensure table_rewrite_oid is reset even
	 * when one trigger fails. (This is perhaps not necessary, as the
	 * currentState variable will be removed shortly by our caller, but it
	 * seems better to play safe.)
	 */</comment>
	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_oid</name></name> <operator>=</operator> <name>tableOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_reason</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>

	<comment type="block">/* Run the triggers. */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EventTriggerInvoke</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trigdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_reason</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_reason</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>runlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure anything the event triggers did will be visible to the main
	 * command.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invoke each event trigger in a list of event triggers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EventTriggerInvoke</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fn_oid_list</name></decl></parameter>, <parameter><decl><type><name>EventTriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to recursive event trigger */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let's evaluate event triggers in their own memory context, so that any
	 * leaks get cleaned up promptly.
	 */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									<argument><expr><literal type="string">"event trigger context"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Call each event trigger. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fn_oid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fnoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FunctionCallInfoData</name></type> <name>fcinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgStat_FunctionCallUsage</name></type> <name>fcusage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"EventTriggerInvoke %u"</literal></expr></argument>, <argument><expr><name>fnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We want each event trigger to be able to see the results of the
		 * previous event trigger's action.  Caller is responsible for any
		 * command-counter increment that is needed between the event trigger
		 * and anything else in the transaction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Look up the function */</comment>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>fnoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Call the function, passing no arguments but setting a context. */</comment>
		<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>trigdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_init_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_end_function_usage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fcusage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reclaim memory. */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Restore old memory context and delete the temporary one. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do event triggers support this object type?
 */</comment>
<function><type><name>bool</name></type>
<name>EventTriggerSupportsObjectType</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>obtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>obtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
			<comment type="block">/* no support for global objects */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<comment type="block">/* no support for event triggers on event triggers */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_AMOP</name></expr>:</case>
		<case>case <expr><name>OBJECT_AMPROC</name></expr>:</case>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
		<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_DEFACL</name></expr>:</case>
		<case>case <expr><name>OBJECT_DEFAULT</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION_REL</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
		<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
		<case>case <expr><name>OBJECT_USER_MAPPING</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

			<comment type="block">/*
			 * There's intentionally no default: case here; we want the
			 * compiler to warn if a new ObjectType hasn't been handled above.
			 */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* Shouldn't get here, but if we do, say "no support" */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do event triggers support this object class?
 */</comment>
<function><type><name>bool</name></type>
<name>EventTriggerSupportsObjectClass</name><parameter_list>(<parameter><decl><type><name>ObjectClass</name></type> <name>objclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>objclass</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
		<case>case <expr><name>OCLASS_TBLSPACE</name></expr>:</case>
		<case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
			<comment type="block">/* no support for global objects */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>OCLASS_EVENT_TRIGGER</name></expr>:</case>
			<comment type="block">/* no support for event triggers on event triggers */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
		<case>case <expr><name>OCLASS_PROC</name></expr>:</case>
		<case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
		<case>case <expr><name>OCLASS_CAST</name></expr>:</case>
		<case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
		<case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OCLASS_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OCLASS_DEFAULT</name></expr>:</case>
		<case>case <expr><name>OCLASS_LANGUAGE</name></expr>:</case>
		<case>case <expr><name>OCLASS_LARGEOBJECT</name></expr>:</case>
		<case>case <expr><name>OCLASS_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OCLASS_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OCLASS_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OCLASS_AM</name></expr>:</case>
		<case>case <expr><name>OCLASS_AMOP</name></expr>:</case>
		<case>case <expr><name>OCLASS_AMPROC</name></expr>:</case>
		<case>case <expr><name>OCLASS_REWRITE</name></expr>:</case>
		<case>case <expr><name>OCLASS_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
		<case>case <expr><name>OCLASS_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSTEMPLATE</name></expr>:</case>
		<case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
		<case>case <expr><name>OCLASS_FDW</name></expr>:</case>
		<case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
		<case>case <expr><name>OCLASS_USER_MAPPING</name></expr>:</case>
		<case>case <expr><name>OCLASS_DEFACL</name></expr>:</case>
		<case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
		<case>case <expr><name>OCLASS_POLICY</name></expr>:</case>
		<case>case <expr><name>OCLASS_PUBLICATION</name></expr>:</case>
		<case>case <expr><name>OCLASS_PUBLICATION_REL</name></expr>:</case>
		<case>case <expr><name>OCLASS_SUBSCRIPTION</name></expr>:</case>
		<case>case <expr><name>OCLASS_TRANSFORM</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

			<comment type="block">/*
			 * There's intentionally no default: case here; we want the
			 * compiler to warn if a new OCLASS hasn't been handled above.
			 */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* Shouldn't get here, but if we do, say "no support" */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare event trigger state for a new complete query to run, if necessary;
 * returns whether this was done.  If it was, EventTriggerEndCompleteQuery must
 * be called when the query is done, regardless of whether it succeeds or fails
 * -- so use of a PG_TRY block is mandatory.
 */</comment>
<function><type><name>bool</name></type>
<name>EventTriggerBeginCompleteQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerQueryState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Currently, sql_drop, table_rewrite, ddl_command_end events are the only
	 * reason to have event trigger state at all; so if there are none, don't
	 * install one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>trackDroppedObjectsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								<argument><expr><literal type="string">"event trigger state"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EventTriggerQueryState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cxt</name></name> <operator>=</operator> <name>cxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>slist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>SQLDropList</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>in_sql_drop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>table_rewrite_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name> <operator>=</operator> <ternary><condition><expr><name>currentEventTriggerState</name></expr> ?</condition><then>
		<expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>currentCommand</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name>currentEventTriggerState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentEventTriggerState</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Query completed (or errored out) -- clean up local state, return to previous
 * one.
 *
 * Note: it's an error to call this routine if EventTriggerBeginCompleteQuery
 * returned false previously.
 *
 * Note: this might be called in the PG_CATCH block of a failing transaction,
 * so be wary of running anything unnecessary.  (In particular, it's probably
 * unwise to try to allocate memory.)
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerEndCompleteQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EventTriggerQueryState</name> <modifier>*</modifier></type><name>prevstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prevstate</name> <operator>=</operator> <name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* this avoids the need for retail pfree of SQLDropList items: */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>currentEventTriggerState</name> <operator>=</operator> <name>prevstate</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do we need to keep close track of objects being dropped?
 *
 * This is useful because there is a cost to running with them enabled.
 */</comment>
<function><type><name>bool</name></type>
<name>trackDroppedObjectsNeeded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * true if any sql_drop, table_rewrite, ddl_command_end event trigger
	 * exists
	 */</comment>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>EventCacheLookup</name><argument_list>(<argument><expr><name>EVT_SQLDrop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><call><name>EventCacheLookup</name><argument_list>(<argument><expr><name>EVT_TableRewrite</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><call><name>EventCacheLookup</name><argument_list>(<argument><expr><name>EVT_DDLCommandEnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Support for dropped objects information on event trigger functions.
 *
 * We keep the list of objects dropped by the current command in current
 * state's SQLDropList (comprising SQLDropObject items).  Each time a new
 * command is to start, a clean EventTriggerQueryState is created; commands
 * that drop objects do the dependency.c dance to drop objects, which
 * populates the current state's SQLDropList; when the event triggers are
 * invoked they can consume the list via pg_event_trigger_dropped_objects().
 * When the command finishes, the EventTriggerQueryState is cleared, and
 * the one from the previous command is restored (when no command is in
 * execution, the current state is NULL).
 *
 * All this lets us support the case that an event trigger function drops
 * objects "reentrantly".
 */</comment>

<comment type="block">/*
 * Register one object as being dropped by the current command.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerSQLDropAddObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>original</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SQLDropObject</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>EventTriggerSupportsObjectClass</name><argument_list>(<argument><expr><call><name>getObjectClass</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* don't report temp schemas except my own */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>NamespaceRelationId</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>isTempNamespace</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SQLDropObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <operator>*</operator><name>object</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>original</name></name> <operator>=</operator> <name>original</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>normal</name></name> <operator>=</operator> <name>normal</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain schema names from the object's catalog tuple, if one exists;
	 * this lets us skip objects in temp schemas.  We trust that
	 * ObjectProperty contains all object classes that can be
	 * schema-qualified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_objectclass_supported</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>get_catalog_object_by_oid</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_object_attnum_namespace</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* temp objects are only reported if they are my own */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>isTempNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <literal type="string">"pg_temp"</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>istemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>istemp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>get_object_namensp_unique</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_object_attnum_name</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
										 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>NamespaceRelationId</name> <operator>&amp;&amp;</operator>
			<call><name>isTempNamespace</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>istemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* object identity, objname and objargs */</comment>
	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>objidentity</name></name> <operator>=</operator>
		<call><name>getObjectIdentityParts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>addrnames</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>addrargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* object type */</comment>
	<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>objecttype</name></name> <operator>=</operator> <call><name>getObjectTypeDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>SQLDropList</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_event_trigger_dropped_objects
 *
 * Make the list of dropped objects available to the user function run by the
 * Event Trigger.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_event_trigger_dropped_objects</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Protect this function from being called out of context
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<operator>!</operator><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>in_sql_drop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_EVENT_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be called in a sql_drop event trigger function"</literal></expr></argument>,
						<argument><expr><literal type="string">"pg_event_trigger_dropped_objects()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build tuplestore to hold the result rows */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;(currentEventTriggerState-&gt;SQLDropList)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SQLDropObject</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>SQLDropObject</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* classid */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* objid */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* objsubid */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>address</name><operator>.</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* original */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>original</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* normal */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>normal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* is_temporary */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>istemp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* object_type */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>objecttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* schema_name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* object_name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>objname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* object_identity */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>objidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>objidentity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* address_names and address_args */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>addrnames</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>strlist_to_textarray</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>addrnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>addrargs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>strlist_to_textarray</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>addrargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_event_trigger_table_rewrite_oid
 *
 * Make the Oid of the table going to be rewritten available to the user
 * function run by the Event Trigger.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_event_trigger_table_rewrite_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Protect this function from being called out of context
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_oid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_EVENT_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be called in a table_rewrite event trigger function"</literal></expr></argument>,
						<argument><expr><literal type="string">"pg_event_trigger_table_rewrite_oid()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_event_trigger_table_rewrite_reason
 *
 * Make the rewrite reason available to the user.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_event_trigger_table_rewrite_reason</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Protect this function from being called out of context
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_reason</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_EVENT_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be called in a table_rewrite event trigger function"</literal></expr></argument>,
						<argument><expr><literal type="string">"pg_event_trigger_table_rewrite_reason()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>table_rewrite_reason</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 * Support for DDL command deparsing
 *
 * The routines below enable an event trigger function to obtain a list of
 * DDL commands as they are executed.  There are three main pieces to this
 * feature:
 *
 * 1) Within ProcessUtilitySlow, or some sub-routine thereof, each DDL command
 * adds a struct CollectedCommand representation of itself to the command list,
 * using the routines below.
 *
 * 2) Some time after that, ddl_command_end fires and the command list is made
 * available to the event trigger function via pg_event_trigger_ddl_commands();
 * the complete command details are exposed as a column of type pg_ddl_command.
 *
 * 3) An extension can install a function capable of taking a value of type
 * pg_ddl_command and transform it into some external, user-visible and/or
 * -modifiable representation.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Inhibit DDL command collection.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerInhibitCommandCollection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-establish DDL command collection.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerUndoInhibitCommandCollection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectSimpleCommand
 *		Save data about a simple DDL command that was just executed
 *
 * address identifies the object being operated on.  secondaryObject is an
 * object address that was related in some way to the executed command; its
 * meaning is command-specific.
 *
 * For instance, for an ALTER obj SET SCHEMA command, objtype is the type of
 * object being moved, objectId is its OID, and secondaryOid is the OID of the
 * old schema.  (The destination schema OID can be obtained by catalog lookup
 * of the object.)
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectSimpleCommand</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>address</name></decl></parameter>,
								 <parameter><decl><type><name>ObjectAddress</name></type> <name>secondaryObject</name></decl></parameter>,
								 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_Simple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>simple</name><operator>.</operator><name>address</name></name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>simple</name><operator>.</operator><name>secondaryObject</name></name> <operator>=</operator> <name>secondaryObject</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>,
													<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerAlterTableStart
 *		Prepare to receive data on an ALTER TABLE command about to be executed
 *
 * Note we don't collect the command immediately; instead we keep it in
 * currentCommand, and only when we're done processing the subcommands we will
 * add it to the command list.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerAlterTableStart</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_AlterTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>subcmds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remember the OID of the object being affected by an ALTER TABLE.
 *
 * This is needed because in some cases we don't know the OID until later.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerAlterTableRelid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>objectId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectAlterTableSubcmd
 *		Save data about a single part of an ALTER TABLE.
 *
 * Several different commands go through this path, but apart from ALTER TABLE
 * itself, they are all concerned with AlterTableCmd nodes that are generated
 * internally, so that's all that this code needs to handle at the moment.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectAlterTableSubcmd</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>subcmd</name></decl></parameter>, <parameter><decl><type><name>ObjectAddress</name></type> <name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedATSubcmd</name> <modifier>*</modifier></type><name>newsub</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subcmd</name></expr></argument>, <argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newsub</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedATSubcmd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newsub</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <name>address</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newsub</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>subcmds</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>subcmds</name></name></expr></argument>, <argument><expr><name>newsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerAlterTableEnd
 *		Finish up saving an ALTER TABLE command, and add it to command list.
 *
 * FIXME this API isn't considering the possibility that an xact/subxact is
 * aborted partway through.  Probably it's best to add an
 * AtEOSubXact_EventTriggers() to fix this.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerAlterTableEnd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

	<comment type="block">/* If no subcommands, don't collect */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>subcmds</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>,
					<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>currentCommand</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectGrant
 *		Save data about a GRANT/REVOKE command being executed
 *
 * This function creates a copy of the InternalGrant, as the original might
 * not have the right lifetime.
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectGrant</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>icopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is tedious, but necessary.
	 */</comment>
	<expr_stmt><expr><name>icopy</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InternalGrant</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>icopy</name></expr></argument>, <argument><expr><name>istmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InternalGrant</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>icopy</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>icopy</name><operator>-&gt;</operator><name>grantees</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>icopy</name><operator>-&gt;</operator><name>col_privs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;col_privs</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>icopy</name><operator>-&gt;</operator><name>col_privs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>icopy</name><operator>-&gt;</operator><name>col_privs</name></name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now collect it, using the copied InternalGrant */</comment>
	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_Grant</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>grant</name><operator>.</operator><name>istmt</name></name> <operator>=</operator> <name>icopy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectAlterOpFam
 *		Save data about an ALTER OPERATOR FAMILY ADD/DROP command being
 *		executed
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectAlterOpFam</name><parameter_list>(<parameter><decl><type><name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamoid</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>operators</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procedures</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_AlterOpFamily</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>opfam</name><operator>.</operator><name>address</name></name></expr></argument>,
					 <argument><expr><name>OperatorFamilyRelationId</name></expr></argument>, <argument><expr><name>opfamoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>opfam</name><operator>.</operator><name>operators</name></name> <operator>=</operator> <name>operators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>opfam</name><operator>.</operator><name>procedures</name></name> <operator>=</operator> <name>procedures</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectCreateOpClass
 *		Save data about a CREATE OPERATOR CLASS command being executed
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectCreateOpClass</name><parameter_list>(<parameter><decl><type><name>CreateOpClassStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opcoid</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>operators</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>procedures</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_CreateOpClass</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>createopc</name><operator>.</operator><name>address</name></name></expr></argument>,
					 <argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>opcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>createopc</name><operator>.</operator><name>operators</name></name> <operator>=</operator> <name>operators</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>createopc</name><operator>.</operator><name>procedures</name></name> <operator>=</operator> <name>procedures</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectAlterTSConfig
 *		Save data about an ALTER TEXT SEARCH CONFIGURATION command being
 *		executed
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectAlterTSConfig</name><parameter_list>(<parameter><decl><type><name>AlterTSConfigurationStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>cfgId</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>dictIds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndicts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_AlterTSConfig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>atscfg</name><operator>.</operator><name>address</name></name></expr></argument>,
					 <argument><expr><name>TSConfigRelationId</name></expr></argument>, <argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>atscfg</name><operator>.</operator><name>dictIds</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>atscfg</name><operator>.</operator><name>dictIds</name></name></expr></argument>, <argument><expr><name>dictIds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>atscfg</name><operator>.</operator><name>ndicts</name></name> <operator>=</operator> <name>ndicts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EventTriggerCollectAlterDefPrivs
 *		Save data about an ALTER DEFAULT PRIVILEGES command being
 *		executed
 */</comment>
<function><type><name>void</name></type>
<name>EventTriggerCollectAlterDefPrivs</name><parameter_list>(<parameter><decl><type><name>AlterDefaultPrivilegesStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>

	<comment type="block">/* ignore if event trigger context not set, or collection disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name> <operator>||</operator>
		<name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandCollectionInhibited</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollectedCommand</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SCT_AlterDefaultPrivileges</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>defprivs</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>action</name><operator>-&gt;</operator><name>objtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>in_extension</name></name> <operator>=</operator> <name>creating_extension</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>parsetree</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>currentEventTriggerState</name><operator>-&gt;</operator><name>commandList</name></name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In a ddl_command_end event trigger, this function reports the DDL commands
 * being run.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_event_trigger_ddl_commands</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Protect this function from being called out of context
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>currentEventTriggerState</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_EVENT_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be called in an event trigger function"</literal></expr></argument>,
						<argument><expr><literal type="string">"pg_event_trigger_ddl_commands()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build tuplestore to hold the result rows */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>currentEventTriggerState-&gt;commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollectedCommand</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For IF NOT EXISTS commands that attempt to create an existing
		 * object, the returned OID is Invalid.  Don't return anything.
		 *
		 * One might think that a viable alternative would be to look up the
		 * Oid of the existing object and run the deparse with that.  But
		 * since the parse tree might be different from the one that created
		 * the object in the first place, we might not end up in a consistent
		 * state anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SCT_Simple</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>simple</name><operator>.</operator><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SCT_Simple</name></expr>:</case>
			<case>case <expr><name>SCT_AlterTable</name></expr>:</case>
			<case>case <expr><name>SCT_AlterOpFamily</name></expr>:</case>
			<case>case <expr><name>SCT_CreateOpClass</name></expr>:</case>
			<case>case <expr><name>SCT_AlterTSConfig</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>identity</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schema</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SCT_Simple</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>simple</name><operator>.</operator><name>address</name></name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SCT_AlterTable</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>addr</name></expr></argument>,
										 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>classId</name></name></expr></argument>,
										 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>alterTable</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SCT_AlterOpFamily</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>opfam</name><operator>.</operator><name>address</name></name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SCT_CreateOpClass</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>createopc</name><operator>.</operator><name>address</name></name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SCT_AlterTSConfig</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>atscfg</name><operator>.</operator><name>address</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>getObjectTypeDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>identity</name> <operator>=</operator> <call><name>getObjectIdentity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Obtain schema name, if any ("pg_temp" if a temp
					 * object). If the object class is not in the supported
					 * list here, we assume it's a schema-less object type,
					 * and thus "schema" remains set to NULL.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>is_objectclass_supported</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>nspAttnum</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>nspAttnum</name> <operator>=</operator> <call><name>get_object_attnum_namespace</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>nspAttnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>objtup</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Oid</name></type>			<name>schema_oid</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>objtup</name> <operator>=</operator> <call><name>get_catalog_object_by_oid</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>,
															   <argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>objtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for object %u/%u"</literal></expr></argument>,
									 <argument><expr><name><name>addr</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>schema_oid</name> <operator>=</operator>
								<call><name>heap_getattr</name><argument_list>(<argument><expr><name>objtup</name></expr></argument>, <argument><expr><name>nspAttnum</name></expr></argument>,
											 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									 <argument><expr><literal type="string">"invalid null namespace in object %u/%u/%d"</literal></expr></argument>,
									 <argument><expr><name><name>addr</name><operator>.</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<comment type="block">/* XXX not quite get_namespace_name_or_temp */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>schema_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schema_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

							<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* classid */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* objid */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* objsubid */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* command tag */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* object_type */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* schema */</comment>
					<if_stmt><if>if <condition>(<expr><name>schema</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<comment type="block">/* identity */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* in_extension */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in_extension</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* command */</comment>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>SCT_AlterDefaultPrivileges</name></expr>:</case>
				<comment type="block">/* classid */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* objid */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* objsubid */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* command tag */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>CreateCommandTag</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* object_type */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>stringify_adefprivs_objtype</name><argument_list>(
																			  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>defprivs</name><operator>.</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* schema */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* identity */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* in_extension */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in_extension</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* command */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>SCT_Grant</name></expr>:</case>
				<comment type="block">/* classid */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* objid */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* objsubid */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* command tag */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>grant</name><operator>.</operator><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr> ?</condition><then>
												  <expr><literal type="string">"GRANT"</literal></expr> </then><else>: <expr><literal type="string">"REVOKE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* object_type */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>stringify_grant_objtype</name><argument_list>(
																		  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>grant</name><operator>.</operator><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* schema */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* identity */</comment>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* in_extension */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>in_extension</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* command */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the ObjectType as a string, as it would appear in GRANT and
 * REVOKE commands.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>stringify_grant_objtype</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<return>return <expr><literal type="string">"COLUMN"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<return>return <expr><literal type="string">"TABLE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<return>return <expr><literal type="string">"SEQUENCE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<return>return <expr><literal type="string">"DATABASE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
			<return>return <expr><literal type="string">"DOMAIN"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<return>return <expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<return>return <expr><literal type="string">"FOREIGN SERVER"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<return>return <expr><literal type="string">"FUNCTION"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<return>return <expr><literal type="string">"LANGUAGE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<return>return <expr><literal type="string">"LARGE OBJECT"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<return>return <expr><literal type="string">"SCHEMA"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<return>return <expr><literal type="string">"PROCEDURE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<return>return <expr><literal type="string">"ROUTINE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<return>return <expr><literal type="string">"TABLESPACE"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<return>return <expr><literal type="string">"TYPE"</literal></expr>;</return>
			<comment type="block">/* these currently aren't used */</comment>
		<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_AMOP</name></expr>:</case>
		<case>case <expr><name>OBJECT_AMPROC</name></expr>:</case>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
		<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_DEFAULT</name></expr>:</case>
		<case>case <expr><name>OBJECT_DEFACL</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION_REL</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_USER_MAPPING</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><literal type="string">"???"</literal></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Return the ObjectType as a string; as above, but use the spelling
 * in ALTER DEFAULT PRIVILEGES commands instead.  Generally this is just
 * the plural.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>stringify_adefprivs_objtype</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<return>return <expr><literal type="string">"COLUMNS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<return>return <expr><literal type="string">"TABLES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<return>return <expr><literal type="string">"SEQUENCES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<return>return <expr><literal type="string">"DATABASES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
			<return>return <expr><literal type="string">"DOMAINS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<return>return <expr><literal type="string">"FOREIGN DATA WRAPPERS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<return>return <expr><literal type="string">"FOREIGN SERVERS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<return>return <expr><literal type="string">"FUNCTIONS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<return>return <expr><literal type="string">"LANGUAGES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<return>return <expr><literal type="string">"LARGE OBJECTS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<return>return <expr><literal type="string">"SCHEMAS"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<return>return <expr><literal type="string">"PROCEDURES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<return>return <expr><literal type="string">"ROUTINES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<return>return <expr><literal type="string">"TABLESPACES"</literal></expr>;</return>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<return>return <expr><literal type="string">"TYPES"</literal></expr>;</return>
			<comment type="block">/* these currently aren't used */</comment>
		<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
		<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_AMOP</name></expr>:</case>
		<case>case <expr><name>OBJECT_AMPROC</name></expr>:</case>
		<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
		<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
		<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_DEFAULT</name></expr>:</case>
		<case>case <expr><name>OBJECT_DEFACL</name></expr>:</case>
		<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
		<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
		<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_PUBLICATION_REL</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
		<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
		<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
		<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
		<case>case <expr><name>OBJECT_USER_MAPPING</name></expr>:</case>
		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><literal type="string">"???"</literal></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>
</unit>
