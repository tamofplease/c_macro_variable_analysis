<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/path/pathkeys.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pathkeys.c
 *	  Utilities for matching and building path keys
 *
 * See src/backend/optimizer/README for a great deal of information about
 * the nature and use of path keys.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/pathkeys.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pathkey_is_redundant</name><parameter_list>(<parameter><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>new_pathkey</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>find_var_for_subquery_tle</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>right_merge_direction</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/****************************************************************************
 *		PATHKEY CONSTRUCTION AND REDUNDANCY TESTING
 ****************************************************************************/</comment>

<comment type="block">/*
 * make_canonical_pathkey
 *	  Given the parameters for a PathKey, find any pre-existing matching
 *	  pathkey in the query's list of "canonical" pathkeys.  Make a new
 *	  entry if there's not one already.
 *
 * Note that this function must not be used until after we have completed
 * merging EquivalenceClasses.  (We don't try to enforce that here; instead,
 * equivclass.c will complain if a merge occurs after root-&gt;canon_pathkeys
 * has become nonempty.)
 */</comment>
<function><type><name>PathKey</name> <modifier>*</modifier></type>
<name>make_canonical_pathkey</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* The passed eclass might be non-canonical, so chase up to the top */</comment>
	<while>while <condition>(<expr><name><name>eclass</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eclass</name> <operator>=</operator> <name><name>eclass</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;canon_pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>pk</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>eclass</name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name> <operator>&amp;&amp;</operator>
			<name>opfamily</name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>&amp;&amp;</operator>
			<name>strategy</name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>&amp;&amp;</operator>
			<name>nulls_first</name> <operator>==</operator> <name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>pk</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Be sure canonical pathkeys are allocated in the main planning context.
	 * Not an issue in normal planning, but it is for GEQO.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pk</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PathKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name> <operator>=</operator> <name>eclass</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>=</operator> <name>opfamily</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_nulls_first</name></name> <operator>=</operator> <name>nulls_first</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>canon_pathkeys</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>canon_pathkeys</name></name></expr></argument>, <argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pathkey_is_redundant
 *	   Is a pathkey redundant with one already in the given list?
 *
 * We detect two cases:
 *
 * 1. If the new pathkey's equivalence class contains a constant, and isn't
 * below an outer join, then we can disregard it as a sort key.  An example:
 *			SELECT ... WHERE x = 42 ORDER BY x, y;
 * We may as well just sort by y.  Note that because of opfamily matching,
 * this is semantically correct: we know that the equality constraint is one
 * that actually binds the variable to a single value in the terms of any
 * ordering operator that might go with the eclass.  This rule not only lets
 * us simplify (or even skip) explicit sorts, but also allows matching index
 * sort orders to a query when there are don't-care index columns.
 *
 * 2. If the new pathkey's equivalence class is the same as that of any
 * existing member of the pathkey list, then it is redundant.  Some examples:
 *			SELECT ... ORDER BY x, x;
 *			SELECT ... ORDER BY x, x DESC;
 *			SELECT ... WHERE x = y ORDER BY x, y;
 * In all these cases the second sort key cannot distinguish values that are
 * considered equal by the first, and so there's no point in using it.
 * Note in particular that we need not compare opfamily (all the opfamilies
 * of the EC have the same notion of equality) nor sort direction.
 *
 * Both the given pathkey and the list members must be canonical for this
 * to work properly, but that's okay since we no longer ever construct any
 * non-canonical pathkeys.  (Note: the notion of a pathkey *list* being
 * canonical includes the additional requirement of no redundant entries,
 * which is exactly what we are checking for here.)
 *
 * Because the equivclass.c machinery forms only one copy of any EC per query,
 * pointer comparison is enough to decide whether canonical ECs are the same.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pathkey_is_redundant</name><parameter_list>(<parameter><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>new_pathkey</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>new_ec</name> <init>= <expr><name><name>new_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Check for EC containing a constant --- unconditionally redundant */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>EC_MUST_BE_REDUNDANT</name><argument_list>(<argument><expr><name>new_ec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If same EC already used in list, then redundant */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>old_pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_ec</name> <operator>==</operator> <name><name>old_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_pathkey_from_sortinfo
 *	  Given an expression and sort-order information, create a PathKey.
 *	  The result is always a "canonical" PathKey, but it might be redundant.
 *
 * expr is the expression, and nullable_relids is the set of base relids
 * that are potentially nullable below it.
 *
 * If the PathKey is being generated from a SortGroupClause, sortref should be
 * the SortGroupClause's SortGroupRef; otherwise zero.
 *
 * If rel is not NULL, it identifies a specific relation we're considering
 * a path for, and indicates that child EC members for that relation can be
 * considered.  Otherwise child members are ignored.  (See the comments for
 * get_eclass_for_sort_expr.)
 *
 * create_it is true if we should create any missing EquivalenceClass
 * needed to represent the sort key.  If it's false, we return NULL if the
 * sort key isn't already present in any EquivalenceClass.
 */</comment>
<function><type><specifier>static</specifier> <name>PathKey</name> <modifier>*</modifier></type>
<name>make_pathkey_from_sortinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>opcintype</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>reverse_sort</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>create_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>equality_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>strategy</name> <operator>=</operator> <ternary><condition><expr><name>reverse_sort</name></expr> ?</condition><then> <expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * EquivalenceClasses need to contain opfamily lists based on the family
	 * membership of mergejoinable equality operators, which could belong to
	 * more than one opfamily.  So we have to look up the opfamily's equality
	 * operator and get its membership.
	 */</comment>
	<expr_stmt><expr><name>equality_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
									  <argument><expr><name>opcintype</name></expr></argument>,
									  <argument><expr><name>opcintype</name></expr></argument>,
									  <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opfamilies</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* certainly should find some */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find opfamilies for equality operator %u"</literal></expr></argument>,
			 <argument><expr><name>equality_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now find or (optionally) create a matching EquivalenceClass */</comment>
	<expr_stmt><expr><name>eclass</name> <operator>=</operator> <call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>nullable_relids</name></expr></argument>,
									  <argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
									  <argument><expr><name>sortref</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>create_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fail if no EC and !create_it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eclass</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* And finally we can find or create a PathKey node */</comment>
	<return>return <expr><call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>eclass</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>,
								  <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_pathkey_from_sortop
 *	  Like make_pathkey_from_sortinfo, but work from a sort operator.
 *
 * This should eventually go away, but we need to restructure SortGroupClause
 * first.
 */</comment>
<function><type><specifier>static</specifier> <name>PathKey</name> <modifier>*</modifier></type>
<name>make_pathkey_from_sortop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>ordering_op</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>create_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>,
				<decl><type ref="prev"/><name>opcintype</name></decl>,
				<decl><type ref="prev"/><name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop --- failure shouldn't happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>ordering_op</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a valid ordering operator"</literal></expr></argument>,
			 <argument><expr><name>ordering_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Because SortGroupClause doesn't carry collation, consult the expr */</comment>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>make_pathkey_from_sortinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>expr</name></expr></argument>,
									  <argument><expr><name>nullable_relids</name></expr></argument>,
									  <argument><expr><name>opfamily</name></expr></argument>,
									  <argument><expr><name>opcintype</name></expr></argument>,
									  <argument><expr><name>collation</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr></argument>,
									  <argument><expr><name>nulls_first</name></expr></argument>,
									  <argument><expr><name>sortref</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>create_it</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************************
 *		PATHKEY COMPARISONS
 ****************************************************************************/</comment>

<comment type="block">/*
 * compare_pathkeys
 *	  Compare two pathkeys to see if they are equivalent, and if not whether
 *	  one is "better" than the other.
 *
 *	  We assume the pathkeys are canonical, and so they can be checked for
 *	  equality by simple pointer comparison.
 */</comment>
<function><type><name>PathKeysComparison</name></type>
<name>compare_pathkeys</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>keys1</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>keys2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>key1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>key2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fall out quickly if we are passed two identical lists.  This mostly
	 * catches the case where both are NIL, but that's common enough to
	 * warrant the test.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>keys1</name> <operator>==</operator> <name>keys2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PATHKEYS_EQUAL</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>forboth</name><argument_list>(<argument>key1</argument>, <argument>keys1</argument>, <argument>key2</argument>, <argument>keys2</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey1</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>key1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey2</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pathkey1</name> <operator>!=</operator> <name>pathkey2</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>PATHKEYS_DIFFERENT</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no need to keep looking */</comment>
	</block_content>}</block>

	<comment type="block">/*
	 * If we reached the end of only one list, the other is longer and
	 * therefore not a subset.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>key1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PATHKEYS_BETTER1</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* key1 is longer */</comment>
	<if_stmt><if>if <condition>(<expr><name>key2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PATHKEYS_BETTER2</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* key2 is longer */</comment>
	<return>return <expr><name>PATHKEYS_EQUAL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pathkeys_contained_in
 *	  Common special case of compare_pathkeys: we just want to know
 *	  if keys2 are at least as well sorted as keys1.
 */</comment>
<function><type><name>bool</name></type>
<name>pathkeys_contained_in</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>keys1</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>keys2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>keys1</name></expr></argument>, <argument><expr><name>keys2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PATHKEYS_EQUAL</name></expr>:</case>
		<case>case <expr><name>PATHKEYS_BETTER2</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_cheapest_path_for_pathkeys
 *	  Find the cheapest path (according to the specified criterion) that
 *	  satisfies the given pathkeys and parameterization.
 *	  Return NULL if no such path.
 *
 * 'paths' is a list of possible paths that all generate the same relation
 * 'pathkeys' represents a required ordering (in canonical form!)
 * 'required_outer' denotes allowable outer relations for parameterized paths
 * 'cost_criterion' is STARTUP_COST or TOTAL_COST
 * 'require_parallel_safe' causes us to consider only parallel-safe paths
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>get_cheapest_path_for_pathkeys</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
							   <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
							   <parameter><decl><type><name>CostSelector</name></type> <name>cost_criterion</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>require_parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>matched_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since cost comparison is a lot cheaper than pathkey comparison, do
		 * that first.  (XXX is that still true?)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>matched_path</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>compare_path_costs</name><argument_list>(<argument><expr><name>matched_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>cost_criterion</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>require_parallel_safe</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>matched_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>matched_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_cheapest_fractional_path_for_pathkeys
 *	  Find the cheapest path (for retrieving a specified fraction of all
 *	  the tuples) that satisfies the given pathkeys and parameterization.
 *	  Return NULL if no such path.
 *
 * See compare_fractional_path_costs() for the interpretation of the fraction
 * parameter.
 *
 * 'paths' is a list of possible paths that all generate the same relation
 * 'pathkeys' represents a required ordering (in canonical form!)
 * 'required_outer' denotes allowable outer relations for parameterized paths
 * 'fraction' is the fraction of the total tuples expected to be retrieved
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>get_cheapest_fractional_path_for_pathkeys</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
										  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
										  <parameter><decl><type><name>double</name></type> <name>fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>matched_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since cost comparison is a lot cheaper than pathkey comparison, do
		 * that first.  (XXX is that still true?)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>matched_path</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>compare_fractional_path_costs</name><argument_list>(<argument><expr><name>matched_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fraction</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>matched_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>matched_path</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_cheapest_parallel_safe_total_inner
 *	  Find the unparameterized parallel-safe path with the least total cost.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>get_cheapest_parallel_safe_total_inner</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>innerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>innerpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
			<call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>innerpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>innerpath</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************
 *		NEW PATHKEY FORMATION
 ****************************************************************************/</comment>

<comment type="block">/*
 * build_index_pathkeys
 *	  Build a pathkeys list that describes the ordering induced by an index
 *	  scan using the given index.  (Note that an unordered index doesn't
 *	  induce any ordering, so we return NIL.)
 *
 * If 'scandir' is BackwardScanDirection, build pathkeys representing a
 * backwards scan of the index.
 *
 * We iterate only key columns of covering indexes, since non-key columns
 * don't influence index ordering.  The result is canonical, meaning that
 * redundant pathkeys are removed; it may therefore have fewer entries than
 * there are key columns in the index.
 *
 * Another reason for stopping early is that we may be able to tell that
 * an index column's sort order is uninteresting for this query.  However,
 * that test is just based on the existence of an EquivalenceClass and not
 * on position in pathkey lists, so it's not complete.  Caller should call
 * truncate_useless_pathkeys() to possibly remove more pathkeys.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_index_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
					 <parameter><decl><type><name>ScanDirection</name></type> <name>scandir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* non-orderable index */</comment>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>index-&gt;indextlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>indextle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>reverse_sort</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>nulls_first</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>cpathkey</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * INCLUDE columns are stored in index unordered, so they don't
		 * support ordered index scan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* We assume we don't need to make a copy of the tlist item */</comment>
		<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <name><name>indextle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>scandir</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>reverse_sort</name> <operator>=</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls_first</name> <operator>=</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>reverse_sort</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nulls_first</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * OK, try to make a canonical pathkey for this sort key.  Note we're
		 * underneath any outer joins, so nullable_relids should be NULL.
		 */</comment>
		<expr_stmt><expr><name>cpathkey</name> <operator>=</operator> <call><name>make_pathkey_from_sortinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>indexkey</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name>reverse_sort</name></expr></argument>,
											  <argument><expr><name>nulls_first</name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cpathkey</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We found the sort key in an EquivalenceClass, so it's relevant
			 * for this query.  Add it to list, unless it's redundant.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkey_is_redundant</name><argument_list>(<argument><expr><name>cpathkey</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>cpathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Boolean index keys might be redundant even if they do not
			 * appear in an EquivalenceClass, because of our special treatment
			 * of boolean equality conditions --- see the comment for
			 * indexcol_is_bool_constant_for_query().  If that applies, we can
			 * continue to examine lower-order index columns.  Otherwise, the
			 * sort key is not an interesting sort order for this query, so we
			 * should stop considering index columns; any lower-order sort
			 * keys won't be useful either.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>indexcol_is_bool_constant_for_query</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_expression_pathkey
 *	  Build a pathkeys list that describes an ordering by a single expression
 *	  using the given sort operator.
 *
 * expr, nullable_relids, and rel are as for make_pathkey_from_sortinfo.
 * We induce the other arguments assuming default sort order for the operator.
 *
 * Similarly to make_pathkey_from_sortinfo, the result is NIL if create_it
 * is false and the expression isn't already in some EquivalenceClass.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_expression_pathkey</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>create_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>,
				<decl><type ref="prev"/><name>opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>cpathkey</name></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop --- failure shouldn't happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a valid ordering operator"</literal></expr></argument>,
			 <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cpathkey</name> <operator>=</operator> <call><name>make_pathkey_from_sortinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>expr</name></expr></argument>,
										  <argument><expr><name>nullable_relids</name></expr></argument>,
										  <argument><expr><name>opfamily</name></expr></argument>,
										  <argument><expr><name>opcintype</name></expr></argument>,
										  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr></argument>,
										  <argument><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr></argument>,
										  <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><name>rel</name></expr></argument>,
										  <argument><expr><name>create_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cpathkey</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>cpathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_subquery_pathkeys
 *	  Build a pathkeys list that describes the ordering of a subquery's
 *	  result, in the terms of the outer query.  This is essentially a
 *	  task of conversion.
 *
 * 'rel': outer query's RelOptInfo for the subquery relation.
 * 'subquery_pathkeys': the subquery's output pathkeys, in its terms.
 * 'subquery_tlist': the subquery's output targetlist, in its terms.
 *
 * We intentionally don't do truncate_useless_pathkeys() here, because there
 * are situations where seeing the raw ordering of the subquery is helpful.
 * For example, if it returns ORDER BY x DESC, that may prompt us to
 * construct a mergejoin using DESC order rather than ASC order; but the
 * right_merge_direction heuristic would have us throw the knowledge away.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>convert_subquery_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subquery_pathkeys</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subquery_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retvallen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outer_query_keys</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>subquery_pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>sub_pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>sub_eclass</name> <init>= <expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>best_pathkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the sub_pathkey's EquivalenceClass is volatile, then it must
			 * have come from an ORDER BY clause, and we have to match it to
			 * that same targetlist entry.
			 */</comment>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>outer_var</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* can't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name>subquery_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Is TLE actually available to the outer query? */</comment>
			<expr_stmt><expr><name>outer_var</name> <operator>=</operator> <call><name>find_var_for_subquery_tle</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>outer_var</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We can represent this sub_pathkey */</comment>
				<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>sub_member</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>outer_ec</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sub_member</name> <operator>=</operator> <operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note: it might look funny to be setting sortref = 0 for a
				 * reference to a volatile sub_eclass.  However, the
				 * expression is *not* volatile in the outer query: it's just
				 * a Var referencing whatever the subquery emitted. (IOW, the
				 * outer query isn't going to re-execute the volatile
				 * expression itself.)	So this is okay.  Likewise, it's
				 * correct to pass nullable_relids = NULL, because we're
				 * underneath any outer joins appearing in the outer query.
				 */</comment>
				<expr_stmt><expr><name>outer_ec</name> <operator>=</operator>
					<call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>outer_var</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>,
											 <argument><expr><name><name>sub_member</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
											 <argument><expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
											 <argument><expr><literal type="number">0</literal></expr></argument>,
											 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we don't find a matching EC, sub-pathkey isn't
				 * interesting to the outer query
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>outer_ec</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>best_pathkey</name> <operator>=</operator>
						<call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>outer_ec</name></expr></argument>,
											   <argument><expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
											   <argument><expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>,
											   <argument><expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, the sub_pathkey's EquivalenceClass could contain
			 * multiple elements (representing knowledge that multiple items
			 * are effectively equal).  Each element might match none, one, or
			 * more of the output columns that are visible to the outer query.
			 * This means we may have multiple possible representations of the
			 * sub_pathkey in the context of the outer query.  Ideally we
			 * would generate them all and put them all into an EC of the
			 * outer query, thereby propagating equality knowledge up to the
			 * outer query.  Right now we cannot do so, because the outer
			 * query's EquivalenceClasses are already frozen when this is
			 * called. Instead we prefer the one that has the highest "score"
			 * (number of EC peers, plus one if it matches the outer
			 * query_pathkeys). This is the most likely to be useful in the
			 * outer query.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>best_score</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>sub_eclass-&gt;ec_members</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>sub_member</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>sub_expr</name> <init>= <expr><name><name>sub_member</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>sub_expr_type</name> <init>= <expr><name><name>sub_member</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>sub_expr_coll</name> <init>= <expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sub_member</name><operator>-&gt;</operator><name>em_is_child</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* ignore children here */</comment>

				<macro><name>foreach</name><argument_list>(<argument>k</argument>, <argument>subquery_tlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>outer_var</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>tle_expr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>outer_ec</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>outer_pk</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>score</name></decl>;</decl_stmt>

					<comment type="block">/* Is TLE actually available to the outer query? */</comment>
					<expr_stmt><expr><name>outer_var</name> <operator>=</operator> <call><name>find_var_for_subquery_tle</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outer_var</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * The targetlist entry is considered to match if it
					 * matches after sort-key canonicalization.  That is
					 * needed since the sub_expr has been through the same
					 * process.
					 */</comment>
					<expr_stmt><expr><name>tle_expr</name> <operator>=</operator> <call><name>canonicalize_ec_expression</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
														  <argument><expr><name>sub_expr_type</name></expr></argument>,
														  <argument><expr><name>sub_expr_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>tle_expr</name></expr></argument>, <argument><expr><name>sub_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* See if we have a matching EC for the TLE */</comment>
					<expr_stmt><expr><name>outer_ec</name> <operator>=</operator> <call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>outer_var</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>,
														<argument><expr><name><name>sub_eclass</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>,
														<argument><expr><name>sub_expr_type</name></expr></argument>,
														<argument><expr><name>sub_expr_coll</name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>,
														<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If we don't find a matching EC, this sub-pathkey isn't
					 * interesting to the outer query
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outer_ec</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>outer_pk</name> <operator>=</operator> <call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name>outer_ec</name></expr></argument>,
													  <argument><expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
													  <argument><expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>,
													  <argument><expr><name><name>sub_pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* score = # of equivalence peers */</comment>
					<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>outer_ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<comment type="block">/* +1 if it matches the proper query_pathkeys item */</comment>
					<if_stmt><if>if <condition>(<expr><name>retvallen</name> <operator>&lt;</operator> <name>outer_query_keys</name> <operator>&amp;&amp;</operator>
						<call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>, <argument><expr><name>retvallen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>outer_pk</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>score</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&gt;</operator> <name>best_score</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>best_pathkey</name> <operator>=</operator> <name>outer_pk</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>best_score</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we couldn't find a representation of this sub_pathkey, we're
		 * done (we can't use the ones to its right, either).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>best_pathkey</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Eliminate redundant ordering info; could happen if outer query
		 * equivalences subquery keys...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkey_is_redundant</name><argument_list>(<argument><expr><name>best_pathkey</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>best_pathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retvallen</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_var_for_subquery_tle
 *
 * If the given subquery tlist entry is due to be emitted by the subquery's
 * scan node, return a Var for it, else return NULL.
 *
 * We need this to ensure that we don't return pathkeys describing values
 * that are unavailable above the level of the subquery scan.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>find_var_for_subquery_tle</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If the TLE is resjunk, it's certainly not visible to the outer query */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search the rel's targetlist to see what it will return */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore placeholders */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we find a Var referencing this TLE, we're good */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Make a copy for safety */</comment>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_join_pathkeys
 *	  Build the path keys for a join relation constructed by mergejoin or
 *	  nestloop join.  This is normally the same as the outer path's keys.
 *
 *	  EXCEPTION: in a FULL or RIGHT join, we cannot treat the result as
 *	  having the outer path's path keys, because null lefthand rows may be
 *	  inserted at random points.  It must be treated as unsorted.
 *
 *	  We truncate away any pathkeys that are uninteresting for higher joins.
 *
 * 'joinrel' is the join relation that paths are being formed for
 * 'jointype' is the join type (inner, left, full, etc)
 * 'outer_pathkeys' is the list of the current outer path's path keys
 *
 * Returns the list of new path keys.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_join_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This used to be quite a complex bit of code, but now that all pathkey
	 * sublists start out life canonicalized, we don't have to do a darn thing
	 * here!
	 *
	 * We do, however, need to truncate the pathkeys list, since it may
	 * contain pathkeys that were useful for forming this joinrel but are
	 * uninteresting to higher levels.
	 */</comment>
	<return>return <expr><call><name>truncate_useless_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_pathkeys</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************
 *		PATHKEYS AND SORT CLAUSES
 ****************************************************************************/</comment>

<comment type="block">/*
 * make_pathkeys_for_sortclauses
 *		Generate a pathkeys list that represents the sort order specified
 *		by a list of SortGroupClauses
 *
 * The resulting PathKeys are always in canonical form.  (Actually, there
 * is no longer any code anywhere that creates non-canonical PathKeys.)
 *
 * We assume that root-&gt;nullable_baserels is the set of base relids that could
 * have gone to NULL below the SortGroupClause expressions.  This is okay if
 * the expressions came from the query's top level (ORDER BY, DISTINCT, etc)
 * and if this function is only invoked after deconstruct_jointree.  In the
 * future we might have to make callers pass in the appropriate
 * nullable-relids set, but for now it seems unnecessary.
 *
 * 'sortclauses' is a list of SortGroupClause nodes
 * 'tlist' is the targetlist to find the referenced tlist entries in
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>make_pathkeys_for_sortclauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortclauses</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sortclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>sortkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sortkey</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <call><name>make_pathkey_from_sortop</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>sortkey</name></expr></argument>,
										   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>nullable_baserels</name></name></expr></argument>,
										   <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>,
										   <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr></argument>,
										   <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Canonical form eliminates redundant ordering keys */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkey_is_redundant</name><argument_list>(<argument><expr><name>pathkey</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>pathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************
 *		PATHKEYS AND MERGECLAUSES
 ****************************************************************************/</comment>

<comment type="block">/*
 * initialize_mergeclause_eclasses
 *		Set the EquivalenceClass links in a mergeclause restrictinfo.
 *
 * RestrictInfo contains fields in which we may cache pointers to
 * EquivalenceClasses for the left and right inputs of the mergeclause.
 * (If the mergeclause is a true equivalence clause these will be the
 * same EquivalenceClass, otherwise not.)  If the mergeclause is either
 * used to generate an EquivalenceClass, or derived from an EquivalenceClass,
 * then it's easy to set up the left_ec and right_ec members --- otherwise,
 * this function should be called to set them up.  We will generate new
 * EquivalenceClauses if necessary to represent the mergeclause's left and
 * right sides.
 *
 * Note this is called before EC merging is complete, so the links won't
 * necessarily point to canonical ECs.  Before they are actually used for
 * anything, update_mergeclause_eclasses must be called to ensure that
 * they've been updated to point to canonical ECs.
 */</comment>
<function><type><name>void</name></type>
<name>initialize_mergeclause_eclasses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
				<decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>

	<comment type="block">/* Should be a mergeclause ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... with links not yet set */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need the declared input types of the operator */</comment>
	<expr_stmt><expr><call><name>op_input_types</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find or create a matching EquivalenceClass for each side */</comment>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator>
		<call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>,
								 <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr></argument>,
								 <argument><expr><name>lefttype</name></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator>
		<call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>,
								 <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name></expr></argument>,
								 <argument><expr><name>righttype</name></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>inputcollid</name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * update_mergeclause_eclasses
 *		Make the cached EquivalenceClass links valid in a mergeclause
 *		restrictinfo.
 *
 * These pointers should have been set by process_equivalence or
 * initialize_mergeclause_eclasses, but they might have been set to
 * non-canonical ECs that got merged later.  Chase up to the canonical
 * merged parent if so.
 */</comment>
<function><type><name>void</name></type>
<name>update_mergeclause_eclasses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Should be a merge clause ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... with pointers already set */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Chase up to the top as needed */</comment>
	<while>while <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>
	<while>while <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 * find_mergeclauses_for_outer_pathkeys
 *	  This routine attempts to find a list of mergeclauses that can be
 *	  used with a specified ordering for the join's outer relation.
 *	  If successful, it returns a list of mergeclauses.
 *
 * 'pathkeys' is a pathkeys list showing the ordering of an outer-rel path.
 * 'restrictinfos' is a list of mergejoinable restriction clauses for the
 *			join relation being formed, in no particular order.
 *
 * The restrictinfos must be marked (via outer_is_left) to show which side
 * of each clause is associated with the current outer path.  (See
 * select_mergejoin_clauses())
 *
 * The result is NIL if no merge can be done, else a maximal list of
 * usable mergeclauses (represented as a list of their restrictinfo nodes).
 * The list is ordered to match the pathkeys, as required for execution.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>find_mergeclauses_for_outer_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

	<comment type="block">/* make sure we have eclasses cached in the clauses */</comment>
	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>restrictinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>pathkey_ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>matched_restrictinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<comment type="block">/*----------
		 * A mergejoin clause matches a pathkey if it has the same EC.
		 * If there are multiple matching clauses, take them all.  In plain
		 * inner-join scenarios we expect only one match, because
		 * equivalence-class processing will have removed any redundant
		 * mergeclauses.  However, in outer-join scenarios there might be
		 * multiple matches.  An example is
		 *
		 *	select * from a full join b
		 *		on a.v1 = b.v1 and a.v2 = b.v2 and a.v1 = b.v2;
		 *
		 * Given the pathkeys ({a.v1}, {a.v2}) it is okay to return all three
		 * clauses (in the order a.v1=b.v1, a.v1=b.v2, a.v2=b.v2) and indeed
		 * we *must* do so or we will be unable to form a valid plan.
		 *
		 * We expect that the given pathkeys list is canonical, which means
		 * no two members have the same EC, so it's not possible for this
		 * code to enter the same mergeclause into the result list twice.
		 *
		 * It's possible that multiple matching clauses might have different
		 * ECs on the other side, in which case the order we put them into our
		 * result makes a difference in the pathkeys required for the inner
		 * input rel.  However this routine hasn't got any info about which
		 * order would be best, so we don't worry about that.
		 *
		 * It's also possible that the selected mergejoin clauses produce
		 * a noncanonical ordering of pathkeys for the inner side, ie, we
		 * might select clauses that reference b.v1, b.v2, b.v1 in that
		 * order.  This is not harmful in itself, though it suggests that
		 * the clauses are partially redundant.  Since the alternative is
		 * to omit mergejoin clauses and thereby possibly fail to generate a
		 * plan altogether, we live with it.  make_inner_pathkeys_for_merge()
		 * has to delete duplicates when it constructs the inner pathkeys
		 * list, and we also have to deal with such cases specially in
		 * create_mergejoin_plan().
		 *----------
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>restrictinfos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>clause_ec</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>clause_ec</name> <operator>=</operator> <ternary><condition><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr> ?</condition><then>
				<expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr> </then><else>: <expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr></else></ternary></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>clause_ec</name> <operator>==</operator> <name>pathkey_ec</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>matched_restrictinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>matched_restrictinfos</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we didn't find a mergeclause, we're done --- any additional
		 * sort-key positions in the pathkeys are useless.  (But we can still
		 * mergejoin if we found at least one mergeclause.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>matched_restrictinfos</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we did find usable mergeclause(s) for this sort-key position,
		 * add them to result list.
		 */</comment>
		<expr_stmt><expr><name>mergeclauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>, <argument><expr><name>matched_restrictinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>mergeclauses</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * select_outer_pathkeys_for_merge
 *	  Builds a pathkey list representing a possible sort ordering
 *	  that can be used with the given mergeclauses.
 *
 * 'mergeclauses' is a list of RestrictInfos for mergejoin clauses
 *			that will be used in a merge join.
 * 'joinrel' is the join relation we are trying to construct.
 *
 * The restrictinfos must be marked (via outer_is_left) to show which side
 * of each clause is associated with the current outer path.  (See
 * select_mergejoin_clauses())
 *
 * Returns a pathkeys list that can be applied to the outer relation.
 *
 * Since we assume here that a sort is required, there is no particular use
 * in matching any available ordering of the outerrel.  (joinpath.c has an
 * entirely separate code path for considering sort-free mergejoins.)  Rather,
 * it's interesting to try to match the requested query_pathkeys so that a
 * second output sort may be avoided; and failing that, we try to list "more
 * popular" keys (those with the most unmatched EquivalenceClass peers)
 * earlier, in hopes of making the resulting ordering useful for as many
 * higher-level mergejoins as possible.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>select_outer_pathkeys_for_merge</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nClauses</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier><modifier>*</modifier></type><name>ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>scores</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>necs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Might have no mergeclauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>nClauses</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make arrays of the ECs used by the mergeclauses (dropping any
	 * duplicates) and their "popularity" scores.
	 */</comment>
	<expr_stmt><expr><name>ecs</name> <operator>=</operator> <operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EquivalenceClass</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scores</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>necs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>oeclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>score</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* get the outer eclass */</comment>
		<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* reject duplicates */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>necs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ecs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>oeclass</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>necs</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* compute score */</comment>
		<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>oeclass-&gt;ec_members</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Potential future join partner? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>score</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>ecs</name><index>[<expr><name>necs</name></expr>]</index></name> <operator>=</operator> <name>oeclass</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scores</name><index>[<expr><name>necs</name></expr>]</index></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>necs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Find out if we have all the ECs mentioned in query_pathkeys; if so we
	 * can generate a sort order that's also useful for final output. There is
	 * no percentage in a partial match, though, so we have to have 'em all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;query_pathkeys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>query_pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>query_ec</name> <init>= <expr><name><name>query_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>necs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>ecs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>query_ec</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* found match */</comment>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>necs</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* didn't find match */</comment>
		</block_content>}</block>
		<comment type="block">/* if we got to the end of the list, we have them all */</comment>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* copy query_pathkeys as starting point for our output */</comment>
			<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* mark their ECs as already-emitted */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;query_pathkeys</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>query_pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>query_ec</name> <init>= <expr><name><name>query_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>necs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>ecs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>query_ec</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add remaining ECs to the list in popularity order, using a default sort
	 * ordering.  (We could use qsort() here, but the list length is usually
	 * so small it's not worth it.)
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_score</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>best_j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>best_score</name> <operator>=</operator> <name><name>scores</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>necs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>best_score</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>best_j</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>best_score</name> <operator>=</operator> <name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>best_score</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* all done */</comment>
		<expr_stmt><expr><name>ec</name> <operator>=</operator> <name><name>ecs</name><index>[<expr><name>best_j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scores</name><index>[<expr><name>best_j</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>ec</name></expr></argument>,
										 <argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_opfamilies</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* can't be redundant because no duplicate ECs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>pathkey_is_redundant</name><argument_list>(<argument><expr><name>pathkey</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>pathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scores</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_inner_pathkeys_for_merge
 *	  Builds a pathkey list representing the explicit sort order that
 *	  must be applied to an inner path to make it usable with the
 *	  given mergeclauses.
 *
 * 'mergeclauses' is a list of RestrictInfos for the mergejoin clauses
 *			that will be used in a merge join, in order.
 * 'outer_pathkeys' are the already-known canonical pathkeys for the outer
 *			side of the join.
 *
 * The restrictinfos must be marked (via outer_is_left) to show which side
 * of each clause is associated with the current outer path.  (See
 * select_mergejoin_clauses())
 *
 * Returns a pathkeys list that can be applied to the inner relation.
 *
 * Note that it is not this routine's job to decide whether sorting is
 * actually needed for a particular input path.  Assume a sort is necessary;
 * just make the keys, eh?
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>make_inner_pathkeys_for_merge</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>lastoeclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>opathkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lop</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lastoeclass</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>opathkey</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lop</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>outer_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>oeclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ieclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ieclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ieclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* outer eclass should match current or next pathkeys */</comment>
		<comment type="block">/* we check this carefully for debugging reasons */</comment>
		<if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>!=</operator> <name>lastoeclass</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lop</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few pathkeys for mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>opathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lop</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastoeclass</name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>!=</operator> <name>lastoeclass</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"outer pathkeys do not match mergeclause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Often, we'll have same EC on both sides, in which case the outer
		 * pathkey is also canonical for the inner side, and we can skip a
		 * useless search.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>==</operator> <name>oeclass</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <name>opathkey</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <call><name>make_canonical_pathkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>ieclass</name></expr></argument>,
											 <argument><expr><name><name>opathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
											 <argument><expr><name><name>opathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>,
											 <argument><expr><name><name>opathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Don't generate redundant pathkeys (which can happen if multiple
		 * mergeclauses refer to the same EC).  Because we do this, the output
		 * pathkey list isn't necessarily ordered like the mergeclauses, which
		 * complicates life for create_mergejoin_plan().  But if we didn't,
		 * we'd have a noncanonical sort key list, which would be bad; for one
		 * reason, it certainly wouldn't match any available sort order for
		 * the input relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkey_is_redundant</name><argument_list>(<argument><expr><name>pathkey</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>pathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * trim_mergeclauses_for_inner_pathkeys
 *	  This routine trims a list of mergeclauses to include just those that
 *	  work with a specified ordering for the join's inner relation.
 *
 * 'mergeclauses' is a list of RestrictInfos for mergejoin clauses for the
 *			join relation being formed, in an order known to work for the
 *			currently-considered sort ordering of the join's outer rel.
 * 'pathkeys' is a pathkeys list showing the ordering of an inner-rel path;
 *			it should be equal to, or a truncation of, the result of
 *			make_inner_pathkeys_for_merge for these mergeclauses.
 *
 * What we return will be a prefix of the given mergeclauses list.
 *
 * We need this logic because make_inner_pathkeys_for_merge's result isn't
 * necessarily in the same order as the mergeclauses.  That means that if we
 * consider an inner-rel pathkey list that is a truncation of that result,
 * we might need to drop mergeclauses even though they match a surviving inner
 * pathkey.  This happens when they are to the right of a mergeclause that
 * matches a removed inner pathkey.
 *
 * The mergeclauses must be marked (via outer_is_left) to show which side
 * of each clause is associated with the current outer path.  (See
 * select_mergejoin_clauses())
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>trim_mergeclauses_for_inner_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_mergeclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>pathkey_ec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>matched_pathkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

	<comment type="block">/* No pathkeys =&gt; no mergeclauses (though we don't expect this case) */</comment>
	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Initialize to consider first pathkey */</comment>
	<expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pathkey_ec</name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>matched_pathkey</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Scan mergeclauses to see how many we can use */</comment>
	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>mergeclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>clause_ec</name></decl>;</decl_stmt>

		<comment type="block">/* Assume we needn't do update_mergeclause_eclasses again here */</comment>

		<comment type="block">/* Check clause's inner-rel EC against current pathkey */</comment>
		<expr_stmt><expr><name>clause_ec</name> <operator>=</operator> <ternary><condition><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr> ?</condition><then>
			<expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr> </then><else>: <expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* If we don't have a match, attempt to advance to next pathkey */</comment>
		<if_stmt><if>if <condition>(<expr><name>clause_ec</name> <operator>!=</operator> <name>pathkey_ec</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If we had no clauses matching this inner pathkey, must stop */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched_pathkey</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Advance to next inner pathkey, if any */</comment>
			<if_stmt><if>if <condition>(<expr><name>lip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pathkey_ec</name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>matched_pathkey</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If mergeclause matches current inner pathkey, we can use it */</comment>
		<if_stmt><if>if <condition>(<expr><name>clause_ec</name> <operator>==</operator> <name>pathkey_ec</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>new_mergeclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_mergeclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>matched_pathkey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Else, no hope of adding any more mergeclauses */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_mergeclauses</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************************
 *		PATHKEY USEFULNESS CHECKS
 *
 * We only want to remember as many of the pathkeys of a path as have some
 * potential use, either for subsequent mergejoins or for meeting the query's
 * requested output ordering.  This ensures that add_path() won't consider
 * a path to have a usefully different ordering unless it really is useful.
 * These routines check for usefulness of given pathkeys.
 ****************************************************************************/</comment>

<comment type="block">/*
 * pathkeys_useful_for_merging
 *		Count the number of pathkeys that may be useful for mergejoins
 *		above the given relation.
 *
 * We consider a pathkey potentially useful if it corresponds to the merge
 * ordering of either side of any joinclause for the rel.  This might be
 * overoptimistic, since joinclauses that require different other relations
 * might never be usable at the same time, but trying to be exact is likely
 * to be more trouble than it's worth.
 *
 * To avoid doubling the number of mergejoin paths considered, we would like
 * to consider only one of the two scan directions (ASC or DESC) as useful
 * for merging for any given target column.  The choice is arbitrary unless
 * one of the directions happens to match an ORDER BY key, in which case
 * that direction should be preferred, in hopes of avoiding a final sort step.
 * right_merge_direction() implements this heuristic.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pathkeys_useful_for_merging</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>useful</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<comment type="block">/* If "wrong" direction, not useful for merging */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>right_merge_direction</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * First look into the EquivalenceClass of the pathkey, to see if
		 * there are any members not yet joined to the rel.  If so, it's
		 * surely possible to generate a mergejoin clause using them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>&amp;&amp;</operator>
			<call><name>eclass_useful_for_merging</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise search the rel's joininfo list, which contains
			 * non-EquivalenceClass-derivable join clauses that might
			 * nonetheless be mergejoinable.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>rel-&gt;joininfo</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name> <operator>==</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>||</operator>
					<name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name> <operator>==</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we didn't find a mergeclause, we're done --- any additional
		 * sort-key positions in the pathkeys are useless.  (But we can still
		 * mergejoin if we found at least one mergeclause.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>matched</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>useful</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>useful</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * right_merge_direction
 *		Check whether the pathkey embodies the preferred sort direction
 *		for merging its target column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>right_merge_direction</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;query_pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>query_pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name> <operator>==</operator> <name><name>query_pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name> <operator>&amp;&amp;</operator>
			<name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>==</operator> <name><name>query_pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found a matching query sort column.  Prefer this pathkey's
			 * direction iff it matches.  Note that we ignore pk_nulls_first,
			 * which means that a sort might be needed anyway ... but we still
			 * want to prefer only one of the two possible directions, and we
			 * might as well use this one.
			 */</comment>
			<return>return <expr><operator>(</operator><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>==</operator> <name><name>query_pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name><operator>)</operator></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* If no matching ORDER BY request, prefer the ASC direction */</comment>
	<return>return <expr><operator>(</operator><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pathkeys_useful_for_ordering
 *		Count the number of pathkeys that are useful for meeting the
 *		query's requested output ordering.
 *
 * Unlike merge pathkeys, this is an all-or-nothing affair: it does us
 * no good to order by just the first key(s) of the requested ordering.
 * So the result is always either 0 or list_length(root-&gt;query_pathkeys).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pathkeys_useful_for_ordering</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* no special ordering requested */</comment>

	<if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* unordered path */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's useful ... or at least the first N keys are */</comment>
		<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* path ordering not useful */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * truncate_useless_pathkeys
 *		Shorten the given pathkey list to just the useful pathkeys.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>truncate_useless_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nuseful</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nuseful2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nuseful</name> <operator>=</operator> <call><name>pathkeys_useful_for_merging</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nuseful2</name> <operator>=</operator> <call><name>pathkeys_useful_for_ordering</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nuseful2</name> <operator>&gt;</operator> <name>nuseful</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nuseful</name> <operator>=</operator> <name>nuseful2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: not safe to modify input list destructively, but we can avoid
	 * copying the list if we're not actually going to change it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nuseful</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>nuseful</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>pathkeys</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nuseful</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * has_useful_pathkeys
 *		Detect whether the specified rel could have any pathkeys that are
 *		useful according to truncate_useless_pathkeys().
 *
 * This is a cheap test that lets us skip building pathkeys at all in very
 * simple queries.  It's OK to err in the direction of returning "true" when
 * there really aren't any usable pathkeys, but erring in the other direction
 * is bad --- so keep this in sync with the routines above!
 *
 * We could make the test more complex, for example checking to see if any of
 * the joinclauses are really mergejoinable, but that likely wouldn't win
 * often enough to repay the extra cycles.  Queries with neither a join nor
 * a sort are reasonably common, though, so this much work seems worthwhile.
 */</comment>
<function><type><name>bool</name></type>
<name>has_useful_pathkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* might be able to use pathkeys for merging */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* might be able to use them for ordering */</comment>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* definitely useless */</comment>
</block_content>}</block></function>
</unit>
