<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/path/costsize.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * costsize.c
 *	  Routines to compute (and set) relation sizes and path costs
 *
 * Path costs are measured in arbitrary units established by these basic
 * parameters:
 *
 *	seq_page_cost		Cost of a sequential page fetch
 *	random_page_cost	Cost of a non-sequential page fetch
 *	cpu_tuple_cost		Cost of typical CPU time to process a tuple
 *	cpu_index_tuple_cost  Cost of typical CPU time to process an index tuple
 *	cpu_operator_cost	Cost of CPU time to execute an operator or function
 *	parallel_tuple_cost Cost of CPU time to pass a tuple from worker to master backend
 *	parallel_setup_cost Cost of setting up shared memory for parallelism
 *
 * We expect that the kernel will typically do some amount of read-ahead
 * optimization; this in conjunction with seek costs means that seq_page_cost
 * is normally considerably less than random_page_cost.  (However, if the
 * database is fully cached in RAM, it is reasonable to set them equal.)
 *
 * We also use a rough estimate "effective_cache_size" of the number of
 * disk pages in Postgres + OS-level disk cache.  (We can't simply use
 * NBuffers for this purpose because that would ignore the effects of
 * the kernel's disk cache.)
 *
 * Obviously, taking constants for these values is an oversimplification,
 * but it's tough enough to get any useful estimates even at this level of
 * detail.  Note that all of these parameters are user-settable, in case
 * the default values are drastically off for a particular platform.
 *
 * seq_page_cost and random_page_cost can also be overridden for an individual
 * tablespace, in case some data is on a fast disk and other data is on a slow
 * disk.  Per-tablespace overrides never apply to temporary work files such as
 * an external sort or a materialize node that overflows work_mem.
 *
 * We compute two separate costs for each path:
 *		total_cost: total estimated cost to fetch all tuples
 *		startup_cost: cost that is expended before first tuple is fetched
 * In some scenarios, such as when there is a LIMIT or we are implementing
 * an EXISTS(...) sub-select, it is not necessary to fetch all tuples of the
 * path's result.  A caller can estimate the cost of fetching a partial
 * result by interpolating between startup_cost and total_cost.  In detail:
 *		actual_cost = startup_cost +
 *			(total_cost - startup_cost) * tuples_to_fetch / path-&gt;rows;
 * Note that a base relation's rows count (and, by extension, plan_rows for
 * plan nodes below the LIMIT node) are set without regard to any LIMIT, so
 * that this equation works properly.  (Note: while path-&gt;rows is never zero
 * for ordinary relations, it is zero for paths for provably-empty relations,
 * so beware of division-by-zero.)	The LIMIT is applied as a top-level
 * plan node.
 *
 * For largely historical reasons, most of the routines in this module use
 * the passed result Path only to store their results (rows, startup_cost and
 * total_cost) into.  All the input data they need is passed as separate
 * parameters, even though much of it could be extracted from the Path.
 * An exception is made for the cost_XXXjoin() routines, which expect all
 * the other fields of the passed XXXPath to be filled in, and similarly
 * cost_index() assumes the passed IndexPath is valid except for its output
 * values.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/costsize.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>				<comment type="block">/* for _isnan */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tsmapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(log(x) / 0.693147180559945)</cpp:value></cpp:define>

<comment type="block">/*
 * Append and MergeAppend nodes are less expensive than some other operations
 * which use cpu_tuple_cost; instead of adding a separate GUC, estimate the
 * per-tuple cost as cpu_tuple_cost multiplied by this value.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_CPU_COST_MULTIPLIER</name></cpp:macro> <cpp:value>0.5</cpp:value></cpp:define>


<decl_stmt><decl><type><name>double</name></type>		<name>seq_page_cost</name> <init>= <expr><name>DEFAULT_SEQ_PAGE_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>random_page_cost</name> <init>= <expr><name>DEFAULT_RANDOM_PAGE_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>cpu_tuple_cost</name> <init>= <expr><name>DEFAULT_CPU_TUPLE_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>cpu_index_tuple_cost</name> <init>= <expr><name>DEFAULT_CPU_INDEX_TUPLE_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>cpu_operator_cost</name> <init>= <expr><name>DEFAULT_CPU_OPERATOR_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>parallel_tuple_cost</name> <init>= <expr><name>DEFAULT_PARALLEL_TUPLE_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>parallel_setup_cost</name> <init>= <expr><name>DEFAULT_PARALLEL_SETUP_COST</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>      <name>polar_stat_stale_cost</name> <init>= <expr><name>DEFAULT_CPU_TUPLE_COST</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>effective_cache_size</name> <init>= <expr><name>DEFAULT_EFFECTIVE_CACHE_SIZE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Cost</name></type>		<name>disable_cost</name> <init>= <expr><literal type="number">1.0e10</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>max_parallel_workers_per_gather</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>enable_seqscan</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_indexscan</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_indexonlyscan</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_bitmapscan</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_tidscan</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_sort</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_hashagg</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_groupagg</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_nestloop</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_material</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_mergejoin</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_hashjoin</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_gathermerge</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_partitionwise_join</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_partitionwise_aggregate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_parallel_append</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_parallel_hash</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>enable_partition_pruning</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>total</name></decl>;</decl_stmt>
}</block></struct></type> <name>cost_qual_eval_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>extract_nonindex_conditions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual_clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexquals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MergeScanSelCache</name> <modifier>*</modifier></type><name>cached_scansel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
			   <parameter><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cost_rescan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
			<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>rescan_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>rescan_total_cost</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cost_qual_eval_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>cost_qual_eval_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_restriction_qual_cost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						  <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>,
						  <parameter><decl><type><name>QualCost</name> <modifier>*</modifier></type><name>qpqual_cost</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_indexed_join_quals</name><parameter_list>(<parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>joinpath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>approx_tuple_count</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_joinrel_size_estimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>outer_rows</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>inner_rows</name></decl></parameter>,
						   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>get_foreign_key_join_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>inner_relids</name></decl></parameter>,
								 <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Cost</name></type> <name>append_nonpartial_cost</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numpaths</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_rel_width</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>relation_byte_size</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>page_size</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>get_parallel_divisor</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * clamp_row_est
 *		Force a row-count estimate to a sane value.
 */</comment>
<function><type><name>double</name></type>
<name>clamp_row_est</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>nrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Force estimate to be at least one row, to make explain output look
	 * better and to avoid possible divide-by-zero when interpolating costs.
	 * Make it an integer, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nrows</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>nrows</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * cost_seqscan
 *	  Determines and returns the cost of scanning a relation sequentially.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_seqscan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_run_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>disk_run_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>spc_seq_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_seqscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* fetch estimated page cost for tablespace containing table */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_seq_page_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * disk costs
	 */</comment>
	<expr_stmt><expr><name>disk_run_cost</name> <operator>=</operator> <name>spc_seq_page_cost</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>

	<comment type="block">/* CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_run_cost</name> <operator>=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/* Adjust costing for parallelism, if used. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The CPU cost is divided among all the workers. */</comment>
		<expr_stmt><expr><name>cpu_run_cost</name> <operator>/=</operator> <name>parallel_divisor</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * It may be possible to amortize some of the I/O cost, but probably
		 * not very much, because most operating systems already do aggressive
		 * prefetching.  For now, we assume that the disk run cost can't be
		 * amortized at all.
		 */</comment>

		<comment type="block">/*
		 * In the case of a parallel plan, the row count needs to represent
		 * the number of tuples processed per worker.
		 */</comment>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>cpu_run_cost</name> <operator>+</operator> <name>disk_run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_samplescan
 *	  Determines and returns the cost of scanning a relation using sampling.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_samplescan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsmRoutine</name> <modifier>*</modifier></type><name>tsm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>spc_seq_page_cost</name></decl>,
				<decl><type ref="prev"/><name>spc_random_page_cost</name></decl>,
				<decl><type ref="prev"/><name>spc_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations with tablesample clauses */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsc</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tsc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tsm</name> <operator>=</operator> <call><name>GetTsmRoutine</name><argument_list>(<argument><expr><name><name>tsc</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* fetch estimated page cost for tablespace containing table */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_seq_page_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if NextSampleBlock is used, assume random access, else sequential */</comment>
	<expr_stmt><expr><name>spc_page_cost</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>tsm</name><operator>-&gt;</operator><name>NextSampleBlock</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
		<expr><name>spc_random_page_cost</name></expr> </then><else>: <expr><name>spc_seq_page_cost</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * disk costs (recall that baserel-&gt;pages has already been set to the
	 * number of pages the sampling method will visit)
	 */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>spc_page_cost</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * CPU costs (recall that baserel-&gt;tuples has already been set to the
	 * number of tuples the sampling method will select).  Note that we ignore
	 * execution cost of the TABLESAMPLE parameter expressions; they will be
	 * evaluated only once per scan, and in most usages they'll likely be
	 * simple constants anyway.  We also don't charge anything for the
	 * calculations the sampling method might do internally.
	 */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_gather
 *	  Determines and returns the cost of gather path.
 *
 * 'rel' is the relation to be operated upon
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 * 'rows' may be used to point to a row estimate; if non-NULL, it overrides
 * both 'rel' and 'param_info'.  This is useful when the path doesn't exactly
 * correspond to any particular RelOptInfo.
 */</comment>
<function><type><name>void</name></type>
<name>cost_gather</name><parameter_list>(<parameter><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>,
			<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>rows</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <operator>*</operator><name>rows</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>run_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>

	<comment type="block">/* Parallel setup and communication cost. */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>parallel_setup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>parallel_tuple_cost</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <operator>(</operator><name>startup_cost</name> <operator>+</operator> <name>run_cost</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_gather_merge
 *	  Determines and returns the cost of gather merge path.
 *
 * GatherMerge merges several pre-sorted input streams, using a heap that at
 * any given instant holds the next tuple from each stream. If there are N
 * streams, we need about N*log2(N) tuple comparisons to construct the heap at
 * startup, and then for each output tuple, about log2(N) comparisons to
 * replace the top heap entry with the next tuple from the same stream.
 */</comment>
<function><type><name>void</name></type>
<name>cost_gather_merge</name><parameter_list>(<parameter><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>,
				  <parameter><decl><type><name>Cost</name></type> <name>input_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_total_cost</name></decl></parameter>,
				  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>comparison_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>N</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>logN</name></decl>;</decl_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>rows</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <operator>*</operator><name>rows</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_gathermerge</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add one to the number of workers to account for the leader.  This might
	 * be overgenerous since the leader will do less work than other workers
	 * in typical cases, but we'll go with it for now.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>path</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>logN</name> <operator>=</operator> <call><name>LOG2</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assumed cost per tuple comparison */</comment>
	<expr_stmt><expr><name>comparison_cost</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Heap creation cost */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>comparison_cost</name> <operator>*</operator> <name>N</name> <operator>*</operator> <name>logN</name></expr>;</expr_stmt>

	<comment type="block">/* Per-tuple heap maintenance cost */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>*</operator> <name>comparison_cost</name> <operator>*</operator> <name>logN</name></expr>;</expr_stmt>

	<comment type="block">/* small cost for heap management, like cost_merge_append */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parallel setup and communication cost.  Since Gather Merge, unlike
	 * Gather, requires us to block until a tuple is available from every
	 * worker, we bump the IPC cost up a little bit as compared with Gather.
	 * For lack of a better idea, charge an extra 5%.
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>parallel_setup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>parallel_tuple_cost</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>*</operator> <literal type="number">1.05</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>input_startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <operator>(</operator><name>startup_cost</name> <operator>+</operator> <name>run_cost</name> <operator>+</operator> <name>input_total_cost</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_index
 *	  Determines and returns the cost of scanning a relation using an index.
 *
 * 'path' describes the indexscan under consideration, and is complete
 *		except for the fields to be set by this routine
 * 'loop_count' is the number of repetitions of the indexscan to factor into
 *		estimates of caching behavior
 *
 * In addition to rows, startup_cost and total_cost, cost_index() sets the
 * path's indextotalcost and indexselectivity fields.  These values will be
 * needed if the IndexPath is used in a BitmapIndexScan.
 *
 * NOTE: path-&gt;indexquals must contain only clauses usable as index
 * restrictions.  Any additional quals evaluated as qpquals may reduce the
 * number of returned tuples, but they won't reduce the number of tuples
 * we have to fetch from the table, so they don't reduce the scan cost.
 */</comment>
<function><type><name>void</name></type>
<name>cost_index</name><parameter_list>(<parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>partial_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>indexonly</name> <init>= <expr><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>==</operator> <name>T_IndexOnlyScan</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>amcostestimate_function</name></type> <name>amcostestimate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qpquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>indexStartupCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>indexTotalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>indexSelectivity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indexCorrelation</name></decl>,
				<decl><type ref="prev"/><name>csquared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>spc_seq_page_cost</name></decl>,
				<decl><type ref="prev"/><name>spc_random_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>min_IO_cost</name></decl>,
				<decl><type ref="prev"/><name>max_IO_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>pages_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rand_heap_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>index_pages</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>IsA</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>IndexOptInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the path with the correct row estimate, and identify which quals
	 * will need to be enforced as qpquals.  We need not check any quals that
	 * are implied by the index's predicate, so we can use indrestrictinfo not
	 * baserestrictinfo as the list of relevant restriction clauses for the
	 * rel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt>
		<comment type="block">/* qpquals come from the rel's restriction clauses and ppi_clauses */</comment>
		<expr_stmt><expr><name>qpquals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(
							  <argument><expr><call><name>extract_nonindex_conditions</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indrestrictinfo</name></name></expr></argument>,
														  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>extract_nonindex_conditions</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>,
														  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<comment type="block">/* qpquals come from just the rel's restriction clauses */</comment>
		<expr_stmt><expr><name>qpquals</name> <operator>=</operator> <call><name>extract_nonindex_conditions</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indrestrictinfo</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_indexscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* we don't need to check enable_indexonlyscan; indxpath.c does that */</comment>

	<comment type="block">/*
	 * Call index-access-method-specific code to estimate the processing cost
	 * for scanning the index, as well as the selectivity of the index (ie,
	 * the fraction of main-table tuples we will have to retrieve) and its
	 * correlation to the main-table tuple order.  We need a cast here because
	 * relation.h uses a weak function type to avoid including amapi.h.
	 */</comment>
	<expr_stmt><expr><name>amcostestimate</name> <operator>=</operator> <operator>(</operator><name>amcostestimate_function</name><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>amcostestimate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>amcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>indexStartupCost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexTotalCost</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>indexSelectivity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexCorrelation</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>index_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save amcostestimate's results for possible use in bitmap scan planning.
	 * We don't bother to save indexStartupCost or indexCorrelation, because a
	 * bitmap scan doesn't care about either.
	 */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>indextotalcost</name></name> <operator>=</operator> <name>indexTotalCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>indexselectivity</name></name> <operator>=</operator> <name>indexSelectivity</name></expr>;</expr_stmt>

	<comment type="block">/* all costs for touching index itself included here */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>indexStartupCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>indexTotalCost</name> <operator>-</operator> <name>indexStartupCost</name></expr>;</expr_stmt>

	<comment type="block">/* estimate number of main-table tuples fetched */</comment>
	<expr_stmt><expr><name>tuples_fetched</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>indexSelectivity</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch estimated page costs for tablespace containing table */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_seq_page_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Estimate number of main-table pages fetched, and compute I/O cost.
	 *
	 * When the index ordering is uncorrelated with the table ordering,
	 * we use an approximation proposed by Mackert and Lohman (see
	 * index_pages_fetched() for details) to compute the number of pages
	 * fetched, and then charge spc_random_page_cost per page fetched.
	 *
	 * When the index ordering is exactly correlated with the table ordering
	 * (just after a CLUSTER, for example), the number of pages fetched should
	 * be exactly selectivity * table_size.  What's more, all but the first
	 * will be sequential fetches, not the random fetches that occur in the
	 * uncorrelated case.  So if the number of pages is more than 1, we
	 * ought to charge
	 *		spc_random_page_cost + (pages_fetched - 1) * spc_seq_page_cost
	 * For partially-correlated indexes, we ought to charge somewhere between
	 * these two estimates.  We currently interpolate linearly between the
	 * estimates based on the correlation squared (XXX is that appropriate?).
	 *
	 * If it's an index-only scan, then we will not need to fetch any heap
	 * pages for which the visibility map shows all tuples are visible.
	 * Hence, reduce the estimated number of heap fetches accordingly.
	 * We use the measured fraction of the entire heap that is all-visible,
	 * which might not be particularly relevant to the subset of the heap
	 * that this query will fetch; but it's not clear how to do better.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>loop_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For repeated indexscans, the appropriate estimate for the
		 * uncorrelated case is to scale up the number of tuples fetched in
		 * the Mackert and Lohman formula by the number of scans, so that we
		 * estimate the number of pages fetched by all the scans; then
		 * pro-rate the costs for one scan.  In this case we assume all the
		 * fetches are random accesses.
		 */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>tuples_fetched</name> <operator>*</operator> <name>loop_count</name></expr></argument>,
											<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>baserel</name><operator>-&gt;</operator><name>allvisfrac</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rand_heap_pages</name> <operator>=</operator> <name>pages_fetched</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>max_IO_cost</name> <operator>=</operator> <operator>(</operator><name>pages_fetched</name> <operator>*</operator> <name>spc_random_page_cost</name><operator>)</operator> <operator>/</operator> <name>loop_count</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In the perfectly correlated case, the number of pages touched by
		 * each scan is selectivity * table_size, and we can use the Mackert
		 * and Lohman formula at the page level to estimate how much work is
		 * saved by caching across scans.  We still assume all the fetches are
		 * random, though, which is an overestimate that's hard to correct for
		 * without double-counting the cache effects.  (But in most cases
		 * where such a plan is actually interesting, only one page would get
		 * fetched per scan anyway, so it shouldn't matter much.)
		 */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>indexSelectivity</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>pages_fetched</name> <operator>*</operator> <name>loop_count</name></expr></argument>,
											<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>baserel</name><operator>-&gt;</operator><name>allvisfrac</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>min_IO_cost</name> <operator>=</operator> <operator>(</operator><name>pages_fetched</name> <operator>*</operator> <name>spc_random_page_cost</name><operator>)</operator> <operator>/</operator> <name>loop_count</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Normal case: apply the Mackert and Lohman formula, and then
		 * interpolate between that and the correlation-derived result.
		 */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>tuples_fetched</name></expr></argument>,
											<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>baserel</name><operator>-&gt;</operator><name>allvisfrac</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rand_heap_pages</name> <operator>=</operator> <name>pages_fetched</name></expr>;</expr_stmt>

		<comment type="block">/* max_IO_cost is for the perfectly uncorrelated case (csquared=0) */</comment>
		<expr_stmt><expr><name>max_IO_cost</name> <operator>=</operator> <name>pages_fetched</name> <operator>*</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt>

		<comment type="block">/* min_IO_cost is for the perfectly correlated case (csquared=1) */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>indexSelectivity</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>baserel</name><operator>-&gt;</operator><name>allvisfrac</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pages_fetched</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>min_IO_cost</name> <operator>=</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pages_fetched</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>min_IO_cost</name> <operator>+=</operator> <operator>(</operator><name>pages_fetched</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>spc_seq_page_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_IO_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partial_path</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For index only scans compute workers based on number of index pages
		 * fetched; the number of heap pages we fetch might be so small as to
		 * effectively rule out parallelism, which we don't want to do.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rand_heap_pages</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Estimate the number of parallel workers required to scan index. Use
		 * the number of heap pages computed considering heap fetches won't be
		 * sequential as for parallel scans the pages are accessed in random
		 * order.
		 */</comment>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <call><name>compute_parallel_worker</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>,
															  <argument><expr><name>rand_heap_pages</name></expr></argument>,
															  <argument><expr><name>index_pages</name></expr></argument>,
															  <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fall out if workers can't be assigned for parallel scan, because in
		 * such a case this path will be rejected.  So there is no benefit in
		 * doing extra computation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now interpolate based on estimated index order correlation to get total
	 * disk I/O cost for main table accesses.
	 */</comment>
	<expr_stmt><expr><name>csquared</name> <operator>=</operator> <name>indexCorrelation</name> <operator>*</operator> <name>indexCorrelation</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>max_IO_cost</name> <operator>+</operator> <name>csquared</name> <operator>*</operator> <operator>(</operator><name>min_IO_cost</name> <operator>-</operator> <name>max_IO_cost</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate CPU costs per tuple.
	 *
	 * What we want here is cpu_tuple_cost plus the evaluation costs of any
	 * qual clauses that we have to evaluate as qpquals.
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>, <argument><expr><name>qpquals</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>cpu_run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>tuples_fetched</name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * polar:
	 * To make the planner more robust to handle some inaccurate statistics
	 * issue, we will add a extra cost to qpquals so that the less qpquals
	 * the lower cost it has.
	 */</comment>
    <expr_stmt><expr><name>cpu_run_cost</name> <operator>+=</operator> <name>polar_stat_stale_cost</name> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>qpquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust costing for parallelism, if used. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The CPU cost is divided among all the workers. */</comment>
		<expr_stmt><expr><name>cpu_run_cost</name> <operator>/=</operator> <name>parallel_divisor</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_run_cost</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * extract_nonindex_conditions
 *
 * Given a list of quals to be enforced in an indexscan, extract the ones that
 * will have to be applied as qpquals (ie, the index machinery won't handle
 * them).  The actual rules for this appear in create_indexscan_plan() in
 * createplan.c, but the full rules are fairly expensive and we don't want to
 * go to that much effort for index paths that don't get selected for the
 * final plan.  So we approximate it as quals that don't appear directly in
 * indexquals and also are not redundant children of the same EquivalenceClass
 * as some indexqual.  This method neglects some infrequently-relevant
 * considerations, specifically clauses that needn't be checked because they
 * are implied by an indexqual.  It does not seem worth the cycles to try to
 * factor that in at this stage, even though createplan.c will take pains to
 * remove such unnecessary clauses from the qpquals list if this path is
 * selected for use.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>extract_nonindex_conditions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual_clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qual_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* we may drop pseudoconstants here */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* simple duplicate */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_redundant_derived_clause</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>indexquals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* derived from same EquivalenceClass */</comment>
		<comment type="block">/* ... skip the predicate proof attempt createplan.c will try ... */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_pages_fetched
 *	  Estimate the number of pages actually fetched after accounting for
 *	  cache effects.
 *
 * We use an approximation proposed by Mackert and Lohman, "Index Scans
 * Using a Finite LRU Buffer: A Validated I/O Model", ACM Transactions
 * on Database Systems, Vol. 14, No. 3, September 1989, Pages 401-424.
 * The Mackert and Lohman approximation is that the number of pages
 * fetched is
 *	PF =
 *		min(2TNs/(2T+Ns), T)			when T &lt;= b
 *		2TNs/(2T+Ns)					when T &gt; b and Ns &lt;= 2Tb/(2T-b)
 *		b + (Ns - 2Tb/(2T-b))*(T-b)/T	when T &gt; b and Ns &gt; 2Tb/(2T-b)
 * where
 *		T = # pages in table
 *		N = # tuples in table
 *		s = selectivity = fraction of table to be scanned
 *		b = # buffer pages available (we include kernel space here)
 *
 * We assume that effective_cache_size is the total number of buffer pages
 * available for the whole query, and pro-rate that space across all the
 * tables in the query and the index currently under consideration.  (This
 * ignores space needed for other indexes used by the query, but since we
 * don't know which indexes will get used, we can't estimate that very well;
 * and in any case counting all the tables may well be an overestimate, since
 * depending on the join plan not all the tables may be scanned concurrently.)
 *
 * The product Ns is the number of tuples fetched; we pass in that
 * product rather than calculating it here.  "pages" is the number of pages
 * in the object under consideration (either an index or a table).
 * "index_pages" is the amount to add to the total table space, which was
 * computed for us by query_planner.
 *
 * Caller is expected to have ensured that tuples_fetched is greater than zero
 * and rounded to integer (see clamp_row_est).  The result will likewise be
 * greater than zero and integral.
 */</comment>
<function><type><name>double</name></type>
<name>index_pages_fetched</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>tuples_fetched</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pages</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>index_pages</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>pages_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>T</name></decl>,
				<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

	<comment type="block">/* T is # pages in table, but don't allow it to be zero */</comment>
	<expr_stmt><expr><name>T</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pages</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator> <name>pages</name></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Compute number of pages assumed to be competing for cache space */</comment>
	<expr_stmt><expr><name>total_pages</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>total_table_pages</name></name> <operator>+</operator> <name>index_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_pages</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>total_pages</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>T</name> <operator>&lt;=</operator> <name>total_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* b is pro-rated share of effective_cache_size */</comment>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>effective_cache_size</name> <operator>*</operator> <name>T</name> <operator>/</operator> <name>total_pages</name></expr>;</expr_stmt>

	<comment type="block">/* force it positive and integral */</comment>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* This part is the Mackert and Lohman formula */</comment>
	<if_stmt><if>if <condition>(<expr><name>T</name> <operator>&lt;=</operator> <name>b</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator>
			<operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>*</operator> <name>tuples_fetched</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>+</operator> <name>tuples_fetched</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pages_fetched</name> <operator>&gt;=</operator> <name>T</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>lim</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lim</name> <operator>=</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>*</operator> <name>b</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>-</operator> <name>b</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuples_fetched</name> <operator>&lt;=</operator> <name>lim</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator>
				<operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>*</operator> <name>tuples_fetched</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>+</operator> <name>tuples_fetched</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator>
				<name>b</name> <operator>+</operator> <operator>(</operator><name>tuples_fetched</name> <operator>-</operator> <name>lim</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>T</name> <operator>-</operator> <name>b</name><operator>)</operator> <operator>/</operator> <name>T</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>pages_fetched</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_indexpath_pages
 *		Determine the total size of the indexes used in a bitmap index path.
 *
 * Note: if the same index is used more than once in a bitmap tree, we will
 * count it multiple times, which perhaps is the wrong thing ... but it's
 * not completely clear, and detecting duplicates is difficult, so ignore it
 * for now.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>get_indexpath_pages</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>apath</name> <init>= <expr><operator>(</operator><name>BitmapAndPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>apath-&gt;bitmapquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>get_indexpath_pages</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>opath</name> <init>= <expr><operator>(</operator><name>BitmapOrPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>opath-&gt;bitmapquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>get_indexpath_pages</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name> <init>= <expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>ipath</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cost_bitmap_heap_scan
 *	  Determines and returns the cost of scanning a relation using a bitmap
 *	  index-then-heap plan.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 * 'bitmapqual' is a tree of IndexPaths, BitmapAndPaths, and BitmapOrPaths
 * 'loop_count' is the number of repetitions of the indexscan to factor into
 *		estimates of caching behavior
 *
 * Note: the component IndexPaths in bitmapqual should have been costed
 * using the same loop_count.
 */</comment>
<function><type><name>void</name></type>
<name>cost_bitmap_heap_scan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
					  <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>indexTotalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cost_per_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_run_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>pages_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>spc_seq_page_cost</name></decl>,
				<decl><type ref="prev"/><name>spc_random_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>T</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_bitmapscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>compute_bitmap_pages</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>bitmapqual</name></expr></argument>,
										 <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexTotalCost</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>tuples_fetched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>indexTotalCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>T</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Fetch estimated page costs for tablespace containing table. */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_seq_page_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For small numbers of pages we should charge spc_random_page_cost
	 * apiece, while if nearly all the table's pages are being read, it's more
	 * appropriate to charge spc_seq_page_cost apiece.  The effect is
	 * nonlinear, too. For lack of a better idea, interpolate like this to
	 * determine the cost per page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pages_fetched</name> <operator>&gt;=</operator> <literal type="number">2.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cost_per_page</name> <operator>=</operator> <name>spc_random_page_cost</name> <operator>-</operator>
			<operator>(</operator><name>spc_random_page_cost</name> <operator>-</operator> <name>spc_seq_page_cost</name><operator>)</operator>
			<operator>*</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>pages_fetched</name> <operator>/</operator> <name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>cost_per_page</name> <operator>=</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>pages_fetched</name> <operator>*</operator> <name>cost_per_page</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate CPU costs per tuple.
	 *
	 * Often the indexquals don't need to be rechecked at each tuple ... but
	 * not always, especially not if there are enough tuples involved that the
	 * bitmaps become lossy.  For the moment, just assume they will be
	 * rechecked always.  This means we charge the full freight for all the
	 * scan clauses.
	 */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_run_cost</name> <operator>=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>tuples_fetched</name></expr>;</expr_stmt>

	<comment type="block">/* Adjust costing for parallelism, if used. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The CPU cost is divided among all the workers. */</comment>
		<expr_stmt><expr><name>cpu_run_cost</name> <operator>/=</operator> <name>parallel_divisor</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_run_cost</name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_bitmap_tree_node
 *		Extract cost and selectivity from a bitmap tree node (index/and/or)
 */</comment>
<function><type><name>void</name></type>
<name>cost_bitmap_tree_node</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>cost</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>selec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>indextotalcost</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>selec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>indexselectivity</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Charge a small amount per retrieved tuple to reflect the costs of
		 * manipulating the bitmap.  This is mostly to make sure that a bitmap
		 * scan doesn't look to be the same cost as an indexscan to retrieve a
		 * single tuple.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>+=</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>selec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BitmapAndPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>bitmapselectivity</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>selec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BitmapOrPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>bitmapselectivity</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <operator>*</operator><name>selec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_bitmap_and_node
 *		Estimate the cost of a BitmapAnd node
 *
 * Note that this considers only the costs of index scanning and bitmap
 * creation, not the eventual heap access.  In that sense the object isn't
 * truly a Path, but it has enough path-like properties (costs in particular)
 * to warrant treating it as one.  We don't bother to set the path rows field,
 * however.
 */</comment>
<function><type><name>void</name></type>
<name>cost_bitmap_and_node</name><parameter_list>(<parameter><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>totalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We estimate AND selectivity on the assumption that the inputs are
	 * independent.  This is probably often wrong, but we don't have the info
	 * to do better.
	 *
	 * The runtime cost of the BitmapAnd itself is estimated at 100x
	 * cpu_operator_cost for each tbm_intersect needed.  Probably too small,
	 * definitely too simplistic?
	 */</comment>
	<expr_stmt><expr><name>totalCost</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>path-&gt;bitmapquals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>subCost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>subselec</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_bitmap_tree_node</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subCost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subselec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <name>subselec</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <name>subCost</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>bitmapquals</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <literal type="number">100.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>bitmapselectivity</name></name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* per above, not used */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>totalCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>totalCost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_bitmap_or_node
 *		Estimate the cost of a BitmapOr node
 *
 * See comments for cost_bitmap_and_node.
 */</comment>
<function><type><name>void</name></type>
<name>cost_bitmap_or_node</name><parameter_list>(<parameter><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>totalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We estimate OR selectivity on the assumption that the inputs are
	 * non-overlapping, since that's often the case in "x IN (list)" type
	 * situations.  Of course, we clamp to 1.0 at the end.
	 *
	 * The runtime cost of the BitmapOr itself is estimated at 100x
	 * cpu_operator_cost for each tbm_union needed.  Probably too small,
	 * definitely too simplistic?  We are aware that the tbm_unions are
	 * optimized out when the inputs are BitmapIndexScans.
	 */</comment>
	<expr_stmt><expr><name>totalCost</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>path-&gt;bitmapquals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>subCost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>subselec</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_bitmap_tree_node</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subCost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subselec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name>subselec</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <name>subCost</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>bitmapquals</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <literal type="number">100.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>bitmapselectivity</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>selec</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* per above, not used */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>totalCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>totalCost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_tidscan
 *	  Determines and returns the cost of scanning a relation using TIDs.
 *
 * 'baserel' is the relation to be scanned
 * 'tidquals' is the list of TID-checkable quals
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_tidscan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCurrentOf</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>tid_qual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>spc_random_page_cost</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Count how many tuples we expect to retrieve */</comment>
	<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tidquals</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Each element of the array yields 1 tuple */</comment>
			<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arraynode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ntuples</name> <operator>+=</operator> <call><name>estimate_array_length</name><argument_list>(<argument><expr><name>arraynode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* CURRENT OF yields 1 tuple */</comment>
			<expr_stmt><expr><name>isCurrentOf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ntuples</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* It's just CTID = something, count 1 tuple */</comment>
			<expr_stmt><expr><name>ntuples</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We must force TID scan for WHERE CURRENT OF, because only nodeTidscan.c
	 * understands how to do it correctly.  Therefore, honor enable_tidscan
	 * only when CURRENT OF isn't present.  Also note that cost_qual_eval
	 * counts a CurrentOfExpr as having startup cost disable_cost, which we
	 * subtract off here; that's to prevent other plan types such as seqscan
	 * from winning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCurrentOf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name> <operator>&gt;=</operator> <name>disable_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>-=</operator> <name>disable_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>enable_tidscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The TID qual expressions will be computed once, any other baserestrict
	 * quals once per retrieved tuple.
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid_qual_cost</name></expr></argument>, <argument><expr><name>tidquals</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch estimated page cost for tablespace containing table */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* disk costs --- assume each tuple on a different page */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>spc_random_page_cost</name> <operator>*</operator> <name>ntuples</name></expr>;</expr_stmt>

	<comment type="block">/* Add scanning CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX currently we assume TID quals are a subset of qpquals */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>tid_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-</operator>
		<name><name>tid_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>ntuples</name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_subqueryscan
 *	  Determines and returns the cost of scanning a subquery RTE.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_subqueryscan</name><parameter_list>(<parameter><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are subqueries */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Cost of path is cost of evaluating the subplan, plus cost of evaluating
	 * any restriction clauses and tlist that will be attached to the
	 * SubqueryScan node, plus cpu_tuple_cost to account for selection and
	 * projection overhead.
	 */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_functionscan
 *	  Determines and returns the cost of scanning a function RTE.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_functionscan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>exprcost</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are functions */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Estimate costs of executing the function expression(s).
	 *
	 * Currently, nodeFunctionscan.c always executes the functions to
	 * completion before returning any rows, and caches the results in a
	 * tuplestore.  So the function eval cost is all startup cost, and per-row
	 * costs are minimal.
	 *
	 * XXX in principle we ought to charge tuplestore spill costs if the
	 * number of rows is large.  However, given how phony our rowcount
	 * estimates for functions tend to be, there's not a lot of point in that
	 * refinement right now.
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exprcost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>exprcost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>exprcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add scanning CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_tablefuncscan
 *	  Determines and returns the cost of scanning a table function.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_tablefuncscan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>exprcost</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are functions */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Estimate costs of executing the table func expression(s).
	 *
	 * XXX in principle we ought to charge tuplestore spill costs if the
	 * number of rows is large.  However, given how phony our rowcount
	 * estimates for tablefuncs tend to be, there's not a lot of point in that
	 * refinement right now.
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exprcost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>exprcost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>exprcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add scanning CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_valuesscan
 *	  Determines and returns the cost of scanning a VALUES RTE.
 *
 * 'baserel' is the relation to be scanned
 * 'param_info' is the ParamPathInfo if this is a parameterized path, else NULL
 */</comment>
<function><type><name>void</name></type>
<name>cost_valuesscan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are values lists */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For now, estimate list evaluation cost at one operator eval per list
	 * (probably pretty bogus, but is it worth being smarter?)
	 */</comment>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Add scanning CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_ctescan
 *	  Determines and returns the cost of scanning a CTE RTE.
 *
 * Note: this is used for both self-reference and regular CTEs; the
 * possible cost differences are below the threshold of what we could
 * estimate accurately anyway.  Note that the costs of evaluating the
 * referenced CTE query are added into the final plan as initplan costs,
 * and should NOT be counted here.
 */</comment>
<function><type><name>void</name></type>
<name>cost_ctescan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are CTEs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Charge one CPU tuple cost per row for tuplestore manipulation */</comment>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Add scanning CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_namedtuplestorescan
 *	  Determines and returns the cost of scanning a named tuplestore.
 */</comment>
<function><type><name>void</name></type>
<name>cost_namedtuplestorescan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qpqual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are Tuplestores */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Charge one CPU tuple cost per row for tuplestore manipulation */</comment>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Add scanning CPU costs */</comment>
	<expr_stmt><expr><call><name>get_restriction_qual_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>param_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qpqual_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qpqual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qpqual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_recursive_union
 *	  Determines and returns the cost of performing a recursive union,
 *	  and also the estimated output size.
 *
 * We are given Paths for the nonrecursive and recursive terms.
 */</comment>
<function><type><name>void</name></type>
<name>cost_recursive_union</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>runion</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>nrterm</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>rterm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_rows</name></decl>;</decl_stmt>

	<comment type="block">/* We probably have decent estimates for the non-recursive term */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name><name>nrterm</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name><name>nrterm</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_rows</name> <operator>=</operator> <name><name>nrterm</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We arbitrarily assume that about 10 recursive iterations will be
	 * needed, and that we've managed to get a good fix on the cost and output
	 * size of each one of them.  These are mighty shaky assumptions but it's
	 * hard to see how to do better.
	 */</comment>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <literal type="number">10</literal> <operator>*</operator> <name><name>rterm</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_rows</name> <operator>+=</operator> <literal type="number">10</literal> <operator>*</operator> <name><name>rterm</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also charge cpu_tuple_cost per row to account for the costs of
	 * manipulating the tuplestores.  (We don't worry about possible
	 * spill-to-disk costs.)
	 */</comment>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>total_rows</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>runion</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>runion</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>runion</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>total_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>runion</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>nrterm</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
									<argument><expr><name><name>rterm</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_sort
 *	  Determines and returns the cost of sorting a relation, including
 *	  the cost of reading the input data.
 *
 * If the total volume of data to sort is less than sort_mem, we will do
 * an in-memory sort, which requires no I/O and about t*log2(t) tuple
 * comparisons for t tuples.
 *
 * If the total volume exceeds sort_mem, we switch to a tape-style merge
 * algorithm.  There will still be about t*log2(t) tuple comparisons in
 * total, but we will also need to write and read each tuple once per
 * merge pass.  We expect about ceil(logM(r)) merge passes where r is the
 * number of initial runs formed and M is the merge order used by tuplesort.c.
 * Since the average initial run should be about sort_mem, we have
 *		disk traffic = 2 * relsize * ceil(logM(p / sort_mem))
 *		cpu = comparison_cost * t * log2(t)
 *
 * If the sort is bounded (i.e., only the first k result tuples are needed)
 * and k tuples can fit into sort_mem, we use a heap method that keeps only
 * k tuples in the heap; this will require about t*log2(k) tuple comparisons.
 *
 * The disk traffic is assumed to be 3/4ths sequential and 1/4th random
 * accesses (XXX can't we refine that guess?)
 *
 * By default, we charge two operator evals per tuple comparison, which should
 * be in the right ballpark in most cases.  The caller can tweak this by
 * specifying nonzero comparison_cost; typically that's used for any extra
 * work that has to be done to prepare the inputs to the comparison operators.
 *
 * 'pathkeys' is a list of sort keys
 * 'input_cost' is the total cost for reading the input data
 * 'tuples' is the number of tuples in the relation
 * 'width' is the average tuple width in bytes
 * 'comparison_cost' is the extra cost per comparison, if any
 * 'sort_mem' is the number of kilobytes of work memory allowed for the sort
 * 'limit_tuples' is the bound on the number of output tuples; -1 if no bound
 *
 * NOTE: some callers currently pass NIL for pathkeys because they
 * can't conveniently supply the sort keys.  Since this routine doesn't
 * currently do anything with pathkeys anyway, that doesn't matter...
 * but if it ever does, it should react gracefully to lack of key data.
 * (Actually, the thing we'd most likely be interested in is just the number
 * of sort keys, which all callers *could* supply.)
 */</comment>
<function><type><name>void</name></type>
<name>cost_sort</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
		  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_cost</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>,
		  <parameter><decl><type><name>Cost</name></type> <name>comparison_cost</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sort_mem</name></decl></parameter>,
		  <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><name>input_cost</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>input_bytes</name> <init>= <expr><call><name>relation_byte_size</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>output_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>output_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>sort_mem_bytes</name> <init>= <expr><name>sort_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>tuples</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to be sure the cost of a sort is never estimated as zero, even
	 * if passed-in tuple count is zero.  Besides, mustn't do log(0)...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&lt;</operator> <literal type="number">2.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuples</name> <operator>=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Include the default cost-per-comparison */</comment>
	<expr_stmt><expr><name>comparison_cost</name> <operator>+=</operator> <literal type="number">2.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Do we have a useful LIMIT? */</comment>
	<if_stmt><if>if <condition>(<expr><name>limit_tuples</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>limit_tuples</name> <operator>&lt;</operator> <name>tuples</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <name>limit_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_bytes</name> <operator>=</operator> <call><name>relation_byte_size</name><argument_list>(<argument><expr><name>output_tuples</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <name>tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_bytes</name> <operator>=</operator> <name>input_bytes</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>output_bytes</name> <operator>&gt;</operator> <name>sort_mem_bytes</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We'll have to use a disk-based sort of all the tuples
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>npages</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>input_bytes</name> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>nruns</name> <init>= <expr><name>input_bytes</name> <operator>/</operator> <name>sort_mem_bytes</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>mergeorder</name> <init>= <expr><call><name>tuplesort_merge_order</name><argument_list>(<argument><expr><name>sort_mem_bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>log_runs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>npageaccesses</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * CPU costs
		 *
		 * Assume about N log2 N comparisons
		 */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>comparison_cost</name> <operator>*</operator> <name>tuples</name> <operator>*</operator> <call><name>LOG2</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Disk costs */</comment>

		<comment type="block">/* Compute logM(r) as log(r) / log(M) */</comment>
		<if_stmt><if>if <condition>(<expr><name>nruns</name> <operator>&gt;</operator> <name>mergeorder</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>log_runs</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><name>nruns</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><name>mergeorder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>log_runs</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>npageaccesses</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>*</operator> <name>npages</name> <operator>*</operator> <name>log_runs</name></expr>;</expr_stmt>
		<comment type="block">/* Assume 3/4ths of accesses are sequential, 1/4th are not */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>npageaccesses</name> <operator>*</operator>
			<operator>(</operator><name>seq_page_cost</name> <operator>*</operator> <literal type="number">0.75</literal> <operator>+</operator> <name>random_page_cost</name> <operator>*</operator> <literal type="number">0.25</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>output_tuples</name> <operator>||</operator> <name>input_bytes</name> <operator>&gt;</operator> <name>sort_mem_bytes</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We'll use a bounded heap-sort keeping just K tuples in memory, for
		 * a total number of tuple comparisons of N log2 K; but the constant
		 * factor is a bit higher than for quicksort.  Tweak it so that the
		 * cost curve is continuous at the crossover point.
		 */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>comparison_cost</name> <operator>*</operator> <name>tuples</name> <operator>*</operator> <call><name>LOG2</name><argument_list>(<argument><expr><literal type="number">2.0</literal> <operator>*</operator> <name>output_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We'll use plain quicksort on all the input tuples */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>comparison_cost</name> <operator>*</operator> <name>tuples</name> <operator>*</operator> <call><name>LOG2</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Also charge a small amount (arbitrarily set equal to operator cost) per
	 * extracted tuple.  We don't charge cpu_tuple_cost because a Sort node
	 * doesn't do qual-checking or projection, so it has less overhead than
	 * most plan nodes.  Note it's correct to use tuples not output_tuples
	 * here --- the upper LIMIT will pro-rate the run cost so we'd be double
	 * counting the LIMIT otherwise.
	 */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name>tuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * append_nonpartial_cost
 *	  Estimate the cost of the non-partial paths in a Parallel Append.
 *	  The non-partial paths are assumed to be the first "numpaths" paths
 *	  from the subpaths list, and to be in order of decreasing cost.
 */</comment>
<function><type><specifier>static</specifier> <name>Cost</name></type>
<name>append_nonpartial_cost</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numpaths</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name>	   <modifier>*</modifier></type><name>costarr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>arrlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>path_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_index</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numpaths</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Array length is number of workers or number of relevants paths,
	 * whichever is less.
	 */</comment>
	<expr_stmt><expr><name>arrlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>numpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>costarr</name> <operator>=</operator> <operator>(</operator><name>Cost</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Cost</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>arrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The first few paths will each be claimed by a different worker. */</comment>
	<expr_stmt><expr><name>path_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>path_index</name> <operator>==</operator> <name>arrlen</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>costarr</name><index>[<expr><name>path_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Since subpaths are sorted by decreasing cost, the last one will have
	 * the minimum cost.
	 */</comment>
	<expr_stmt><expr><name>min_index</name> <operator>=</operator> <name>arrlen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each of the remaining subpaths, add its cost to the array element
	 * with minimum cost.
	 */</comment>
	<macro><name>for_each_cell</name><argument_list>(<argument>l</argument>, <argument>cell</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Consider only the non-partial paths */</comment>
		<if_stmt><if>if <condition>(<expr><name>path_index</name><operator>++</operator> <operator>==</operator> <name>numpaths</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>costarr</name><index>[<expr><name>min_index</name></expr>]</index></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>

		<comment type="block">/* Update the new min cost array index */</comment>
		<for>for <control>(<init><expr><name>min_index</name> <operator>=</operator> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>costarr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>costarr</name><index>[<expr><name>min_index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>min_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/* Return the highest cost from the array */</comment>
	<for>for <control>(<init><expr><name>max_index</name> <operator>=</operator> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>costarr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>costarr</name><index>[<expr><name>max_index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>costarr</name><index>[<expr><name>max_index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cost_append
 *	  Determines and returns the cost of an Append node.
 */</comment>
<function><type><name>void</name></type>
<name>cost_append</name><parameter_list>(<parameter><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>apath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Startup cost of non-parallel-aware Append is the startup cost of
		 * first subpath.
		 */</comment>
		<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>

		<comment type="block">/* Compute rows and costs as sums of subplan rows and costs. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>apath-&gt;subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* parallel-aware */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apath</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Calculate startup cost. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>apath-&gt;subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Append will start returning tuples when the child node having
			 * lowest startup cost is done setting up. We consider only the
			 * first few subplans that immediately get a worker assigned.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
											   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Apply parallel divisor to subpaths.  Scale the number of rows
			 * for each partial subpath based on the ratio of the parallel
			 * divisor originally used for the subpath to the one we adopted.
			 * Also add the cost of partial paths to the total cost, but
			 * ignore non-partial paths for now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>apath</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>double</name></type>		<name>subpath_parallel_divisor</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>subpath_parallel_divisor</name> <operator>=</operator> <call><name>get_parallel_divisor</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <operator>(</operator><name>subpath_parallel_divisor</name> <operator>/</operator>
													 <name>parallel_divisor</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Add cost for non-partial subpaths. */</comment>
		<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator>
			<call><name>append_nonpartial_cost</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>,
								   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>first_partial_path</name></name></expr></argument>,
								   <argument><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Although Append does not do any selection or projection, it's not free;
	 * add a small per-tuple overhead.
	 */</comment>
	<expr_stmt><expr><name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator>
		<name>cpu_tuple_cost</name> <operator>*</operator> <name>APPEND_CPU_COST_MULTIPLIER</name> <operator>*</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_merge_append
 *	  Determines and returns the cost of a MergeAppend node.
 *
 * MergeAppend merges several pre-sorted input streams, using a heap that
 * at any given instant holds the next tuple from each stream.  If there
 * are N streams, we need about N*log2(N) tuple comparisons to construct
 * the heap at startup, and then for each output tuple, about log2(N)
 * comparisons to replace the top entry.
 *
 * (The effective value of N will drop once some of the input streams are
 * exhausted, but it seems unlikely to be worth trying to account for that.)
 *
 * The heap is never spilled to disk, since we assume N is not very large.
 * So this is much simpler than cost_sort.
 *
 * As in cost_sort, we charge two operator evals per tuple comparison.
 *
 * 'pathkeys' is a list of sort keys
 * 'n_streams' is the number of input streams
 * 'input_startup_cost' is the sum of the input streams' startup costs
 * 'input_total_cost' is the sum of the input streams' total costs
 * 'tuples' is the number of tuples in all the streams
 */</comment>
<function><type><name>void</name></type>
<name>cost_merge_append</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_streams</name></decl></parameter>,
				  <parameter><decl><type><name>Cost</name></type> <name>input_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_total_cost</name></decl></parameter>,
				  <parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>comparison_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>N</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>logN</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Avoid log(0)...
	 */</comment>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>n_streams</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2.0</literal></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator> <name>n_streams</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>logN</name> <operator>=</operator> <call><name>LOG2</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assumed cost per tuple comparison */</comment>
	<expr_stmt><expr><name>comparison_cost</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>

	<comment type="block">/* Heap creation cost */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>comparison_cost</name> <operator>*</operator> <name>N</name> <operator>*</operator> <name>logN</name></expr>;</expr_stmt>

	<comment type="block">/* Per-tuple heap maintenance cost */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>tuples</name> <operator>*</operator> <name>comparison_cost</name> <operator>*</operator> <name>logN</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Although MergeAppend does not do any selection or projection, it's not
	 * free; add a small per-tuple overhead.
	 */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>APPEND_CPU_COST_MULTIPLIER</name> <operator>*</operator> <name>tuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>input_startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name> <operator>+</operator> <name>input_total_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_material
 *	  Determines and returns the cost of materializing a relation, including
 *	  the cost of reading the input data.
 *
 * If the total volume of data to materialize exceeds work_mem, we will need
 * to write it to disk, so the cost is much higher in that case.
 *
 * Note that here we are estimating the costs for the first scan of the
 * relation, so the materialization is all overhead --- any savings will
 * occur only on rescan, which is estimated in cost_rescan.
 */</comment>
<function><type><name>void</name></type>
<name>cost_material</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
			  <parameter><decl><type><name>Cost</name></type> <name>input_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_total_cost</name></decl></parameter>,
			  <parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><name>input_startup_cost</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><name>input_total_cost</name> <operator>-</operator> <name>input_startup_cost</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nbytes</name> <init>= <expr><call><name>relation_byte_size</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>work_mem_bytes</name> <init>= <expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>tuples</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Whether spilling or not, charge 2x cpu_operator_cost per tuple to
	 * reflect bookkeeping overhead.  (This rate must be more than what
	 * cost_rescan charges for materialize, ie, cpu_operator_cost per tuple;
	 * if it is exactly the same then there will be a cost tie between
	 * nestloop with A outer, materialized B inner and nestloop with B outer,
	 * materialized A inner.  The extra cost ensures we'll prefer
	 * materializing the smaller rel.)	Note that this is normally a good deal
	 * less than cpu_tuple_cost; which is OK because a Material plan node
	 * doesn't do qual-checking or projection, so it's got less overhead than
	 * most plan nodes.
	 */</comment>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name>tuples</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we will spill to disk, charge at the rate of seq_page_cost per page.
	 * This cost is assumed to be evenly spread through the plan run phase,
	 * which isn't exactly accurate but our cost model doesn't allow for
	 * nonuniform costs within the run phase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <name>work_mem_bytes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>npages</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>nbytes</name> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>npages</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_agg
 *		Determines and returns the cost of performing an Agg plan node,
 *		including the cost of its input.
 *
 * aggcosts can be NULL when there are no actual aggregate functions (i.e.,
 * we are using a hashed Agg node just to do grouping).
 *
 * Note: when aggstrategy == AGG_SORTED, caller must ensure that input costs
 * are for appropriately-sorted input.
 */</comment>
<function><type><name>void</name></type>
<name>cost_agg</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
		 <parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>aggcosts</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>,
		 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>,
		 <parameter><decl><type><name>Cost</name></type> <name>input_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_total_cost</name></decl></parameter>,
		 <parameter><decl><type><name>double</name></type> <name>input_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>output_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>dummy_aggcosts</name></decl>;</decl_stmt>

	<comment type="block">/* Use all-zero per-aggregate costs if NULL is passed */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggcosts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_HASHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummy_aggcosts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggcosts</name> <operator>=</operator> <operator>&amp;</operator><name>dummy_aggcosts</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The transCost.per_tuple component of aggcosts should be charged once
	 * per input tuple, corresponding to the costs of evaluating the aggregate
	 * transfns and their input expressions (with any startup cost of course
	 * charged but once).  The finalCost component is charged once per output
	 * tuple, corresponding to the costs of evaluating the finalfns.
	 *
	 * If we are grouping, we charge an additional cpu_operator_cost per
	 * grouping column per input tuple for grouping comparisons.
	 *
	 * We will produce a single output tuple if not grouping, and a tuple per
	 * group otherwise.  We charge cpu_tuple_cost for each output tuple.
	 *
	 * Note: in this cost model, AGG_SORTED and AGG_HASHED have exactly the
	 * same total CPU cost, but AGG_SORTED has lower startup cost.  If the
	 * input path is already sorted appropriately, AGG_SORTED should be
	 * preferred (since it has no risk of memory overflow).  This will happen
	 * as long as the computed total costs are indeed exactly equal --- but if
	 * there's roundoff error we might do the wrong thing.  So be sure that
	 * the computations below form the same intermediate values in the same
	 * order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_PLAIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name>input_total_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>finalCost</name></name></expr>;</expr_stmt>
		<comment type="block">/* we aren't grouping */</comment>
		<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>cpu_tuple_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name> <operator>||</operator> <name>aggstrategy</name> <operator>==</operator> <name>AGG_MIXED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Here we are able to deliver output on-the-fly */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name>input_startup_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name>input_total_cost</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>enable_hashagg</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* calcs phrased this way to match HASHED case, see note above */</comment>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <operator>(</operator><name>cpu_operator_cost</name> <operator>*</operator> <name>numGroupCols</name><operator>)</operator> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>finalCost</name></name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* must be AGG_HASHED */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name>input_total_cost</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_hashagg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>transCost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name>cpu_operator_cost</name> <operator>*</operator> <name>numGroupCols</name><operator>)</operator> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>aggcosts</name><operator>-&gt;</operator><name>finalCost</name></name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>numGroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If there are quals (HAVING quals), account for their cost and
	 * selectivity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>quals</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>qual_cost</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qual_cost</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name>output_tuples</name> <operator>*</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>output_tuples</name> <operator>*</operator>
									  <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name>quals</name></expr></argument>,
															 <argument><expr><literal type="number">0</literal></expr></argument>,
															 <argument><expr><name>JOIN_INNER</name></expr></argument>,
															 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>output_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_windowagg
 *		Determines and returns the cost of performing a WindowAgg plan node,
 *		including the cost of its input.
 *
 * Input is assumed already properly sorted.
 */</comment>
<function><type><name>void</name></type>
<name>cost_windowagg</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowFuncs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numPartCols</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numOrderCols</name></decl></parameter>,
			   <parameter><decl><type><name>Cost</name></type> <name>input_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_total_cost</name></decl></parameter>,
			   <parameter><decl><type><name>double</name></type> <name>input_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name>input_startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name>input_total_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Window functions are assumed to cost their stated execution cost, plus
	 * the cost of evaluating their input expressions, per tuple.  Since they
	 * may in fact evaluate their inputs at multiple rows during each cycle,
	 * this could be a drastic underestimate; but without a way to know how
	 * many rows the window function will fetch, it's hard to do better.  In
	 * any case, it's a good estimate for all the built-in window functions,
	 * so we'll just do this for now.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>windowFuncs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>wfunccost</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>argcosts</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>wfunccost</name> <operator>=</operator> <call><name>get_func_cost</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>

		<comment type="block">/* also add the input expressions' cost to per-input-row costs */</comment>
		<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argcosts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>wfunccost</name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the filter's cost to per-input-row costs.  XXX We should reduce
		 * input expression costs according to filter selectivity.
		 */</comment>
		<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argcosts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>wfunccost</name> <operator>+=</operator> <name><name>argcosts</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>wfunccost</name> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We also charge cpu_operator_cost per grouping column per tuple for
	 * grouping comparisons, plus cpu_tuple_cost per tuple for general
	 * overhead.
	 *
	 * XXX this neglects costs of spooling the data to disk when it overflows
	 * work_mem.  Sooner or later that should get accounted for.
	 */</comment>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <operator>(</operator><name>numPartCols</name> <operator>+</operator> <name>numOrderCols</name><operator>)</operator> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_tuple_cost</name> <operator>*</operator> <name>input_tuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>input_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_group
 *		Determines and returns the cost of performing a Group plan node,
 *		including the cost of its input.
 *
 * Note: caller must ensure that input costs are for appropriately-sorted
 * input.
 */</comment>
<function><type><name>void</name></type>
<name>cost_group</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>,
		   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>,
		   <parameter><decl><type><name>Cost</name></type> <name>input_startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>input_total_cost</name></decl></parameter>,
		   <parameter><decl><type><name>double</name></type> <name>input_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>output_tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>total_cost</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>startup_cost</name> <operator>=</operator> <name>input_startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_cost</name> <operator>=</operator> <name>input_total_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Charge one cpu_operator_cost per comparison per input tuple. We assume
	 * all columns get compared at most of the tuples.
	 */</comment>
	<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name>input_tuples</name> <operator>*</operator> <name>numGroupCols</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are quals (HAVING quals), account for their cost and
	 * selectivity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>quals</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>qual_cost</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qual_cost</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_cost</name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name>output_tuples</name> <operator>*</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>output_tuples</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>output_tuples</name> <operator>*</operator>
									  <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name>quals</name></expr></argument>,
															 <argument><expr><literal type="number">0</literal></expr></argument>,
															 <argument><expr><name>JOIN_INNER</name></expr></argument>,
															 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>output_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initial_cost_nestloop
 *	  Preliminary estimate of the cost of a nestloop join path.
 *
 * This must quickly produce lower-bound estimates of the path's startup and
 * total costs.  If we are unable to eliminate the proposed path from
 * consideration using the lower bounds, final_cost_nestloop will be called
 * to obtain the final estimates.
 *
 * The exact division of labor between this function and final_cost_nestloop
 * is private to them, and represents a tradeoff between speed of the initial
 * estimate and getting a tight lower bound.  We choose to not examine the
 * join quals here, since that's by far the most expensive part of the
 * calculations.  The end result is that CPU-cost considerations must be
 * left for the second phase; and for SEMI/ANTI joins, we must also postpone
 * incorporation of the inner path's run cost.
 *
 * 'workspace' is to be filled with startup_cost, total_cost, and perhaps
 *		other data to be used by final_cost_nestloop
 * 'jointype' is the type of join to be performed
 * 'outer_path' is the outer input to the join
 * 'inner_path' is the inner input to the join
 * 'extra' contains miscellaneous information about the join
 */</comment>
<function><type><name>void</name></type>
<name>initial_cost_nestloop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
					  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_path_rows</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_rescan_start_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_rescan_total_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_run_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_rescan_run_cost</name></decl>;</decl_stmt>

	<comment type="block">/* estimate costs to rescan the inner relation */</comment>
	<expr_stmt><expr><call><name>cost_rescan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>inner_rescan_start_cost</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>inner_rescan_total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cost of source data */</comment>

	<comment type="block">/*
	 * NOTE: clearly, we must pay both outer and inner paths' startup_cost
	 * before we can start returning tuples, so the join's startup cost is
	 * their sum.  We'll also pay the inner path's rescan startup cost
	 * multiple times.
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>outer_path_rows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <operator>(</operator><name>outer_path_rows</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>inner_rescan_start_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>inner_run_cost</name> <operator>=</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_rescan_run_cost</name> <operator>=</operator> <name>inner_rescan_total_cost</name> <operator>-</operator> <name>inner_rescan_start_cost</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
		<name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * With a SEMI or ANTI join, or if the innerrel is known unique, the
		 * executor will stop after the first match.
		 *
		 * Getting decent estimates requires inspection of the join quals,
		 * which we choose to postpone to final_cost_nestloop.
		 */</comment>

		<comment type="block">/* Save private data for final_cost_nestloop */</comment>
		<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_run_cost</name></name> <operator>=</operator> <name>inner_run_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_rescan_run_cost</name></name> <operator>=</operator> <name>inner_rescan_run_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal case; we'll scan whole input rel for each outer row */</comment>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>inner_run_cost</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>outer_path_rows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <operator>(</operator><name>outer_path_rows</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>inner_rescan_run_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* CPU costs left for later */</comment>

	<comment type="block">/* Public result fields */</comment>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
	<comment type="block">/* Save private data for final_cost_nestloop */</comment>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>=</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * final_cost_nestloop
 *	  Final estimate of the cost and result size of a nestloop join path.
 *
 * 'path' is already filled in except for the rows and cost fields
 * 'workspace' is the result from initial_cost_nestloop
 * 'extra' contains miscellaneous information about the join
 */</comment>
<function><type><name>void</name></type>
<name>final_cost_nestloop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					<parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outer_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>inner_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_path_rows</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>run_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>restrict_qual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name></decl>;</decl_stmt>

	<comment type="block">/* Protect some assumptions below that rowcounts aren't zero or NaN */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_path_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>outer_path_rows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_path_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_path_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>inner_path_rows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_path_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* For partial paths, scale row estimate. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We could include disable_cost in the preliminary estimate, but that
	 * would amount to optimizing for the case where the join method is
	 * disabled, which doesn't seem like the way to bet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_nestloop</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* cost of inner-relation source data (we already dealt with outer rel) */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name><name>path</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
		<name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * With a SEMI or ANTI join, or if the innerrel is known unique, the
		 * executor will stop after the first match.
		 */</comment>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_run_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_run_cost</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_rescan_run_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_rescan_run_cost</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>outer_matched_rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>outer_unmatched_rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>inner_scan_frac</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For an outer-rel row that has at least one match, we can expect the
		 * inner scan to stop after a fraction 1/(match_count+1) of the inner
		 * rows, if the matches are evenly distributed.  Since they probably
		 * aren't quite evenly distributed, we apply a fuzz factor of 2.0 to
		 * that fraction.  (If we used a larger fuzz factor, we'd have to
		 * clamp inner_scan_frac to at most 1.0; but since match_count is at
		 * least 1, no such clamp is needed now.)
		 */</comment>
		<expr_stmt><expr><name>outer_matched_rows</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>outer_path_rows</name> <operator>*</operator> <name><name>extra</name><operator>-&gt;</operator><name>semifactors</name><operator>.</operator><name>outer_match_frac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outer_unmatched_rows</name> <operator>=</operator> <name>outer_path_rows</name> <operator>-</operator> <name>outer_matched_rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_scan_frac</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>/</operator> <operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>semifactors</name><operator>.</operator><name>match_count</name></name> <operator>+</operator> <literal type="number">1.0</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute number of tuples processed (not number emitted!).  First,
		 * account for successfully-matched outer rows.
		 */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <name>outer_matched_rows</name> <operator>*</operator> <name>inner_path_rows</name> <operator>*</operator> <name>inner_scan_frac</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we need to estimate the actual costs of scanning the inner
		 * relation, which may be quite a bit less than N times inner_run_cost
		 * due to early scan stops.  We consider two cases.  If the inner path
		 * is an indexscan using all the joinquals as indexquals, then an
		 * unmatched outer row results in an indexscan returning no rows,
		 * which is probably quite cheap.  Otherwise, the executor will have
		 * to scan the whole inner rel for an unmatched row; not so cheap.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>has_indexed_join_quals</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Successfully-matched outer rows will only require scanning
			 * inner_scan_frac of the inner relation.  In this case, we don't
			 * need to charge the full inner_run_cost even when that's more
			 * than inner_rescan_run_cost, because we can assume that none of
			 * the inner scans ever scan the whole inner relation.  So it's
			 * okay to assume that all the inner scan executions can be
			 * fractions of the full cost, even if materialization is reducing
			 * the rescan cost.  At this writing, it's impossible to get here
			 * for a materialized inner scan, so inner_run_cost and
			 * inner_rescan_run_cost will be the same anyway; but just in
			 * case, use inner_run_cost for the first matched tuple and
			 * inner_rescan_run_cost for additional ones.
			 */</comment>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>inner_run_cost</name> <operator>*</operator> <name>inner_scan_frac</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>outer_matched_rows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <operator>(</operator><name>outer_matched_rows</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>inner_rescan_run_cost</name> <operator>*</operator> <name>inner_scan_frac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Add the cost of inner-scan executions for unmatched outer rows.
			 * We estimate this as the same cost as returning the first tuple
			 * of a nonempty scan.  We consider that these are all rescans,
			 * since we used inner_run_cost once already.
			 */</comment>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>outer_unmatched_rows</name> <operator>*</operator>
				<name>inner_rescan_run_cost</name> <operator>/</operator> <name>inner_path_rows</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We won't be evaluating any quals at all for unmatched rows, so
			 * don't add them to ntuples.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Here, a complicating factor is that rescans may be cheaper than
			 * first scans.  If we never scan all the way to the end of the
			 * inner rel, it might be (depending on the plan type) that we'd
			 * never pay the whole inner first-scan run cost.  However it is
			 * difficult to estimate whether that will happen (and it could
			 * not happen if there are any unmatched outer rows!), so be
			 * conservative and always charge the whole first-scan cost once.
			 * We consider this charge to correspond to the first unmatched
			 * outer row, unless there isn't one in our estimate, in which
			 * case blame it on the first matched row.
			 */</comment>

			<comment type="block">/* First, count all unmatched join tuples as being processed */</comment>
			<expr_stmt><expr><name>ntuples</name> <operator>+=</operator> <name>outer_unmatched_rows</name> <operator>*</operator> <name>inner_path_rows</name></expr>;</expr_stmt>

			<comment type="block">/* Now add the forced full scan, and decrement appropriate count */</comment>
			<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>inner_run_cost</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>outer_unmatched_rows</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>outer_unmatched_rows</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>outer_matched_rows</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Add inner run cost for additional outer tuples having matches */</comment>
			<if_stmt><if>if <condition>(<expr><name>outer_matched_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>outer_matched_rows</name> <operator>*</operator> <name>inner_rescan_run_cost</name> <operator>*</operator> <name>inner_scan_frac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Add inner run cost for additional unmatched outer tuples */</comment>
			<if_stmt><if>if <condition>(<expr><name>outer_unmatched_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>outer_unmatched_rows</name> <operator>*</operator> <name>inner_rescan_run_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal-case source costs were included in preliminary estimate */</comment>

		<comment type="block">/* Compute number of tuples processed (not number emitted!) */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <name>outer_path_rows</name> <operator>*</operator> <name>inner_path_rows</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* CPU costs */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>restrict_qual_cost</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>restrict_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>restrict_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>ntuples</name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initial_cost_mergejoin
 *	  Preliminary estimate of the cost of a mergejoin path.
 *
 * This must quickly produce lower-bound estimates of the path's startup and
 * total costs.  If we are unable to eliminate the proposed path from
 * consideration using the lower bounds, final_cost_mergejoin will be called
 * to obtain the final estimates.
 *
 * The exact division of labor between this function and final_cost_mergejoin
 * is private to them, and represents a tradeoff between speed of the initial
 * estimate and getting a tight lower bound.  We choose to not examine the
 * join quals here, except for obtaining the scan selectivity estimate which
 * is really essential (but fortunately, use of caching keeps the cost of
 * getting that down to something reasonable).
 * We also assume that cost_sort is cheap enough to use here.
 *
 * 'workspace' is to be filled with startup_cost, total_cost, and perhaps
 *		other data to be used by final_cost_mergejoin
 * 'jointype' is the type of join to be performed
 * 'mergeclauses' is the list of joinclauses to be used as merge clauses
 * 'outer_path' is the outer input to the join
 * 'inner_path' is the inner input to the join
 * 'outersortkeys' is the list of sort keys for the outer path
 * 'innersortkeys' is the list of sort keys for the inner path
 * 'extra' contains miscellaneous information about the join
 *
 * Note: outersortkeys and innersortkeys should be NIL if no explicit
 * sort is needed because the respective source path is already ordered.
 */</comment>
<function><type><name>void</name></type>
<name>initial_cost_mergejoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
					   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outersortkeys</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>innersortkeys</name></decl></parameter>,
					   <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_path_rows</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_run_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_rows</name></decl>,
				<decl><type ref="prev"/><name>inner_rows</name></decl>,
				<decl><type ref="prev"/><name>outer_skip_rows</name></decl>,
				<decl><type ref="prev"/><name>inner_skip_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>outerstartsel</name></decl>,
				<decl><type ref="prev"/><name>outerendsel</name></decl>,
				<decl><type ref="prev"/><name>innerstartsel</name></decl>,
				<decl><type ref="prev"/><name>innerendsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sort_path</name></decl>;</decl_stmt>		<comment type="block">/* dummy for result of cost_sort */</comment>

	<comment type="block">/* Protect some assumptions below that rowcounts aren't zero or NaN */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_path_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>outer_path_rows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_path_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>inner_path_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>inner_path_rows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_path_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A merge join will stop as soon as it exhausts either input stream
	 * (unless it's an outer join, in which case the outer side has to be
	 * scanned all the way anyway).  Estimate fraction of the left and right
	 * inputs that will actually need to be scanned.  Likewise, we can
	 * estimate the number of rows that will be skipped before the first join
	 * pair is found, which should be factored into startup cost. We use only
	 * the first (most significant) merge clause for this purpose. Since
	 * mergejoinscansel() is a fairly expensive computation, we cache the
	 * results in the merge clause RestrictInfo.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mergeclauses</name> <operator>&amp;&amp;</operator> <name>jointype</name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>firstclause</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opathkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ipathkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>opathkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>ipathkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MergeScanSelCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>

		<comment type="block">/* Get the input pathkeys to determine the sort-order details */</comment>
		<expr_stmt><expr><name>opathkeys</name> <operator>=</operator> <ternary><condition><expr><name>outersortkeys</name></expr> ?</condition><then> <expr><name>outersortkeys</name></expr> </then><else>: <expr><name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>ipathkeys</name> <operator>=</operator> <ternary><condition><expr><name>innersortkeys</name></expr> ?</condition><then> <expr><name>innersortkeys</name></expr> </then><else>: <expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ipathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>opathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>ipathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* debugging check */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>opathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>||</operator>
			<name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>||</operator>
			<name><name>opathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>||</operator>
			<name><name>opathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"left and right pathkeys do not match in mergejoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Get the selectivity with caching */</comment>
		<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>cached_scansel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>firstclause</name></expr></argument>, <argument><expr><name>opathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>firstclause</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
						  <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* left side of clause is outer */</comment>
			<expr_stmt><expr><name>outerstartsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>leftstartsel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>outerendsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>leftendsel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>innerstartsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>rightstartsel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>innerendsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>rightendsel</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* left side of clause is inner */</comment>
			<expr_stmt><expr><name>outerstartsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>rightstartsel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>outerendsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>rightendsel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>innerstartsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>leftstartsel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>innerendsel</name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>leftendsel</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator>
			<name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>outerstartsel</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>outerendsel</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>innerstartsel</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>innerendsel</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* cope with clauseless or full mergejoin */</comment>
		<expr_stmt><expr><name>outerstartsel</name> <operator>=</operator> <name>innerstartsel</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>outerendsel</name> <operator>=</operator> <name>innerendsel</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Convert selectivities to row counts.  We force outer_rows and
	 * inner_rows to be at least 1, but the skip_rows estimates can be zero.
	 */</comment>
	<expr_stmt><expr><name>outer_skip_rows</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>outer_path_rows</name> <operator>*</operator> <name>outerstartsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_skip_rows</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>inner_path_rows</name> <operator>*</operator> <name>innerstartsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>outer_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>outer_path_rows</name> <operator>*</operator> <name>outerendsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>inner_path_rows</name> <operator>*</operator> <name>innerendsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_skip_rows</name> <operator>&lt;=</operator> <name>outer_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_skip_rows</name> <operator>&lt;=</operator> <name>inner_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Readjust scan selectivities to account for above rounding.  This is
	 * normally an insignificant effect, but when there are only a few rows in
	 * the inputs, failing to do this makes for a large percentage error.
	 */</comment>
	<expr_stmt><expr><name>outerstartsel</name> <operator>=</operator> <name>outer_skip_rows</name> <operator>/</operator> <name>outer_path_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerstartsel</name> <operator>=</operator> <name>inner_skip_rows</name> <operator>/</operator> <name>inner_path_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outerendsel</name> <operator>=</operator> <name>outer_rows</name> <operator>/</operator> <name>outer_path_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerendsel</name> <operator>=</operator> <name>inner_rows</name> <operator>/</operator> <name>inner_path_rows</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outerstartsel</name> <operator>&lt;=</operator> <name>outerendsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>innerstartsel</name> <operator>&lt;=</operator> <name>innerendsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cost of source data */</comment>

	<if_stmt><if>if <condition>(<expr><name>outersortkeys</name></expr>)</condition>			<comment type="block">/* do we need to sort outer? */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
				  <argument><expr><name>root</name></expr></argument>,
				  <argument><expr><name>outersortkeys</name></expr></argument>,
				  <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><name>outer_path_rows</name></expr></argument>,
				  <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
				  <argument><expr><literal type="number">0.0</literal></expr></argument>,
				  <argument><expr><name>work_mem</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>-</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <name>outerstartsel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <operator>(</operator><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>-</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <operator>(</operator><name>outerendsel</name> <operator>-</operator> <name>outerstartsel</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name><name>outer_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <name>outerstartsel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <operator>(</operator><name><name>outer_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <operator>(</operator><name>outerendsel</name> <operator>-</operator> <name>outerstartsel</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>innersortkeys</name></expr>)</condition>			<comment type="block">/* do we need to sort inner? */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
				  <argument><expr><name>root</name></expr></argument>,
				  <argument><expr><name>innersortkeys</name></expr></argument>,
				  <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
				  <argument><expr><name>inner_path_rows</name></expr></argument>,
				  <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
				  <argument><expr><literal type="number">0.0</literal></expr></argument>,
				  <argument><expr><name>work_mem</name></expr></argument>,
				  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>-</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <name>innerstartsel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_run_cost</name> <operator>=</operator> <operator>(</operator><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>-</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <operator>(</operator><name>innerendsel</name> <operator>-</operator> <name>innerstartsel</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name><name>inner_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <name>innerstartsel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_run_cost</name> <operator>=</operator> <operator>(</operator><name><name>inner_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator>
			<operator>*</operator> <operator>(</operator><name>innerendsel</name> <operator>-</operator> <name>innerstartsel</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We can't yet determine whether rescanning occurs, or whether
	 * materialization of the inner input should be done.  The minimum
	 * possible inner input cost, regardless of rescan and materialization
	 * considerations, is inner_run_cost.  We include that in
	 * workspace-&gt;total_cost, but not yet in run_cost.
	 */</comment>

	<comment type="block">/* CPU costs left for later */</comment>

	<comment type="block">/* Public result fields */</comment>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name> <operator>+</operator> <name>inner_run_cost</name></expr>;</expr_stmt>
	<comment type="block">/* Save private data for final_cost_mergejoin */</comment>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>=</operator> <name>run_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_run_cost</name></name> <operator>=</operator> <name>inner_run_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>outer_rows</name></name> <operator>=</operator> <name>outer_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_rows</name></name> <operator>=</operator> <name>inner_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>outer_skip_rows</name></name> <operator>=</operator> <name>outer_skip_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_skip_rows</name></name> <operator>=</operator> <name>inner_skip_rows</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * final_cost_mergejoin
 *	  Final estimate of the cost and result size of a mergejoin path.
 *
 * Unlike other costsize functions, this routine makes two actual decisions:
 * whether the executor will need to do mark/restore, and whether we should
 * materialize the inner path.  It would be logically cleaner to build
 * separate paths testing these alternatives, but that would require repeating
 * most of the cost calculations, which are not all that cheap.  Since the
 * choice will not affect output pathkeys or startup cost, only total cost,
 * there is no possibility of wanting to keep more than one path.  So it seems
 * best to make the decisions here and record them in the path's
 * skip_mark_restore and materialize_inner fields.
 *
 * Mark/restore overhead is usually required, but can be skipped if we know
 * that the executor need find only one match per outer tuple, and that the
 * mergeclauses are sufficient to identify a match.
 *
 * We materialize the inner path if we need mark/restore and either the inner
 * path can't support mark/restore, or it's cheaper to use an interposed
 * Material node to handle mark/restore.
 *
 * 'path' is already filled in except for the rows and cost fields and
 *		skip_mark_restore and materialize_inner
 * 'workspace' is the result from initial_cost_mergejoin
 * 'extra' contains miscellaneous information about the join
 */</comment>
<function><type><name>void</name></type>
<name>final_cost_mergejoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					 <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outer_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>inner_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeclauses</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>innersortkeys</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>run_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>inner_run_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_run_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_rows</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>outer_rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_rows</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_skip_rows</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>outer_skip_rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_skip_rows</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_skip_rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>,
				<decl><type ref="prev"/><name>bare_inner_cost</name></decl>,
				<decl><type ref="prev"/><name>mat_inner_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>merge_qual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qp_qual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>mergejointuples</name></decl>,
				<decl><type ref="prev"/><name>rescannedtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rescanratio</name></decl>;</decl_stmt>

	<comment type="block">/* Protect some assumptions below that rowcounts aren't zero or NaN */</comment>
	<if_stmt><if>if <condition>(<expr><name>inner_path_rows</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>inner_path_rows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_path_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* For partial paths, scale row estimate. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We could include disable_cost in the preliminary estimate, but that
	 * would amount to optimizing for the case where the join method is
	 * disabled, which doesn't seem like the way to bet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_mergejoin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute cost of the mergequals and qpquals (other restriction clauses)
	 * separately.
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge_qual_cost</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qp_qual_cost</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qp_qual_cost</name><operator>.</operator><name>startup</name></name> <operator>-=</operator> <name><name>merge_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qp_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-=</operator> <name><name>merge_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * With a SEMI or ANTI join, or if the innerrel is known unique, the
	 * executor will stop scanning for matches after the first match.  When
	 * all the joinclauses are merge clauses, this means we don't ever need to
	 * back up the merge, and so we can skip mark/restore overhead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
		 <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
		 <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
		 <call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>skip_mark_restore</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>skip_mark_restore</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Get approx # tuples passing the mergequals.  We use approx_tuple_count
	 * here because we need an estimate done with JOIN_INNER semantics.
	 */</comment>
	<expr_stmt><expr><name>mergejointuples</name> <operator>=</operator> <call><name>approx_tuple_count</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>jpath</name></name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When there are equal merge keys in the outer relation, the mergejoin
	 * must rescan any matching tuples in the inner relation. This means
	 * re-fetching inner tuples; we have to estimate how often that happens.
	 *
	 * For regular inner and outer joins, the number of re-fetches can be
	 * estimated approximately as size of merge join output minus size of
	 * inner relation. Assume that the distinct key values are 1, 2, ..., and
	 * denote the number of values of each key in the outer relation as m1,
	 * m2, ...; in the inner relation, n1, n2, ...  Then we have
	 *
	 * size of join = m1 * n1 + m2 * n2 + ...
	 *
	 * number of rescanned tuples = (m1 - 1) * n1 + (m2 - 1) * n2 + ... = m1 *
	 * n1 + m2 * n2 + ... - (n1 + n2 + ...) = size of join - size of inner
	 * relation
	 *
	 * This equation works correctly for outer tuples having no inner match
	 * (nk = 0), but not for inner tuples having no outer match (mk = 0); we
	 * are effectively subtracting those from the number of rescanned tuples,
	 * when we should not.  Can we do better without expensive selectivity
	 * computations?
	 *
	 * The whole issue is moot if we are working from a unique-ified outer
	 * input, or if we know we don't need to mark/restore at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call> <operator>||</operator><name><name>path</name><operator>-&gt;</operator><name>skip_mark_restore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rescannedtuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rescannedtuples</name> <operator>=</operator> <name>mergejointuples</name> <operator>-</operator> <name>inner_path_rows</name></expr>;</expr_stmt>
		<comment type="block">/* Must clamp because of possible underestimate */</comment>
		<if_stmt><if>if <condition>(<expr><name>rescannedtuples</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rescannedtuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We'll inflate various costs this much to account for rescanning.  Note
	 * that this is to be multiplied by something involving inner_rows, or
	 * another number related to the portion of the inner rel we'll scan.
	 */</comment>
	<expr_stmt><expr><name>rescanratio</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>+</operator> <operator>(</operator><name>rescannedtuples</name> <operator>/</operator> <name>inner_rows</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decide whether we want to materialize the inner input to shield it from
	 * mark/restore and performing re-fetches.  Our cost model for regular
	 * re-fetches is that a re-fetch costs the same as an original fetch,
	 * which is probably an overestimate; but on the other hand we ignore the
	 * bookkeeping costs of mark/restore.  Not clear if it's worth developing
	 * a more refined model.  So we just need to inflate the inner run cost by
	 * rescanratio.
	 */</comment>
	<expr_stmt><expr><name>bare_inner_cost</name> <operator>=</operator> <name>inner_run_cost</name> <operator>*</operator> <name>rescanratio</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When we interpose a Material node the re-fetch cost is assumed to be
	 * just cpu_operator_cost per tuple, independently of the underlying
	 * plan's cost; and we charge an extra cpu_operator_cost per original
	 * fetch as well.  Note that we're assuming the materialize node will
	 * never spill to disk, since it only has to remember tuples back to the
	 * last mark.  (If there are a huge number of duplicates, our other cost
	 * factors will make the path so expensive that it probably won't get
	 * chosen anyway.)	So we don't use cost_rescan here.
	 *
	 * Note: keep this estimate in sync with create_mergejoin_plan's labeling
	 * of the generated Material node.
	 */</comment>
	<expr_stmt><expr><name>mat_inner_cost</name> <operator>=</operator> <name>inner_run_cost</name> <operator>+</operator>
		<name>cpu_operator_cost</name> <operator>*</operator> <name>inner_rows</name> <operator>*</operator> <name>rescanratio</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we don't need mark/restore at all, we don't need materialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>skip_mark_restore</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>materialize_inner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * Prefer materializing if it looks cheaper, unless the user has asked to
	 * suppress materialization.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>enable_material</name> <operator>&amp;&amp;</operator> <name>mat_inner_cost</name> <operator>&lt;</operator> <name>bare_inner_cost</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>materialize_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * Even if materializing doesn't look cheaper, we *must* do it if the
	 * inner path is to be used directly (without sorting) and it doesn't
	 * support mark/restore.
	 *
	 * Since the inner side must be ordered, and only Sorts and IndexScans can
	 * create order to begin with, and they both support mark/restore, you
	 * might think there's no problem --- but you'd be wrong.  Nestloop and
	 * merge joins can *preserve* the order of their inputs, so they can be
	 * selected as the input of a mergejoin, and they don't support
	 * mark/restore at present.
	 *
	 * We don't test the value of enable_material here, because
	 * materialization is required for correctness in this case, and turning
	 * it off does not entitle us to deliver an invalid plan.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>innersortkeys</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>ExecSupportsMarkRestore</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>materialize_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/*
	 * Also, force materializing if the inner path is to be sorted and the
	 * sort is expected to spill to disk.  This is because the final merge
	 * pass can be done on-the-fly if it doesn't have to support mark/restore.
	 * We don't try to adjust the cost estimates for this consideration,
	 * though.
	 *
	 * Since materialization is a performance optimization in this case,
	 * rather than necessary for correctness, we skip it if enable_material is
	 * off.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>enable_material</name> <operator>&amp;&amp;</operator> <name>innersortkeys</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			 <call><name>relation_byte_size</name><argument_list>(<argument><expr><name>inner_path_rows</name></expr></argument>,
								<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
			 <operator>(</operator><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>materialize_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>materialize_inner</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Charge the right incremental cost for the chosen case */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>materialize_inner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>mat_inner_cost</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>bare_inner_cost</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* CPU costs */</comment>

	<comment type="block">/*
	 * The number of tuple comparisons needed is approximately number of outer
	 * rows plus number of inner rows plus number of rescanned tuples (can we
	 * refine this?).  At each one, we need to evaluate the mergejoin quals.
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>merge_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>merge_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator>
		<operator>(</operator><name>outer_skip_rows</name> <operator>+</operator> <name>inner_skip_rows</name> <operator>*</operator> <name>rescanratio</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>merge_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator>
		<operator>(</operator><operator>(</operator><name>outer_rows</name> <operator>-</operator> <name>outer_skip_rows</name><operator>)</operator> <operator>+</operator>
		 <operator>(</operator><name>inner_rows</name> <operator>-</operator> <name>inner_skip_rows</name><operator>)</operator> <operator>*</operator> <name>rescanratio</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each tuple that gets through the mergejoin proper, we charge
	 * cpu_tuple_cost plus the cost of evaluating additional restriction
	 * clauses that are to be applied at the join.  (This is pessimistic since
	 * not all of the quals may get evaluated at each tuple.)
	 *
	 * Note: we could adjust for SEMI/ANTI joins skipping some qual
	 * evaluations here, but it's probably not worth the trouble.
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qp_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qp_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>mergejointuples</name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * run mergejoinscansel() with caching
 */</comment>
<function><type><specifier>static</specifier> <name>MergeScanSelCache</name> <modifier>*</modifier></type>
<name>cached_scansel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>PathKey</name> <modifier>*</modifier></type><name>pathkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MergeScanSelCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>leftstartsel</name></decl>,
				<decl><type ref="prev"/><name>leftendsel</name></decl>,
				<decl><type ref="prev"/><name>rightstartsel</name></decl>,
				<decl><type ref="prev"/><name>rightendsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Do we have this result already? */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rinfo-&gt;scansel_cache</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>cache</name> <operator>=</operator> <operator>(</operator><name>MergeScanSelCache</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>opfamily</name></name> <operator>==</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>&amp;&amp;</operator>
			<name><name>cache</name><operator>-&gt;</operator><name>collation</name></name> <operator>==</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>&amp;&amp;</operator>
			<name><name>cache</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>&amp;&amp;</operator>
			<name><name>cache</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>==</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cache</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Nope, do the computation */</comment>
	<expr_stmt><expr><call><name>mergejoinscansel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>,
					 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
					 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>,
					 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>leftstartsel</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>leftendsel</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>rightstartsel</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>rightendsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cache the result in suitably long-lived workspace */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cache</name> <operator>=</operator> <operator>(</operator><name>MergeScanSelCache</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MergeScanSelCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>opfamily</name></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>leftstartsel</name></name> <operator>=</operator> <name>leftstartsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>leftendsel</name></name> <operator>=</operator> <name>leftendsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>rightstartsel</name></name> <operator>=</operator> <name>rightstartsel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>rightendsel</name></name> <operator>=</operator> <name>rightendsel</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>scansel_cache</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>scansel_cache</name></name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * initial_cost_hashjoin
 *	  Preliminary estimate of the cost of a hashjoin path.
 *
 * This must quickly produce lower-bound estimates of the path's startup and
 * total costs.  If we are unable to eliminate the proposed path from
 * consideration using the lower bounds, final_cost_hashjoin will be called
 * to obtain the final estimates.
 *
 * The exact division of labor between this function and final_cost_hashjoin
 * is private to them, and represents a tradeoff between speed of the initial
 * estimate and getting a tight lower bound.  We choose to not examine the
 * join quals here (other than by counting the number of hash clauses),
 * so we can't do much with CPU costs.  We do assume that
 * ExecChooseHashTableSize is cheap enough to use here.
 *
 * 'workspace' is to be filled with startup_cost, total_cost, and perhaps
 *		other data to be used by final_cost_hashjoin
 * 'jointype' is the type of join to be performed
 * 'hashclauses' is the list of joinclauses to be used as hash clauses
 * 'outer_path' is the outer input to the join
 * 'inner_path' is the inner input to the join
 * 'extra' contains miscellaneous information about the join
 * 'parallel_hash' indicates that inner_path is partial and that a shared
 *		hash table will be built in parallel
 */</comment>
<function><type><name>void</name></type>
<name>initial_cost_hashjoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
					  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>parallel_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_path_rows</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows_total</name> <init>= <expr><name>inner_path_rows</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_hashclauses</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numbatches</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_skew_mcvs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>space_allowed</name></decl>;</decl_stmt>	<comment type="block">/* unused */</comment>

	<comment type="block">/* cost of source data */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cost of computing hash function: must do it once per input tuple. We
	 * charge one cpu_operator_cost for each column's hash function.  Also,
	 * tack on one cpu_tuple_cost per inner row, to model the costs of
	 * inserting the row into the hashtable.
	 *
	 * XXX when a hashclause is more complex than a single operator, we really
	 * should charge the extra eval costs of the left or right side, as
	 * appropriate, here.  This seems more work than it's worth at the moment.
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <operator>(</operator><name>cpu_operator_cost</name> <operator>*</operator> <name>num_hashclauses</name> <operator>+</operator> <name>cpu_tuple_cost</name><operator>)</operator>
		<operator>*</operator> <name>inner_path_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name>num_hashclauses</name> <operator>*</operator> <name>outer_path_rows</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a parallel hash build, then the value we have for
	 * inner_rows_total currently refers only to the rows returned by each
	 * participant.  For shared hash table size estimation, we need the total
	 * number, so we need to undo the division.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_path_rows_total</name> <operator>*=</operator> <call><name>get_parallel_divisor</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get hash table size that executor would use for inner relation.
	 *
	 * XXX for the moment, always assume that skew optimization will be
	 * performed.  As long as SKEW_WORK_MEM_PERCENT is small, it's not worth
	 * trying to determine that for sure.
	 *
	 * XXX at some point it might be interesting to try to account for skew
	 * optimization in the cost estimate, but for now, we don't.
	 */</comment>
	<expr_stmt><expr><call><name>ExecChooseHashTableSize</name><argument_list>(<argument><expr><name>inner_path_rows_total</name></expr></argument>,
							<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* useskew */</comment>
							<argument><expr><name>parallel_hash</name></expr></argument>,	<comment type="block">/* try_combined_work_mem */</comment>
							<argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>space_allowed</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>numbuckets</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>numbatches</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>num_skew_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If inner relation is too big then we will need to "batch" the join,
	 * which implies writing and reading most of the tuples to disk an extra
	 * time.  Charge seq_page_cost per page, since the I/O should be nice and
	 * sequential.  Writing the inner rel counts as startup cost, all the rest
	 * as run cost.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numbatches</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>outerpages</name> <init>= <expr><call><name>page_size</name><argument_list>(<argument><expr><name>outer_path_rows</name></expr></argument>,
										   <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>innerpages</name> <init>= <expr><call><name>page_size</name><argument_list>(<argument><expr><name>inner_path_rows</name></expr></argument>,
										   <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>innerpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <operator>(</operator><name>innerpages</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>outerpages</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* CPU costs left for later */</comment>

	<comment type="block">/* Public result fields */</comment>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
	<comment type="block">/* Save private data for final_cost_hashjoin */</comment>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>run_cost</name></name> <operator>=</operator> <name>run_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>numbuckets</name></name> <operator>=</operator> <name>numbuckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>numbatches</name></name> <operator>=</operator> <name>numbatches</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_rows_total</name></name> <operator>=</operator> <name>inner_path_rows_total</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * final_cost_hashjoin
 *	  Final estimate of the cost and result size of a hashjoin path.
 *
 * Note: the numbatches estimate is also saved into 'path' for use later
 *
 * 'path' is already filled in except for the rows and cost fields and
 *		num_batches
 * 'workspace' is the result from initial_cost_hashjoin
 * 'extra' contains miscellaneous information about the join
 */</comment>
<function><type><name>void</name></type>
<name>final_cost_hashjoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					<parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
					<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outer_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>inner_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_path_rows</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_path_rows_total</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>inner_rows_total</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashclauses</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>startup_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>run_cost</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numbuckets</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>numbuckets</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numbatches</name> <init>= <expr><name><name>workspace</name><operator>-&gt;</operator><name>numbatches</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cpu_per_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>hash_qual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>qp_qual_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>hashjointuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>virtualbuckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>innerbucketsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>innermcvfreq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>hcl</name></decl>;</decl_stmt>

	<comment type="block">/* Mark the path with the correct row estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* For partial paths, scale row estimate. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><call><name>get_parallel_divisor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>/</operator> <name>parallel_divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We could include disable_cost in the preliminary estimate, but that
	 * would amount to optimizing for the case where the join method is
	 * disabled, which doesn't seem like the way to bet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_hashjoin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* mark the path with estimated # of batches */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>num_batches</name></name> <operator>=</operator> <name>numbatches</name></expr>;</expr_stmt>

	<comment type="block">/* store the total number of tuples (sum of partial row estimates) */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>inner_rows_total</name></name> <operator>=</operator> <name>inner_path_rows_total</name></expr>;</expr_stmt>

	<comment type="block">/* and compute the number of "virtual" buckets in the whole join */</comment>
	<expr_stmt><expr><name>virtualbuckets</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numbuckets</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numbatches</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine bucketsize fraction and MCV frequency for the inner relation.
	 * We use the smallest bucketsize or MCV frequency estimated for any
	 * individual hashclause; this is undoubtedly conservative.
	 *
	 * BUT: if inner relation has been unique-ified, we can assume it's good
	 * for hashing.  This is important both because it's the right answer, and
	 * because we avoid contaminating the cache with a value that's wrong for
	 * non-unique-ified paths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>innerbucketsize</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>virtualbuckets</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>innermcvfreq</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>innerbucketsize</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>innermcvfreq</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>hcl</argument>, <argument>hashclauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>hcl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Selectivity</name></type> <name>thisbucketsize</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Selectivity</name></type> <name>thismcvfreq</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * First we have to figure out which side of the hashjoin clause
			 * is the inner side.
			 *
			 * Since we tend to visit the same clauses over and over when
			 * planning a large query, we cache the bucket stats estimates in
			 * the RestrictInfo node to avoid repeated lookups of statistics.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>,
							  <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* righthand side is inner */</comment>
				<expr_stmt><expr><name>thisbucketsize</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>thisbucketsize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* not cached yet */</comment>
					<expr_stmt><expr><call><name>estimate_hash_bucket_stats</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><call><name>get_rightop</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>virtualbuckets</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_mcvfreq</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>thisbucketsize</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>thismcvfreq</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>right_mcvfreq</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
									 <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* lefthand side is inner */</comment>
				<expr_stmt><expr><name>thisbucketsize</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>thisbucketsize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* not cached yet */</comment>
					<expr_stmt><expr><call><name>estimate_hash_bucket_stats</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><call><name>get_leftop</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>virtualbuckets</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_mcvfreq</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>thisbucketsize</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>thismcvfreq</name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>left_mcvfreq</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>innerbucketsize</name> <operator>&gt;</operator> <name>thisbucketsize</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>innerbucketsize</name> <operator>=</operator> <name>thisbucketsize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>innermcvfreq</name> <operator>&gt;</operator> <name>thismcvfreq</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>innermcvfreq</name> <operator>=</operator> <name>thismcvfreq</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the bucket holding the inner MCV would exceed work_mem, we don't
	 * want to hash unless there is really no other alternative, so apply
	 * disable_cost.  (The executor normally copes with excessive memory usage
	 * by splitting batches, but obviously it cannot separate equal values
	 * that way, so it will be unable to drive the batch size below work_mem
	 * when this is true.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>relation_byte_size</name><argument_list>(<argument><expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>inner_path_rows</name> <operator>*</operator> <name>innermcvfreq</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
		<operator>(</operator><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute cost of the hashquals and qpquals (other restriction clauses)
	 * separately.
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_qual_cost</name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qp_qual_cost</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qp_qual_cost</name><operator>.</operator><name>startup</name></name> <operator>-=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>qp_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/* CPU costs */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
		<name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator>
		<name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>outer_matched_rows</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>inner_scan_frac</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * With a SEMI or ANTI join, or if the innerrel is known unique, the
		 * executor will stop after the first match.
		 *
		 * For an outer-rel row that has at least one match, we can expect the
		 * bucket scan to stop after a fraction 1/(match_count+1) of the
		 * bucket's rows, if the matches are evenly distributed.  Since they
		 * probably aren't quite evenly distributed, we apply a fuzz factor of
		 * 2.0 to that fraction.  (If we used a larger fuzz factor, we'd have
		 * to clamp inner_scan_frac to at most 1.0; but since match_count is
		 * at least 1, no such clamp is needed now.)
		 */</comment>
		<expr_stmt><expr><name>outer_matched_rows</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>outer_path_rows</name> <operator>*</operator> <name><name>extra</name><operator>-&gt;</operator><name>semifactors</name><operator>.</operator><name>outer_match_frac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_scan_frac</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>/</operator> <operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>semifactors</name><operator>.</operator><name>match_count</name></name> <operator>+</operator> <literal type="number">1.0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>outer_matched_rows</name> <operator>*</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name>inner_path_rows</name> <operator>*</operator> <name>innerbucketsize</name> <operator>*</operator> <name>inner_scan_frac</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * For unmatched outer-rel rows, the picture is quite a lot different.
		 * In the first place, there is no reason to assume that these rows
		 * preferentially hit heavily-populated buckets; instead assume they
		 * are uncorrelated with the inner distribution and so they see an
		 * average bucket size of inner_path_rows / virtualbuckets.  In the
		 * second place, it seems likely that they will have few if any exact
		 * hash-code matches and so very few of the tuples in the bucket will
		 * actually require eval of the hash quals.  We don't have any good
		 * way to estimate how many will, but for the moment assume that the
		 * effective cost per bucket entry is one-tenth what it is for
		 * matchable tuples.
		 */</comment>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator>
			<operator>(</operator><name>outer_path_rows</name> <operator>-</operator> <name>outer_matched_rows</name><operator>)</operator> <operator>*</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name>inner_path_rows</name> <operator>/</operator> <name>virtualbuckets</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">0.05</literal></expr>;</expr_stmt>

		<comment type="block">/* Get # of tuples that will pass the basic join */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hashjointuples</name> <operator>=</operator> <name>outer_path_rows</name> <operator>-</operator> <name>outer_matched_rows</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hashjointuples</name> <operator>=</operator> <name>outer_matched_rows</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The number of tuple comparisons needed is the number of outer
		 * tuples times the typical number of tuples in a hash bucket, which
		 * is the inner relation size times its bucketsize fraction.  At each
		 * one, we need to evaluate the hashjoin quals.  But actually,
		 * charging the full qual eval cost at each tuple is pessimistic,
		 * since we don't evaluate the quals unless the hash values match
		 * exactly.  For lack of a better idea, halve the cost estimate to
		 * allow for that.
		 */</comment>
		<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>hash_qual_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name>outer_path_rows</name> <operator>*</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name>inner_path_rows</name> <operator>*</operator> <name>innerbucketsize</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get approx # tuples passing the hashquals.  We use
		 * approx_tuple_count here because we need an estimate done with
		 * JOIN_INNER semantics.
		 */</comment>
		<expr_stmt><expr><name>hashjointuples</name> <operator>=</operator> <call><name>approx_tuple_count</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>path</name><operator>-&gt;</operator><name>jpath</name></name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * For each tuple that gets through the hashjoin proper, we charge
	 * cpu_tuple_cost plus the cost of evaluating additional restriction
	 * clauses that are to be applied at the join.  (This is pessimistic since
	 * not all of the quals may get evaluated at each tuple.)
	 */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>qp_qual_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu_per_tuple</name> <operator>=</operator> <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>qp_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>cpu_per_tuple</name> <operator>*</operator> <name>hashjointuples</name></expr>;</expr_stmt>

	<comment type="block">/* tlist eval costs are paid per output row, not per tuple scanned */</comment>
	<expr_stmt><expr><name>startup_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>startup_cost</name> <operator>+</operator> <name>run_cost</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * cost_subplan
 *		Figure the costs for a SubPlan (or initplan).
 *
 * Note: we could dig the subplan's Plan out of the root list, but in practice
 * all callers have it handy already, so we make them pass it.
 */</comment>
<function><type><name>void</name></type>
<name>cost_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>sp_cost</name></decl>;</decl_stmt>

	<comment type="block">/* Figure any cost for evaluating the testexpr */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sp_cost</name></expr></argument>,
				   <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are using a hash table for the subquery outputs, then the
		 * cost of evaluating the query is a one-time cost.  We charge one
		 * cpu_operator_cost per tuple for the work of loading the hashtable,
		 * too.
		 */</comment>
		<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
			<name>cpu_operator_cost</name> <operator>*</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The per-tuple costs include the cost of evaluating the lefthand
		 * expressions, plus the cost of probing the hashtable.  We already
		 * accounted for the lefthand expressions as part of the testexpr, and
		 * will also have counted one cpu_operator_cost for each comparison
		 * operator.  That is probably too low for the probing cost, but it's
		 * hard to make a better estimate, so live with it for now.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise we will be rescanning the subplan output on each
		 * evaluation.  We need to estimate how much of the output we will
		 * actually need to scan.  NOTE: this logic should agree with the
		 * tuple_fraction estimates used by make_subplan() in
		 * plan/subselect.c.
		 */</comment>
		<decl_stmt><decl><type><name>Cost</name></type>		<name>plan_run_cost</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we only need to fetch 1 tuple; clamp to avoid zero divide */</comment>
			<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name>plan_run_cost</name> <operator>/</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ALL_SUBLINK</name> <operator>||</operator>
				 <name><name>subplan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* assume we need 50% of the tuples */</comment>
			<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <literal type="number">0.50</literal> <operator>*</operator> <name>plan_run_cost</name></expr>;</expr_stmt>
			<comment type="block">/* also charge a cpu_operator_cost per row examined */</comment>
			<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <literal type="number">0.50</literal> <operator>*</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* assume we need all tuples */</comment>
			<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name>plan_run_cost</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Also account for subplan's startup cost. If the subplan is
		 * uncorrelated or undirect correlated, AND its topmost node is one
		 * that materializes its output, assume that we'll only need to pay
		 * its startup cost once; otherwise assume we pay the startup cost
		 * every time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>ExecMaterializesOutput</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sp_cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sp_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>per_call_cost</name></name> <operator>=</operator> <name><name>sp_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * cost_rescan
 *		Given a finished Path, estimate the costs of rescanning it after
 *		having done so the first time.  For some Path types a rescan is
 *		cheaper than an original scan (if no parameters change), and this
 *		function embodies knowledge about that.  The default is to return
 *		the same costs stored in the Path.  (Note that the cost estimates
 *		actually stored in Paths are always for first scans.)
 *
 * This function is not currently intended to model effects such as rescans
 * being cheaper due to disk block caching; what we are concerned with is
 * plan types wherein the executor caches results explicitly, or doesn't
 * redo startup calculations, etc.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cost_rescan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
			<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>rescan_startup_cost</name></decl></parameter>,	<comment type="block">/* output parameters */</comment>
			<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>rescan_total_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>

			<comment type="block">/*
			 * Currently, nodeFunctionscan.c always executes the function to
			 * completion before returning any rows, and caches the results in
			 * a tuplestore.  So the function eval cost is all startup cost
			 * and isn't paid over again on rescans. However, all run costs
			 * will be paid over again.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>rescan_startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rescan_total_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>

			<comment type="block">/*
			 * If it's a single-batch join, we don't need to rebuild the hash
			 * table during a rescan.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>HashPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>num_batches</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Startup cost is exactly the cost of hash table building */</comment>
				<expr_stmt><expr><operator>*</operator><name>rescan_startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rescan_total_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Otherwise, no special treatment */</comment>
				<expr_stmt><expr><operator>*</operator><name>rescan_startup_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rescan_total_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CteScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * These plan types materialize their final result in a
				 * tuplestore or tuplesort object.  So the rescan cost is only
				 * cpu_tuple_cost per tuple, unless the result is large enough
				 * to spill to disk.
				 */</comment>
				<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><name>cpu_tuple_cost</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>nbytes</name> <init>= <expr><call><name>relation_byte_size</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
														<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type>		<name>work_mem_bytes</name> <init>= <expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <name>work_mem_bytes</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* It will spill, so account for re-read cost */</comment>
					<decl_stmt><decl><type><name>double</name></type>		<name>npages</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>nbytes</name> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>npages</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>rescan_startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rescan_total_cost</name> <operator>=</operator> <name>run_cost</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * These plan types not only materialize their results, but do
				 * not implement qual filtering or projection.  So they are
				 * even cheaper to rescan than the ones above.  We charge only
				 * cpu_operator_cost per tuple.  (Note: keep that in sync with
				 * the run_cost charge in cost_sort, and also see comments in
				 * cost_material before you change it.)
				 */</comment>
				<decl_stmt><decl><type><name>Cost</name></type>		<name>run_cost</name> <init>= <expr><name>cpu_operator_cost</name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>nbytes</name> <init>= <expr><call><name>relation_byte_size</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
														<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type>		<name>work_mem_bytes</name> <init>= <expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <name>work_mem_bytes</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* It will spill, so account for re-read cost */</comment>
					<decl_stmt><decl><type><name>double</name></type>		<name>npages</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>nbytes</name> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>run_cost</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>npages</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>rescan_startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rescan_total_cost</name> <operator>=</operator> <name>run_cost</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><operator>*</operator><name>rescan_startup_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rescan_total_cost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * cost_qual_eval
 *		Estimate the CPU costs of evaluating a WHERE clause.
 *		The input can be either an implicitly-ANDed list of boolean
 *		expressions, or a list of RestrictInfo nodes.  (The latter is
 *		preferred since it allows caching of the results.)
 *		The result includes both a one-time (startup) component,
 *		and a per-evaluation component.
 */</comment>
<function><type><name>void</name></type>
<name>cost_qual_eval</name><parameter_list>(<parameter><decl><type><name>QualCost</name> <modifier>*</modifier></type><name>cost</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>cost_qual_eval_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* We don't charge any cost for the implicit ANDing at top level ... */</comment>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval_walker</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>total</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cost_qual_eval_node
 *		As above, for a single RestrictInfo or expression.
 */</comment>
<function><type><name>void</name></type>
<name>cost_qual_eval_node</name><parameter_list>(<parameter><decl><type><name>QualCost</name> <modifier>*</modifier></type><name>cost</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>cost_qual_eval_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_qual_eval_walker</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>total</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cost_qual_eval_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>cost_qual_eval_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * RestrictInfo nodes contain an eval_cost field reserved for this
	 * routine's use, so that it's not necessary to evaluate the qual clause's
	 * cost more than once.  If the clause's cost hasn't been computed yet,
	 * the field's startup value will contain -1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>startup</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>cost_qual_eval_context</name></type> <name>locContext</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * For an OR clause, recurse into the marked-up tree so that we
			 * set the eval_cost for contained RestrictInfos too.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>cost_qual_eval_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>orclause</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>cost_qual_eval_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * If the RestrictInfo is marked pseudoconstant, it will be tested
			 * only once, so treat its cost as all startup cost.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* count one execution during startup */</comment>
				<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>locContext</name><operator>.</operator><name>total</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>eval_cost</name></name> <operator>=</operator> <name><name>locContext</name><operator>.</operator><name>total</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		<comment type="block">/* do NOT recurse into children */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For each operator or function node in the given tree, we charge the
	 * estimated execution cost given by pg_proc.procost (remember to multiply
	 * this by cpu_operator_cost).
	 *
	 * Vars and Consts are charged zero, and so are boolean operators (AND,
	 * OR, NOT). Simplistic, but a lot better than no model at all.
	 *
	 * Should we try to account for the possibility of short-circuit
	 * evaluation of AND/OR?  Probably *not*, because that would make the
	 * results depend on the clause ordering, and we are not in any position
	 * to expect that the current ordering of the clauses is the one that's
	 * going to end up being used.  The above per-RestrictInfo caching would
	 * not mix well with trying to re-order clauses anyway.
	 *
	 * Another issue that is entirely ignored here is that if a set-returning
	 * function is below top level in the tree, the functions/operators above
	 * it will need to be evaluated multiple times.  In practical use, such
	 * cases arise so seldom as to not be worth the added complexity needed;
	 * moreover, since our rowcount estimates for functions tend to be pretty
	 * phony, the results would also be pretty phony.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator>
			<call><name>get_func_cost</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* rely on struct equivalence to treat these all alike */</comment>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator>
			<call><name>get_func_cost</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>opfuncid</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Estimate that the operator will be applied to about half of the
		 * array elements before the answer is determined.
		 */</comment>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arraynode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>set_sa_opfuncid</name><argument_list>(<argument><expr><name>saop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <call><name>get_func_cost</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call> <operator>*</operator>
			<name>cpu_operator_cost</name> <operator>*</operator> <call><name>estimate_array_length</name><argument_list>(<argument><expr><name>arraynode</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Aggref and WindowFunc nodes are (and should be) treated like Vars,
		 * ie, zero execution cost in the current model, because they behave
		 * essentially like Vars at execution.  We disregard the costs of
		 * their input expressions for the same reason.  The actual execution
		 * costs of the aggregate/window functions and their arguments have to
		 * be factored into plan-node-specific costing of the Agg or WindowAgg
		 * plan node.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* don't recurse into children */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>iofunc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

		<comment type="block">/* check the result type's input function */</comment>
		<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <call><name>get_func_cost</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
		<comment type="block">/* check the input type's output function */</comment>
		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <call><name>get_func_cost</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>perelemcost</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>perelemcost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>perelemcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>perelemcost</name><operator>.</operator><name>per_tuple</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>perelemcost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator>
				<call><name>estimate_array_length</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Conservatively assume we will check all the columns */</comment>
		<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rcexpr-&gt;opnos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <call><name>get_func_cost</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator>
				<name>cpu_operator_cost</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Treat all these as having cost 1 */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Report high cost to prevent selection of anything but TID scan */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name>disable_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This routine should not be applied to un-planned expressions */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot handle unplanned sub-select"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A subplan node in an expression typically indicates that the
		 * subplan will be executed on each evaluation, so charge accordingly.
		 * (Sub-selects that can be executed as InitPlans have already been
		 * removed from the expression.)
		 */</comment>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>total</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>per_call_cost</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't want to recurse into the testexpr, because it was already
		 * counted in the SubPlan node's costs.  So we're done.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Arbitrarily use the first alternative plan for costing.  (We should
		 * certainly only include one alternative, and we don't yet have
		 * enough information to know which one the executor is most likely to
		 * use.)
		 */</comment>
		<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>cost_qual_eval_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A PlaceHolderVar should be given cost zero when considering general
		 * expression evaluation costs.  The expense of doing the contained
		 * expression is charged as part of the tlist eval costs of the scan
		 * or join where the PHV is first computed (see set_rel_width and
		 * add_placeholders_to_joinrel).  If we charged it again here, we'd be
		 * double-counting the cost for each level of plan that the PHV
		 * bubbles up through.  Hence, return without recursing into the
		 * phexpr.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* recurse into children */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cost_qual_eval_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_restriction_qual_cost
 *	  Compute evaluation costs of a baserel's restriction quals, plus any
 *	  movable join quals that have been pushed down to the scan.
 *	  Results are returned into *qpqual_cost.
 *
 * This is a convenience subroutine that works for seqscans and other cases
 * where all the given quals will be evaluated the hard way.  It's not useful
 * for cost_index(), for example, where the index machinery takes care of
 * some of the quals.  We assume baserestrictcost was previously set by
 * set_baserel_size_estimates().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_restriction_qual_cost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						  <parameter><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>param_info</name></decl></parameter>,
						  <parameter><decl><type><name>QualCost</name> <modifier>*</modifier></type><name>qpqual_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>param_info</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Include costs of pushed-down clauses */</comment>
		<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><name>qpqual_cost</name></expr></argument>, <argument><expr><name><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>qpqual_cost</name><operator>-&gt;</operator><name>startup</name></name> <operator>+=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qpqual_cost</name><operator>-&gt;</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>qpqual_cost</name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * compute_semi_anti_join_factors
 *	  Estimate how much of the inner input a SEMI, ANTI, or inner_unique join
 *	  can be expected to scan.
 *
 * In a hash or nestloop SEMI/ANTI join, the executor will stop scanning
 * inner rows as soon as it finds a match to the current outer row.
 * The same happens if we have detected the inner rel is unique.
 * We should therefore adjust some of the cost components for this effect.
 * This function computes some estimates needed for these adjustments.
 * These estimates will be the same regardless of the particular paths used
 * for the outer and inner relation, so we compute these once and then pass
 * them to all the join cost estimation functions.
 *
 * Input parameters:
 *	joinrel: join relation under consideration
 *	outerrel: outer relation under consideration
 *	innerrel: inner relation under consideration
 *	jointype: if not JOIN_SEMI or JOIN_ANTI, we assume it's inner_unique
 *	sjinfo: SpecialJoinInfo relevant to this join
 *	restrictlist: join quals
 * Output parameters:
 *	*semifactors is filled in (see relation.h for field definitions)
 */</comment>
<function><type><name>void</name></type>
<name>compute_semi_anti_join_factors</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>,
							   <parameter><decl><type><name>SemiAntiJoinFactors</name> <modifier>*</modifier></type><name>semifactors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>jselec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>nselec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>avgmatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name></type> <name>norm_sjinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinquals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In an ANTI join, we must ignore clauses that are "pushed down", since
	 * those won't affect the match logic.  In a SEMI join, we do not
	 * distinguish joinquals from "pushed down" quals, so just use the whole
	 * restrictinfo list.  For other outer join types, we should consider only
	 * non-pushed-down quals, so that this devolves to an IS_OUTER_JOIN check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>joinquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>joinquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinquals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinquals</name> <operator>=</operator> <name>restrictlist</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Get the JOIN_SEMI or JOIN_ANTI selectivity of the join clauses.
	 */</comment>
	<expr_stmt><expr><name>jselec</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>joinquals</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><ternary><condition><expr><operator>(</operator><name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator></expr> ?</condition><then> <expr><name>JOIN_ANTI</name></expr> </then><else>: <expr><name>JOIN_SEMI</name></expr></else></ternary></expr></argument>,
									<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also get the normal inner-join selectivity of the join clauses.
	 */</comment>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_SpecialJoinInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>min_lefthand</name></name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>min_righthand</name></name> <operator>=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>syn_lefthand</name></name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>syn_righthand</name></name> <operator>=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
	<comment type="block">/* we don't bother trying to make the remaining fields valid */</comment>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>lhs_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>delay_upper_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>semi_can_btree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>semi_operators</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>norm_sjinfo</name><operator>.</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nselec</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>joinquals</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><name>JOIN_INNER</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>norm_sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Avoid leaking a lot of ListCells */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * jselec can be interpreted as the fraction of outer-rel rows that have
	 * any matches (this is true for both SEMI and ANTI cases).  And nselec is
	 * the fraction of the Cartesian product that matches.  So, the average
	 * number of matches for each outer-rel row that has at least one match is
	 * nselec * inner_rows / jselec.
	 *
	 * Note: it is correct to use the inner rel's "rows" count here, even
	 * though we might later be considering a parameterized inner path with
	 * fewer rows.  This is because we have included all the join clauses in
	 * the selectivity estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jselec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>				<comment type="block">/* protect against zero divide */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>avgmatch</name> <operator>=</operator> <name>nselec</name> <operator>*</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>jselec</name></expr>;</expr_stmt>
		<comment type="block">/* Clamp to sane range */</comment>
		<expr_stmt><expr><name>avgmatch</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>avgmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>avgmatch</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>semifactors</name><operator>-&gt;</operator><name>outer_match_frac</name></name> <operator>=</operator> <name>jselec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>semifactors</name><operator>-&gt;</operator><name>match_count</name></name> <operator>=</operator> <name>avgmatch</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * has_indexed_join_quals
 *	  Check whether all the joinquals of a nestloop join are used as
 *	  inner index quals.
 *
 * If the inner path of a SEMI/ANTI join is an indexscan (including bitmap
 * indexscan) that uses all the joinquals as indexquals, we can assume that an
 * unmatched outer tuple is cheap to process, whereas otherwise it's probably
 * expensive.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_indexed_join_quals</name><parameter_list>(<parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>joinpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>joinrelids</name> <init>= <expr><name><name>joinpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>innerpath</name> <init>= <expr><name><name>joinpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_one</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If join still has quals to evaluate, it's not fast */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>joinpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Nor if the inner path isn't parameterized at all */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>innerpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Find the indexclauses list for the inner scan */</comment>
	<switch>switch <condition>(<expr><name><name>innerpath</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><name>indexclauses</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>innerpath</name><operator>)</operator><operator>-&gt;</operator><name>indexclauses</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Accept only a simple bitmap scan, not AND/OR cases */</comment>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>bmqual</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BitmapHeapPath</name> <operator>*</operator><operator>)</operator> <name>innerpath</name><operator>)</operator><operator>-&gt;</operator><name>bitmapqual</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bmqual</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexclauses</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>bmqual</name><operator>)</operator><operator>-&gt;</operator><name>indexclauses</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>

			<comment type="block">/*
			 * If it's not a simple indexscan, it probably doesn't run quickly
			 * for zero rows out, even if it's a parameterized path using all
			 * the joinquals.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Examine the inner path's param clauses.  Any that are from the outer
	 * path must be found in the indexclauses list, either exactly or in an
	 * equivalent form generated by equivclass.c.  Also, we must find at least
	 * one such clause, else it's a clauseless join which isn't fast.
	 */</comment>
	<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>innerpath-&gt;param_info-&gt;ppi_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										<argument><expr><name><name>innerpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>indexclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>is_redundant_derived_clause</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>indexclauses</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>found_one</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * approx_tuple_count
 *		Quick-and-dirty estimation of the number of join rows passing
 *		a set of qual conditions.
 *
 * The quals can be either an implicitly-ANDed list of boolean expressions,
 * or a list of RestrictInfo nodes (typically the latter).
 *
 * We intentionally compute the selectivity under JOIN_INNER rules, even
 * if it's some type of outer join.  This is appropriate because we are
 * trying to figure out how many tuples pass the initial merge or hash
 * join step.
 *
 * This is quick-and-dirty because we bypass clauselist_selectivity, and
 * simply multiply the independent clause selectivities together.  Now
 * clauselist_selectivity often can't do any better than that anyhow, but
 * for some situations (such as range constraints) it is smarter.  However,
 * we can't effectively cache the results of clauselist_selectivity, whereas
 * the individual clause selectivities can be and are cached.
 *
 * Since we are only using the results to estimate how many potential
 * output tuples are generated and passed through qpqual checking, it
 * seems OK to live with the approximation.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>approx_tuple_count</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>outer_tuples</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>inner_tuples</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name></type> <name>sjinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make up a SpecialJoinInfo for JOIN_INNER semantics.
	 */</comment>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_SpecialJoinInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>min_lefthand</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>min_righthand</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>syn_lefthand</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>syn_righthand</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
	<comment type="block">/* we don't bother trying to make the remaining fields valid */</comment>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>lhs_strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>delay_upper_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>semi_can_btree</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>semi_operators</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>.</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Get the approximate selectivity */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Note that clause_selectivity will be able to cache its result */</comment>
		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <call><name>clause_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Apply it to the input relation sizes */</comment>
	<expr_stmt><expr><name>tuples</name> <operator>=</operator> <name>selec</name> <operator>*</operator> <name>outer_tuples</name> <operator>*</operator> <name>inner_tuples</name></expr>;</expr_stmt>

	<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set_baserel_size_estimates
 *		Set the size estimates for the given base relation.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already, and rel-&gt;tuples must be set.
 *
 * We set the following fields of the rel node:
 *	rows: the estimated number of output tuples (after applying
 *		  restriction clauses).
 *	width: the estimated average output tuple width in bytes.
 *	baserestrictcost: estimated cost of evaluating baserestrictinfo clauses.
 */</comment>
<function><type><name>void</name></type>
<name>set_baserel_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>nrows</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator>
		<call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>JOIN_INNER</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_rel_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_parameterized_baserel_size
 *		Make a size estimate for a parameterized scan of a base relation.
 *
 * 'param_clauses' lists the additional join clauses to be used.
 *
 * set_baserel_size_estimates must have been applied already.
 */</comment>
<function><type><name>double</name></type>
<name>get_parameterized_baserel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>allclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nrows</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Estimate the number of rows returned by the parameterized scan, knowing
	 * that it will apply all the extra join clauses as well as the rel's own
	 * restriction clauses.  Note that we force the clauses to be treated as
	 * non-join clauses during selectivity estimation.
	 */</comment>
	<expr_stmt><expr><name>allclauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>param_clauses</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator>
		<call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							   <argument><expr><name>allclauses</name></expr></argument>,
							   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,	<comment type="block">/* do not use 0! */</comment>
							   <argument><expr><name>JOIN_INNER</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* For safety, make sure result is not more than the base estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>nrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_joinrel_size_estimates
 *		Set the size estimates for the given join relation.
 *
 * The rel's targetlist must have been constructed already, and a
 * restriction clause list that matches the given component rels must
 * be provided.
 *
 * Since there is more than one way to make a joinrel for more than two
 * base relations, the results we get here could depend on which component
 * rel pair is provided.  In theory we should get the same answers no matter
 * which pair is provided; in practice, since the selectivity estimation
 * routines don't handle all cases equally well, we might not.  But there's
 * not much to be done about it.  (Would it make sense to repeat the
 * calculations for each pair of input rels that's encountered, and somehow
 * average the results?  Probably way more trouble than it's worth, and
 * anyway we must keep the rowcount estimate the same for all paths for the
 * joinrel.)
 *
 * We set only the rows field here.  The reltarget field was already set by
 * build_joinrel_tlist, and baserestrictcost is not used for join rels.
 */</comment>
<function><type><name>void</name></type>
<name>set_joinrel_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
						   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <call><name>calc_joinrel_size_estimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><name>outer_rel</name></expr></argument>,
										   <argument><expr><name>inner_rel</name></expr></argument>,
										   <argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
										   <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
										   <argument><expr><name>sjinfo</name></expr></argument>,
										   <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_parameterized_joinrel_size
 *		Make a size estimate for a parameterized scan of a join relation.
 *
 * 'rel' is the joinrel under consideration.
 * 'outer_path', 'inner_path' are (probably also parameterized) Paths that
 *		produce the relations being joined.
 * 'sjinfo' is any SpecialJoinInfo relevant to this join.
 * 'restrict_clauses' lists the join clauses that need to be applied at the
 * join node (including any movable clauses that were moved down to this join,
 * and not including any movable clauses that were pushed down into the
 * child paths).
 *
 * set_joinrel_size_estimates must have been applied already.
 */</comment>
<function><type><name>double</name></type>
<name>get_parameterized_joinrel_size</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
							   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
							   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>nrows</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Estimate the number of rows returned by the parameterized join as the
	 * sizes of the input paths times the selectivity of the clauses that have
	 * ended up at this join node.
	 *
	 * As with set_joinrel_size_estimates, the rowcount estimate could depend
	 * on the pair of input paths provided, though ideally we'd get the same
	 * estimate for any pair with the same parameterization.
	 */</comment>
	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>calc_joinrel_size_estimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>rel</name></expr></argument>,
									   <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
									   <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
									   <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
									   <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
									   <argument><expr><name>sjinfo</name></expr></argument>,
									   <argument><expr><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* For safety, make sure result is not more than the base estimate */</comment>
	<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>nrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calc_joinrel_size_estimate
 *		Workhorse for set_joinrel_size_estimates and
 *		get_parameterized_joinrel_size.
 *
 * outer_rel/inner_rel are the relations being joined, but they should be
 * assumed to have sizes outer_rows/inner_rows; those numbers might be less
 * than what rel-&gt;rows says, when we are considering parameterized paths.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_joinrel_size_estimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>outer_rows</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>inner_rows</name></decl></parameter>,
						   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist_in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This apparently-useless variable dodges a compiler bug in VS2013: */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>restrictlist</name> <init>= <expr><name>restrictlist_in</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>fkselec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>jselec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>pselec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nrows</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute joinclause selectivity.  Note that we are only considering
	 * clauses that become restriction clauses at this join level; we are not
	 * double-counting them because they were not considered in estimating the
	 * sizes of the component rels.
	 *
	 * First, see whether any of the joinclauses can be matched to known FK
	 * constraints.  If so, drop those clauses from the restrictlist, and
	 * instead estimate their selectivity using FK semantics.  (We do this
	 * without regard to whether said clauses are local or "pushed down".
	 * Probably, an FK-matching clause could never be seen as pushed down at
	 * an outer join, since it would be strict and hence would be grounds for
	 * join strength reduction.)  fkselec gets the net selectivity for
	 * FK-matching clauses, or 1.0 if there are none.
	 */</comment>
	<expr_stmt><expr><name>fkselec</name> <operator>=</operator> <call><name>get_foreign_key_join_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											   <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											   <argument><expr><name>sjinfo</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For an outer join, we have to distinguish the selectivity of the join's
	 * own clauses (JOIN/ON conditions) from any clauses that were "pushed
	 * down".  For inner joins we just count them all as joinclauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pushedquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Grovel through the clauses to separate into two lists */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pushedquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pushedquals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>joinquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinquals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Get the separate selectivities */</comment>
		<expr_stmt><expr><name>jselec</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>joinquals</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>jointype</name></expr></argument>,
										<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pselec</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>pushedquals</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>jointype</name></expr></argument>,
										<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Avoid leaking a lot of ListCells */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>pushedquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>jselec</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>restrictlist</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>jointype</name></expr></argument>,
										<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pselec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>			<comment type="block">/* not used, keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Basically, we multiply size of Cartesian product by selectivity.
	 *
	 * If we are doing an outer join, take that into account: the joinqual
	 * selectivity has to be clamped using the knowledge that the output must
	 * be at least as large as the non-nullable input.  However, any
	 * pushed-down quals are applied after the outer join, so their
	 * selectivity applies fully.
	 *
	 * For JOIN_SEMI and JOIN_ANTI, the selectivity is defined as the fraction
	 * of LHS rows that have matches, and we apply that straightforwardly.
	 */</comment>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name> <operator>*</operator> <name>inner_rows</name> <operator>*</operator> <name>fkselec</name> <operator>*</operator> <name>jselec</name></expr>;</expr_stmt>
			<comment type="block">/* pselec not used */</comment>
			<break>break;</break>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name> <operator>*</operator> <name>inner_rows</name> <operator>*</operator> <name>fkselec</name> <operator>*</operator> <name>jselec</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&lt;</operator> <name>outer_rows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nrows</name> <operator>*=</operator> <name>pselec</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name> <operator>*</operator> <name>inner_rows</name> <operator>*</operator> <name>fkselec</name> <operator>*</operator> <name>jselec</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&lt;</operator> <name>outer_rows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&lt;</operator> <name>inner_rows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>inner_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nrows</name> <operator>*=</operator> <name>pselec</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name> <operator>*</operator> <name>fkselec</name> <operator>*</operator> <name>jselec</name></expr>;</expr_stmt>
			<comment type="block">/* pselec not used */</comment>
			<break>break;</break>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <name>outer_rows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>fkselec</name> <operator>*</operator> <name>jselec</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nrows</name> <operator>*=</operator> <name>pselec</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* other values not expected here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>nrows</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_foreign_key_join_selectivity
 *		Estimate join selectivity for foreign-key-related clauses.
 *
 * Remove any clauses that can be matched to FK constraints from *restrictlist,
 * and return a substitute estimate of their selectivity.  1.0 is returned
 * when there are no such clauses.
 *
 * The reason for treating such clauses specially is that we can get better
 * estimates this way than by relying on clauselist_selectivity(), especially
 * for multi-column FKs where that function's assumption that the clauses are
 * independent falls down badly.  But even with single-column FKs, we may be
 * able to get a better answer when the pg_statistic stats are missing or out
 * of date.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>get_foreign_key_join_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>inner_relids</name></decl></parameter>,
								 <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>fkselec</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>worklist</name> <init>= <expr><operator>*</operator><name>restrictlist</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Consider each FK constraint that is known to match the query */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;fkey_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyOptInfo</name> <modifier>*</modifier></type><name>fkinfo</name> <init>= <expr><operator>(</operator><name>ForeignKeyOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ref_is_outer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>removedlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This FK is not relevant unless it connects a baserel on one side of
		 * this join to a baserel on the other side.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name></expr></argument>, <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name></expr></argument>, <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ref_is_outer</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name></expr></argument>, <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>con_relid</name></name></expr></argument>, <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ref_is_outer</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If we're dealing with a semi/anti join, and the FK's referenced
		 * relation is on the outside, then knowledge of the FK doesn't help
		 * us figure out what we need to know (which is the fraction of outer
		 * rows that have matches).  On the other hand, if the referenced rel
		 * is on the inside, then all outer rows must have matches in the
		 * referenced table (ignoring nulls).  But any restriction or join
		 * clauses that filter that table will reduce the fraction of matches.
		 * We can account for restriction clauses, but it's too hard to guess
		 * how many table rows would get through a join that's inside the RHS.
		 * Hence, if either case applies, punt and ignore the FK.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>ref_is_outer</name> <operator>||</operator> <call><name>bms_membership</name><argument_list>(<argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_SINGLETON</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Modify the restrictlist by removing clauses that match the FK (and
		 * putting them into removedlist instead).  It seems unsafe to modify
		 * the originally-passed List structure, so we make a shallow copy the
		 * first time through.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>worklist</name> <operator>==</operator> <operator>*</operator><name>restrictlist</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>worklist</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>worklist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>removedlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>worklist</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>remove_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Drop this clause if it matches any column of the FK */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * EC-derived clauses can only match by EC.  It is okay to
					 * consider any clause derived from the same EC as
					 * matching the FK: even if equivclass.c chose to generate
					 * a clause equating some other pair of Vars, it could
					 * have generated one equating the FK's Vars.  So for
					 * purposes of estimation, we can act as though it did so.
					 *
					 * Note: checking parent_ec is a bit of a cheat because
					 * there are EC-derived clauses that don't have parent_ec
					 * set; but such clauses must compare expressions that
					 * aren't just Vars, so they cannot match the FK anyway.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>fkinfo</name><operator>-&gt;</operator><name>eclass</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>remove_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Otherwise, see if rinfo was previously matched to FK as
					 * a "loose" clause.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>remove_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>remove_it</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>worklist</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>worklist</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>removedlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>removedlist</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If we failed to remove all the matching clauses we expected to
		 * find, chicken out and ignore this FK; applying its selectivity
		 * might result in double-counting.  Put any clauses we did manage to
		 * remove back into the worklist.
		 *
		 * Since the matching clauses are known not outerjoin-delayed, they
		 * should certainly have appeared in the initial joinclause list.  If
		 * we didn't find them, they must have been matched to, and removed
		 * by, some other FK in a previous iteration of this loop.  (A likely
		 * case is that two FKs are matched to the same EC; there will be only
		 * one EC-derived clause in the initial list, so the first FK will
		 * consume it.)  Applying both FKs' selectivity independently risks
		 * underestimating the join size; in particular, this would undo one
		 * of the main things that ECs were invented for, namely to avoid
		 * double-counting the selectivity of redundant equality conditions.
		 * Later we might think of a reasonable way to combine the estimates,
		 * but for now, just punt, since this is a fairly uncommon situation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>removedlist</name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<operator>(</operator><name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_ec</name></name> <operator>+</operator> <name><name>fkinfo</name><operator>-&gt;</operator><name>nmatched_ri</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>worklist</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>worklist</name></expr></argument>, <argument><expr><name>removedlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Finally we get to the payoff: estimate selectivity using the
		 * knowledge that each referencing row will match exactly one row in
		 * the referenced table.
		 *
		 * XXX that's not true in the presence of nulls in the referencing
		 * column(s), so in principle we should derate the estimate for those.
		 * However (1) if there are any strict restriction clauses for the
		 * referencing column(s) elsewhere in the query, derating here would
		 * be double-counting the null fraction, and (2) it's not very clear
		 * how to combine null fractions for multiple referencing columns. So
		 * we do nothing for now about correcting for nulls.
		 *
		 * XXX another point here is that if either side of an FK constraint
		 * is an inheritance parent, we estimate as though the constraint
		 * covers all its children as well.  This is not an unreasonable
		 * assumption for a referencing table, ie the user probably applied
		 * identical constraints to all child tables (though perhaps we ought
		 * to check that).  But it's not possible to have done that for a
		 * referenced table.  Fortunately, precisely because that doesn't
		 * work, it is uncommon in practice to have an FK referencing a parent
		 * table.  So, at least for now, disregard inheritance here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For JOIN_SEMI and JOIN_ANTI, we only get here when the FK's
			 * referenced table is exactly the inside of the join.  The join
			 * selectivity is defined as the fraction of LHS rows that have
			 * matches.  The FK implies that every LHS row has a match *in the
			 * referenced table*; but any restriction clauses on it will
			 * reduce the number of matches.  Hence we take the join
			 * selectivity as equal to the selectivity of the table's
			 * restriction clauses, which is rows / tuples; but we must guard
			 * against tuples == 0.
			 */</comment>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>ref_rel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>ref_tuples</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>ref_rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fkselec</name> <operator>*=</operator> <name><name>ref_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name>ref_tuples</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, selectivity is exactly 1/referenced-table-size; but
			 * guard against tuples == 0.  Note we should use the raw table
			 * tuple count, not any estimate of its filtered or joined size.
			 */</comment>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>ref_rel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fkinfo</name><operator>-&gt;</operator><name>ref_relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>ref_tuples</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>ref_rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fkselec</name> <operator>*=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>ref_tuples</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>restrictlist</name> <operator>=</operator> <name>worklist</name></expr>;</expr_stmt>
	<return>return <expr><name>fkselec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_subquery_size_estimates
 *		Set the size estimates for a base relation that is a subquery.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already, and the Paths for the subquery must have been completed.
 * We look at the subquery's PlannerInfo to extract data.
 *
 * We set the same fields as set_baserel_size_estimates.
 */</comment>
<function><type><name>void</name></type>
<name>set_subquery_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>sub_final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are subqueries */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rtekind</name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy raw number of output rows from subquery.  All of its paths should
	 * have the same output rowcount, so just look at cheapest-total.
	 */</comment>
	<expr_stmt><expr><name>sub_final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>sub_final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute per-output-column width estimates by examining the subquery's
	 * targetlist.  For any output that is a plain Var, get the width estimate
	 * that was made while planning the subquery.  Otherwise, we leave it to
	 * set_rel_width to fill in a datatype-based default estimate.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subroot-&gt;parse-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>texpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>item_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* junk columns aren't visible to upper query */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The subquery could be an expansion of a view that's had columns
		 * added to it since the current query was parsed, so that there are
		 * non-junk tlist columns in it that don't correspond to any column
		 * visible at our query level.  Ignore such columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>||</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * XXX This currently doesn't work for subqueries containing set
		 * operations, because the Vars in their tlists are bogus references
		 * to the first leaf subquery, which wouldn't give the right answer
		 * even if we could still get to its PlannerInfo.
		 *
		 * Also, the subquery could be an appendrel for which all branches are
		 * known empty due to constraint exclusion, in which case
		 * set_append_rel_pathlist will have left the attr_widths set to zero.
		 *
		 * In either case, we just leave the width estimate zero until
		 * set_rel_width fixes it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>texpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>texpr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>subrel</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>item_width</name> <operator>=</operator> <name><name>subrel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name><name>subrel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name> <operator>=</operator> <name>item_width</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Now estimate number of output rows, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_function_size_estimates
 *		Set the size estimates for a base relation that is a function call.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already.
 *
 * We set the same fields as set_baserel_size_estimates.
 */</comment>
<function><type><name>void</name></type>
<name>set_function_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are functions */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of rows the functions will return. The rowcount of the
	 * node is that of the largest function result.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>ntup</name> <init>= <expr><call><name>expression_returns_set_rows</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ntup</name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>ntup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Now estimate number of output rows, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_function_size_estimates
 *		Set the size estimates for a base relation that is a function call.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already.
 *
 * We set the same fields as set_tablefunc_size_estimates.
 */</comment>
<function><type><name>void</name></type>
<name>set_tablefunc_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Should only be applied to base relations that are functions */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rtekind</name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>

	<comment type="block">/* Now estimate number of output rows, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_values_size_estimates
 *		Set the size estimates for a base relation that is a values list.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already.
 *
 * We set the same fields as set_baserel_size_estimates.
 */</comment>
<function><type><name>void</name></type>
<name>set_values_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are values lists */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of rows the values list will return. We know this
	 * precisely based on the list length (well, barring set-returning
	 * functions in list items, but that's a refinement not catered for
	 * anywhere else either).
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now estimate number of output rows, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_cte_size_estimates
 *		Set the size estimates for a base relation that is a CTE reference.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already, and we need an estimate of the number of rows returned by the CTE
 * (if a regular CTE) or the non-recursive term (if a self-reference).
 *
 * We set the same fields as set_baserel_size_estimates.
 */</comment>
<function><type><name>void</name></type>
<name>set_cte_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>cte_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are CTE references */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In a self-reference, arbitrarily assume the average worktable size
		 * is about 10 times the nonrecursive term's size.
		 */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name>cte_rows</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Otherwise just believe the CTE's rowcount estimate */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name>cte_rows</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Now estimate number of output rows, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_namedtuplestore_size_estimates
 *		Set the size estimates for a base relation that is a tuplestore reference.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already.
 *
 * We set the same fields as set_baserel_size_estimates.
 */</comment>
<function><type><name>void</name></type>
<name>set_namedtuplestore_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be applied to base relations that are tuplestore references */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use the estimate provided by the code which is generating the named
	 * tuplestore.  In some cases, the actual number might be available; in
	 * others the same plan will be re-used, so a "typical" value might be
	 * estimated and used.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>enrtuples</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now estimate number of output rows, etc */</comment>
	<expr_stmt><expr><call><name>set_baserel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_foreign_size_estimates
 *		Set the size estimates for a base relation that is a foreign table.
 *
 * There is not a whole lot that we can do here; the foreign-data wrapper
 * is responsible for producing useful estimates.  We can do a decent job
 * of estimating baserestrictcost, so we set that, and we also set up width
 * using what will be purely datatype-driven estimates from the targetlist.
 * There is no way to do anything sane with the rows value, so we just put
 * a default estimate and hope that the wrapper can improve on it.  The
 * wrapper's GetForeignRelSize function will be called momentarily.
 *
 * The rel's targetlist and restrictinfo list must have been constructed
 * already.
 */</comment>
<function><type><name>void</name></type>
<name>set_foreign_size_estimates</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Should only be applied to base relations */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>			<comment type="block">/* entirely bogus default estimate */</comment>

	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_rel_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set_rel_width
 *		Set the estimated output width of a base relation.
 *
 * The estimated output width is the sum of the per-attribute width estimates
 * for the actually-referenced columns, plus any PHVs or other expressions
 * that have to be calculated at this relation.  This is the amount of data
 * we'd need to pass upwards in case of a sort, hash, etc.
 *
 * This function also sets reltarget-&gt;cost, so it's a bit misnamed now.
 *
 * NB: this works best on plain relations because it prefers to look at
 * real Vars.  For subqueries, set_subquery_size_estimates will already have
 * copied up whatever per-column estimates were made within the subquery,
 * and for other types of rels there isn't much we can do anyway.  We fall
 * back on (fairly stupid) datatype-based width estimates if we can't get
 * any better number.
 *
 * The per-attribute width estimates are cached for possible re-use while
 * building join relations or post-scan/join pathtargets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rel_width</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_wholerow_var</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Vars are assumed to have cost zero, but other exprs do not */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ordinarily, a Var in a rel's targetlist must belong to that rel;
		 * but there are corner cases involving LATERAL references where that
		 * isn't so.  If the Var has the wrong varno, fall through to the
		 * generic case (it doesn't seem worth the trouble to be any smarter).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>item_width</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ndx</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If it's a whole-row Var, we'll deal with it below after we have
			 * already cached as many attr widths as possible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>have_wholerow_var</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * The width may have been cached already (especially if it's a
			 * subquery), so don't duplicate effort.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Try to get column width from statistics */</comment>
			<if_stmt><if>if <condition>(<expr><name>reloid</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_attavgwidth</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>item_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>=</operator> <name>item_width</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>item_width</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Not a plain relation, or can't find statistics for it. Estimate
			 * using just the type info.
			 */</comment>
			<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>=</operator> <name>item_width</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>item_width</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We will need to evaluate the PHV's contained expression while
			 * scanning this rel, so be sure to include it in reltarget-&gt;cost.
			 */</comment>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>QualCost</name></type>	<name>cost</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name><name>phinfo</name><operator>-&gt;</operator><name>ph_width</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We could be looking at an expression pulled up from a subquery,
			 * or a ROW() representing a whole-row child Var, etc.  Do what we
			 * can using the expression type information.
			 */</comment>
			<decl_stmt><decl><type><name>int32</name></type>		<name>item_width</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>QualCost</name></type>	<name>cost</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>item_width</name></expr>;</expr_stmt>
			<comment type="block">/* Not entirely clear if we need to account for cost, but do so */</comment>
			<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we have a whole-row reference, estimate its width as the sum of
	 * per-column widths plus heap tuple header overhead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_wholerow_var</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>wholerow_width</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>reloid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Real relation, so estimate true tuple width */</comment>
			<expr_stmt><expr><name>wholerow_width</name> <operator>+=</operator> <call><name>get_relation_data_width</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>,
													  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Do what we can with info for a phony rel */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>wholerow_width</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>i</name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><literal type="number">0</literal> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name> <operator>=</operator> <name>wholerow_width</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Include the whole-row Var as part of the output tuple.  Yes, that
		 * really is what happens at runtime.
		 */</comment>
		<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>wholerow_width</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple_width</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>tuple_width</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_pathtarget_cost_width
 *		Set the estimated eval cost and output width of a PathTarget tlist.
 *
 * As a notational convenience, returns the same PathTarget pointer passed in.
 *
 * Most, though not quite all, uses of this function occur after we've run
 * set_rel_width() for base relations; so we can usually obtain cached width
 * estimates for Vars.  If we can't, fall back on datatype-based width
 * estimates.  Present early-planning uses of PathTargets don't need accurate
 * widths badly enough to justify going to the catalogs for better data.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>set_pathtarget_cost_width</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Vars are assumed to have cost zero, but other exprs do not */</comment>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>item_width</name></decl>;</decl_stmt>

			<comment type="block">/* We should not see any upper-level Vars here */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Try to get data from RelOptInfo cache */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>&amp;&amp;</operator>
					<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * No cached data available, so estimate using just the type info.
			 */</comment>
			<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>item_width</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Handle general expressions using type info.
			 */</comment>
			<decl_stmt><decl><type><name>int32</name></type>		<name>item_width</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>QualCost</name></type>	<name>cost</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>item_width</name></expr>;</expr_stmt>

			<comment type="block">/* Account for cost, too */</comment>
			<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+=</operator> <name><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple_width</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name>tuple_width</name></expr>;</expr_stmt>

	<return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * relation_byte_size
 *	  Estimate the storage space in bytes for a given number of tuples
 *	  of a given width (size in bytes).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>relation_byte_size</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>tuples</name> <operator>*</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * page_size
 *	  Returns an estimate of the number of pages covered by a given
 *	  number of tuples of a given width (size in bytes).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>page_size</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ceil</name><argument_list>(<argument><expr><call><name>relation_byte_size</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the fraction of the work that each worker will do given the
 * number of workers budgeted for the path.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>get_parallel_divisor</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>parallel_divisor</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Early experience with parallel query suggests that when there is only
	 * one worker, the leader often makes a very substantial contribution to
	 * executing the parallel portion of the plan, but as more workers are
	 * added, it does less and less, because it's busy reading tuples from the
	 * workers and doing whatever non-parallel post-processing is needed.  By
	 * the time we reach 4 workers, the leader no longer makes a meaningful
	 * contribution.  Thus, for now, estimate that the leader spends 30% of
	 * its time servicing each worker, and the remainder executing the
	 * parallel plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel_leader_participation</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>leader_contribution</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>leader_contribution</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><literal type="number">0.3</literal> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>leader_contribution</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parallel_divisor</name> <operator>+=</operator> <name>leader_contribution</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>parallel_divisor</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute_bitmap_pages
 *
 * compute number of pages fetched from heap in bitmap heap scan.
 */</comment>
<function><type><name>double</name></type>
<name>compute_bitmap_pages</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>loop_count</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>cost</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>indexTotalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>indexSelectivity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>T</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>pages_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuples_fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>heap_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>maxentries</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch total cost of obtaining the bitmap, as well as its total
	 * selectivity.
	 */</comment>
	<expr_stmt><expr><call><name>cost_bitmap_tree_node</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexTotalCost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexSelectivity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of main-table pages fetched.
	 */</comment>
	<expr_stmt><expr><name>tuples_fetched</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>indexSelectivity</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>T</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a single scan, the number of heap pages that need to be fetched is
	 * the same as the Mackert and Lohman formula for the case T &lt;= b (ie, no
	 * re-reads needed).
	 */</comment>
	<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>*</operator> <name>tuples_fetched</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">2.0</literal> <operator>*</operator> <name>T</name> <operator>+</operator> <name>tuples_fetched</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the number of pages fetched from the heap.  Then based on
	 * current work_mem estimate get the estimated maxentries in the bitmap.
	 * (Note that we always do this calculation based on the number of pages
	 * that would be fetched in a single iteration, even if loop_count &gt; 1.
	 * That's correct, because only that number of entries will be stored in
	 * the bitmap at one time.)
	 */</comment>
	<expr_stmt><expr><name>heap_pages</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>pages_fetched</name></expr></argument>, <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxentries</name> <operator>=</operator> <call><name>tbm_calculate_entries</name><argument_list>(<argument><expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>loop_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For repeated bitmap scans, scale up the number of tuples fetched in
		 * the Mackert and Lohman formula by the number of scans, so that we
		 * estimate the number of pages fetched by all the scans. Then
		 * pro-rate for one scan.
		 */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>tuples_fetched</name> <operator>*</operator> <name>loop_count</name></expr></argument>,
											<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><call><name>get_indexpath_pages</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pages_fetched</name> <operator>/=</operator> <name>loop_count</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pages_fetched</name> <operator>&gt;=</operator> <name>T</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>pages_fetched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>maxentries</name> <operator>&lt;</operator> <name>heap_pages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>exact_pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>lossy_pages</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Crude approximation of the number of lossy pages.  Because of the
		 * way tbm_lossify() is coded, the number of lossy pages increases
		 * very sharply as soon as we run short of memory; this formula has
		 * that property and seems to perform adequately in testing, but it's
		 * possible we could do better somehow.
		 */</comment>
		<expr_stmt><expr><name>lossy_pages</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>heap_pages</name> <operator>-</operator> <name>maxentries</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exact_pages</name> <operator>=</operator> <name>heap_pages</name> <operator>-</operator> <name>lossy_pages</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are lossy pages then recompute the  number of tuples
		 * processed by the bitmap heap node.  We assume here that the chance
		 * of a given tuple coming from an exact page is the same as the
		 * chance that a given page is exact.  This might not be true, but
		 * it's not clear how we can do any better.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lossy_pages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuples_fetched</name> <operator>=</operator>
				<call><name>clamp_row_est</name><argument_list>(<argument><expr><name>indexSelectivity</name> <operator>*</operator>
							  <operator>(</operator><name>exact_pages</name> <operator>/</operator> <name>heap_pages</name><operator>)</operator> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>+</operator>
							  <operator>(</operator><name>lossy_pages</name> <operator>/</operator> <name>heap_pages</name><operator>)</operator> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cost</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>cost</name> <operator>=</operator> <name>indexTotalCost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tuple</name> <operator>=</operator> <name>tuples_fetched</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pages_fetched</name></expr>;</return>
</block_content>}</block></function>
</unit>
