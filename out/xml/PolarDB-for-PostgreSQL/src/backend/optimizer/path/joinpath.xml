<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/path/joinpath.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * joinpath.c
 *	  Routines to find all possible paths for processing a set of joins
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/path/joinpath.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>

<comment type="block">/* Hook for plugins to get control in add_paths_to_joinrel() */</comment>
<decl_stmt><decl><type><name>set_join_pathlist_hook_type</name></type> <name>set_join_pathlist_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Paths parameterized by the parent can be considered to be parameterized by
 * any of its child.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_PARAM_BY_PARENT</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>rel</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((path)-&gt;param_info &amp;&amp; bms_overlap(PATH_REQ_OUTER(path),	\
									   (rel)-&gt;top_parent_relids))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_PARAM_BY_REL_SELF</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>rel</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>((path)-&gt;param_info &amp;&amp; bms_overlap(PATH_REQ_OUTER(path), (rel)-&gt;relids))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_PARAM_BY_REL</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>rel</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(PATH_PARAM_BY_REL_SELF(path, rel) || PATH_PARAM_BY_PARENT(path, rel))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>try_partial_mergejoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outersortkeys</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>innersortkeys</name></decl></parameter>,
						   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						   <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sort_inner_and_outer</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>match_unsorted_outer</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consider_parallel_nestloop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
						   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						   <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consider_parallel_mergejoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_cheapest_total</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hash_inner_and_outer</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>select_mergejoin_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>,
						 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergejoin_allowed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_mergejoin_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outerpath</name></decl></parameter>,
						 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>useallclauses</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_cheapest_total</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merge_pathkeys</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>is_partial</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * add_paths_to_joinrel
 *	  Given a join relation and two component rels from which it can be made,
 *	  consider all possible paths that use the two component rels as outer
 *	  and inner rel respectively.  Add these paths to the join rel's pathlist
 *	  if they survive comparison with other paths (and remove any existing
 *	  paths that are dominated by these paths).
 *
 * Modifies the pathlist field of the joinrel node to contain the best
 * paths found so far.
 *
 * jointype is not necessarily the same as sjinfo-&gt;jointype; it might be
 * "flipped around" if we are considering joining the rels in the opposite
 * direction from what's indicated in sjinfo.
 *
 * Also, this routine and others in this module accept the special JoinTypes
 * JOIN_UNIQUE_OUTER and JOIN_UNIQUE_INNER to indicate that we should
 * unique-ify the outer or inner relation and then apply a regular inner
 * join.  These values are not allowed to propagate outside this module,
 * however.  Path cost estimation code may need to recognize that it's
 * dealing with such a case --- the combination of nominal jointype INNER
 * with sjinfo-&gt;jointype == JOIN_SEMI indicates that.
 */</comment>
<function><type><name>void</name></type>
<name>add_paths_to_joinrel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					 <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinPathExtraData</name></type> <name>extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mergejoin_allowed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>joinrelids</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * PlannerInfo doesn't contain the SpecialJoinInfos created for joins
	 * between child relations, even if there is a SpecialJoinInfo node for
	 * the join between the topmost parents. So, while calculating Relids set
	 * representing the restriction, consider relids of topmost parent of
	 * partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_JOINREL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>restrictlist</name></name> <operator>=</operator> <name>restrictlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>mergeclause_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>sjinfo</name></name> <operator>=</operator> <name>sjinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if the inner relation is provably unique for this outer rel.
	 *
	 * We have some special cases: for JOIN_SEMI and JOIN_ANTI, it doesn't
	 * matter since the executor can make the equivalent optimization anyway;
	 * we need not expend planner cycles on proofs.  For JOIN_UNIQUE_INNER, we
	 * must be considering a semijoin whose inner side is not provably unique
	 * (else reduce_unique_semijoins would've simplified it), so there's no
	 * point in calling innerrel_is_unique.  However, if the LHS covers all of
	 * the semijoin's min_lefthand, then it's appropriate to set inner_unique
	 * because the path produced by create_unique_path will be unique relative
	 * to the LHS.  (If we have an LHS that's only part of the min_lefthand,
	 * that is *not* true.)  For JOIN_UNIQUE_OUTER, pass JOIN_INNER to avoid
	 * letting that value escape this module.
	 */</comment>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* well, unproven */</comment>
			<break>break;</break>
		<case>case <expr><name>JOIN_UNIQUE_INNER</name></expr>:</case>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>,
											   <argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_UNIQUE_OUTER</name></expr>:</case>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <call><name>innerrel_is_unique</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
													<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
													<argument><expr><name>innerrel</name></expr></argument>,
													<argument><expr><name>JOIN_INNER</name></expr></argument>,
													<argument><expr><name>restrictlist</name></expr></argument>,
													<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <call><name>innerrel_is_unique</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
													<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
													<argument><expr><name>innerrel</name></expr></argument>,
													<argument><expr><name>jointype</name></expr></argument>,
													<argument><expr><name>restrictlist</name></expr></argument>,
													<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Find potential mergejoin clauses.  We can skip this if we are not
	 * interested in doing a mergejoin.  However, mergejoin may be our only
	 * way of implementing a full outer join, so override enable_mergejoin if
	 * it's a full join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_mergejoin</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>mergeclause_list</name></name> <operator>=</operator> <call><name>select_mergejoin_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><name>joinrel</name></expr></argument>,
														  <argument><expr><name>outerrel</name></expr></argument>,
														  <argument><expr><name>innerrel</name></expr></argument>,
														  <argument><expr><name>restrictlist</name></expr></argument>,
														  <argument><expr><name>jointype</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>mergejoin_allowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's SEMI, ANTI, or inner_unique join, compute correction factors
	 * for cost estimation.  These will be the same for all paths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name> <operator>||</operator> <name><name>extra</name><operator>.</operator><name>inner_unique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>compute_semi_anti_join_factors</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
									   <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>extra</name><operator>.</operator><name>semifactors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide whether it's sensible to generate parameterized paths for this
	 * joinrel, and if so, which relations such paths should require.  There
	 * is usually no need to create a parameterized result path unless there
	 * is a join order restriction that prevents joining one of our input rels
	 * directly to the parameter source rel instead of joining to the other
	 * input rel.  (But see allow_star_schema_join().)	This restriction
	 * reduces the number of parameterized paths we have to deal with at
	 * higher join levels, without compromising the quality of the resulting
	 * plan.  We express the restriction as a Relids set that must overlap the
	 * parameterization of any proposed join path.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;join_info_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo2</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * SJ is relevant to this join if we have some part of its RHS
		 * (possibly not all of it), and haven't yet joined to its LHS.  (This
		 * test is pretty simplistic, but should be sufficient considering the
		 * join has already been proven legal.)  If the SJ is relevant, it
		 * presents constraints for joining to anything not in its RHS.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name></expr></argument>,
											   <argument><expr><call><name>bms_difference</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>,
															  <argument><expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* full joins constrain both sides symmetrically */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
			<call><name>bms_overlap</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>, <argument><expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name></expr></argument>,
											   <argument><expr><call><name>bms_difference</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>,
															  <argument><expr><name><name>sjinfo2</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * However, when a LATERAL subquery is involved, there will simply not be
	 * any paths for the joinrel that aren't parameterized by whatever the
	 * subquery is parameterized by, unless its parameterization is resolved
	 * within the joinrel.  So we might as well allow additional dependencies
	 * on whatever residual lateral dependencies the joinrel will have.
	 */</comment>
	<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>extra</name><operator>.</operator><name>param_source_rels</name></name></expr></argument>,
											  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 1. Consider mergejoin paths where both relations must be explicitly
	 * sorted.  Skip this if we can't mergejoin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mergejoin_allowed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sort_inner_and_outer</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 2. Consider paths where the outer relation need not be explicitly
	 * sorted. This includes both nestloops and mergejoins where the outer
	 * path is already ordered.  Again, skip this if we can't mergejoin.
	 * (That's okay because we know that nestloop can't handle right/full
	 * joins at all, so it wouldn't work in the prohibited cases either.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mergejoin_allowed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>match_unsorted_outer</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>

	<comment type="block">/*
	 * 3. Consider paths where the inner relation need not be explicitly
	 * sorted.  This includes mergejoins only (nestloops were already built in
	 * match_unsorted_outer).
	 *
	 * Diked out as redundant 2/13/2000 -- tgl.  There isn't any really
	 * significant difference between the inner and outer side of a mergejoin,
	 * so match_unsorted_inner creates no paths that aren't equivalent to
	 * those made by match_unsorted_outer when add_paths_to_joinrel() is
	 * invoked with the two rels given in the other order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mergejoin_allowed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>match_unsorted_inner</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * 4. Consider paths where both outer and inner relations must be hashed
	 * before being joined.  As above, disregard enable_hashjoin for full
	 * joins, because there may be no other alternative.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_hashjoin</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_inner_and_outer</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 5. If inner and outer relations are foreign tables (or joins) belonging
	 * to the same server and assigned to the same user to check access
	 * permissions as, give the FDW a chance to push down joins.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignJoinPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignJoinPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
												 <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
												 <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 6. Finally, give extensions a chance to manipulate the path list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>set_join_pathlist_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_join_pathlist_hook</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
							   <argument><expr><name>jointype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We override the param_source_rels heuristic to accept nestloop paths in
 * which the outer rel satisfies some but not all of the inner path's
 * parameterization.  This is necessary to get good plans for star-schema
 * scenarios, in which a parameterized path for a large table may require
 * parameters from multiple small tables that will not get joined directly to
 * each other.  We can handle that by stacking nestloops that have the small
 * tables on the outside; but this breaks the rule the param_source_rels
 * heuristic is based on, namely that parameters should not be passed down
 * across joins unless there's a join-order-constraint-based reason to do so.
 * So we ignore the param_source_rels restriction when this case applies.
 *
 * allow_star_schema_join() returns true if the param_source_rels restriction
 * should be overridden, ie, it's okay to perform this join.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>allow_star_schema_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>inner_paramrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * It's a star-schema case if the outer rel provides some but not all of
	 * the inner rel's parameterization.
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * try_nestloop_path
 *	  Consider a nestloop join path; if it appears useful, push it into
 *	  the joinrel's pathlist via add_path().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_nestloop_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
				  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinCostWorkspace</name></type> <name>workspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>innerrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>outerrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_paramrels</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_paramrels</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Paths are parameterized by top-level parents, so run parameterization
	 * tests on the parent relids.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>innerrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>innerrelids</name> <operator>=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>innerrelids</name> <operator>=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>outerrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outerrelids</name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>outerrelids</name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Check to see if proposed path is still parameterized, and reject if the
	 * parameterization wouldn't be sensible --- unless allow_star_schema_join
	 * says to allow it anyway.  Also, we must reject if have_dangerous_phv
	 * doesn't like the look of it, which could only happen if the nestloop is
	 * still parameterized.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>calc_nestloop_required_outer</name><argument_list>(<argument><expr><name>outerrelids</name></expr></argument>, <argument><expr><name>outer_paramrels</name></expr></argument>,
												  <argument><expr><name>innerrelids</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>required_outer</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>param_source_rels</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <operator>!</operator><call><name>allow_star_schema_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		 <call><name>have_dangerous_phv</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Waste no memory when we reject a path here */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do a precheck to quickly eliminate obviously-inferior paths.  We
	 * calculate a cheap lower bound on the path's cost and then use
	 * add_path_precheck() to see if the path is clearly going to be dominated
	 * by some existing path for the joinrel.  If not, do the full pushup with
	 * creating a fully valid path structure and submitting it to add_path().
	 * The latter two steps are expensive enough to make this two-phase
	 * methodology worthwhile.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
						  <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>add_path_precheck</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>,
						  <argument><expr><name><name>workspace</name><operator>.</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
						  <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the inner path is parameterized, it is parameterized by the
		 * topmost parent of the outer rel, not the outer rel itself.  Fix
		 * that.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_PARENT</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>inner_path</name> <operator>=</operator> <call><name>reparameterize_path_by_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
													  <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we could not translate the path, we can't create nest loop
			 * path.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inner_path</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_nestloop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>joinrel</name></expr></argument>,
									  <argument><expr><name>jointype</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>,
									  <argument><expr><name>extra</name></expr></argument>,
									  <argument><expr><name>outer_path</name></expr></argument>,
									  <argument><expr><name>inner_path</name></expr></argument>,
									  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>,
									  <argument><expr><name>pathkeys</name></expr></argument>,
									  <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Waste no memory when we reject a path here */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * try_partial_nestloop_path
 *	  Consider a partial nestloop join path; if it appears useful, push it into
 *	  the joinrel's partial_pathlist via add_partial_path().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_partial_nestloop_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinCostWorkspace</name></type> <name>workspace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the inner path is parameterized, the parameterization must be fully
	 * satisfied by the proposed outer path.  Parameterized partial paths are
	 * not supported.  The caller should already have verified that no
	 * extra_lateral_rels are required here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_paramrels</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>outerrelids</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The inner and outer paths are parameterized, if at all, by the top
		 * level parents, not the child relations, so we must use those relids
		 * for our parameterization tests.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>outerrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>outerrelids</name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>outerrelids</name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Before creating a path, get a quick lower bound on what it is likely to
	 * cost.  Bail out right away if it looks terrible.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
						  <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_partial_path_precheck</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>total_cost</name></name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the inner path is parameterized, it is parameterized by the topmost
	 * parent of the outer rel, not the outer rel itself.  Fix that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_PARENT</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>inner_path</name> <operator>=</operator> <call><name>reparameterize_path_by_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
												  <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we could not translate the path, we can't create nest loop path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inner_path</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Might be good enough to be worth trying, so let's try it. */</comment>
	<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_nestloop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>joinrel</name></expr></argument>,
										  <argument><expr><name>jointype</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>,
										  <argument><expr><name>extra</name></expr></argument>,
										  <argument><expr><name>outer_path</name></expr></argument>,
										  <argument><expr><name>inner_path</name></expr></argument>,
										  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>,
										  <argument><expr><name>pathkeys</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * try_mergejoin_path
 *	  Consider a merge join path; if it appears useful, push it into
 *	  the joinrel's pathlist via add_path().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_mergejoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
				   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
				   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outersortkeys</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>innersortkeys</name></decl></parameter>,
				   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				   <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>is_partial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinCostWorkspace</name></type> <name>workspace</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_partial</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>try_partial_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name>joinrel</name></expr></argument>,
								   <argument><expr><name>outer_path</name></expr></argument>,
								   <argument><expr><name>inner_path</name></expr></argument>,
								   <argument><expr><name>pathkeys</name></expr></argument>,
								   <argument><expr><name>mergeclauses</name></expr></argument>,
								   <argument><expr><name>outersortkeys</name></expr></argument>,
								   <argument><expr><name>innersortkeys</name></expr></argument>,
								   <argument><expr><name>jointype</name></expr></argument>,
								   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check to see if proposed path is still parameterized, and reject if the
	 * parameterization wouldn't be sensible.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>calc_non_nestloop_required_outer</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>,
													  <argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>required_outer</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>param_source_rels</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Waste no memory when we reject a path here */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the given paths are already well enough ordered, we can skip doing
	 * an explicit sort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outersortkeys</name> <operator>&amp;&amp;</operator>
		<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>innersortkeys</name> <operator>&amp;&amp;</operator>
		<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>, <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See comments in try_nestloop_path().
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>,
						   <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
						   <argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name>innersortkeys</name></expr></argument>,
						   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>add_path_precheck</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>,
						  <argument><expr><name><name>workspace</name><operator>.</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
						  <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>joinrel</name></expr></argument>,
									   <argument><expr><name>jointype</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>,
									   <argument><expr><name>extra</name></expr></argument>,
									   <argument><expr><name>outer_path</name></expr></argument>,
									   <argument><expr><name>inner_path</name></expr></argument>,
									   <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>,
									   <argument><expr><name>pathkeys</name></expr></argument>,
									   <argument><expr><name>required_outer</name></expr></argument>,
									   <argument><expr><name>mergeclauses</name></expr></argument>,
									   <argument><expr><name>outersortkeys</name></expr></argument>,
									   <argument><expr><name>innersortkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Waste no memory when we reject a path here */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * try_partial_mergejoin_path
 *	  Consider a partial merge join path; if it appears useful, push it into
 *	  the joinrel's pathlist via add_partial_path().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_partial_mergejoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outersortkeys</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>innersortkeys</name></decl></parameter>,
						   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						   <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinCostWorkspace</name></type> <name>workspace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See comments in try_partial_hashjoin_path().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_paramrels</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the given paths are already well enough ordered, we can skip doing
	 * an explicit sort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outersortkeys</name> <operator>&amp;&amp;</operator>
		<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>innersortkeys</name> <operator>&amp;&amp;</operator>
		<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>, <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See comments in try_partial_nestloop_path().
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>,
						   <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>,
						   <argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name>innersortkeys</name></expr></argument>,
						   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_partial_path_precheck</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>total_cost</name></name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Might be good enough to be worth trying, so let's try it. */</comment>
	<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>joinrel</name></expr></argument>,
										   <argument><expr><name>jointype</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>,
										   <argument><expr><name>extra</name></expr></argument>,
										   <argument><expr><name>outer_path</name></expr></argument>,
										   <argument><expr><name>inner_path</name></expr></argument>,
										   <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>,
										   <argument><expr><name>pathkeys</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>mergeclauses</name></expr></argument>,
										   <argument><expr><name>outersortkeys</name></expr></argument>,
										   <argument><expr><name>innersortkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * try_hashjoin_path
 *	  Consider a hash join path; if it appears useful, push it into
 *	  the joinrel's pathlist via add_path().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_hashjoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
				  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>,
				  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinCostWorkspace</name></type> <name>workspace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check to see if proposed path is still parameterized, and reject if the
	 * parameterization wouldn't be sensible.
	 */</comment>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>calc_non_nestloop_required_outer</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>,
													  <argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>required_outer</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>param_source_rels</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Waste no memory when we reject a path here */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * See comments in try_nestloop_path().  Also note that hashjoin paths
	 * never have any output pathkeys, per comments in create_hashjoin_path.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>,
						  <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>add_path_precheck</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>,
						  <argument><expr><name><name>workspace</name><operator>.</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
						  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>joinrel</name></expr></argument>,
									  <argument><expr><name>jointype</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>,
									  <argument><expr><name>extra</name></expr></argument>,
									  <argument><expr><name>outer_path</name></expr></argument>,
									  <argument><expr><name>inner_path</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* parallel_hash */</comment>
									  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>,
									  <argument><expr><name>required_outer</name></expr></argument>,
									  <argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Waste no memory when we reject a path here */</comment>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * try_partial_hashjoin_path
 *	  Consider a partial hashjoin join path; if it appears useful, push it into
 *	  the joinrel's partial_pathlist via add_partial_path().
 *	  The outer side is partial.  If parallel_hash is true, then the inner path
 *	  must be partial and will be run in parallel to create one or more shared
 *	  hash tables; otherwise the inner path must be complete and a copy of it
 *	  is run in every process to create separate identical private hash tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_partial_hashjoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>,
						  <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						  <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>parallel_hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinCostWorkspace</name></type> <name>workspace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the inner path is parameterized, the parameterization must be fully
	 * satisfied by the proposed outer path.  Parameterized partial paths are
	 * not supported.  The caller should already have verified that no
	 * extra_lateral_rels are required here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_paramrels</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Before creating a path, get a quick lower bound on what it is likely to
	 * cost.  Bail out right away if it looks terrible.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>,
						  <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>parallel_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_partial_path_precheck</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>total_cost</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Might be good enough to be worth trying, so let's try it. */</comment>
	<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>joinrel</name></expr></argument>,
										  <argument><expr><name>jointype</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>workspace</name></expr></argument>,
										  <argument><expr><name>extra</name></expr></argument>,
										  <argument><expr><name>outer_path</name></expr></argument>,
										  <argument><expr><name>inner_path</name></expr></argument>,
										  <argument><expr><name>parallel_hash</name></expr></argument>,
										  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * clause_sides_match_join
 *	  Determine whether a join clause is of the right form to use in this join.
 *
 * We already know that the clause is a binary opclause referencing only the
 * rels in the current join.  The point here is to check whether it has the
 * form "outerrel_expr op innerrel_expr" or "innerrel_expr op outerrel_expr",
 * rather than mixing outer and inner vars on either side.  If it matches,
 * we set the transient flag outer_is_left to identify which side is which.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>clause_sides_match_join</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* lefthand side is outer */</comment>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* righthand side is outer */</comment>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* no good for these input relations */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * sort_inner_and_outer
 *	  Create mergejoin join paths by explicitly sorting both the outer and
 *	  inner join relations on each available merge ordering.
 *
 * 'joinrel' is the join relation
 * 'outerrel' is the outer join relation
 * 'innerrel' is the inner join relation
 * 'jointype' is the type of join to do
 * 'extra' contains additional input values
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_inner_and_outer</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>save_jointype</name> <init>= <expr><name>jointype</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outer_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>inner_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_outer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_safe_inner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only consider the cheapest-total-cost input paths, since we are
	 * assuming here that a sort is required.  We will consider
	 * cheapest-startup-cost input paths later, and only if they don't need a
	 * sort.
	 *
	 * This function intentionally does not consider parameterized input
	 * paths, except when the cheapest-total is parameterized.  If we did so,
	 * we'd have a combinatorial explosion of mergejoin paths of dubious
	 * value.  This interacts with decisions elsewhere that also discriminate
	 * against mergejoins with parameterized inputs; see comments in
	 * src/backend/optimizer/README.
	 */</comment>
	<expr_stmt><expr><name>outer_path</name> <operator>=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_path</name> <operator>=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If either cheapest-total path is parameterized by the other rel, we
	 * can't use a mergejoin.  (There's no use looking for alternative input
	 * paths, since these should already be the least-parameterized available
	 * paths.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If unique-ification is requested, do it and then handle as a plain
	 * inner join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_OUTER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>outer_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>,
												 <argument><expr><name>outer_path</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>inner_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
												 <argument><expr><name>inner_path</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the joinrel is parallel-safe, we may be able to consider a partial
	 * merge join.  However, we can't handle JOIN_UNIQUE_OUTER, because the
	 * outer path will be partial, and therefore we won't be able to properly
	 * guarantee uniqueness.  Similarly, we can't handle JOIN_FULL and
	 * JOIN_RIGHT, because they can produce false null extended rows.  Also,
	 * the resulting path must not be parameterized.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name>save_jointype</name> <operator>!=</operator> <name>JOIN_UNIQUE_OUTER</name> <operator>&amp;&amp;</operator>
		<name>save_jointype</name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
		<name>save_jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator>
		<name><name>outerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cheapest_partial_outer</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cheapest_safe_inner</name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>save_jointype</name> <operator>!=</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cheapest_safe_inner</name> <operator>=</operator>
				<call><name>get_cheapest_parallel_safe_total_inner</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Each possible ordering of the available mergejoin clauses will generate
	 * a differently-sorted result path at essentially the same cost.  We have
	 * no basis for choosing one over another at this level of joining, but
	 * some sort orders may be more useful than others for higher-level
	 * mergejoins, so it's worth considering multiple orderings.
	 *
	 * Actually, it's not quite true that every mergeclause ordering will
	 * generate a different path order, because some of the clauses may be
	 * partially redundant (refer to the same EquivalenceClasses).  Therefore,
	 * what we do is convert the mergeclause list to a list of canonical
	 * pathkeys, and then consider different orderings of the pathkeys.
	 *
	 * Generating a path for *every* permutation of the pathkeys doesn't seem
	 * like a winning strategy; the cost in planning time is too high. For
	 * now, we generate one path for each pathkey, listing that pathkey first
	 * and the rest in random order.  This should allow at least a one-clause
	 * mergejoin without re-sorting against any other possible mergejoin
	 * partner path.  But if we've not guessed the right ordering of secondary
	 * keys, we may end up evaluating clauses as qpquals when they could have
	 * been done as mergeclauses.  (In practice, it's rare that there's more
	 * than two or three mergeclauses, so expending a huge amount of thought
	 * on that is probably not worth it.)
	 *
	 * The pathkey order returned by select_outer_pathkeys_for_merge() has
	 * some heuristics behind it (see that function), so be sure to try it
	 * exactly as-is as well as making variants.
	 */</comment>
	<expr_stmt><expr><name>all_pathkeys</name> <operator>=</operator> <call><name>select_outer_pathkeys_for_merge</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>mergeclause_list</name></name></expr></argument>,
												   <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>all_pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>front_pathkey</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cur_mergeclauses</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outerkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>innerkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merge_pathkeys</name></decl>;</decl_stmt>

		<comment type="block">/* Make a pathkey list with this guy first */</comment>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>all_pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>outerkeys</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>front_pathkey</name></expr></argument>,
							  <argument><expr><call><name>list_delete_ptr</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>all_pathkeys</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>front_pathkey</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>outerkeys</name> <operator>=</operator> <name>all_pathkeys</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* no work at first one... */</comment>

		<comment type="block">/* Sort the mergeclauses into the corresponding ordering */</comment>
		<expr_stmt><expr><name>cur_mergeclauses</name> <operator>=</operator>
			<call><name>find_mergeclauses_for_outer_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>outerkeys</name></expr></argument>,
												 <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>mergeclause_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Should have used them all... */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>cur_mergeclauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>mergeclause_list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build sort pathkeys for the inner side */</comment>
		<expr_stmt><expr><name>innerkeys</name> <operator>=</operator> <call><name>make_inner_pathkeys_for_merge</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><name>cur_mergeclauses</name></expr></argument>,
												  <argument><expr><name>outerkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build pathkeys representing output sort order */</comment>
		<expr_stmt><expr><name>merge_pathkeys</name> <operator>=</operator> <call><name>build_join_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
											 <argument><expr><name>outerkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And now we can make the path.
		 *
		 * Note: it's possible that the cheapest paths will already be sorted
		 * properly.  try_mergejoin_path will detect that case and suppress an
		 * explicit sort step, so we needn't do so here.
		 */</comment>
		<expr_stmt><expr><call><name>try_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						   <argument><expr><name>joinrel</name></expr></argument>,
						   <argument><expr><name>outer_path</name></expr></argument>,
						   <argument><expr><name>inner_path</name></expr></argument>,
						   <argument><expr><name>merge_pathkeys</name></expr></argument>,
						   <argument><expr><name>cur_mergeclauses</name></expr></argument>,
						   <argument><expr><name>outerkeys</name></expr></argument>,
						   <argument><expr><name>innerkeys</name></expr></argument>,
						   <argument><expr><name>jointype</name></expr></argument>,
						   <argument><expr><name>extra</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have partial outer and parallel safe inner path then try
		 * partial mergejoin path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cheapest_partial_outer</name> <operator>&amp;&amp;</operator> <name>cheapest_safe_inner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>try_partial_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>joinrel</name></expr></argument>,
									   <argument><expr><name>cheapest_partial_outer</name></expr></argument>,
									   <argument><expr><name>cheapest_safe_inner</name></expr></argument>,
									   <argument><expr><name>merge_pathkeys</name></expr></argument>,
									   <argument><expr><name>cur_mergeclauses</name></expr></argument>,
									   <argument><expr><name>outerkeys</name></expr></argument>,
									   <argument><expr><name>innerkeys</name></expr></argument>,
									   <argument><expr><name>jointype</name></expr></argument>,
									   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * generate_mergejoin_paths
 *	Creates possible mergejoin paths for input outerpath.
 *
 * We generate mergejoins if mergejoin clauses are available.  We have
 * two ways to generate the inner path for a mergejoin: sort the cheapest
 * inner path, or use an inner path that is already suitably ordered for the
 * merge.  If we have several mergeclauses, it could be that there is no inner
 * path (or only a very expensive one) for the full list of mergeclauses, but
 * better paths exist if we truncate the mergeclause list (thereby discarding
 * some sort key requirements).  So, we consider truncations of the
 * mergeclause list as well as the full list.  (Ideally we'd consider all
 * subsets of the mergeclause list, but that seems way too expensive.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_mergejoin_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outerpath</name></decl></parameter>,
						 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>useallclauses</name></decl></parameter>,
						 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_cheapest_total</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>merge_pathkeys</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>is_partial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>innersortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>trialsortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_startup_inner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_total_inner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>save_jointype</name> <init>= <expr><name>jointype</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_sortkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sortkeycnt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_OUTER</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look for useful mergeclauses (if any) */</comment>
	<expr_stmt><expr><name>mergeclauses</name> <operator>=</operator>
		<call><name>find_mergeclauses_for_outer_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name><name>outerpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
											 <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>mergeclause_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Done with this outer path if no chance for a mergejoin.
	 *
	 * Special corner case: for "x FULL JOIN y ON true", there will be no join
	 * clauses at all.  Ordinarily we'd generate a clauseless nestloop path,
	 * but since mergejoin is our only join type that supports FULL JOIN
	 * without any join clauses, it's necessary to generate a clauseless
	 * mergejoin path instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mergeclauses</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
			 <comment type="block">/* okay to try for mergejoin */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>useallclauses</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>mergeclause_list</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Compute the required ordering of the inner path */</comment>
	<expr_stmt><expr><name>innersortkeys</name> <operator>=</operator> <call><name>make_inner_pathkeys_for_merge</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												  <argument><expr><name>mergeclauses</name></expr></argument>,
												  <argument><expr><name><name>outerpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate a mergejoin on the basis of sorting the cheapest inner. Since
	 * a sort will be needed, only cheapest total cost matters. (But
	 * try_mergejoin_path will do the right thing if inner_cheapest_total is
	 * already correctly sorted.)
	 */</comment>
	<expr_stmt><expr><call><name>try_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
					   <argument><expr><name>joinrel</name></expr></argument>,
					   <argument><expr><name>outerpath</name></expr></argument>,
					   <argument><expr><name>inner_cheapest_total</name></expr></argument>,
					   <argument><expr><name>merge_pathkeys</name></expr></argument>,
					   <argument><expr><name>mergeclauses</name></expr></argument>,
					   <argument><expr><name>NIL</name></expr></argument>,
					   <argument><expr><name>innersortkeys</name></expr></argument>,
					   <argument><expr><name>jointype</name></expr></argument>,
					   <argument><expr><name>extra</name></expr></argument>,
					   <argument><expr><name>is_partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't do anything else if inner path needs to be unique'd */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look for presorted inner paths that satisfy the innersortkey list ---
	 * or any truncation thereof, if we are allowed to build a mergejoin using
	 * a subset of the merge clauses.  Here, we consider both cheap startup
	 * cost and cheap total cost.
	 *
	 * Currently we do not consider parameterized inner paths here. This
	 * interacts with decisions elsewhere that also discriminate against
	 * mergejoins with parameterized inputs; see comments in
	 * src/backend/optimizer/README.
	 *
	 * As we shorten the sortkey list, we should consider only paths that are
	 * strictly cheaper than (in particular, not the same as) any path found
	 * in an earlier iteration.  Otherwise we'd be intentionally using fewer
	 * merge keys than a given path allows (treating the rest as plain
	 * joinquals), which is unlikely to be a good idea.  Also, eliminating
	 * paths here on the basis of compare_path_costs is a lot cheaper than
	 * building the mergejoin path only to throw it away.
	 *
	 * If inner_cheapest_total is well enough sorted to have not required a
	 * sort in the path made above, we shouldn't make a duplicate path with
	 * it, either.  We handle that case with the same logic that handles the
	 * previous consideration, by initializing the variables that track
	 * cheapest-so-far properly.  Note that we do NOT reject
	 * inner_cheapest_total if we find it matches some shorter set of
	 * pathkeys.  That case corresponds to using fewer mergekeys to avoid
	 * sorting inner_cheapest_total, whereas we did sort it above, so the
	 * plans being considered are different.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>,
							  <argument><expr><name><name>inner_cheapest_total</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* inner_cheapest_total didn't require a sort */</comment>
		<expr_stmt><expr><name>cheapest_startup_inner</name> <operator>=</operator> <name>inner_cheapest_total</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cheapest_total_inner</name> <operator>=</operator> <name>inner_cheapest_total</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* it did require a sort, at least for the full set of keys */</comment>
		<expr_stmt><expr><name>cheapest_startup_inner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cheapest_total_inner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>num_sortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_sortkeys</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>useallclauses</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>trialsortkeys</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* need modifiable copy */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>trialsortkeys</name> <operator>=</operator> <name>innersortkeys</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* won't really truncate */</comment>

	<for>for <control>(<init><expr><name>sortkeycnt</name> <operator>=</operator> <name>num_sortkeys</name></expr>;</init> <condition><expr><name>sortkeycnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>sortkeycnt</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>innerpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Look for an inner path ordered well enough for the first
		 * 'sortkeycnt' innersortkeys.  NB: trialsortkeys list is modified
		 * destructively, which is why we made a copy...
		 */</comment>
		<expr_stmt><expr><name>trialsortkeys</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>trialsortkeys</name></expr></argument>, <argument><expr><name>sortkeycnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>innerpath</name> <operator>=</operator> <call><name>get_cheapest_path_for_pathkeys</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
												   <argument><expr><name>trialsortkeys</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>TOTAL_COST</name></expr></argument>,
												   <argument><expr><name>is_partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>innerpath</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>cheapest_total_inner</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			 <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>innerpath</name></expr></argument>, <argument><expr><name>cheapest_total_inner</name></expr></argument>,
								<argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a cheap (or even-cheaper) sorted path */</comment>
			<comment type="block">/* Select the right mergeclauses, if we didn't already */</comment>
			<if_stmt><if>if <condition>(<expr><name>sortkeycnt</name> <operator>&lt;</operator> <name>num_sortkeys</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newclauses</name> <operator>=</operator>
					<call><name>trim_mergeclauses_for_inner_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>mergeclauses</name></expr></argument>,
														 <argument><expr><name>trialsortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newclauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newclauses</name> <operator>=</operator> <name>mergeclauses</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>try_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							   <argument><expr><name>joinrel</name></expr></argument>,
							   <argument><expr><name>outerpath</name></expr></argument>,
							   <argument><expr><name>innerpath</name></expr></argument>,
							   <argument><expr><name>merge_pathkeys</name></expr></argument>,
							   <argument><expr><name>newclauses</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>,
							   <argument><expr><name>jointype</name></expr></argument>,
							   <argument><expr><name>extra</name></expr></argument>,
							   <argument><expr><name>is_partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cheapest_total_inner</name> <operator>=</operator> <name>innerpath</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Same on the basis of cheapest startup cost ... */</comment>
		<expr_stmt><expr><name>innerpath</name> <operator>=</operator> <call><name>get_cheapest_path_for_pathkeys</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
												   <argument><expr><name>trialsortkeys</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>STARTUP_COST</name></expr></argument>,
												   <argument><expr><name>is_partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>innerpath</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>cheapest_startup_inner</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			 <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>innerpath</name></expr></argument>, <argument><expr><name>cheapest_startup_inner</name></expr></argument>,
								<argument><expr><name>STARTUP_COST</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a cheap (or even-cheaper) sorted path */</comment>
			<if_stmt><if>if <condition>(<expr><name>innerpath</name> <operator>!=</operator> <name>cheapest_total_inner</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Avoid rebuilding clause list if we already made one; saves
				 * memory in big join trees...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>newclauses</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>sortkeycnt</name> <operator>&lt;</operator> <name>num_sortkeys</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>newclauses</name> <operator>=</operator>
							<call><name>trim_mergeclauses_for_inner_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																 <argument><expr><name>mergeclauses</name></expr></argument>,
																 <argument><expr><name>trialsortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newclauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>newclauses</name> <operator>=</operator> <name>mergeclauses</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>try_mergejoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name>joinrel</name></expr></argument>,
								   <argument><expr><name>outerpath</name></expr></argument>,
								   <argument><expr><name>innerpath</name></expr></argument>,
								   <argument><expr><name>merge_pathkeys</name></expr></argument>,
								   <argument><expr><name>newclauses</name></expr></argument>,
								   <argument><expr><name>NIL</name></expr></argument>,
								   <argument><expr><name>NIL</name></expr></argument>,
								   <argument><expr><name>jointype</name></expr></argument>,
								   <argument><expr><name>extra</name></expr></argument>,
								   <argument><expr><name>is_partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cheapest_startup_inner</name> <operator>=</operator> <name>innerpath</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Don't consider truncated sortkeys if we need all clauses.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>useallclauses</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * match_unsorted_outer
 *	  Creates possible join paths for processing a single join relation
 *	  'joinrel' by employing either iterative substitution or
 *	  mergejoining on each of its possible outer paths (considering
 *	  only outer paths that are already ordered well enough for merging).
 *
 * We always generate a nestloop path for each available outer path.
 * In fact we may generate as many as five: one on the cheapest-total-cost
 * inner path, one on the same with materialization, one on the
 * cheapest-startup-cost inner path (if different), one on the
 * cheapest-total inner-indexscan path (if any), and one on the
 * cheapest-startup inner-indexscan path (if different).
 *
 * We also consider mergejoins if mergejoin clauses are available.  See
 * detailed comments in generate_mergejoin_paths.
 *
 * 'joinrel' is the join relation
 * 'outerrel' is the outer join relation
 * 'innerrel' is the inner join relation
 * 'jointype' is the type of join to do
 * 'extra' contains additional input values
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>match_unsorted_outer</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>save_jointype</name> <init>= <expr><name>jointype</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nestjoinOK</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useallclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>inner_cheapest_total</name> <init>= <expr><name><name>innerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>matpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nestloop only supports inner, left, semi, and anti joins.  Also, if we
	 * are doing a right or full mergejoin, we must use *all* the mergeclauses
	 * as join clauses, else we will not have a valid plan.  (Although these
	 * two flags are currently inverses, keep them separate for clarity and
	 * possible future changes.)
	 */</comment>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<expr_stmt><expr><name>nestjoinOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>useallclauses</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name>nestjoinOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>useallclauses</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_UNIQUE_OUTER</name></expr>:</case>
		<case>case <expr><name>JOIN_UNIQUE_INNER</name></expr>:</case>
			<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nestjoinOK</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>useallclauses</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nestjoinOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>useallclauses</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If inner_cheapest_total is parameterized by the outer rel, ignore it;
	 * we will consider it below as a member of cheapest_parameterized_paths,
	 * but the other possibilities considered in this routine aren't usable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>inner_cheapest_total</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_cheapest_total</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to unique-ify the inner path, we will consider only the
	 * cheapest-total inner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No way to do this with an inner path parameterized by outer rel */</comment>
		<if_stmt><if>if <condition>(<expr><name>inner_cheapest_total</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>inner_cheapest_total</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>inner_cheapest_total</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>inner_cheapest_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nestjoinOK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Consider materializing the cheapest inner path, unless
		 * enable_material is off or the path in question materializes its
		 * output anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_material</name> <operator>&amp;&amp;</operator> <name>inner_cheapest_total</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ExecMaterializesOutput</name><argument_list>(<argument><expr><name><name>inner_cheapest_total</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>matpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_material_path</name><argument_list>(<argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>inner_cheapest_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>outerrel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merge_pathkeys</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We cannot use an outer path that is parameterized by the inner rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>outerpath</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we need to unique-ify the outer path, it's pointless to consider
		 * any but the cheapest outer.  (XXX we don't consider parameterized
		 * outers, nor inners, for unique-ified cases.  Should we?)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_OUTER</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>outerpath</name> <operator>!=</operator> <name><name>outerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>outerpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>,
													<argument><expr><name>outerpath</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outerpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The result will have this sort order (even if it is implemented as
		 * a nestloop, and even if some of the mergeclauses are implemented by
		 * qpquals rather than as true mergeclauses):
		 */</comment>
		<expr_stmt><expr><name>merge_pathkeys</name> <operator>=</operator> <call><name>build_join_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
											 <argument><expr><name><name>outerpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Consider nestloop join, but only with the unique-ified cheapest
			 * inner path
			 */</comment>
			<expr_stmt><expr><call><name>try_nestloop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							  <argument><expr><name>joinrel</name></expr></argument>,
							  <argument><expr><name>outerpath</name></expr></argument>,
							  <argument><expr><name>inner_cheapest_total</name></expr></argument>,
							  <argument><expr><name>merge_pathkeys</name></expr></argument>,
							  <argument><expr><name>jointype</name></expr></argument>,
							  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>nestjoinOK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Consider nestloop joins using this outer path and various
			 * available paths for the inner relation.  We consider the
			 * cheapest-total paths for each available parameterization of the
			 * inner relation, including the unparameterized case.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>innerrel-&gt;cheapest_parameterized_paths</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>innerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>try_nestloop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>outerpath</name></expr></argument>,
								  <argument><expr><name>innerpath</name></expr></argument>,
								  <argument><expr><name>merge_pathkeys</name></expr></argument>,
								  <argument><expr><name>jointype</name></expr></argument>,
								  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* Also consider materialized form of the cheapest inner path */</comment>
			<if_stmt><if>if <condition>(<expr><name>matpath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>try_nestloop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>outerpath</name></expr></argument>,
								  <argument><expr><name>matpath</name></expr></argument>,
								  <argument><expr><name>merge_pathkeys</name></expr></argument>,
								  <argument><expr><name>jointype</name></expr></argument>,
								  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Can't do anything else if outer path needs to be unique'd */</comment>
		<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_OUTER</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Can't do anything else if inner rel is parameterized by outer */</comment>
		<if_stmt><if>if <condition>(<expr><name>inner_cheapest_total</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Generate merge join paths */</comment>
		<expr_stmt><expr><call><name>generate_mergejoin_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>outerpath</name></expr></argument>,
								 <argument><expr><name>save_jointype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>useallclauses</name></expr></argument>,
								 <argument><expr><name>inner_cheapest_total</name></expr></argument>, <argument><expr><name>merge_pathkeys</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Consider partial nestloop and mergejoin plan if outerrel has any
	 * partial path and the joinrel is parallel-safe.  However, we can't
	 * handle JOIN_UNIQUE_OUTER, because the outer path will be partial, and
	 * therefore we won't be able to properly guarantee uniqueness.  Nor can
	 * we handle extra_lateral_rels, since partial paths must not be
	 * parameterized. Similarly, we can't handle JOIN_FULL and JOIN_RIGHT,
	 * because they can produce false null extended rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<name>save_jointype</name> <operator>!=</operator> <name>JOIN_UNIQUE_OUTER</name> <operator>&amp;&amp;</operator>
		<name>save_jointype</name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
		<name>save_jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator>
		<name><name>outerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nestjoinOK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>consider_parallel_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
									   <argument><expr><name>save_jointype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If inner_cheapest_total is NULL or non parallel-safe then find the
		 * cheapest total parallel safe path.  If doing JOIN_UNIQUE_INNER, we
		 * can't use any alternative inner path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inner_cheapest_total</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>!</operator><name><name>inner_cheapest_total</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>inner_cheapest_total</name> <operator>=</operator> <call><name>get_cheapest_parallel_safe_total_inner</name><argument_list>(
																		  <argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>inner_cheapest_total</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>consider_parallel_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
										<argument><expr><name>save_jointype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>,
										<argument><expr><name>inner_cheapest_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * consider_parallel_mergejoin
 *	  Try to build partial paths for a joinrel by joining a partial path
 *	  for the outer relation to a complete path for the inner relation.
 *
 * 'joinrel' is the join relation
 * 'outerrel' is the outer join relation
 * 'innerrel' is the inner join relation
 * 'jointype' is the type of join to do
 * 'extra' contains additional input values
 * 'inner_cheapest_total' cheapest total path for innerrel
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consider_parallel_mergejoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_cheapest_total</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/* generate merge join path for each partial outer path */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>outerrel-&gt;partial_pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>merge_pathkeys</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Figure out what useful ordering any paths we create will have.
		 */</comment>
		<expr_stmt><expr><name>merge_pathkeys</name> <operator>=</operator> <call><name>build_join_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
											 <argument><expr><name><name>outerpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>generate_mergejoin_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>, <argument><expr><name>outerpath</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
								 <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>inner_cheapest_total</name></expr></argument>,
								 <argument><expr><name>merge_pathkeys</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * consider_parallel_nestloop
 *	  Try to build partial paths for a joinrel by joining a partial path for the
 *	  outer relation to a complete path for the inner relation.
 *
 * 'joinrel' is the join relation
 * 'outerrel' is the outer join relation
 * 'innerrel' is the inner join relation
 * 'jointype' is the type of join to do
 * 'extra' contains additional input values
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consider_parallel_nestloop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
						   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						   <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>save_jointype</name> <init>= <expr><name>jointype</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>outerrel-&gt;partial_pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Figure out what useful ordering any paths we create will have. */</comment>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <call><name>build_join_pathkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
									   <argument><expr><name><name>outerpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try the cheapest parameterized paths; only those which will produce
		 * an unparameterized path when joined to this outerrel will survive
		 * try_partial_nestloop_path.  The cheapest unparameterized path is
		 * also in this list.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>innerrel-&gt;cheapest_parameterized_paths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>innerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Can't join to an inner path that is not parallel-safe */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>innerpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we're doing JOIN_UNIQUE_INNER, we can only use the inner's
			 * cheapest_total_path, and we have to unique-ify it.  (We might
			 * be able to relax this to allow other safe, unparameterized
			 * inner paths, but right now create_unique_path is not on board
			 * with that.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>save_jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>innerpath</name> <operator>!=</operator> <name><name>innerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>innerpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
														<argument><expr><name>innerpath</name></expr></argument>,
														<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>innerpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>try_partial_nestloop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outerpath</name></expr></argument>, <argument><expr><name>innerpath</name></expr></argument>,
									  <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * hash_inner_and_outer
 *	  Create hashjoin join paths by explicitly hashing both the outer and
 *	  inner keys of each available hash clause.
 *
 * 'joinrel' is the join relation
 * 'outerrel' is the outer join relation
 * 'innerrel' is the inner join relation
 * 'jointype' is the type of join to do
 * 'extra' contains additional input values
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_inner_and_outer</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
					 <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>save_jointype</name> <init>= <expr><name>jointype</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isouterjoin</name> <init>= <expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to build only one hashclauses list for any given pair of outer
	 * and inner relations; all of the hashable clauses will be used as keys.
	 *
	 * Scan the join's restrictinfo list to find hashjoinable clauses that are
	 * usable with this pair of sub-relations.
	 */</comment>
	<expr_stmt><expr><name>hashclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>extra-&gt;restrictlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If processing an outer join, only use its own join clauses for
		 * hashing.  For inner joins we need not be so picky.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isouterjoin</name> <operator>&amp;&amp;</operator> <call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name> <operator>||</operator>
			<name><name>restrictinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not hashjoinable */</comment>

		<comment type="block">/*
		 * Check if clause has the form "outer op inner" or "inner op outer".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clause_sides_match_join</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no good for these input relations */</comment>

		<expr_stmt><expr><name>hashclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* If we found any usable hashclauses, make paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>hashclauses</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We consider both the cheapest-total-cost and cheapest-startup-cost
		 * outer paths.  There's no need to consider any but the
		 * cheapest-total-cost inner path, however.
		 */</comment>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_startup_outer</name> <init>= <expr><name><name>outerrel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_total_outer</name> <init>= <expr><name><name>outerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_total_inner</name> <init>= <expr><name><name>innerrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If either cheapest-total path is parameterized by the other rel, we
		 * can't use a hashjoin.  (There's no use looking for alternative
		 * input paths, since these should already be the least-parameterized
		 * available paths.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>cheapest_total_outer</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>cheapest_total_inner</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Unique-ify if need be; we ignore parameterized possibilities */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_OUTER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cheapest_total_outer</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>,
								   <argument><expr><name>cheapest_total_outer</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cheapest_total_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>try_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							  <argument><expr><name>joinrel</name></expr></argument>,
							  <argument><expr><name>cheapest_total_outer</name></expr></argument>,
							  <argument><expr><name>cheapest_total_inner</name></expr></argument>,
							  <argument><expr><name>hashclauses</name></expr></argument>,
							  <argument><expr><name>jointype</name></expr></argument>,
							  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* no possibility of cheap startup here */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cheapest_total_inner</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>,
								   <argument><expr><name>cheapest_total_inner</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cheapest_total_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>try_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							  <argument><expr><name>joinrel</name></expr></argument>,
							  <argument><expr><name>cheapest_total_outer</name></expr></argument>,
							  <argument><expr><name>cheapest_total_inner</name></expr></argument>,
							  <argument><expr><name>hashclauses</name></expr></argument>,
							  <argument><expr><name>jointype</name></expr></argument>,
							  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cheapest_startup_outer</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name>cheapest_startup_outer</name> <operator>!=</operator> <name>cheapest_total_outer</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>try_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>cheapest_startup_outer</name></expr></argument>,
								  <argument><expr><name>cheapest_total_inner</name></expr></argument>,
								  <argument><expr><name>hashclauses</name></expr></argument>,
								  <argument><expr><name>jointype</name></expr></argument>,
								  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For other jointypes, we consider the cheapest startup outer
			 * together with the cheapest total inner, and then consider
			 * pairings of cheapest-total paths including parameterized ones.
			 * There is no use in generating parameterized paths on the basis
			 * of possibly cheap startup cost, so this is sufficient.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>cheapest_startup_outer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>try_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>joinrel</name></expr></argument>,
								  <argument><expr><name>cheapest_startup_outer</name></expr></argument>,
								  <argument><expr><name>cheapest_total_inner</name></expr></argument>,
								  <argument><expr><name>hashclauses</name></expr></argument>,
								  <argument><expr><name>jointype</name></expr></argument>,
								  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>outerrel-&gt;cheapest_parameterized_paths</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>outerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * We cannot use an outer path that is parameterized by the
				 * inner rel.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>outerpath</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>innerrel-&gt;cheapest_parameterized_paths</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>innerpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * We cannot use an inner path that is parameterized by
					 * the outer rel, either.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>PATH_PARAM_BY_REL</name><argument_list>(<argument><expr><name>innerpath</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>outerpath</name> <operator>==</operator> <name>cheapest_startup_outer</name> <operator>&amp;&amp;</operator>
						<name>innerpath</name> <operator>==</operator> <name>cheapest_total_inner</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* already tried it */</comment>

					<expr_stmt><expr><call><name>try_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>joinrel</name></expr></argument>,
									  <argument><expr><name>outerpath</name></expr></argument>,
									  <argument><expr><name>innerpath</name></expr></argument>,
									  <argument><expr><name>hashclauses</name></expr></argument>,
									  <argument><expr><name>jointype</name></expr></argument>,
									  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If the joinrel is parallel-safe, we may be able to consider a
		 * partial hash join.  However, we can't handle JOIN_UNIQUE_OUTER,
		 * because the outer path will be partial, and therefore we won't be
		 * able to properly guarantee uniqueness.  Similarly, we can't handle
		 * JOIN_FULL and JOIN_RIGHT, because they can produce false null
		 * extended rows.  Also, the resulting path must not be parameterized.
		 * We would be able to support JOIN_FULL and JOIN_RIGHT for Parallel
		 * Hash, since in that case we're back to a single hash table with a
		 * single set of match bits for each batch, but that will require
		 * figuring out a deadlock-free way to wait for the probe to finish.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
			<name>save_jointype</name> <operator>!=</operator> <name>JOIN_UNIQUE_OUTER</name> <operator>&amp;&amp;</operator>
			<name>save_jointype</name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
			<name>save_jointype</name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator>
			<name><name>outerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_outer</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_inner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_safe_inner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>cheapest_partial_outer</name> <operator>=</operator>
				<operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Can we use a partial inner plan too, so that we can build a
			 * shared hash table in parallel?  We can't handle
			 * JOIN_UNIQUE_INNER because we can't guarantee uniqueness.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>innerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
				<name>save_jointype</name> <operator>!=</operator> <name>JOIN_UNIQUE_INNER</name> <operator>&amp;&amp;</operator>
				<name>enable_parallel_hash</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cheapest_partial_inner</name> <operator>=</operator>
					<operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>try_partial_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
										  <argument><expr><name>cheapest_partial_outer</name></expr></argument>,
										  <argument><expr><name>cheapest_partial_inner</name></expr></argument>,
										  <argument><expr><name>hashclauses</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument> <comment type="block">/* parallel_hash */</comment> )</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Normally, given that the joinrel is parallel-safe, the cheapest
			 * total inner path will also be parallel-safe, but if not, we'll
			 * have to search for the cheapest safe, unparameterized inner
			 * path.  If doing JOIN_UNIQUE_INNER, we can't use any alternative
			 * inner path.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cheapest_total_inner</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cheapest_safe_inner</name> <operator>=</operator> <name>cheapest_total_inner</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>save_jointype</name> <operator>!=</operator> <name>JOIN_UNIQUE_INNER</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cheapest_safe_inner</name> <operator>=</operator>
					<call><name>get_cheapest_parallel_safe_total_inner</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>cheapest_safe_inner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>try_partial_hashjoin_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
										  <argument><expr><name>cheapest_partial_outer</name></expr></argument>,
										  <argument><expr><name>cheapest_safe_inner</name></expr></argument>,
										  <argument><expr><name>hashclauses</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument> <comment type="block">/* parallel_hash */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * select_mergejoin_clauses
 *	  Select mergejoin clauses that are usable for a particular join.
 *	  Returns a list of RestrictInfo nodes for those clauses.
 *
 * *mergejoin_allowed is normally set to true, but it is set to false if
 * this is a right/full join and there are nonmergejoinable join clauses.
 * The executor's mergejoin machinery cannot handle such cases, so we have
 * to avoid generating a mergejoin plan.  (Note that this flag does NOT
 * consider whether there are actually any mergejoinable clauses.  This is
 * correct because in some cases we need to build a clauseless mergejoin.
 * Simply returning NIL is therefore not enough to distinguish safe from
 * unsafe cases.)
 *
 * We also mark each selected RestrictInfo to show which side is currently
 * being considered as outer.  These are transient markings that are only
 * good for the duration of the current add_paths_to_joinrel() call!
 *
 * We examine each restrictinfo clause known for the join to see
 * if it is mergejoinable and involves vars from the two sub-relations
 * currently of interest.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>select_mergejoin_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
						 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>,
						 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergejoin_allowed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isouterjoin</name> <init>= <expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_nonmergeable_joinclause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If processing an outer join, only use its own join clauses in the
		 * merge.  For inner joins we can use pushed-down clauses too. (Note:
		 * we don't set have_nonmergeable_joinclause here because pushed-down
		 * clauses will become otherquals not joinquals.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isouterjoin</name> <operator>&amp;&amp;</operator> <call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check that clause is a mergeable operator clause */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name> <operator>||</operator>
			<name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The executor can handle extra joinquals that are constants, but
			 * not anything else, when doing right/full merge join.  (The
			 * reason to support constants is so we can do FULL JOIN ON
			 * FALSE.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_nonmergeable_joinclause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>			<comment type="block">/* not mergejoinable */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check if clause has the form "outer op inner" or "inner op outer".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clause_sides_match_join</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name>outerrel</name></expr></argument>, <argument><expr><name>innerrel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_nonmergeable_joinclause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>			<comment type="block">/* no good for these input relations */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Insist that each side have a non-redundant eclass.  This
		 * restriction is needed because various bits of the planner expect
		 * that each clause in a merge be associable with some pathkey in a
		 * canonical pathkey list, but redundant eclasses can't appear in
		 * canonical sort orderings.  (XXX it might be worth relaxing this,
		 * but not enough time to address it for 8.3.)
		 *
		 * Note: it would be bad if this condition failed for an otherwise
		 * mergejoinable FULL JOIN clause, since that would result in
		 * undesirable planner failure.  I believe that is not possible
		 * however; a variable involved in a full join could only appear in
		 * below_outer_join eclasses, which aren't considered redundant.
		 *
		 * This case *can* happen for left/right join clauses: the outer-side
		 * variable could be equated to a constant.  Because we will propagate
		 * that constant across the join clause, the loss of ability to do a
		 * mergejoin is not really all that big a deal, and so it's not clear
		 * that improving this is important.
		 */</comment>
		<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>EC_MUST_BE_REDUNDANT</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>EC_MUST_BE_REDUNDANT</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_nonmergeable_joinclause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>			<comment type="block">/* can't handle redundant eclasses */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result_list</name></expr></argument>, <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Report whether mergejoin is allowed (see comment at top of function).
	 */</comment>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>mergejoin_allowed</name> <operator>=</operator> <operator>!</operator><name>have_nonmergeable_joinclause</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><operator>*</operator><name>mergejoin_allowed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result_list</name></expr>;</return>
</block_content>}</block></function>
</unit>
