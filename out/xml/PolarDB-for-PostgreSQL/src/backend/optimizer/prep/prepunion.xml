<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/prep/prepunion.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * prepunion.c
 *	  Routines to plan set-operation queries.  The filename is a leftover
 *	  from a time when only UNIONs were implemented.
 *
 * There are two code paths in the planner for set-operation queries.
 * If a subquery consists entirely of simple UNION ALL operations, it
 * is converted into an "append relation".  Otherwise, it is handled
 * by the general code in this module (plan_set_operations and its
 * subroutines).  There is some support code here for the append-relation
 * case, but most of the heavy lifting for that is done elsewhere,
 * notably in prepjointree.c and allpaths.c.
 *
 * There is also some code here to support planning of queries that use
 * inheritance (SELECT FROM foo*).  Inheritance trees are converted into
 * append relations, and thenceforth share code with the UNION ALL case.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/prep/prepunion.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
}</block></struct></type> <name>adjust_appendrel_attrs_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>recurse_set_operations</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>,
					   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pNumGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>generate_recursion_path</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>,
						<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>generate_union_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>generate_nonunion_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>plan_union_children</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>top_union</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>make_union_unique</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				  <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>postprocess_setop_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>choose_hashed_setop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>,
					<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>input_path</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dNumOutputRows</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>construct</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>hack_constants</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_append_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlists</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_setop_grouplist</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_inherited_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_partitioned_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
						   <parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_single_inheritance_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
								<parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
								<parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>childrel</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>childrte_p</name></decl></parameter>,
								<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>childRTindex_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_inh_translation_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>oldrelation</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>newrelation</name></decl></parameter>,
						  <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>translate_col_privs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>parent_privs</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>adjust_appendrel_attrs_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>adjust_appendrel_attrs_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>adjust_child_relids</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>,
					<parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>adjust_inherited_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * plan_set_operations
 *
 *	  Plans the queries for a tree of set operations (UNION/INTERSECT/EXCEPT)
 *
 * This routine only deals with the setOperations tree of the given query.
 * Any top-level ORDER BY requested in root-&gt;parse-&gt;sortClause will be handled
 * when we return to grouping_planner; likewise for LIMIT.
 *
 * What we return is an "upperrel" RelOptInfo containing at least one Path
 * that implements the set-operation tree.  In addition, root-&gt;processed_tlist
 * receives a targetlist representing the output of the topmost setop node.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>plan_set_operations</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>topop</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftmostRTE</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>setop_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>top_tlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>topop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check for unsupported stuff */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'll need to build RelOptInfos for each of the leaf subqueries, which
	 * are RTE_SUBQUERY rangetable entries in this Query.  Prepare the index
	 * arrays for that.
	 */</comment>
	<expr_stmt><expr><call><name>setup_simple_rel_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Populate append_rel_array with each AppendRelInfo to allow direct
	 * lookups by child relid.
	 */</comment>
	<expr_stmt><expr><call><name>setup_append_rel_array</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the leftmost component Query.  We need to use its column names for
	 * all generated tlists (else SELECT INTO won't work right).
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>topop</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostRTE</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <name><name>leftmostRTE</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the topmost node is a recursive union, it needs special processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>setop_rel</name> <operator>=</operator> <call><name>generate_recursion_path</name><argument_list>(<argument><expr><name>topop</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
											<argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>top_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Recurse on setOperations tree to generate paths for set ops. The
		 * final output paths should have just the column types shown as the
		 * output from the top-level node, plus possibly resjunk working
		 * columns (we can rely on upper-level nodes to deal with that).
		 */</comment>
		<expr_stmt><expr><name>setop_rel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>topop</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>top_tlist</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Must return the built tlist into root-&gt;processed_tlist. */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>top_tlist</name></expr>;</expr_stmt>

	<return>return <expr><name>setop_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * recurse_set_operations
 *	  Recursively handle one step in a tree of set operations
 *
 * colTypes: OID list of set-op's result column datatypes
 * colCollations: OID list of set-op's result column collations
 * junkOK: if true, child resjunk columns may be left in the result
 * flag: if &gt;= 0, add a resjunk output column indicating value of flag
 * refnames_tlist: targetlist to take column names from
 *
 * Returns a RelOptInfo for the subtree, as well as these output parameters:
 * *pTargetList: receives the fully-fledged tlist for the subtree's top plan
 * *pNumGroups: if not NULL, we estimate the number of distinct groups
 *		in the result, and store it there
 *
 * The pTargetList output parameter is mostly redundant with the pathtarget
 * of the returned RelOptInfo, but for the moment we need it because much of
 * the logic in this file depends on flag columns being marked resjunk.
 * Pending a redesign of how that works, this is the easy way out.
 *
 * We don't have to care about typmods here: the only allowed difference
 * between set-op input and output typmods is input is a specific typmod
 * and output is -1, and that does not require a coercion.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>recurse_set_operations</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>,
					   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* keep compiler quiet */</comment>

	<comment type="block">/* Guard against stack overflow due to overly complex setop nests */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build a RelOptInfo for this leaf subquery. */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan_params should not be in use in current query level */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate a subroot and Paths for the subquery */</comment>
		<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
												  <argument><expr><name>root</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>,
												  <argument><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It should not be possible for the primitive query to contain any
		 * cross-references to other primitive queries in the setop tree.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected outer reference in set operation subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Figure out the appropriate target list for this subquery. */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_setop_tlist</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>colCollations</name></expr></argument>,
									 <argument><expr><name>flag</name></expr></argument>,
									 <argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>,
									 <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return the fully-fledged tlist to caller, too */</comment>
		<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark rel with estimated output rows, width, etc.  Note that we have
		 * to do this before generating outer-query paths, else
		 * cost_subqueryscan is not happy.
		 */</comment>
		<expr_stmt><expr><call><name>set_subquery_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since we may want to add a partial path to this relation, we must
		 * set its consider_parallel flag correctly.
		 */</comment>
		<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For the moment, we consider only a single Path for the subquery.
		 * This should change soon (make it look more like
		 * set_subquery_pathlist).
		 */</comment>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>get_cheapest_fractional_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>,
											   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Stick a SubqueryScanPath atop that.
		 *
		 * We don't bother to determine the subquery's output ordering since
		 * it won't be reflected in the set-op result anyhow; so just label
		 * the SubqueryScanPath with nil pathkeys.  (XXX that should change
		 * soon too, likely.)
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
												 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have a partial path for the child relation, we can use that
		 * to build a partial path for this relation.  But there's no point in
		 * considering any path but the cheapest.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>partial_subpath</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>partial_path</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partial_subpath</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partial_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partial_subpath</name></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Estimate number of groups if caller wants it.  If the subquery used
		 * grouping or aggregation, its output is probably mostly unique
		 * anyway; otherwise do statistical estimation.
		 *
		 * XXX you don't really want to know about this: we do the estimation
		 * using the subquery's original targetlist expressions, not the
		 * subroot-&gt;processed_tlist which might seem more appropriate.  The
		 * reason is that if the subquery is itself a setop, it may return a
		 * processed_tlist containing "varno 0" Vars generated by
		 * generate_append_tlist, and those would confuse estimate_num_groups
		 * mightily.  We ought to get rid of the "varno 0" hack, but that
		 * requires a redesign of the parsetree representation of setops, so
		 * that there can be an RTE corresponding to each setop's output.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>pNumGroups</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
				<name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
				<name><name>subroot</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>||</operator> <name><name>subquery</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>pNumGroups</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>pNumGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>,
												  <argument><expr><call><name>get_tlist_exprs</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* UNIONs are much different from INTERSECT/EXCEPT */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>generate_union_paths</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>refnames_tlist</name></expr></argument>,
									   <argument><expr><name>pTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>generate_nonunion_paths</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>refnames_tlist</name></expr></argument>,
										  <argument><expr><name>pTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>pNumGroups</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>pNumGroups</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If necessary, add a Result node to project the caller-requested
		 * output columns.
		 *
		 * XXX you don't really want to know about this: setrefs.c will apply
		 * fix_upper_expr() to the Result node's tlist. This would fail if the
		 * Vars generated by generate_setop_tlist() were not exactly equal()
		 * to the corresponding tlist entries of the subplan. However, since
		 * the subplan was generated by generate_union_plan() or
		 * generate_nonunion_plan(), and hence its tlist was generated by
		 * generate_append_tlist(), this will work.  We just tell
		 * generate_setop_tlist() to use varno 0.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><call><name>tlist_same_datatypes</name><argument_list>(<argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>, <argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>junkOK</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>tlist_same_collations</name><argument_list>(<argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>, <argument><expr><name>colCollations</name></expr></argument>, <argument><expr><name>junkOK</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <call><name>generate_setop_tlist</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>colCollations</name></expr></argument>,
												<argument><expr><name>flag</name></expr></argument>,
												<argument><expr><literal type="number">0</literal></expr></argument>,
												<argument><expr><name>false</name></expr></argument>,
												<argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>,
												<argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>*</operator><name>pTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Apply projection to each path */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
												<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* If we had to add a Result, path is different from subpath */</comment>
				<if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>subpath</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* Apply projection to each partial path */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* avoid apply_projection_to_path, in case of multiple refs */</comment>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
													   <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>postprocess_setop_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate paths for a recursive UNION node
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>generate_recursion_path</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>lrel</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>lpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>rpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lpath_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rpath_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>

	<comment type="block">/* Parser should have rejected other cases */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>setOp</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only UNION queries can be recursive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Worktable ID should be assigned */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unlike a regular UNION node, process the left and right inputs
	 * separately without any intention of combining them into one Append.
	 */</comment>
	<expr_stmt><expr><name>lrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>lpath_tlist</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpath</name> <operator>=</operator> <name><name>lrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<comment type="block">/* The right path will want to look at the left one ... */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>lpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>rpath_tlist</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpath</name> <operator>=</operator> <name><name>rrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate tlist for RecursiveUnion path node --- same as in Append cases
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_append_tlist</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lpath_tlist</name></expr></argument>, <argument><expr><name>rpath_tlist</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Build result relation. */</comment>
	<expr_stmt><expr><name>result_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>,
								 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If UNION, identify the grouping operators
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>setOp</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>groupList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Identify the grouping semantics */</comment>
		<expr_stmt><expr><name>groupList</name> <operator>=</operator> <call><name>generate_setop_grouplist</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We only support hashing here */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name>groupList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement recursive UNION"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"All column datatypes must be hashable."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For the moment, take the number of distinct groups as equal to the
		 * total input size, ie, the worst case.
		 */</comment>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name><name>lpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>+</operator> <name><name>rpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * And make the path node.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_recursiveunion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>result_rel</name></expr></argument>,
											   <argument><expr><name>lpath</name></expr></argument>,
											   <argument><expr><name>rpath</name></expr></argument>,
											   <argument><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
											   <argument><expr><name>groupList</name></expr></argument>,
											   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name></expr></argument>,
											   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>postprocess_setop_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate paths for a UNION or UNION ALL node
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>generate_union_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>save_fraction</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pathlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partial_pathlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partial_paths_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>consider_parallel</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rellist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If plain UNION, tell children to fetch all tuples.
	 *
	 * Note: in UNION ALL, we pass the top-level tuple_fraction unmodified to
	 * each arm of the UNION ALL.  One could make a case for reducing the
	 * tuple fraction for later arms (discounting by the expected size of the
	 * earlier arms' results) but it seems not worth the trouble. The normal
	 * case where tuple_fraction isn't already zero is a LIMIT at top level,
	 * and passing it down as-is is usually enough to get the desired result
	 * of preferring fast-start plans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If any of my children are identical UNION nodes (same op, all-flag, and
	 * colTypes) then they can be merged into this node so that we generate
	 * only one Append and unique-ification for the lot.  Recurse to find such
	 * nodes and compute their children's paths.
	 */</comment>
	<expr_stmt><expr><name>rellist</name> <operator>=</operator> <call><name>plan_union_children</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>refnames_tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlist_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate tlist for Append plan node.
	 *
	 * The tlist for an Append plan isn't important as far as the Append is
	 * concerned, but we must make it look real anyway for the benefit of the
	 * next plan level up.
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_append_tlist</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>tlist_list</name></expr></argument>, <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Build path lists and relid set. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rellist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pathlist</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>consider_parallel</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>consider_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>partial_paths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>partial_paths_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>partial_pathlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>partial_pathlist</name></expr></argument>,
										   <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Build result relation. */</comment>
	<expr_stmt><expr><name>result_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>consider_parallel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Append the child results together.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>pathlist</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For UNION ALL, we just need the Append path.  For UNION, need to add
	 * node(s) to remove duplicates.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>make_union_unique</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of groups.  For now we just assume the output is unique
	 * --- this is certainly true for the UNION case, and we want worst-case
	 * estimates anyway.
	 */</comment>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now consider doing the same thing using the partial paths plus Append
	 * plus Gather.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partial_paths_valid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>ppath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find the highest number of workers requested for any subpath. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the use of parallel append is permitted, always request at least
		 * log2(# of children) paths.  We assume it can be useful to have
		 * extra workers in this case because they will be spread out across
		 * the children.  The precise formula is just a guess; see
		 * add_paths_to_append_rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_parallel_append</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
								   <argument><expr><call><name>fls</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>partial_pathlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>,
								   <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ppath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>partial_pathlist</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>enable_parallel_append</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ppath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_gather_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>ppath</name></expr></argument>,
							   <argument><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ppath</name> <operator>=</operator> <call><name>make_union_unique</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>ppath</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>ppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Undo effects of possibly forcing tuple_fraction to 0 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <name>save_fraction</name></expr>;</expr_stmt>

	<return>return <expr><name>result_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate paths for an INTERSECT, INTERSECT ALL, EXCEPT, or EXCEPT ALL node
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>generate_nonunion_paths</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>lrel</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>save_fraction</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>lpath</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rpath</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lpath_tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rpath_tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tlist_list</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>groupList</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pathlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dLeftGroups</name></decl>,
				<decl><type ref="prev"/><name>dRightGroups</name></decl>,
				<decl><type ref="prev"/><name>dNumGroups</name></decl>,
				<decl><type ref="prev"/><name>dNumOutputRows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOpCmd</name></type>	<name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstFlag</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Tell children to fetch all tuples.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<comment type="block">/* Recurse on children, ensuring their outputs are marked */</comment>
	<expr_stmt><expr><name>lrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>lpath_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>dLeftGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpath</name> <operator>=</operator> <name><name>lrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rrel</name> <operator>=</operator> <call><name>recurse_set_operations</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>refnames_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>rpath_tlist</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>dRightGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpath</name> <operator>=</operator> <name><name>rrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

	<comment type="block">/* Undo effects of forcing tuple_fraction to 0 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <name>save_fraction</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For EXCEPT, we must put the left input first.  For INTERSECT, either
	 * order should give the same results, and we prefer to put the smaller
	 * input first in order to minimize the size of the hash table in the
	 * hashing case.  "Smaller" means the one with the fewer groups.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_EXCEPT</name> <operator>||</operator> <name>dLeftGroups</name> <operator>&lt;=</operator> <name>dRightGroups</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>lpath</name></expr></argument>, <argument><expr><name>rpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist_list</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>lpath_tlist</name></expr></argument>, <argument><expr><name>rpath_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstFlag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>pathlist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>rpath</name></expr></argument>, <argument><expr><name>lpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist_list</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>rpath_tlist</name></expr></argument>, <argument><expr><name>lpath_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Generate tlist for Append plan node.
	 *
	 * The tlist for an Append plan isn't important as far as the Append is
	 * concerned, but we must make it look real anyway for the benefit of the
	 * next plan level up.  In fact, it has to be real enough that the flag
	 * column is shown as a variable not a constant, else setrefs.c will get
	 * confused.
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>generate_append_tlist</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>tlist_list</name></expr></argument>, <argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pTargetList</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

	<comment type="block">/* Build result relation. */</comment>
	<expr_stmt><expr><name>result_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>,
								 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>rrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Append the child results together.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>pathlist</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify the grouping semantics */</comment>
	<expr_stmt><expr><name>groupList</name> <operator>=</operator> <call><name>generate_setop_grouplist</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of distinct groups that we'll need hashtable entries
	 * for; this is the size of the left-hand input for EXCEPT, or the smaller
	 * input for INTERSECT.  Also estimate the number of eventual output rows.
	 * In non-ALL cases, we estimate each group produces one output row; in
	 * ALL cases use the relevant relation size.  These are worst-case
	 * estimates, of course, but we need to be conservative.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_EXCEPT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name>dLeftGroups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dNumOutputRows</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><name><name>lpath</name><operator>-&gt;</operator><name>rows</name></name></expr> </then><else>: <expr><name>dNumGroups</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dLeftGroups</name></expr></argument>, <argument><expr><name>dRightGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dNumOutputRows</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>lpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>rpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>dNumGroups</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Decide whether to hash or sort, and add a sort node if needed.
	 */</comment>
	<expr_stmt><expr><name>use_hash</name> <operator>=</operator> <call><name>choose_hashed_setop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupList</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
								   <argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><name>dNumOutputRows</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_INTERSECT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"INTERSECT"</literal></expr> </then><else>: <expr><literal type="string">"EXCEPT"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupList</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>result_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																	   <argument><expr><name>groupList</name></expr></argument>,
																	   <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Finally, add a SetOp path node to generate the correct output.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SETOP_INTERSECT</name></expr>:</case>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><name>SETOPCMD_INTERSECT_ALL</name></expr> </then><else>: <expr><name>SETOPCMD_INTERSECT</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SETOP_EXCEPT</name></expr>:</case>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr> ?</condition><then> <expr><name>SETOPCMD_EXCEPT_ALL</name></expr> </then><else>: <expr><name>SETOPCMD_EXCEPT</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized set op: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>SETOPCMD_INTERSECT</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_setop_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>result_rel</name></expr></argument>,
									  <argument><expr><name>path</name></expr></argument>,
									  <argument><expr><name>cmd</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>use_hash</name></expr> ?</condition><then> <expr><name>SETOP_HASHED</name></expr> </then><else>: <expr><name>SETOP_SORTED</name></expr></else></ternary></expr></argument>,
									  <argument><expr><name>groupList</name></expr></argument>,
									  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									  <argument><expr><ternary><condition><expr><name>use_hash</name></expr> ?</condition><then> <expr><name>firstFlag</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,
									  <argument><expr><name>dNumGroups</name></expr></argument>,
									  <argument><expr><name>dNumOutputRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>result_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pull up children of a UNION node that are identically-propertied UNIONs.
 *
 * NOTE: we can also pull a UNION ALL up into a UNION, since the distinct
 * output rows will be lost anyway.
 *
 * NOTE: currently, we ignore collations while determining if a child has
 * the same properties.  This is semantically sound only so long as all
 * collations have the same notion of equality.  It is valid from an
 * implementation standpoint because we don't care about the ordering of
 * a UNION child's result: UNION ALL results are always unordered, and
 * generate_union_paths will force a fresh sort if the top level is a UNION.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>plan_union_children</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>top_union</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tlist_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pending_rels</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>top_union</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_tlist</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tlist_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>pending_rels</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>setOp</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pending_rels</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name><name>top_union</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>==</operator> <name><name>top_union</name><operator>-&gt;</operator><name>all</name></name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name><name>top_union</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Same UNION, so fold children into parent */</comment>
				<expr_stmt><expr><name>pending_rels</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pending_rels</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>pending_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Not same, so plan this child separately.
		 *
		 * Note we disallow any resjunk columns in child results.  This is
		 * necessary since the Append node that implements the union won't do
		 * any projection, and upper levels will get confused if some of our
		 * output tuples have junk and some don't.  This case only arises when
		 * we have an EXCEPT or INTERSECT as child, else there won't be
		 * resjunk anyway.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>recurse_set_operations</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
														<argument><expr><name><name>top_union</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>,
														<argument><expr><name><name>top_union</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
														<argument><expr><name>refnames_tlist</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>child_tlist</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>tlist_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tlist_list</name></expr></argument>, <argument><expr><name>child_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add nodes to the given path tree to unique-ify the result of a UNION.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>make_union_unique</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
				  <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>result_rel</name> <init>= <expr><call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>

	<comment type="block">/* Identify the grouping semantics */</comment>
	<expr_stmt><expr><name>groupList</name> <operator>=</operator> <call><name>generate_setop_grouplist</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX for the moment, take the number of distinct groups as equal to the
	 * total input size, ie, the worst case.  This is too conservative, but we
	 * don't want to risk having the hashtable overrun memory; also, it's not
	 * clear how to get a decent estimate of the true size.  One should note
	 * as well the propensity of novices to write UNION rather than UNION ALL
	 * even when they don't expect any duplicates...
	 */</comment>
	<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

	<comment type="block">/* Decide whether to hash or sort */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>choose_hashed_setop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupList</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
							<argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>,
							<argument><expr><literal type="string">"UNION"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Hashed aggregate plan --- no sort needed */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>result_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>groupList</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Sort and Unique */</comment>
		<if_stmt><if>if <condition>(<expr><name>groupList</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>result_rel</name></expr></argument>,
								 <argument><expr><name>path</name></expr></argument>,
								 <argument><expr><call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															   <argument><expr><name>groupList</name></expr></argument>,
															   <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>result_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * postprocess_setop_rel - perform steps required after adding paths
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>postprocess_setop_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't currently worry about allowing FDWs to contribute paths to
	 * this relation, but give extensions a chance.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_SETOP</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Select cheapest path */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * choose_hashed_setop - should we use hashing for a set operation?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>choose_hashed_setop</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>,
					<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>input_path</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dNumOutputRows</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>construct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroupCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>hashed_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>sorted_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuple_fraction</name></decl>;</decl_stmt>

	<comment type="block">/* Check whether the operators support sorting or hashing */</comment>
	<expr_stmt><expr><name>can_sort</name> <operator>=</operator> <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>can_hash</name> <operator>=</operator> <call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>can_hash</name> <operator>&amp;&amp;</operator> <name>can_sort</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we have a meaningful choice to make, continue ... */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>can_hash</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>can_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is UNION, INTERSECT, or EXCEPT */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement %s"</literal></expr></argument>, <argument><expr><name>construct</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Prefer sorting when enable_hashagg is off */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_hashagg</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't do it if it doesn't look like the hashtable will fit into
	 * work_mem.
	 */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hashentrysize</name> <operator>*</operator> <name>dNumGroups</name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See if the estimated cost is no more than doing it the other way.
	 *
	 * We need to consider input_plan + hashagg versus input_plan + sort +
	 * group.  Note that the actual result plan might involve a SetOp or
	 * Unique node, not Agg or Group, but the cost estimates for Agg and Group
	 * should be close enough for our purposes here.
	 *
	 * These path variables are dummies that just hold cost fields; we don't
	 * make actual Paths for these steps.
	 */</comment>
	<expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashed_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>AGG_HASHED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			 <argument><expr><name>numGroupCols</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>,
			 <argument><expr><name>NIL</name></expr></argument>,
			 <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
			 <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now for the sorted case.  Note that the input is *always* unsorted,
	 * since it was made by appending unrelated sub-relations together.
	 */</comment>
	<expr_stmt><expr><name><name>sorted_p</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>input_path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sorted_p</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>input_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<comment type="block">/* XXX cost_sort doesn't actually look at pathkeys, so just pass NIL */</comment>
	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorted_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>sorted_p</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
			  <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
			  <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_group</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sorted_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>numGroupCols</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>,
			   <argument><expr><name>NIL</name></expr></argument>,
			   <argument><expr><name><name>sorted_p</name><operator>.</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>sorted_p</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
			   <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now make the decision using the top-level tuple fraction.  First we
	 * have to convert an absolute count (LIMIT) into fractional form.
	 */</comment>
	<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>/=</operator> <name>dNumOutputRows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>compare_fractional_path_costs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashed_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sorted_p</name></expr></argument>,
									  <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Hashed is cheaper, so use it */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate targetlist for a set-operation plan node
 *
 * colTypes: OID list of set-op's result column datatypes
 * colCollations: OID list of set-op's result column collations
 * flag: -1 if no flag column needed, 0 or 1 to create a const flag column
 * varno: varno to use in generated Vars
 * hack_constants: true to copy up constants (see comments in code)
 * input_tlist: targetlist of this node's input node
 * refnames_tlist: targetlist to take column names from
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
					 <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>hack_constants</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlist</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ctlc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cclc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>itlc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rtlc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/* there's no forfour() so we must chase one list manually */</comment>
	<expr_stmt><expr><name>rtlc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>refnames_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>ctlc</argument>, <argument>colTypes</argument>, <argument>cclc</argument>, <argument>colCollations</argument>, <argument>itlc</argument>, <argument>input_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>ctlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colColl</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cclc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>inputtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>itlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>reftle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rtlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rtlc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>rtlc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>inputtle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>inputtle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>reftle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate columns referencing input columns and having appropriate
		 * data types and column names.  Insert datatype coercions where
		 * necessary.
		 *
		 * HACK: constants in the input's targetlist are copied up as-is
		 * rather than being referenced as subquery outputs.  This is mainly
		 * to ensure that when we try to coerce them to the output column's
		 * datatype, the right things happen for UNKNOWN constants.  But do
		 * this only at the first level of subquery-scan plans; we don't want
		 * phony constants appearing in the output tlists of upper-level
		 * nodes!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hack_constants</name> <operator>&amp;&amp;</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
									<argument><expr><name><name>inputtle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>inputtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>colType</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: it's not really cool to be applying coerce_to_common_type
			 * here; one notable point is that assign_expr_collations never
			 * gets run on any generated nodes.  For the moment that's not a
			 * problem because we force the correct exposed collation below.
			 * It would likely be best to make the parser generate the correct
			 * output tlist for every set-op to begin with, though.
			 */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no UNKNOWNs here */</comment>
										 <argument><expr><name>expr</name></expr></argument>,
										 <argument><expr><name>colType</name></expr></argument>,
										 <argument><expr><literal type="string">"UNION/INTERSECT/EXCEPT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ensure the tlist entry's exposed collation matches the set-op. This
		 * is necessary because plan_set_operations() reports the result
		 * ordering as a list of SortGroupClauses, which don't carry collation
		 * themselves but just refer to tlist entries.  If we don't show the
		 * right collation then planner.c might do the wrong thing in
		 * higher-level queries.
		 *
		 * Note we use RelabelType, not CollateExpr, since this expression
		 * will reach the executor without any further processing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>colColl</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>colColl</name></expr></argument>,
											<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * By convention, all non-resjunk columns in a setop tree have
		 * ressortgroupref equal to their resno.  In some cases the ref isn't
		 * needed, but this is a cleaner way than modifying the tlist later.
		 */</comment>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add a resjunk flag column */</comment>
		<comment type="block">/* flag value is the given constant */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate targetlist for a set-operation Append node
 *
 * colTypes: OID list of set-op's result column datatypes
 * colCollations: OID list of set-op's result column collations
 * flag: true to create a flag column copied up from subplans
 * input_tlists: list of tlists for sub-plans of the Append
 * refnames_tlist: targetlist to take column names from
 *
 * The entries in the Append's targetlist should always be simple Vars;
 * we just have to make sure they have the right datatypes/typmods/collations.
 * The Vars are always generated with varno 0.
 *
 * XXX a problem with the varno-zero approach is that set_pathtarget_cost_width
 * cannot figure out a realistic width for the tlist we make here.  But we
 * ought to refactor this code to produce a PathTarget directly, anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_append_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>input_tlists</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>refnames_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColCollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ref_tl_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlistl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>colTypmods</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First extract typmods to use.
	 *
	 * If the inputs all agree on type and typmod of a particular column, use
	 * that typmod; else use -1.
	 */</comment>
	<expr_stmt><expr><name>colTypmods</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tlistl</argument>, <argument>input_tlists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subtlist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlistl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subtlistl</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>curColType</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>subtlistl</argument>, <argument>subtlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subtlistl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>subtle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curColType</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If first subplan, copy the typmod; else compare */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>subtypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subtle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>tlistl</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>input_tlists</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name> <operator>=</operator> <name>subtypmod</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>subtypmod</name> <operator>!=</operator> <name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* types disagree, so force typmod to -1 */</comment>
				<expr_stmt><expr><name><name>colTypmods</name><index>[<expr><name>colindex</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>curColType</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colindex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curColType</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now we can build the tlist for the Append.
	 */</comment>
	<expr_stmt><expr><name>colindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>curColType</argument>, <argument>colTypes</argument>, <argument>curColCollation</argument>, <argument>colCollations</argument>,
			 <argument>ref_tl_item</argument>, <argument>refnames_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>colTypmod</name> <init>= <expr><name><name>colTypmods</name><index>[<expr><name>colindex</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>colColl</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColCollation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>reftle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ref_tl_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>reftle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>resno</name></expr></argument>,
								<argument><expr><name>colType</name></expr></argument>,
								<argument><expr><name>colTypmod</name></expr></argument>,
								<argument><expr><name>colColl</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>reftle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * By convention, all non-resjunk columns in a setop tree have
		 * ressortgroupref equal to their resno.  In some cases the ref isn't
		 * needed, but this is a cleaner way than modifying the tlist later.
		 */</comment>
		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add a resjunk flag column */</comment>
		<comment type="block">/* flag value is shown as copied up from subplan */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>resno</name></expr></argument>,
								<argument><expr><name>INT4OID</name></expr></argument>,
								<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>resno</name><operator>++</operator></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_setop_grouplist
 *		Build a SortGroupClause list defining the sort/grouping properties
 *		of the setop's output columns.
 *
 * Parse analysis already determined the properties and built a suitable
 * list, except that the entries do not have sortgrouprefs set because
 * the parser output representation doesn't include a tlist for each
 * setop.  So what we need to do here is copy that list and install
 * proper sortgrouprefs into it (copying those from the targetlist).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_setop_grouplist</name><parameter_list>(<parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grouplist</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lg</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>grouplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* resjunk columns should not have sortgrouprefs */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>			<comment type="block">/* ignore resjunk columns */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* non-resjunk columns should have sortgroupref = resno */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* non-resjunk columns should have grouping clauses */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sgc</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sgc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sgc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lg</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>grouplist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * expand_inherited_tables
 *		Expand each rangetable entry that represents an inheritance set
 *		into an "append relation".  At the conclusion of this process,
 *		the "inh" flag is set in all and only those RTEs that are append
 *		relation parents.
 */</comment>
<function><type><name>void</name></type>
<name>expand_inherited_tables</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>nrtes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * expand_inherited_rtentry may add RTEs to parse-&gt;rtable. The function is
	 * expected to recursively handle any RTEs that it creates with inh=true.
	 * So just scan as far as the original end of the rtable list.
	 */</comment>
	<expr_stmt><expr><name>nrtes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rl</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;=</operator> <name>nrtes</name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>expand_inherited_rtentry</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>rl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * expand_inherited_rtentry
 *		Check whether a rangetable entry represents an inheritance set.
 *		If so, add entries for all the child tables to the query's
 *		rangetable, and build AppendRelInfo nodes for all the child tables
 *		and add them to root-&gt;append_rel_list.  If not, clear the entry's
 *		"inh" flag to prevent later code from looking for AppendRelInfos.
 *
 * Note that the original RTE is considered to represent the whole
 * inheritance set.  The first of the generated RTEs is an RTE for the same
 * table, but with inh = false, to represent the parent table in its role
 * as a simple member of the inheritance set.
 *
 * A childless table is never considered to be an inheritance set. For
 * regular inheritance, a parent RTE must always have at least two associated
 * AppendRelInfos: one corresponding to the parent table as a simple member of
 * inheritance set and one or more corresponding to the actual children.
 * Since a partitioned table is not scanned, it might have only one associated
 * AppendRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_inherited_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>oldrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>oldrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhOIDs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Does RT entry allow inheritance? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Ignore any already-expanded UNION ALL nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fast path for common case of childless table */</comment>
	<expr_stmt><expr><name>parentOID</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>parentOID</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Clear flag before returning */</comment>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The rewriter should already have obtained an appropriate lock on each
	 * relation named in the query.  However, for each child relation we add
	 * to the query, we must obtain an appropriate lock, because this will be
	 * the first use of those relations in the parse/rewrite/plan pipeline.
	 *
	 * If the parent relation is the query's result relation, then we need
	 * RowExclusiveLock.  Otherwise, if it's accessed FOR UPDATE/SHARE, we
	 * need RowShareLock; otherwise AccessShareLock.  We can't just grab
	 * AccessShareLock because then the executor would be trying to upgrade
	 * the lock, leading to possible deadlocks.  (This code should match the
	 * parser and rewriter.)
	 */</comment>
	<expr_stmt><expr><name>oldrc</name> <operator>=</operator> <call><name>get_plan_rowmark</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rti</name> <operator>==</operator> <name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>oldrc</name> <operator>&amp;&amp;</operator> <call><name>RowMarkRequiresRowShareLock</name><argument_list>(<argument><expr><name><name>oldrc</name><operator>-&gt;</operator><name>markType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowShareLock</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Scan for all members of inheritance set, acquire needed locks */</comment>
	<expr_stmt><expr><name>inhOIDs</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>parentOID</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that there's at least one descendant, else treat as no-child
	 * case.  This could happen despite above has_subclass() check, if table
	 * once had a child but no longer does.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>inhOIDs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Clear flag before returning */</comment>
		<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If parent relation is selected FOR UPDATE/SHARE, we need to mark its
	 * PlanRowMark as isParent = true, and generate a new PlanRowMark for each
	 * child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldrc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>oldrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must open the parent relation to examine its tupdesc.  We need not lock
	 * it; we assume the rewriter already did.
	 */</comment>
	<expr_stmt><expr><name>oldrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>parentOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan the inheritance set and expand it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this table has partitions, recursively expand them in the order
		 * in which they appear in the PartitionDesc.  While at it, also
		 * extract the partition key columns of all the partitioned tables.
		 */</comment>
		<expr_stmt><expr><call><name>expand_partitioned_rtentry</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>oldrelation</name></expr></argument>, <argument><expr><name>oldrc</name></expr></argument>,
								   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>appinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This table has no partitions.  Expand any plain inheritance
		 * children in the order the OIDs were returned by
		 * find_all_inheritors.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>inhOIDs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>newrelation</name></decl>;</decl_stmt>

			<comment type="block">/* Open rel if needed; we already have required locks */</comment>
			<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newrelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newrelation</name> <operator>=</operator> <name>oldrelation</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * It is possible that the parent table has children that are temp
			 * tables of other backends.  We cannot safely access such tables
			 * (because of buffering issues), and the best thing to do seems
			 * to be to silently ignore them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name> <operator>&amp;&amp;</operator> <call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>expand_single_inheritance_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>oldrelation</name></expr></argument>, <argument><expr><name>oldrc</name></expr></argument>,
											<argument><expr><name>newrelation</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>appinfos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childrte</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close child relations, but keep locks */</comment>
			<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If all the children were temp tables, pretend it's a
		 * non-inheritance situation; we don't need Append node in that case.
		 * The duplicate RTE we added for the parent table is harmless, so we
		 * don't bother to get rid of it; ditto for the useless PlanRowMark
		 * node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>,
												<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * expand_partitioned_rtentry
 *		Recursively expand an RTE for a partitioned table.
 *
 * Note that RelationGetPartitionDispatchInfo will expand partitions in the
 * same order as this code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_partitioned_rtentry</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
						   <parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A partitioned table should always have a partition descriptor. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note down whether any partition key cols are being updated. Though it's
	 * the root partitioned table's updatedCols we are interested in, we
	 * instead use parentrte to get the updatedCols. This is convenient
	 * because parentrte already has the root partrel's updatedCols translated
	 * to match the attribute ordering of parentrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator>
			<call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* First expand the partitioned table itself. */</comment>
	<expr_stmt><expr><call><name>expand_single_inheritance_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parentrte</name></expr></argument>, <argument><expr><name>parentRTindex</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>,
									<argument><expr><name>top_parentrc</name></expr></argument>, <argument><expr><name>parentrel</name></expr></argument>,
									<argument><expr><name>appinfos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childrte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the partitioned table has no partitions, treat this as the
	 * non-inheritance case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parentrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Open rel; we already have required locks */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Temporary partitions belonging to other sessions should have been
		 * disallowed at definition, but for paranoia's sake, let's double
		 * check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"temporary relation from another session found as partition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>expand_single_inheritance_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parentrte</name></expr></argument>, <argument><expr><name>parentRTindex</name></expr></argument>,
										<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>top_parentrc</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
										<argument><expr><name>appinfos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childrte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If this child is itself partitioned, recurse */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>expand_partitioned_rtentry</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>childrte</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>,
									   <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>top_parentrc</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Close child relation, but keep locks */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * expand_single_inheritance_child
 *		Build a RangeTblEntry and an AppendRelInfo, if appropriate, plus
 *		maybe a PlanRowMark.
 *
 * We now expand the partition hierarchy level by level, creating a
 * corresponding hierarchy of AppendRelInfos and RelOptInfos, where each
 * partitioned descendant acts as a parent of its immediate partitions.
 * (This is a difference from what older versions of PostgreSQL did and what
 * is still done in the case of table inheritance for unpartitioned tables,
 * where the hierarchy is flattened during RTE expansion.)
 *
 * PlanRowMarks still carry the top-parent's RTI, and the top-parent's
 * allMarkTypes field still accumulates values from all descendents.
 *
 * "parentrte" and "parentRTindex" are immediate parent's RTE and
 * RTI. "top_parentrc" is top parent's PlanRowMark.
 *
 * The child RangeTblEntry and its RTI are returned in "childrte_p" and
 * "childRTindex_p" resp.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_single_inheritance_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parentrte</name></decl></parameter>,
								<parameter><decl><type><name>Index</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentrel</name></decl></parameter>,
								<parameter><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>top_parentrc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>childrel</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>childrte_p</name></decl></parameter>,
								<parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>childRTindex_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOID</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>childRTindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build an RTE for the child, and attach to query's rangetable list. We
	 * copy most fields of the parent's RTE, but replace relation OID and
	 * relkind, and set inh = false.  Also, set requiredPerms to zero since
	 * all required permissions checks are done on the original RTE. Likewise,
	 * set the child's securityQuals to empty, because we only want to apply
	 * the parent's RLS conditions regardless of what RLS properties
	 * individual children may have.  (This is an intentional choice to make
	 * inherited RLS work like regular permissions checks.) The parent
	 * securityQuals will be propagated to children along with other base
	 * restriction clauses, so we don't need to do it here.
	 */</comment>
	<expr_stmt><expr><name>childrte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parentrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>childrte_p</name> <operator>=</operator> <name>childrte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>childOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<comment type="block">/* A partitioned child will need to be expanded further. */</comment>
	<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name> <operator>&amp;&amp;</operator>
		<name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>childrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>childRTindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>childRTindex_p</name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need an AppendRelInfo if paths will be built for the child RTE. If
	 * childrte-&gt;inh is true, then we'll always need to generate append paths
	 * for it.  If childrte-&gt;inh is false, we must scan it if it's not a
	 * partitioned table; but if it is a partitioned table, then it never has
	 * any data of its own and need not be scanned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator> <name><name>childrte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name>parentRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name> <operator>=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>make_inh_translation_list</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>=</operator> <name>parentOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>appinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>appinfos</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Translate the column permissions bitmaps to the child's attnums (we
		 * have to build the translated_vars list before we can do this). But
		 * if this is the parent table, leave copyObject's result alone.
		 *
		 * Note: we need to do this even though the executor won't run any
		 * permissions checks on the child RTE.  The insertedCols/updatedCols
		 * bitmaps may be examined for trigger-firing purposes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>childOID</name> <operator>!=</operator> <name>parentOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>,
														 <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
														 <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>childrte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <call><name>translate_col_privs</name><argument_list>(<argument><expr><name><name>parentrte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
														<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build a PlanRowMark if parent is marked FOR UPDATE/SHARE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>top_parentrc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>childrc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>rti</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>rowmarkId</name></name></expr>;</expr_stmt>
		<comment type="block">/* Reselect rowmark type, because relkind might not match parent */</comment>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <call><name>select_rowmark_type</name><argument_list>(<argument><expr><name>childrte</name></expr></argument>,
												<argument><expr><name><name>top_parentrc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>childrc</name><operator>-&gt;</operator><name>markType</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>top_parentrc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We mark RowMarks for partitioned child tables as parent RowMarks so
		 * that the executor ignores them (except their existence means that
		 * the child tables be locked using appropriate mode).
		 */</comment>
		<expr_stmt><expr><name><name>childrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <operator>(</operator><name><name>childrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Include child's rowmark type in top parent's allMarkTypes */</comment>
		<expr_stmt><expr><name><name>top_parentrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>|=</operator> <name><name>childrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>childrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make_inh_translation_list
 *	  Build the list of translations from parent Vars to child Vars for
 *	  an inheritance child.
 *
 * For paranoia's sake, we match type/collation as well as attribute name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_inh_translation_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>oldrelation</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>newrelation</name></decl></parameter>,
						  <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>old_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>oldrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>new_tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldnatts</name> <init>= <expr><name><name>old_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newnatts</name> <init>= <expr><name><name>new_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_attno</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>old_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>old_attno</name> <operator>&lt;</operator> <name>oldnatts</name></expr>;</condition> <incr><expr><name>old_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>new_attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>old_tupdesc</name></expr></argument>, <argument><expr><name>old_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Just put NULL into this list entry */</comment>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When we are generating the "translation list" for the parent table
		 * of an inheritance set, no need to search for matches.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldrelation</name> <operator>==</operator> <name>newrelation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>old_attno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
										 <argument><expr><name>atttypid</name></expr></argument>,
										 <argument><expr><name>atttypmod</name></expr></argument>,
										 <argument><expr><name>attcollation</name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise we have to search for the matching column by name.
		 * There's no guarantee it'll have the same column position, because
		 * of cases like ALTER TABLE ADD COLUMN and multiple inheritance.
		 * However, in simple cases it will be the same column number, so try
		 * that before we go groveling through all the columns.
		 *
		 * Note: the test for (att = ...) != NULL cannot fail, it's just a
		 * notational device to include the assignment into the if-clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_attno</name> <operator>&lt;</operator> <name>newnatts</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>new_tupdesc</name></expr></argument>, <argument><expr><name>old_attno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_attno</name> <operator>=</operator> <name>old_attno</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>new_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>new_attno</name> <operator>&lt;</operator> <name>newnatts</name></expr>;</condition> <incr><expr><name>new_attno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>new_tupdesc</name></expr></argument>, <argument><expr><name>new_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>new_attno</name> <operator>&gt;=</operator> <name>newnatts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find inherited attribute \"%s\" of relation \"%s\""</literal></expr></argument>,
					 <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Found it, check type and collation match */</comment>
		<if_stmt><if>if <condition>(<expr><name>atttypid</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator> <name>atttypmod</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute \"%s\" of relation \"%s\" does not match parent's type"</literal></expr></argument>,
				 <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attcollation</name> <operator>!=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute \"%s\" of relation \"%s\" does not match parent's collation"</literal></expr></argument>,
				 <argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>newrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>makeVar</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>new_attno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
									 <argument><expr><name>atttypid</name></expr></argument>,
									 <argument><expr><name>atttypmod</name></expr></argument>,
									 <argument><expr><name>attcollation</name></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>translated_vars</name> <operator>=</operator> <name>vars</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * translate_col_privs
 *	  Translate a bitmapset representing per-column privileges from the
 *	  parent rel's attribute numbering to the child's.
 *
 * The only surprise here is that we don't translate a parent whole-row
 * reference into a child whole-row reference.  That would mean requiring
 * permissions on all child columns, which is overly strict, since the
 * query is really only going to reference the inherited columns.  Instead
 * we set the per-column bits for all inherited columns.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>translate_col_privs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>parent_privs</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>child_privs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>whole_row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* System attributes have the same numbers in all tables */</comment>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						  <argument><expr><name>parent_privs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>child_privs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>child_privs</name></expr></argument>,
										 <argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Check if parent has whole-row reference */</comment>
	<expr_stmt><expr><name>whole_row</name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							  <argument><expr><name>parent_privs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And now translate the regular user attributes, using the vars list */</comment>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>translated_vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* ignore dropped columns */</comment>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>whole_row</name> <operator>||</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
						  <argument><expr><name>parent_privs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>child_privs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>child_privs</name></expr></argument>,
										 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>child_privs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_appendrel_attrs
 *	  Copy the specified query or expression and translate Vars referring to a
 *	  parent rel to refer to the corresponding child rel instead.  We also
 *	  update rtindexes appearing outside Vars, such as resultRelation and
 *	  jointree relids.
 *
 * Note: this is only applied after conversion of sublinks to subplans,
 * so we don't need to cope with recursion into sub-queries.
 *
 * Note: this is not hugely different from what pullup_replace_vars() does;
 * maybe we should try to fold the two routines together.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>adjust_appendrel_attrs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>,
					   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>adjust_appendrel_attrs_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nappinfos</name></name> <operator>=</operator> <name>nappinfos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>appinfos</name></name> <operator>=</operator> <name>appinfos</name></expr>;</expr_stmt>

	<comment type="block">/* If there's nothing to adjust, don't call this function. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nappinfos</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>appinfos</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
									 <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									 <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>newnode</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<comment type="block">/* Fix tlist resnos too, if it's inherited UPDATE */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>newnode</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator>
						<call><name>adjust_inherited_tlist</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											   <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>adjust_appendrel_attrs_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>adjust_appendrel_attrs_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>adjust_appendrel_attrs_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name><operator>-&gt;</operator><name>parent_relid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>appinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
						 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>,
											  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
						 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>newnode</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Whole-row Var: if we are dealing with named rowtypes, we
				 * can use a whole-row Var for the child table plus a coercion
				 * step to convert the tuple layout to the parent's rowtype.
				 * Otherwise we have to generate a RowExpr.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>!=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
						<comment type="block">/* Make sure the Var node has the right type ID, too */</comment>
						<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>r</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Build a RowExpr containing the translated variables.
					 *
					 * In practice var-&gt;vartype will always be RECORDOID here,
					 * so we need to come up with some suitable column names.
					 * We use the parent RTE's column names.
					 *
					 * Note: we can't get here for inheritance cases, so there
					 * is no need to worry that translated_vars might contain
					 * some dummy NULLs.
					 */</comment>
					<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>,
								   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* system attributes don't need any other translation */</comment>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy the JoinExpr node with correct mutation of subnodes */</comment>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
												 <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* now fix JoinExpr's rtindex (probably never happens) */</comment>
		<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy the PlaceHolderVar node with correct mutation of subnodes */</comment>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>phv</name> <operator>=</operator> <operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
														 <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* now fix PlaceHolderVar's relid sets */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Shouldn't need to handle planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to process RestrictInfo nodes specially.  (Note: although
	 * set_append_rel_pathlist will hide RestrictInfos in the parent's
	 * baserestrictinfo list from us, it doesn't hide those in joininfo.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>oldinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>newinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Copy all flat-copiable fields */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newinfo</name></expr></argument>, <argument><expr><name>oldinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recursively fix the clause itself */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and the modified version, if an OR clause */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>orclause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldinfo</name><operator>-&gt;</operator><name>orclause</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust relid sets too */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>clause_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>,
													 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>outer_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
												   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
												   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_relids</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>oldinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nappinfos</name></name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>appinfos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset cached derivative fields, since these might need to have
		 * different values when considering the child relation.  Note we
		 * don't reset left_ec/right_ec: each child variable is implicitly
		 * equivalent to its parent, so still a member of the same EC if any.
		 */</comment>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>scansel_cache</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>left_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newinfo</name><operator>-&gt;</operator><name>right_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newinfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * NOTE: we do not need to recurse into sublinks, because they should
	 * already have been converted to subplans before we see them.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>adjust_appendrel_attrs_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Substitute child relids for parent relids in a Relid set.  The array of
 * appinfos specifies the substitutions to be performed.
 */</comment>
<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>adjust_child_relids</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Remove parent, add child */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Make a copy if we are changing the set. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If we made any changes, return the modified copy. */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, return the original set without modification. */</comment>
	<return>return <expr><name>relids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Replace any relid present in top_parent_relids with its child in
 * child_relids. Members of child_relids can be multiple levels below top
 * parent in the partition hierarchy.
 */</comment>
<function><type><name>Relids</name></type>
<name>adjust_child_relids_multilevel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
							   <parameter><decl><type><name>Relids</name></type> <name>child_relids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>top_parent_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>parent_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>tmp_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the given relids set doesn't contain any of the top parent relids,
	 * it will remain unchanged.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>relids</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_relids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct relids set for the immediate parent of the given child. */</comment>
	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Recurse if immediate parent is not the top parent. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp_result</name> <operator>=</operator> <call><name>adjust_child_relids_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>,
													<argument><expr><name>parent_relids</name></expr></argument>,
													<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <name>tmp_result</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free memory consumed by any intermediate result. */</comment>
	<if_stmt><if>if <condition>(<expr><name>tmp_result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmp_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the targetlist entries of an inherited UPDATE operation
 *
 * The expressions have already been fixed, but we have to make sure that
 * the target resnos match the child table (they may not, in the case of
 * a column that was added after-the-fact by ALTER TABLE).  In some cases
 * this can force us to re-order the tlist to preserve resno ordering.
 * (We do all this work in special cases so that preptlist.c is fast for
 * the typical case.)
 *
 * The given tlist has already been through expression_tree_mutator;
 * therefore the TargetEntry nodes are fresh copies that it's okay to
 * scribble on.
 *
 * Note that this is not needed for INSERT because INSERT isn't inheritable.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjust_inherited_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>more</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>;</decl_stmt>

	<comment type="block">/* This should only happen for an inheritance case, not UNION ALL */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan tlist and update resnos to match attnums of child rel */</comment>
	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>childvar</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk items */</comment>

		<comment type="block">/* Look up the translation of this column: it must be a Var */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
				 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>childvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>childvar</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>childvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute %d of relation \"%s\" does not exist"</literal></expr></argument>,
				 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>parent_reloid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>!=</operator> <name><name>childvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>childvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>changed_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we changed anything, re-sort the tlist by resno, and make sure
	 * resjunk entries have resnos above the last real resno.  The sort
	 * algorithm is a bit stupid, but for such a seldom-taken path, small is
	 * probably better than fast.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_it</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>tlist</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>more</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>more</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* ignore junk items */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>&gt;</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* here, ignore non-junk items */</comment>

		<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>attrno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_appendrel_attrs_multilevel
 *	  Apply Var translations from a toplevel appendrel parent down to a child.
 *
 * In some cases we need to translate expressions referencing a parent relation
 * to reference an appendrel child that's multiple levels removed from it.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>adjust_appendrel_attrs_multilevel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>Relids</name></type> <name>child_relids</name></decl></parameter>,
								  <parameter><decl><type><name>Relids</name></type> <name>top_parent_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>parent_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>child_relids</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_relids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct relids set for the immediate parent of given child. */</comment>
	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>nappinfos</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>appinfos</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Recurse if immediate parent is not the top parent. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>adjust_appendrel_attrs_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent_relids</name></expr></argument>,
												 <argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now translate for this child */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct the SpecialJoinInfo for a child-join by translating
 * SpecialJoinInfo for the join between parents. left_relids and right_relids
 * are the relids of left and right side of the join respectively.
 */</comment>
<function><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type>
<name>build_child_join_sjinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>parent_sjinfo</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>left_relids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>right_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>left_appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>left_nappinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>right_appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>right_nappinfos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>parent_sjinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>left_relids</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>left_nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>right_relids</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>right_nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_lefthand</name></name></expr></argument>,
											   <argument><expr><name>left_nappinfos</name></expr></argument>, <argument><expr><name>left_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>,
												<argument><expr><name>right_nappinfos</name></expr></argument>,
												<argument><expr><name>right_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>,
											   <argument><expr><name>left_nappinfos</name></expr></argument>, <argument><expr><name>left_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name> <operator>=</operator> <call><name>adjust_child_relids</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>,
												<argument><expr><name>right_nappinfos</name></expr></argument>,
												<argument><expr><name>right_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
															 <argument><expr><name>right_nappinfos</name></expr></argument>,
															 <argument><expr><name>right_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>left_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>right_appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sjinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_appinfos_by_relids
 * 		Find AppendRelInfo structures for all relations specified by relids.
 *
 * The AppendRelInfos are returned in an array, which can be pfree'd by the
 * caller. *nappinfos is set to the number of entries in the array.
 */</comment>
<function><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>find_appinfos_by_relids</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nappinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>nappinfos</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>appinfo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"child rel %d not found in append_rel_array"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>appinfos</name><index>[<expr><name>cnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>appinfo</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>appinfos</name></expr>;</return>
</block_content>}</block></function>
</unit>
