<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/prep/prepjointree.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * prepjointree.c
 *	  Planner preprocessing for subqueries and join tree manipulation.
 *
 * NOTE: the intended sequence for invoking these operations is
 *		pull_up_sublinks
 *		inline_set_returning_functions
 *		pull_up_subqueries
 *		flatten_simple_union_all
 *		do expression preprocessing (including flattening JOIN alias vars)
 *		reduce_outer_joins
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/prep/prepjointree.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>pullup_replace_vars_context</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetlist</name></decl>;</decl_stmt>		<comment type="block">/* tlist of subquery being pulled up */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl>;</decl_stmt>	<comment type="block">/* RTE of subquery */</comment>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>			<comment type="block">/* relids within subquery, as numbered after
								 * pullup (set only if target_rte-&gt;lateral) */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>outer_hasSubLinks</name></decl>;</decl_stmt>	<comment type="block">/* -&gt; outer query's hasSubLinks */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>varno</name></decl>;</decl_stmt>			<comment type="block">/* varno of subquery */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_phvs</name></decl>;</decl_stmt>		<comment type="block">/* do we need PlaceHolderVars? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wrap_non_vars</name></decl>;</decl_stmt>	<comment type="block">/* do we need 'em on *all* non-Vars? */</comment>
	<decl_stmt><decl><type><name>Node</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>rv_cache</name></decl>;</decl_stmt>		<comment type="block">/* cache for results with PHVs */</comment>
}</block></struct></type> <name>pullup_replace_vars_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>reduce_outer_joins_state</name>
<block>{
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>			<comment type="block">/* base relids within this subtree */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>contains_outer</name></decl>;</decl_stmt> <comment type="block">/* does subtree contain outer join(s)? */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sub_states</name></decl>;</decl_stmt>		<comment type="block">/* List of states for subtree components */</comment>
}</block></struct></type> <name>reduce_outer_joins_state</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_sublinks_jointree_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
								  <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_sublinks_qual_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink1</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels1</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink2</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_subqueries_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
						   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_nulling_outer_join</name></decl></parameter>,
						   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>containing_appendrel</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_simple_subquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
						<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_nulling_outer_join</name></decl></parameter>,
						<parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>containing_appendrel</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_simple_union_all</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pull_up_union_leaf_queries</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>parentRTindex</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>setOpQuery</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>childRToffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_setop_translation_list</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_simple_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_simple_values</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
					  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_simple_values</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_simple_union_all</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_simple_union_all_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>setOpQuery</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_safe_append_member</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>jointree_contains_lateral_outer_refs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restricted</name></decl></parameter>,
									 <parameter><decl><type><name>Relids</name></type> <name>safe_upper_varnos</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>replace_vars_in_jointree</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						 <parameter><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_nulling_outer_join</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pullup_replace_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
					<parameter><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pullup_replace_vars_callback</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
							 <parameter><decl><type><name>replace_rte_variables_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>pullup_replace_vars_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
							 <parameter><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pull_up_subqueries_cleanup</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>reduce_outer_joins_pass1</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reduce_outer_joins_pass2</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						 <parameter><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>nonnullable_rels</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nonnullable_vars</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>forced_null_vars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>substitute_multiple_relids</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>subrelids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fix_append_rel_relids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>append_rel_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>,
					  <parameter><decl><type><name>Relids</name></type> <name>subrelids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>find_jointree_node_for_rel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * pull_up_sublinks
 *		Attempt to pull up ANY and EXISTS SubLinks to be treated as
 *		semijoins or anti-semijoins.
 *
 * A clause "foo op ANY (sub-SELECT)" can be processed by pulling the
 * sub-SELECT up to become a rangetable entry and treating the implied
 * comparisons as quals of a semijoin.  However, this optimization *only*
 * works at the top level of WHERE or a JOIN/ON clause, because we cannot
 * distinguish whether the ANY ought to return FALSE or NULL in cases
 * involving NULL inputs.  Also, in an outer join's ON clause we can only
 * do this if the sublink is degenerate (ie, references only the nullable
 * side of the join).  In that case it is legal to push the semijoin
 * down into the nullable side of the join.  If the sublink references any
 * nonnullable-side variables then it would have to be evaluated as part
 * of the outer join, which makes things way too complicated.
 *
 * Under similar conditions, EXISTS and NOT EXISTS clauses can be handled
 * by pulling up the sub-SELECT and creating a semijoin or anti-semijoin.
 *
 * This routine searches for such clauses and does the necessary parsetree
 * transformations if any are found.
 *
 * This routine has to run before preprocess_expression(), so the quals
 * clauses are not yet reduced to implicit-AND format, and are not guaranteed
 * to be AND/OR-flat either.  That means we need to recursively search through
 * explicit AND clauses.  We stop as soon as we hit a non-AND item.
 */</comment>
<function><type><name>void</name></type>
<name>pull_up_sublinks</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jtnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name></decl>;</decl_stmt>

	<comment type="block">/* Begin recursion through the jointree */</comment>
	<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * root-&gt;parse-&gt;jointree must always be a FromExpr, so insert a dummy one
	 * if we got a bare RangeTblRef or JoinExpr out of the recursion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recurse through jointree nodes for pull_up_sublinks()
 *
 * In addition to returning the possibly-modified jointree node, we return
 * a relids set of the contained rels into *relids.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_sublinks_jointree_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
								  <parameter><decl><type><name>Relids</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* jtnode is returned unmodified */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newfromlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>frelids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>newf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jtlink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* First, recurse to process children and collect their relids */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newchild</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>childrelids</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newchild</name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>childrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newfromlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newfromlist</name></expr></argument>, <argument><expr><name>newchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>frelids</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>frelids</name></expr></argument>, <argument><expr><name>childrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* Build the replacement FromExpr; no quals yet */</comment>
		<expr_stmt><expr><name>newf</name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name>newfromlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Set up a link representing the rebuilt jointree */</comment>
		<expr_stmt><expr><name>jtlink</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newf</name></expr>;</expr_stmt>
		<comment type="block">/* Now process qual --- all children are available for use */</comment>
		<expr_stmt><expr><name><name>newf</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>jtlink</name></expr></argument>, <argument><expr><name>frelids</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that the result will be either newf, or a stack of JoinExprs
		 * with newf at the base.  We rely on subsequent optimization steps to
		 * flatten this and rearrange the joins as needed.
		 *
		 * Although we could include the pulled-up subqueries in the returned
		 * relids, there's no need since upper quals couldn't refer to their
		 * outputs anyway.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <name>frelids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <name>jtlink</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>leftrelids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>rightrelids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jtlink</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make a modifiable copy of join node, but don't bother copying its
		 * subnodes (yet).
		 */</comment>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>jtnode</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jtlink</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>

		<comment type="block">/* Recurse to process children and collect their relids */</comment>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>leftrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>rightrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now process qual, showing appropriate child relids as available,
		 * and attach any pulled-up jointree items at the right place. In the
		 * inner-join case we put new JoinExprs above the existing one (much
		 * as for a FromExpr-style join).  In outer-join cases the new
		 * JoinExprs must go into the nullable side of the outer join. The
		 * point of the available_rels machinations is to ensure that we only
		 * pull up quals for which that's okay.
		 *
		 * We don't expect to see any pre-existing JOIN_SEMI or JOIN_ANTI
		 * nodes here.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>jtlink</name></expr></argument>,
														 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name>leftrelids</name></expr></argument>,
																   <argument><expr><name>rightrelids</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
														 <argument><expr><name>rightrelids</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<comment type="block">/* can't do anything with full-join quals */</comment>
				<break>break;</break>
			<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
														 <argument><expr><name>leftrelids</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Although we could include the pulled-up subqueries in the returned
		 * relids, there's no need since upper quals couldn't refer to their
		 * outputs anyway.  But we *do* need to include the join's own rtindex
		 * because we haven't yet collapsed join alias variables, so upper
		 * levels would mistakenly think they couldn't use references to this
		 * join.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>leftrelids</name></expr></argument>, <argument><expr><name>rightrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>relids</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <name>jtlink</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>jtnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recurse through top-level qual nodes for pull_up_sublinks()
 *
 * jtlink1 points to the link in the jointree where any new JoinExprs should
 * be inserted if they reference available_rels1 (i.e., available_rels1
 * denotes the relations present underneath jtlink1).  Optionally, jtlink2 can
 * point to a second link where new JoinExprs should be inserted if they
 * reference available_rels2 (pass NULL for both those arguments if not used).
 * Note that SubLinks referencing both sets of variables cannot be optimized.
 * If we find multiple pull-up-able SubLinks, they'll get stacked onto jtlink1
 * and/or jtlink2 in the order we encounter them.  We rely on subsequent
 * optimization to rearrange the stack if appropriate.
 *
 * Returns the replacement qual node, or NULL if the qual should be removed.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_sublinks_qual_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink1</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels1</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink2</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>child_rels</name></decl>;</decl_stmt>

		<comment type="block">/* Is it a convertible ANY or EXISTS clause? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>convert_ANY_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>,
												 <argument><expr><name>available_rels1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes; insert the new join node into the join tree */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>*</operator><name>jtlink1</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>jtlink1</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>
				<comment type="block">/* Recursively process pulled-up jointree nodes */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now recursively process the pulled-up quals.  Any inserted
				 * joins can get stacked onto either j-&gt;larg or j-&gt;rarg,
				 * depending on which rels they reference.
				 */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
														 <argument><expr><name>available_rels1</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
														 <argument><expr><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Return NULL representing constant TRUE */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>available_rels2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>j</name> <operator>=</operator> <call><name>convert_ANY_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>,
												 <argument><expr><name>available_rels2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes; insert the new join node into the join tree */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>*</operator><name>jtlink2</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>jtlink2</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>
				<comment type="block">/* Recursively process pulled-up jointree nodes */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now recursively process the pulled-up quals.  Any inserted
				 * joins can get stacked onto either j-&gt;larg or j-&gt;rarg,
				 * depending on which rels they reference.
				 */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
														 <argument><expr><name>available_rels2</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
														 <argument><expr><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Return NULL representing constant TRUE */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>convert_EXISTS_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>available_rels1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes; insert the new join node into the join tree */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>*</operator><name>jtlink1</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>jtlink1</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>
				<comment type="block">/* Recursively process pulled-up jointree nodes */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now recursively process the pulled-up quals.  Any inserted
				 * joins can get stacked onto either j-&gt;larg or j-&gt;rarg,
				 * depending on which rels they reference.
				 */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
														 <argument><expr><name>available_rels1</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
														 <argument><expr><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Return NULL representing constant TRUE */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>available_rels2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>j</name> <operator>=</operator> <call><name>convert_EXISTS_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>available_rels2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes; insert the new join node into the join tree */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>*</operator><name>jtlink2</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>jtlink2</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>
				<comment type="block">/* Recursively process pulled-up jointree nodes */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now recursively process the pulled-up quals.  Any inserted
				 * joins can get stacked onto either j-&gt;larg or j-&gt;rarg,
				 * depending on which rels they reference.
				 */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
														 <argument><expr><name>available_rels2</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
														 <argument><expr><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Return NULL representing constant TRUE */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Else return it unmodified */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>not_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If the immediate argument of NOT is EXISTS, try to convert */</comment>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <call><name>get_notclausearg</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>child_rels</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sublink</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>convert_EXISTS_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
														<argument><expr><name>available_rels1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Yes; insert the new join node into the join tree */</comment>
					<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>*</operator><name>jtlink1</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>jtlink1</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>
					<comment type="block">/* Recursively process pulled-up jointree nodes */</comment>
					<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Now recursively process the pulled-up quals.  Because
					 * we are underneath a NOT, we can't pull up sublinks that
					 * reference the left-hand stuff, but it's still okay to
					 * pull up sublinks referencing j-&gt;rarg.
					 */</comment>
					<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
															 <argument><expr><name>child_rels</name></expr></argument>,
															 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Return NULL representing constant TRUE */</comment>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>available_rels2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>j</name> <operator>=</operator> <call><name>convert_EXISTS_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
														<argument><expr><name>available_rels2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Yes; insert the new join node into the join tree */</comment>
					<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>*</operator><name>jtlink2</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>jtlink2</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>j</name></expr>;</expr_stmt>
					<comment type="block">/* Recursively process pulled-up jointree nodes */</comment>
					<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_sublinks_jointree_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Now recursively process the pulled-up quals.  Because
					 * we are underneath a NOT, we can't pull up sublinks that
					 * reference the left-hand stuff, but it's still okay to
					 * pull up sublinks referencing j-&gt;rarg.
					 */</comment>
					<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
															 <argument><expr><name>child_rels</name></expr></argument>,
															 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Return NULL representing constant TRUE */</comment>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Else return it unmodified */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into AND clause */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) node)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>oldclause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newclause</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newclause</name> <operator>=</operator> <call><name>pull_up_sublinks_qual_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name>oldclause</name></expr></argument>,
													  <argument><expr><name>jtlink1</name></expr></argument>,
													  <argument><expr><name>available_rels1</name></expr></argument>,
													  <argument><expr><name>jtlink2</name></expr></argument>,
													  <argument><expr><name>available_rels2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newclause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newclauses</name></expr></argument>, <argument><expr><name>newclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* We might have got back fewer clauses than we started with */</comment>
		<if_stmt><if>if <condition>(<expr><name>newclauses</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newclauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>newclauses</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>newclauses</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Stop if not an AND */</comment>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inline_set_returning_functions
 *		Attempt to "inline" set-returning functions in the FROM clause.
 *
 * If an RTE_FUNCTION rtable entry invokes a set-returning function that
 * contains just a simple SELECT, we can convert the rtable entry to an
 * RTE_SUBQUERY entry exposing the SELECT directly.  This is especially
 * useful if the subquery can then be "pulled up" for further optimization,
 * but we do it even if not, to reduce executor overhead.
 *
 * This has to be done before we have started to do any optimization of
 * subqueries, else any such steps wouldn't get applied to subqueries
 * obtained via inlining.  However, we do it after pull_up_sublinks
 * so that we can inline any functions used in SubLink subselects.
 *
 * Like most of the planner, this feels free to scribble on its input data
 * structure.
 */</comment>
<function><type><name>void</name></type>
<name>inline_set_returning_functions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>root-&gt;parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>funcquery</name></decl>;</decl_stmt>

			<comment type="block">/* Check safety of expansion, and expand if possible */</comment>
			<expr_stmt><expr><name>funcquery</name> <operator>=</operator> <call><name>inline_set_returning_function</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>funcquery</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Successful expansion, replace the rtable entry */</comment>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>funcquery</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_subqueries
 *		Look for subqueries in the rangetable that can be pulled up into
 *		the parent query.  If the subquery has no special features like
 *		grouping/aggregation then we can merge it into the parent's jointree.
 *		Also, subqueries that are simple UNION ALL structures can be
 *		converted into "append relations".
 */</comment>
<function><type><name>void</name></type>
<name>pull_up_subqueries</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Top level of jointree must always be a FromExpr */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reset flag saying we need a deletion cleanup pass */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasDeletedRTEs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* Recursion starts with no containing join nor appendrel */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator>
		<call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Apply cleanup phase if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasDeletedRTEs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator>
			<call><name>pull_up_subqueries_cleanup</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_subqueries_recurse
 *		Recursive guts of pull_up_subqueries.
 *
 * This recursively processes the jointree and returns a modified jointree.
 * Or, if it's valid to drop the current node from the jointree completely,
 * it returns NULL.
 *
 * If this jointree node is within either side of an outer join, then
 * lowest_outer_join references the lowest such JoinExpr node; otherwise
 * it is NULL.  We use this to constrain the effects of LATERAL subqueries.
 *
 * If this jointree node is within the nullable side of an outer join, then
 * lowest_nulling_outer_join references the lowest such JoinExpr node;
 * otherwise it is NULL.  This forces use of the PlaceHolderVar mechanism for
 * references to non-nullable targetlist items, but only for references above
 * that join.
 *
 * If we are looking at a member subquery of an append relation,
 * containing_appendrel describes that relation; else it is NULL.
 * This forces use of the PlaceHolderVar mechanism for all non-Var targetlist
 * items, and puts some additional restrictions on what can be pulled up.
 *
 * deletion_ok is true if the caller can cope with us returning NULL for a
 * deletable leaf node (for example, a VALUES RTE that could be pulled up).
 * If it's false, we'll avoid pullup in such cases.
 *
 * A tricky aspect of this code is that if we pull up a subquery we have
 * to replace Vars that reference the subquery's outputs throughout the
 * parent query, including quals attached to jointree nodes above the one
 * we are currently processing!  We handle this by being careful not to
 * change the jointree structure while recursing: no nodes other than leaf
 * RangeTblRef entries and entirely-empty FromExprs will be replaced or
 * deleted.  Also, we can't turn pullup_replace_vars loose on the whole
 * jointree, because it'll return a mutated copy of the tree; we have to
 * invoke it just on the quals, instead.  This behavior is what makes it
 * reasonable to pass lowest_outer_join and lowest_nulling_outer_join as
 * pointers rather than some more-indirect way of identifying the lowest
 * OJs.  Likewise, we don't replace append_rel_list members but only their
 * substructure, so the containing_appendrel reference is safe to use.
 *
 * Because of the rule that no jointree nodes with substructure can be
 * replaced, we cannot fully handle the case of deleting nodes from the tree:
 * when we delete one child of a JoinExpr, we need to replace the JoinExpr
 * with a FromExpr, and that can't happen here.  Instead, we set the
 * root-&gt;hasDeletedRTEs flag, which tells pull_up_subqueries() that an
 * additional pass over the tree is needed to clean up.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_subqueries_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
						   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_nulling_outer_join</name></decl></parameter>,
						   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>containing_appendrel</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jtnode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Is this a subquery RTE, and if so, is the subquery simple enough to
		 * pull up?
		 *
		 * If we are looking at an append-relation member, we can't pull it up
		 * unless is_safe_append_member says so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
			<call><name>is_simple_subquery</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
							   <argument><expr><name>lowest_outer_join</name></expr></argument>, <argument><expr><name>deletion_ok</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>containing_appendrel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			 <call><name>is_safe_append_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pull_up_simple_subquery</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
										   <argument><expr><name>lowest_outer_join</name></expr></argument>,
										   <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>,
										   <argument><expr><name>containing_appendrel</name></expr></argument>,
										   <argument><expr><name>deletion_ok</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Alternatively, is it a simple UNION ALL subquery?  If so, flatten
		 * into an "append relation".
		 *
		 * It's safe to do this regardless of whether this query is itself an
		 * appendrel member.  (If you're thinking we should try to flatten the
		 * two levels of appendrel together, you're right; but we handle that
		 * in set_append_rel_pathlist, not here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
			<call><name>is_simple_union_all</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pull_up_simple_union_all</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Or perhaps it's a simple VALUES RTE?
		 *
		 * We don't allow VALUES pullup below an outer join nor into an
		 * appendrel (such cases are impossible anyway at the moment).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name> <operator>&amp;&amp;</operator>
			<name>lowest_outer_join</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name>containing_appendrel</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>is_simple_values</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>deletion_ok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pull_up_simple_values</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, do nothing at this node. */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>have_undeleted_child</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>containing_appendrel</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the FromExpr has quals, it's not deletable even if its parent
		 * would allow deletion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>deletion_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * In a non-deletable FromExpr, we can allow deletion of child
			 * nodes so long as at least one child remains; so it's okay
			 * either if any previous child survives, or if there's more to
			 * come.  If all children are deletable in themselves, we'll force
			 * the last one to remain unflattened.
			 *
			 * As a separate matter, we can allow deletion of all children of
			 * the top-level FromExpr in a query, since that's a special case
			 * anyway.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>sub_deletion_ok</name> <init>= <expr><operator>(</operator><name>deletion_ok</name> <operator>||</operator>
										   <name>have_undeleted_child</name> <operator>||</operator>
										   <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
										   <name>f</name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>lowest_outer_join</name></expr></argument>,
												   <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>sub_deletion_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_undeleted_child</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>deletion_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_undeleted_child</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to delete this FromExpr entirely */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasDeletedRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* probably is set already */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>containing_appendrel</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Recurse, being careful to tell myself when inside outer join */</comment>
		<switch>switch <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>

				<comment type="block">/*
				 * INNER JOIN can allow deletion of either child node, but not
				 * both.  So right child gets permission to delete only if
				 * left child didn't get removed.
				 */</comment>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
													 <argument><expr><name>lowest_outer_join</name></expr></argument>,
													 <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													 <argument><expr><name>lowest_outer_join</name></expr></argument>,
													 <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
			<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
													 <argument><expr><name>j</name></expr></argument>,
													 <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>jtnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_simple_subquery
 *		Attempt to pull up a single simple subquery.
 *
 * jtnode is a RangeTblRef that has been tentatively identified as a simple
 * subquery by pull_up_subqueries.  We return the replacement jointree node,
 * or NULL if the subquery can be deleted entirely, or jtnode itself if we
 * determine that the subquery can't be pulled up after all.
 *
 * rte is the RangeTblEntry referenced by jtnode.  Remaining parameters are
 * as for pull_up_subqueries_recurse.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_simple_subquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
						<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_nulling_outer_join</name></decl></parameter>,
						<parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>containing_appendrel</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pullup_replace_vars_context</name></type> <name>rvcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need a modifiable copy of the subquery to hack on.  Even if we didn't
	 * sometimes choose not to pull up below, we must do this to avoid
	 * problems if the same subquery is referenced from multiple jointree
	 * items (which can't happen normally, but might after rule rewriting).
	 */</comment>
	<expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a PlannerInfo data structure for this subquery.
	 *
	 * NOTE: the next few steps should match the first processing in
	 * subquery_planner().  Can we refactor to avoid code duplication, or
	 * would that just make things uglier?
	 */</comment>
	<expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parent_root</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>outer_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>multiexpr_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>upper_rels</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>upper_rels</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>upper_targets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>upper_targets</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>qual_security_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>=</operator> <name>INHKIND_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>hasRecursion</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* No CTEs to worry about */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pull up any SubLinks within the subquery's quals, so that we don't
	 * leave unoptimized SubLinks behind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pull_up_sublinks</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, inline any set-returning functions in its rangetable.
	 */</comment>
	<expr_stmt><expr><call><name>inline_set_returning_functions</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recursively pull up the subquery's subqueries, so that
	 * pull_up_subqueries' processing is complete for its jointree and
	 * rangetable.
	 *
	 * Note: it's okay that the subquery's recursion starts with NULL for
	 * containing-join info, even if we are within an outer join in the upper
	 * query; the lower query starts with a clean slate for outer-join
	 * semantics.  Likewise, we needn't pass down appendrel state.
	 */</comment>
	<expr_stmt><expr><call><name>pull_up_subqueries</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we must recheck whether the subquery is still simple enough to pull
	 * up.  If not, abandon processing it.
	 *
	 * We don't really need to recheck all the conditions involved, but it's
	 * easier just to keep this "if" looking the same as the one in
	 * pull_up_subqueries_recurse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_simple_subquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
						   <argument><expr><name>lowest_outer_join</name></expr></argument>, <argument><expr><name>deletion_ok</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>containing_appendrel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>is_safe_append_member</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* good to go */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Give up, return unmodified RangeTblRef.
		 *
		 * Note: The work we just did will be redone when the subquery gets
		 * planned on its own.  Perhaps we could avoid that by storing the
		 * modified subquery back into the rangetable, but I'm not gonna risk
		 * it now.
		 */</comment>
		<return>return <expr><name>jtnode</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We must flatten any join alias Vars in the subquery's targetlist,
	 * because pulling up the subquery's subqueries might have changed their
	 * expansions into arbitrary expressions, which could affect
	 * pullup_replace_vars' decisions about whether PlaceHolderVar wrappers
	 * are needed for tlist entries.  (Likely it'd be better to do
	 * flatten_join_alias_vars on the whole query tree at some earlier stage,
	 * maybe even in the rewriter; but for now let's just fix this case here.)
	 */</comment>
	<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust level-0 varnos in subquery so that we can append its rangetable
	 * to upper query's.  We have to fix the subquery's append_rel_list as
	 * well.
	 */</comment>
	<expr_stmt><expr><name>rtoffset</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subquery</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Upper-level vars in subquery are now one level closer to their parent
	 * than before.
	 */</comment>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subquery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The subquery's targetlist items are now in the appropriate form to
	 * insert into the top query, except that we may need to wrap them in
	 * PlaceHolderVars.  Set up required context data for pullup_replace_vars.
	 */</comment>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>target_rte</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* won't need relids */</comment>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>outer_hasSubLinks</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
	<comment type="block">/* these flags will be set below, if needed */</comment>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>wrap_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* initialize cache array with indexes 0 .. length(tlist) */</comment>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>rv_cache</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
								 <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are under an outer join then non-nullable items and lateral
	 * references may have to be turned into PlaceHolderVars.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lowest_nulling_outer_join</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are dealing with an appendrel member then anything that's not a
	 * simple Var has to be turned into a PlaceHolderVar.  We force this to
	 * ensure that what we pull up doesn't get merged into a surrounding
	 * expression during later processing and then fail to match the
	 * expression actually available from the appendrel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>containing_appendrel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>wrap_non_vars</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the parent query uses grouping sets, we need a PlaceHolderVar for
	 * anything that's not a simple Var.  Again, this ensures that expressions
	 * retain their separate identity so that they will match grouping set
	 * columns when appropriate.  (It'd be sufficient to wrap values used in
	 * grouping set columns, and do so only in non-aggregated portions of the
	 * tlist and havingQual, but that would require a lot of infrastructure
	 * that pullup_replace_vars hasn't currently got.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>wrap_non_vars</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Replace all of the top query's references to the subquery's outputs
	 * with copies of the adjusted subtlist items, being careful not to
	 * replace any of the jointree structure. (This'd be a lot cleaner if we
	 * could use query_tree_mutator.)  We have to use PHVs in the targetList,
	 * returningList, and havingQual, since those are certainly above any
	 * outer join.  replace_vars_in_jointree tracks its location in the
	 * jointree and uses PHVs or not appropriately.
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator>
			<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume ON CONFLICT's arbiterElems, arbiterWhere, exclRelTlist
		 * can't contain any references to a subquery
		 */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>replace_vars_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>,
							 <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>pullup_replace_vars</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace references in the translated_vars lists of appendrels. When
	 * pulling up an appendrel member, we do not need PHVs in the list of the
	 * parent appendrel --- there isn't any outer join between. Elsewhere, use
	 * PHVs for safety.  (This analysis could be made tighter but it seems
	 * unlikely to be worth much trouble.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_need_phvs</name> <init>= <expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>appinfo</name> <operator>==</operator> <name>containing_appendrel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>save_need_phvs</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Replace references in the joinaliasvars lists of join RTEs.
	 *
	 * You might think that we could avoid using PHVs for alias vars of joins
	 * below lowest_nulling_outer_join, but that doesn't work because the
	 * alias vars could be referenced above that join; we need the PHVs to be
	 * present in such references after the alias vars get flattened.  (It
	 * might be worth trying to be smarter here, someday.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>otherrte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>otherrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>otherrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
				<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>otherrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the subquery had a LATERAL marker, propagate that to any of its
	 * child RTEs that could possibly now contain lateral cross-references.
	 * The children might or might not contain any actual lateral
	 * cross-references, but we have to mark the pulled-up child RTEs so that
	 * later planner stages will check for such.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subquery-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>child_rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>child_rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTE_RELATION</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>child_rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
					<expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_JOIN</name></expr>:</case>
				<case>case <expr><name>RTE_CTE</name></expr>:</case>
				<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
				<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
				<case>case <expr><name>RTE_VOID</name></expr>:</case>
					<comment type="block">/* these can't contain any lateral references */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now append the adjusted rtable entries to upper query. (We hold off
	 * until after fixing the upper rtable entries; no point in running that
	 * code on the subquery ones too.)
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pull up any FOR UPDATE/SHARE markers, too.  (OffsetVarNodes already
	 * adjusted the marker rtindexes, so just concat the lists.)
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We also have to fix the relid sets of any PlaceHolderVar nodes in the
	 * parent query.  (This could perhaps be done by pullup_replace_vars(),
	 * but it seems cleaner to use two passes.)  Note in particular that any
	 * PlaceHolderVar nodes just created by pullup_replace_vars() will be
	 * adjusted, so having created them with the subquery's varno is correct.
	 *
	 * Likewise, relids appearing in AppendRelInfo nodes have to be fixed. We
	 * already checked that this won't require introducing multiple subrelids
	 * into the single-slot AppendRelInfo structs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastPHId</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>subrelids</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subrelids</name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>substitute_multiple_relids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parse</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>subrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_append_rel_relids</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>subrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And now add subquery's AppendRelInfos to our list.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>,
										<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't have to do the equivalent bookkeeping for outer-join info,
	 * because that hasn't been set up yet.  placeholder_list likewise.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Miscellaneous housekeeping.
	 *
	 * Although replace_rte_variables() faithfully updated parse-&gt;hasSubLinks
	 * if it copied any SubLinks out of the subquery's targetlist, we still
	 * could have SubLinks added to the query in the expressions of FUNCTION
	 * and VALUES RTEs copied up from the subquery.  So it's necessary to copy
	 * subquery-&gt;hasSubLinks anyway.  Perhaps this can be improved someday.
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>|=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>;</expr_stmt>

	<comment type="block">/* If subquery had any RLS conditions, now main query does too */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>hasRowSecurity</name></name> <operator>|=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>hasRowSecurity</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * subquery won't be pulled up if it hasAggs, hasWindowFuncs, or
	 * hasTargetSRFs, so no work needed on those flags
	 */</comment>

	<comment type="block">/*
	 * Return the adjusted subquery jointree to replace the RangeTblRef entry
	 * in parent's jointree; or, if we're flattening a subquery with empty
	 * FROM list, return NULL to signal deletion of the subquery from the
	 * parent jointree (and set hasDeletedRTEs to ensure cleanup later).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>deletion_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasDeletedRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_simple_union_all
 *		Pull up a single simple UNION ALL subquery.
 *
 * jtnode is a RangeTblRef that has been identified as a simple UNION ALL
 * subquery by pull_up_subqueries.  We pull up the leaf subqueries and
 * build an "append relation" for the union set.  The result value is just
 * jtnode, since we don't actually need to change the query jointree.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_simple_union_all</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make a modifiable copy of the subquery's rtable, so we can adjust
	 * upper-level Vars in it.  There are no such Vars in the setOperations
	 * tree proper, so fixing the rtable should be sufficient.
	 */</comment>
	<expr_stmt><expr><name>rtable</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Upper-level vars in subquery are now one level closer to their parent
	 * than before.  We don't have to worry about offsetting varnos, though,
	 * because the UNION leaf queries can't cross-reference each other.
	 */</comment>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp_rtable</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the UNION ALL subquery had a LATERAL marker, propagate that to all
	 * its children.  The individual children might or might not contain any
	 * actual lateral cross-references, but we have to mark the pulled-up
	 * child RTEs so that later planner stages will check for such.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rt</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rt</argument>, <argument>rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>child_rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>child_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Append child RTEs to parent rtable.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recursively scan the subquery's setOperations tree and add
	 * AppendRelInfo nodes for leaf subqueries to the parent's
	 * append_rel_list.  Also apply pull_up_subqueries to the leaf subqueries.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pull_up_union_leaf_queries</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
							   <argument><expr><name>rtoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the parent as an append relation.
	 */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>jtnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_union_leaf_queries -- recursive guts of pull_up_simple_union_all
 *
 * Build an AppendRelInfo for each leaf query in the setop tree, and then
 * apply pull_up_subqueries to the leaf query.
 *
 * Note that setOpQuery is the Query containing the setOp node, whose tlist
 * contains references to all the setop output columns.  When called from
 * pull_up_simple_union_all, this is *not* the same as root-&gt;parse, which is
 * the parent Query we are pulling up into.
 *
 * parentRTindex is the appendrel parent's index in root-&gt;parse-&gt;rtable.
 *
 * The child RTEs have already been copied to the parent.  childRToffset
 * tells us where in the parent's range table they were copied.  When called
 * from flatten_simple_union_all, childRToffset is 0 since the child RTEs
 * were already in root-&gt;parse-&gt;rtable and no RT index adjustment is needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pull_up_union_leaf_queries</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parentRTindex</name></decl></parameter>,
						   <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>setOpQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>childRToffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childRTindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Calculate the index in the parent's range table
		 */</comment>
		<expr_stmt><expr><name>childRTindex</name> <operator>=</operator> <name>childRToffset</name> <operator>+</operator> <name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build a suitable AppendRelInfo, and attach to parent's list.
		 */</comment>
		<expr_stmt><expr><name>appinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>=</operator> <name>parentRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reltype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_reltype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>make_setop_translation_list</name><argument_list>(<argument><expr><name>setOpQuery</name></expr></argument>, <argument><expr><name>childRTindex</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recursively apply pull_up_subqueries to the new child RTE.  (We
		 * must build the AppendRelInfo first, because this will modify it.)
		 * Note that we can pass NULL for containing-join info even if we're
		 * actually under an outer join, because the child's expressions
		 * aren't going to propagate up to the join.  Also, we ignore the
		 * possibility that pull_up_subqueries_recurse() returns a different
		 * jointree node than what we pass it; if it does, the important thing
		 * is that it replaced the child relid in the AppendRelInfo node.
		 */</comment>
		<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>childRTindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pull_up_subqueries_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>appinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Recurse to reach leaf queries */</comment>
		<expr_stmt><expr><call><name>pull_up_union_leaf_queries</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>parentRTindex</name></expr></argument>, <argument><expr><name>setOpQuery</name></expr></argument>,
								   <argument><expr><name>childRToffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pull_up_union_leaf_queries</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>parentRTindex</name></expr></argument>, <argument><expr><name>setOpQuery</name></expr></argument>,
								   <argument><expr><name>childRToffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * make_setop_translation_list
 *	  Build the list of translations from parent Vars to child Vars for
 *	  a UNION ALL member.  (At this point it's just a simple list of
 *	  referencing Vars, but if we succeed in pulling up the member
 *	  subquery, the Vars will get replaced by pulled-up expressions.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_setop_translation_list</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>translated_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>newvarno</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>translated_vars</name> <operator>=</operator> <name>vars</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * is_simple_subquery
 *	  Check a subquery in the range table to see if it's simple enough
 *	  to pull up into the parent query.
 *
 * rte is the RTE_SUBQUERY RangeTblEntry that contained the subquery.
 * (Note subquery is not necessarily equal to rte-&gt;subquery; it could be a
 * processed copy of that.)
 * lowest_outer_join is the lowest outer join above the subquery, or NULL.
 * deletion_ok is true if it'd be okay to delete the subquery entirely.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Let's just make sure it's a valid subselect ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't currently pull up a query with setops (unless it's simple UNION
	 * ALL, which is handled by a different code path). Maybe after querytree
	 * redesign...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't pull up a subquery involving grouping, aggregation, SRFs,
	 * sorting, limiting, or WITH.  (XXX WITH could possibly be allowed later)
	 *
	 * We also don't pull up a subquery that has explicit FOR UPDATE/SHARE
	 * clauses, because pullup would cause the locking to occur semantically
	 * higher than it should.  Implicit FOR UPDATE/SHARE is okay because in
	 * that case the locking was originally declared in the upper query
	 * anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't pull up if the RTE represents a security-barrier view; we
	 * couldn't prevent information leakage once the RTE's Vars are scattered
	 * about in the upper query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>security_barrier</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't pull up a subquery with an empty jointree, unless it has no quals
	 * and deletion_ok is true and we're not underneath an outer join.
	 *
	 * query_planner() will correctly generate a Result plan for a jointree
	 * that's totally empty, but we can't cope with an empty FromExpr
	 * appearing lower down in a jointree: we identify join rels via baserelid
	 * sets, so we couldn't distinguish a join containing such a FromExpr from
	 * one without it.  We can only handle such cases if the place where the
	 * subquery is linked is a FromExpr or inner JOIN that would still be
	 * nonempty after removal of the subquery, so that it's still identifiable
	 * via its contained baserelids.  Safe contexts are signaled by
	 * deletion_ok.
	 *
	 * But even in a safe context, we must keep the subquery if it has any
	 * quals, because it's unclear where to put them in the upper query.
	 *
	 * Also, we must forbid pullup if such a subquery is underneath an outer
	 * join, because then we might need to wrap its output columns with
	 * PlaceHolderVars, and the PHVs would then have empty relid sets meaning
	 * we couldn't tell where to evaluate them.  (This test is separate from
	 * the deletion_ok flag for possible future expansion: deletion_ok tells
	 * whether the immediate parent site in the jointree could cope, not
	 * whether we'd have PHV issues.  It's possible this restriction could be
	 * fixed by letting the PHVs use the relids of the parent jointree item,
	 * but that complication is for another day.)
	 *
	 * Note that deletion of a subquery is also dependent on the check below
	 * that its targetlist contains no set-returning functions.  Deletion from
	 * a FROM list or inner JOIN is okay only if the subquery must return
	 * exactly one row.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		 <operator>!</operator><name>deletion_ok</name> <operator>||</operator>
		 <name>lowest_outer_join</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the subquery is LATERAL, check for pullup restrictions from that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>restricted</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>safe_upper_varnos</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The subquery's WHERE and JOIN/ON quals mustn't contain any lateral
		 * references to rels outside a higher outer join (including the case
		 * where the outer join is within the subquery itself).  In such a
		 * case, pulling up would result in a situation where we need to
		 * postpone quals from below an outer join to above it, which is
		 * probably completely wrong and in any case is a complication that
		 * doesn't seem worth addressing at the moment.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lowest_outer_join</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>restricted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>safe_upper_varnos</name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>lowest_outer_join</name></expr></argument>,
													   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>restricted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>safe_upper_varnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>jointree_contains_lateral_outer_refs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
												 <argument><expr><name>restricted</name></expr></argument>, <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there's an outer join above the LATERAL subquery, also disallow
		 * pullup if the subquery's targetlist has any references to rels
		 * outside the outer join, since these might get pulled into quals
		 * above the subquery (but in or below the outer join) and then lead
		 * to qual-postponement issues similar to the case checked for above.
		 * (We wouldn't need to prevent pullup if no such references appear in
		 * outer-query quals, but we don't have enough info here to check
		 * that.  Also, maybe this restriction could be removed if we forced
		 * such refs to be wrapped in PlaceHolderVars, even when they're below
		 * the nearest outer join?	But it's a pretty hokey usage, so not
		 * clear this is worth sweating over.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lowest_outer_join</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>lvarnos</name> <init>= <expr><call><name>pull_varnos_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>lvarnos</name></expr></argument>, <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't pull up a subquery that has any volatile functions in its
	 * targetlist.  Otherwise we might introduce multiple evaluations of these
	 * functions, if they get copied to multiple places in the upper query,
	 * leading to surprising results.  (Note: the PlaceHolderVar mechanism
	 * doesn't quite guarantee single evaluation; else we could pull up anyway
	 * and just wrap such items in PlaceHolderVars ...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_simple_values
 *		Pull up a single simple VALUES RTE.
 *
 * jtnode is a RangeTblRef that has been identified as a simple VALUES RTE
 * by pull_up_subqueries.  We always return NULL indicating that the RTE
 * can be deleted entirely (all failure cases should have been detected by
 * is_simple_values()).
 *
 * rte is the RangeTblEntry referenced by jtnode.  Because of the limited
 * possible usage of VALUES RTEs, we do not need the remaining parameters
 * of pull_up_subqueries_recurse.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_simple_values</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>values_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attrno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pullup_replace_vars_context</name></type> <name>rvcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need a modifiable copy of the VALUES list to hack on, just in case it's
	 * multiply referenced.
	 */</comment>
	<expr_stmt><expr><name>values_list</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The VALUES RTE can't contain any Vars of level zero, let alone any that
	 * are join aliases, so no need to flatten join alias Vars.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>values_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up required context data for pullup_replace_vars.  In particular,
	 * we have to make the VALUES list look like a subquery targetlist.
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>values_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
						<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>attrno</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attrno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>target_rte</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>outer_hasSubLinks</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>need_phvs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>wrap_non_vars</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* initialize cache array with indexes 0 .. length(tlist) */</comment>
	<expr_stmt><expr><name><name>rvcontext</name><operator>.</operator><name>rv_cache</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
								 <sizeof>sizeof<argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace all of the top query's references to the RTE's outputs with
	 * copies of the adjusted VALUES expressions, being careful not to replace
	 * any of the jointree structure. (This'd be a lot cleaner if we could use
	 * query_tree_mutator.)  Much of this should be no-ops in the dummy Query
	 * that surrounds a VALUES RTE, but it's not enough code to be worth
	 * removing.
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator>
			<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume ON CONFLICT's arbiterElems, arbiterWhere, exclRelTlist
		 * can't contain any references to a subquery
		 */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>replace_vars_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>pullup_replace_vars</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rvcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There should be no appendrels to fix, nor any join alias Vars, nor any
	 * outer joins and hence no PlaceHolderVars.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return NULL to signal deletion of the VALUES RTE from the parent
	 * jointree (and set hasDeletedRTEs to ensure cleanup later).
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasDeletedRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_simple_values
 *	  Check a VALUES RTE in the range table to see if it's simple enough
 *	  to pull up into the parent query.
 *
 * rte is the RTE_VALUES RangeTblEntry to check.
 * deletion_ok is true if it'd be okay to delete the VALUES RTE entirely.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_values</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can only pull up a VALUES RTE if deletion_ok is true.  It's
	 * basically the same case as a sub-select with empty FROM list; see
	 * comments in is_simple_subquery().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deletion_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also, there must be exactly one VALUES list, else it's not semantically
	 * correct to delete the VALUES RTE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Because VALUES can't appear under an outer join (or at least, we won't
	 * try to pull it up if it does), we need not worry about LATERAL, nor
	 * about validity of PHVs for the VALUES' outputs.
	 */</comment>

	<comment type="block">/*
	 * Don't pull up a VALUES that contains any set-returning or volatile
	 * functions.  Again, the considerations here are basically identical to
	 * restrictions on a subquery's targetlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do not pull up a VALUES that's not the only RTE in its parent query.
	 * This is actually the only case that the parser will generate at the
	 * moment, and assuming this is true greatly simplifies
	 * pull_up_simple_values().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<name>rte</name> <operator>!=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_simple_union_all
 *	  Check a subquery to see if it's a simple UNION ALL.
 *
 * We require all the setops to be UNION ALL (no mixing) and there can't be
 * any datatype coercions involved, ie, all the leaf queries must emit the
 * same datatypes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_union_all</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>topop</name></decl>;</decl_stmt>

	<comment type="block">/* Let's just make sure it's a valid subselect ... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Is it a set-operation query at all? */</comment>
	<expr_stmt><expr><name>topop</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>, <argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>topop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Can't handle ORDER BY, LIMIT/OFFSET, locking, or WITH */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Recursively check the tree of set operations */</comment>
	<return>return <expr><call><name>is_simple_union_all_recurse</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>topop</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
									   <argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_union_all_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>setOpQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>setOpQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Leaf nodes are OK if they match the toplevel column types */</comment>
		<comment type="block">/* We don't have to compare typmods or collations here */</comment>
		<return>return <expr><call><name>tlist_same_datatypes</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>colTypes</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Must be UNION ALL */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Recurse to check inputs */</comment>
		<return>return <expr><call><name>is_simple_union_all_recurse</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>setOpQuery</name></expr></argument>, <argument><expr><name>colTypes</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>is_simple_union_all_recurse</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>setOpQuery</name></expr></argument>, <argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * is_safe_append_member
 *	  Check a subquery that is a leaf of a UNION ALL appendrel to see if it's
 *	  safe to pull up.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_safe_append_member</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>jtnode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's only safe to pull up the child if its jointree contains exactly
	 * one RTE, else the AppendRelInfo data structure breaks. The one base RTE
	 * could be buried in several levels of FromExpr, however.
	 *
	 * Also, the child can't have any WHERE quals because there's no place to
	 * put them in an appendrel.  (This is a bit annoying...) If we didn't
	 * need to check this, we'd just test whether get_relids_in_jointree()
	 * yields a singleton set, to be more consistent with the coding of
	 * fix_append_rel_relids().
	 */</comment>
	<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>jtnode</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>jtnode</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>jtnode</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * jointree_contains_lateral_outer_refs
 *		Check for disallowed lateral references in a jointree's quals
 *
 * If restricted is false, all level-1 Vars are allowed (but we still must
 * search the jointree, since it might contain outer joins below which there
 * will be restrictions).  If restricted is true, return true when any qual
 * in the jointree contains level-1 Vars coming from outside the rels listed
 * in safe_upper_varnos.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>jointree_contains_lateral_outer_refs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restricted</name></decl></parameter>,
									 <parameter><decl><type><name>Relids</name></type> <name>safe_upper_varnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* First, recurse to check child joins */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>jointree_contains_lateral_outer_refs</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>restricted</name></expr></argument>,
													 <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Then check the top-level quals */</comment>
		<if_stmt><if>if <condition>(<expr><name>restricted</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>pull_varnos_of_level</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this is an outer join, we mustn't allow any upper lateral
		 * references in or below it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>restricted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>safe_upper_varnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check the child joins */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>jointree_contains_lateral_outer_refs</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
												 <argument><expr><name>restricted</name></expr></argument>,
												 <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>jointree_contains_lateral_outer_refs</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
												 <argument><expr><name>restricted</name></expr></argument>,
												 <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Check the JOIN's qual clauses */</comment>
		<if_stmt><if>if <condition>(<expr><name>restricted</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>pull_varnos_of_level</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>safe_upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine for pull_up_subqueries: do pullup_replace_vars on every
 * expression in the jointree, without changing the jointree structure itself.
 * Ugly, but there's no other way...
 *
 * If we are at or below lowest_nulling_outer_join, we can suppress use of
 * PlaceHolderVars wrapped around the replacement expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>replace_vars_in_jointree</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						 <parameter><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						 <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_nulling_outer_join</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the RangeTblRef refers to a LATERAL subquery (that isn't the
		 * same subquery we're pulling up), it might contain references to the
		 * target subquery, which we must replace.  We drive this from the
		 * jointree scan, rather than a scan of the rtable, for a couple of
		 * reasons: we can avoid processing no-longer-referenced RTEs, and we
		 * can use the appropriate setting of need_phvs depending on whether
		 * the RTE is above possibly-nulling outer joins or not.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>	<comment type="block">/* ignore target subquery itself */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>target_rte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>RTE_RELATION</name></expr>:</case>
						<comment type="block">/* shouldn't be marked LATERAL unless tablesample */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator>
							<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>,
												<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator>
							<call><name>pullup_replace_vars_subquery</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
														 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
					<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
							<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
												<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator>
							<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>,
												<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RTE_VALUES</name></expr>:</case>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
							<call><name>pullup_replace_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>,
												<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RTE_JOIN</name></expr>:</case>
					<case>case <expr><name>RTE_CTE</name></expr>:</case>
					<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
					<case>case <expr><name>RTE_VOID</name></expr>:</case>
						<comment type="block">/* these shouldn't be marked LATERAL */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>replace_vars_in_jointree</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									 <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pullup_replace_vars</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_need_phvs</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>need_phvs</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>lowest_nulling_outer_join</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no more PHVs in or below this join */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>need_phvs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowest_nulling_outer_join</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>replace_vars_in_jointree</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>replace_vars_in_jointree</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>lowest_nulling_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>pullup_replace_vars</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't bother to update the colvars list, since it won't be used
		 * again ...
		 */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>need_phvs</name></name> <operator>=</operator> <name>save_need_phvs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply pullup variable replacement throughout an expression tree
 *
 * Returns a modified copy of the tree, so this can't be used where we
 * need to do in-place replacement.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pullup_replace_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>replace_rte_variables</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
								 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>pullup_replace_vars_callback</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>outer_hasSubLinks</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pullup_replace_vars_callback</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
							 <parameter><decl><type><name>replace_rte_variables_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>rcon</name> <init>= <expr><operator>(</operator><name>pullup_replace_vars_context</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>callback_arg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varattno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If PlaceHolderVars are needed, we cache the modified expressions in
	 * rcon-&gt;rv_cache[].  This is not in hopes of any material speed gain
	 * within this function, but to avoid generating identical PHVs with
	 * different IDs.  That would result in duplicate evaluations at runtime,
	 * and possibly prevent optimizations that rely on recognizing different
	 * references to the same subquery output as being equal().  So it's worth
	 * a bit of extra effort to avoid it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rcon</name><operator>-&gt;</operator><name>need_phvs</name></name> <operator>&amp;&amp;</operator>
		<name>varattno</name> <operator>&gt;=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator>
		<name>varattno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>rcon</name><operator>-&gt;</operator><name>rv_cache</name><index>[<expr><name>varattno</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Just copy the entry and fall through to adjust its varlevelsup */</comment>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>rv_cache</name><index>[<expr><name>varattno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must expand whole-tuple reference into RowExpr */</comment>
		<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_need_phvs</name> <init>= <expr><name><name>rcon</name><operator>-&gt;</operator><name>need_phvs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_sublevelsup</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If generating an expansion for a var of a named rowtype (ie, this
		 * is a plain relation RTE), then we must include dummy items for
		 * dropped columns.  If the var is RECORD (ie, this is a JOIN), then
		 * omit dropped columns. Either way, attach column names to the
		 * RowExpr for use of ruleutils.c.
		 *
		 * In order to be able to cache the results, we always generate the
		 * expansion with varlevelsup = 0, and then adjust if needed.
		 */</comment>
		<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>target_rte</name></name></expr></argument>,
				  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* not varlevelsup */</comment> , <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
				  <argument><expr><operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name><operator>)</operator></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Adjust the generated per-field Vars, but don't insert PHVs */</comment>
		<expr_stmt><expr><name><name>rcon</name><operator>-&gt;</operator><name>need_phvs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* to match the expandRTE output */</comment>
		<expr_stmt><expr><name>fields</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_rte_variables_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fields</name></expr></argument>,
														<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rcon</name><operator>-&gt;</operator><name>need_phvs</name></name> <operator>=</operator> <name>save_need_phvs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>=</operator> <name>save_sublevelsup</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>colnames</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Insert PlaceHolderVar if needed.  Notice that we are wrapping one
		 * PlaceHolderVar around the whole RowExpr, rather than putting one
		 * around each element of the row.  This is because we need the
		 * expression to yield NULL, not ROW(NULL,NULL,...) when it is forced
		 * to null by an outer join.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rcon</name><operator>-&gt;</operator><name>need_phvs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* RowExpr is certainly not strict, so always need PHV */</comment>
			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>make_placeholder_expr</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>,
									  <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* cache it with the PHV, and with varlevelsup still zero */</comment>
			<expr_stmt><expr><name><name>rcon</name><operator>-&gt;</operator><name>rv_cache</name><index>[<expr><name>InvalidAttrNumber</name></expr>]</index></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal case referencing one targetlist element */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find attribute %d in subquery targetlist"</literal></expr></argument>,
				 <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make a copy of the tlist item to return */</comment>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Insert PlaceHolderVar if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rcon</name><operator>-&gt;</operator><name>need_phvs</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>wrap</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>newnode</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>newnode</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Simple Vars always escape being wrapped, unless they are
				 * lateral references to something outside the subquery being
				 * pulled up.  (Even then, we could omit the PlaceHolderVar if
				 * the referenced rel is under the same lowest outer join, but
				 * it doesn't seem worth the trouble to check that.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rcon</name><operator>-&gt;</operator><name>target_rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>newnode</name><operator>)</operator><operator>-&gt;</operator><name>varno</name></expr></argument>, <argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>newnode</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>newnode</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No need to wrap a PlaceHolderVar with another one, either */</comment>
				<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rcon</name><operator>-&gt;</operator><name>wrap_non_vars</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Wrap all non-Vars in a PlaceHolderVar */</comment>
				<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If it contains a Var of the subquery being pulled up, and
				 * does not contain any non-strict constructs, then it's
				 * certainly nullable so we don't need to insert a
				 * PlaceHolderVar.
				 *
				 * This analysis could be tighter: in particular, a non-strict
				 * construct hidden within a lower-level PlaceHolderVar is not
				 * reason to add another PHV.  But for now it doesn't seem
				 * worth the code to be more exact.
				 *
				 * Note: in future maybe we should insert a PlaceHolderVar
				 * anyway, if the tlist item is expensive to evaluate?
				 *
				 * For a LATERAL subquery, we have to check the actual var
				 * membership of the node, but if it's non-lateral then any
				 * level-zero var must belong to the subquery.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name><name>rcon</name><operator>-&gt;</operator><name>target_rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then>
					 <expr><call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>contain_nonstrict_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* No wrap needed */</comment>
					<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Else wrap it in a PlaceHolderVar */</comment>
					<expr_stmt><expr><name>wrap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>wrap</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
					<call><name>make_placeholder_expr</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr></argument>,
										  <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Cache it if possible (ie, if the attno is in range, which it
			 * probably always should be).  We can cache the value even if we
			 * decided we didn't need a PHV, since this result will be
			 * suitable for any request that has need_phvs.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>varattno</name> <operator>&gt;</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator>
				<name>varattno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rcon</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rcon</name><operator>-&gt;</operator><name>rv_cache</name><index>[<expr><name>varattno</name></expr>]</index></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Must adjust varlevelsup if tlist item is from higher query */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>newnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply pullup variable replacement to a subquery
 *
 * This needs to be different from pullup_replace_vars() because
 * replace_rte_variables will think that it shouldn't increment sublevels_up
 * before entering the Query; so we need to call it with sublevels_up == 1.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>pullup_replace_vars_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
							 <parameter><decl><type><name>pullup_replace_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>replace_rte_variables</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>,
										   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><name>pullup_replace_vars_callback</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_up_subqueries_cleanup
 *		Recursively fix up jointree after deletion of some subqueries.
 *
 * The jointree now contains some NULL subtrees, which we need to get rid of.
 * In a FromExpr, just rebuild the child-node list with null entries deleted.
 * In an inner JOIN, replace the JoinExpr node with a one-child FromExpr.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pull_up_subqueries_cleanup</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>jtnode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing to do at leaf nodes. */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newfrom</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>child</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>pull_up_subqueries_cleanup</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newfrom</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newfrom</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <name>newfrom</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_cleanup</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>pull_up_subqueries_cleanup</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>jtnode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * flatten_simple_union_all
 *		Try to optimize top-level UNION ALL structure into an appendrel
 *
 * If a query's setOperations tree consists entirely of simple UNION ALL
 * operations, flatten it into an append relation, which we can process more
 * intelligently than the general setops case.  Otherwise, do nothing.
 *
 * In most cases, this can succeed only for a top-level query, because for a
 * subquery in FROM, the parent query's invocation of pull_up_subqueries would
 * already have flattened the UNION via pull_up_simple_union_all.  But there
 * are a few cases we can support here but not in that code path, for example
 * when the subquery also contains ORDER BY.
 */</comment>
<function><type><name>void</name></type>
<name>flatten_simple_union_all</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>topop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftmostjtnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftmostRTI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftmostRTE</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>childRTI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>childRTE</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't be called unless query has setops */</comment>
	<expr_stmt><expr><name>topop</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>topop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't optimize away a recursive UNION */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Recursively check the tree of set operations.  If not all UNION ALL
	 * with identical column types, punt.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_simple_union_all_recurse</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>topop</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name><name>topop</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Locate the leftmost leaf query in the setops tree.  The upper query's
	 * Vars all refer to this RTE (see transformSetOperationStmt).
	 */</comment>
	<expr_stmt><expr><name>leftmostjtnode</name> <operator>=</operator> <name><name>topop</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>leftmostjtnode</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftmostjtnode</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftmostjtnode</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>leftmostjtnode</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostjtnode</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>leftmostjtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>leftmostjtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmostRTE</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftmostRTE</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a copy of the leftmost RTE and add it to the rtable.  This copy
	 * will represent the leftmost leaf query in its capacity as a member of
	 * the appendrel.  The original will represent the appendrel as a whole.
	 * (We must do things this way because the upper query's Vars have to be
	 * seen as referring to the whole appendrel.)
	 */</comment>
	<expr_stmt><expr><name>childRTE</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>leftmostRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>childRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>childRTI</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Modify the setops tree to reference the child copy */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>leftmostjtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name> <operator>=</operator> <name>childRTI</name></expr>;</expr_stmt>

	<comment type="block">/* Modify the formerly-leftmost RTE to mark it as an appendrel parent */</comment>
	<expr_stmt><expr><name><name>leftmostRTE</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form a RangeTblRef for the appendrel, and insert it into FROM.  The top
	 * Query of a setops tree should have had an empty FromClause initially.
	 */</comment>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>leftmostRTI</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now pretend the query has no setops.  We must do this before trying to
	 * do subquery pullup, because of Assert in pull_up_simple_subquery.
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build AppendRelInfo information, and apply pull_up_subqueries to the
	 * leaf queries of the UNION ALL.  (We must do that now because they
	 * weren't previously referenced by the jointree, and so were missed by
	 * the main invocation of pull_up_subqueries.)
	 */</comment>
	<expr_stmt><expr><call><name>pull_up_union_leaf_queries</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>topop</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * reduce_outer_joins
 *		Attempt to reduce outer joins to plain inner joins.
 *
 * The idea here is that given a query like
 *		SELECT ... FROM a LEFT JOIN b ON (...) WHERE b.y = 42;
 * we can reduce the LEFT JOIN to a plain JOIN if the "=" operator in WHERE
 * is strict.  The strict operator will always return NULL, causing the outer
 * WHERE to fail, on any row where the LEFT JOIN filled in NULLs for b's
 * columns.  Therefore, there's no need for the join to produce null-extended
 * rows in the first place --- which makes it a plain join not an outer join.
 * (This scenario may not be very likely in a query written out by hand, but
 * it's reasonably likely when pushing quals down into complex views.)
 *
 * More generally, an outer join can be reduced in strength if there is a
 * strict qual above it in the qual tree that constrains a Var from the
 * nullable side of the join to be non-null.  (For FULL joins this applies
 * to each side separately.)
 *
 * Another transformation we apply here is to recognize cases like
 *		SELECT ... FROM a LEFT JOIN b ON (a.x = b.y) WHERE b.y IS NULL;
 * If the join clause is strict for b.y, then only null-extended rows could
 * pass the upper WHERE, and we can conclude that what the query is really
 * specifying is an anti-semijoin.  We change the join type from JOIN_LEFT
 * to JOIN_ANTI.  The IS NULL clause then becomes redundant, and must be
 * removed to prevent bogus selectivity calculations, but we leave it to
 * distribute_qual_to_rels to get rid of such clauses.
 *
 * Also, we get rid of JOIN_RIGHT cases by flipping them around to become
 * JOIN_LEFT.  This saves some code here and in some later planner routines,
 * but the main reason to do it is to not need to invent a JOIN_REVERSE_ANTI
 * join type.
 *
 * To ease recognition of strict qual clauses, we require this routine to be
 * run after expression preprocessing (i.e., qual canonicalization and JOIN
 * alias-var expansion).
 */</comment>
<function><type><name>void</name></type>
<name>reduce_outer_joins</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid doing strictness checks on more quals than necessary, we want
	 * to stop descending the jointree as soon as there are no outer joins
	 * below our current point.  This consideration forces a two-pass process.
	 * The first pass gathers information about which base rels appear below
	 * each side of each join clause, and about whether there are outer
	 * join(s) below each side of each join clause. The second pass examines
	 * qual clauses and changes join types as it descends the tree.
	 */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>reduce_outer_joins_pass1</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* planner.c shouldn't have called me if no outer joins */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"so where are the outer joins?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>reduce_outer_joins_pass2</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
							 <argument><expr><name>state</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * reduce_outer_joins_pass1 - phase 1 data collection
 *
 * Returns a state node describing the given jointree node.
 */</comment>
<function><type><specifier>static</specifier> <name>reduce_outer_joins_state</name> <modifier>*</modifier></type>
<name>reduce_outer_joins_pass1</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>reduce_outer_joins_state</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reduce_outer_joins_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>contains_outer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>sub_state</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sub_state</name> <operator>=</operator> <call><name>reduce_outer_joins_pass1</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name><name>sub_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>contains_outer</name></name> <operator>|=</operator> <name><name>sub_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>, <argument><expr><name>sub_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>sub_state</name></decl>;</decl_stmt>

		<comment type="block">/* join's own RT index is not wanted in result-&gt;relids */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>contains_outer</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>sub_state</name> <operator>=</operator> <call><name>reduce_outer_joins_pass1</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										 <argument><expr><name><name>sub_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>contains_outer</name></name> <operator>|=</operator> <name><name>sub_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>, <argument><expr><name>sub_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sub_state</name> <operator>=</operator> <call><name>reduce_outer_joins_pass1</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										 <argument><expr><name><name>sub_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>contains_outer</name></name> <operator>|=</operator> <name><name>sub_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>, <argument><expr><name>sub_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reduce_outer_joins_pass2 - phase 2 processing
 *
 *	jtnode: current jointree node
 *	state: state data collected by phase 1 for this node
 *	root: toplevel planner state
 *	nonnullable_rels: set of base relids forced non-null by upper quals
 *	nonnullable_vars: list of Vars forced non-null by upper quals
 *	forced_null_vars: list of Vars forced null by upper quals
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce_outer_joins_pass2</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
						 <parameter><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Relids</name></type> <name>nonnullable_rels</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nonnullable_vars</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>forced_null_vars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * pass 2 should never descend as far as an empty subnode or base rel,
	 * because it's only called on subtrees marked as contains_outer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"reached empty jointree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"reached base rel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>pass_nonnullable_rels</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pass_nonnullable_vars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pass_forced_null_vars</name></decl>;</decl_stmt>

		<comment type="block">/* Scan quals to see if we can add any constraints */</comment>
		<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <call><name>find_nonnullable_rels</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>pass_nonnullable_rels</name></expr></argument>,
												<argument><expr><name>nonnullable_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* NB: we rely on list_concat to not damage its second argument */</comment>
		<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <call><name>find_nonnullable_vars</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pass_nonnullable_vars</name></expr></argument>,
											<argument><expr><name>nonnullable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <call><name>find_forced_null_vars</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pass_forced_null_vars</name></expr></argument>,
											<argument><expr><name>forced_null_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* And recurse --- but only into interesting subtrees */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>, <argument>s</argument>, <argument>state-&gt;sub_states</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>sub_state</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>sub_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>reduce_outer_joins_pass2</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sub_state</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>pass_nonnullable_rels</name></expr></argument>,
										 <argument><expr><name>pass_nonnullable_vars</name></expr></argument>,
										 <argument><expr><name>pass_forced_null_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>pass_nonnullable_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* can't so easily clean up var lists, unfortunately */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name> <init>= <expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>left_state</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>reduce_outer_joins_state</name> <modifier>*</modifier></type><name>right_state</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>local_nonnullable_vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>computed_local_nonnullable_vars</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Can we simplify this join? */</comment>
		<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>nonnullable_rels</name></expr></argument>, <argument><expr><name><name>right_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>nonnullable_rels</name></expr></argument>, <argument><expr><name><name>left_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>nonnullable_rels</name></expr></argument>, <argument><expr><name><name>left_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>nonnullable_rels</name></expr></argument>, <argument><expr><name><name>right_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>nonnullable_rels</name></expr></argument>, <argument><expr><name><name>right_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_RIGHT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
			<case>case <expr><name>JOIN_ANTI</name></expr>:</case>

				<comment type="block">/*
				 * These could only have been introduced by pull_up_sublinks,
				 * so there's no way that upper quals could refer to their
				 * righthand sides, and no point in checking.
				 */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Convert JOIN_RIGHT to JOIN_LEFT.  Note that in the case where we
		 * reduced JOIN_FULL to JOIN_RIGHT, this will mean the JoinExpr no
		 * longer matches the internal ordering of any CoalesceExpr's built to
		 * represent merged join variables.  We don't care about that at
		 * present, but be wary of it ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tmparg</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tmparg</name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <name>tmparg</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>right_state</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>left_state</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sub_states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * See if we can reduce JOIN_LEFT to JOIN_ANTI.  This is the case if
		 * the join's own quals are strict for any var that was forced null by
		 * higher qual levels.  NOTE: there are other ways that we could
		 * detect an anti-join, in particular if we were to check whether Vars
		 * coming from the RHS must be non-null because of table constraints.
		 * That seems complicated and expensive though (in particular, one
		 * would have to be wary of lower outer joins). For the moment this
		 * seems sufficient.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>overlap</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>local_nonnullable_vars</name> <operator>=</operator> <call><name>find_nonnullable_vars</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>computed_local_nonnullable_vars</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * It's not sufficient to check whether local_nonnullable_vars and
			 * forced_null_vars overlap: we need to know if the overlap
			 * includes any RHS variables.
			 */</comment>
			<expr_stmt><expr><name>overlap</name> <operator>=</operator> <call><name>list_intersection</name><argument_list>(<argument><expr><name>local_nonnullable_vars</name></expr></argument>,
										<argument><expr><name>forced_null_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>overlap</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>overlap</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>right_state</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>jointype</name> <operator>=</operator> <name>JOIN_ANTI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Apply the jointype change, if any, to both jointree node and RTE */</comment>
		<if_stmt><if>if <condition>(<expr><name>rtindex</name> <operator>&amp;&amp;</operator> <name>jointype</name> <operator>!=</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>

		<comment type="block">/* Only recurse if there's more to do below here */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>left_state</name><operator>-&gt;</operator><name>contains_outer</name></name> <operator>||</operator> <name><name>right_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>local_nonnullable_rels</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>local_forced_null_vars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relids</name></type>		<name>pass_nonnullable_rels</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pass_nonnullable_vars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pass_forced_null_vars</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this join is (now) inner, we can add any constraints its
			 * quals provide to those we got from above.  But if it is outer,
			 * we can pass down the local constraints only into the nullable
			 * side, because an outer join never eliminates any rows from its
			 * non-nullable side.  Also, there is no point in passing upper
			 * constraints into the nullable side, since if there were any
			 * we'd have been able to reduce the join.  (In the case of upper
			 * forced-null constraints, we *must not* pass them into the
			 * nullable side --- they either applied here, or not.) The upshot
			 * is that we pass either the local or the upper constraints,
			 * never both, to the children of an outer join.
			 *
			 * Note that a SEMI join works like an inner join here: it's okay
			 * to pass down both local and upper constraints.  (There can't be
			 * any upper constraints affecting its inner side, but it's not
			 * worth having a separate code path to avoid passing them.)
			 *
			 * At a FULL join we just punt and pass nothing down --- is it
			 * possible to be smarter?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>local_nonnullable_rels</name> <operator>=</operator> <call><name>find_nonnullable_rels</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>computed_local_nonnullable_vars</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>local_nonnullable_vars</name> <operator>=</operator> <call><name>find_nonnullable_vars</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>local_forced_null_vars</name> <operator>=</operator> <call><name>find_forced_null_vars</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* OK to merge upper and local constraints */</comment>
					<expr_stmt><expr><name>local_nonnullable_rels</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>local_nonnullable_rels</name></expr></argument>,
															 <argument><expr><name>nonnullable_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>local_nonnullable_vars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>local_nonnullable_vars</name></expr></argument>,
														 <argument><expr><name>nonnullable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>local_forced_null_vars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>local_forced_null_vars</name></expr></argument>,
														 <argument><expr><name>forced_null_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* no use in calculating these */</comment>
				<expr_stmt><expr><name>local_nonnullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>local_forced_null_vars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>left_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* pass union of local and upper constraints */</comment>
					<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <name>local_nonnullable_rels</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <name>local_nonnullable_vars</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <name>local_forced_null_vars</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>jointype</name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition> <comment type="block">/* ie, LEFT or ANTI */</comment>
				<block>{<block_content>
					<comment type="block">/* can't pass local constraints to non-nullable side */</comment>
					<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <name>nonnullable_rels</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <name>nonnullable_vars</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <name>forced_null_vars</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* no constraints pass through JOIN_FULL */</comment>
					<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>reduce_outer_joins_pass2</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>left_state</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>pass_nonnullable_rels</name></expr></argument>,
										 <argument><expr><name>pass_nonnullable_vars</name></expr></argument>,
										 <argument><expr><name>pass_forced_null_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>right_state</name><operator>-&gt;</operator><name>contains_outer</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition>	<comment type="block">/* ie, INNER/LEFT/SEMI/ANTI */</comment>
				<block>{<block_content>
					<comment type="block">/* pass appropriate constraints, per comment above */</comment>
					<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <name>local_nonnullable_rels</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <name>local_nonnullable_vars</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <name>local_forced_null_vars</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* no constraints pass through JOIN_FULL */</comment>
					<expr_stmt><expr><name>pass_nonnullable_rels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_nonnullable_vars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass_forced_null_vars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>reduce_outer_joins_pass2</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>right_state</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>pass_nonnullable_rels</name></expr></argument>,
										 <argument><expr><name>pass_nonnullable_vars</name></expr></argument>,
										 <argument><expr><name>pass_forced_null_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>local_nonnullable_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * substitute_multiple_relids - adjust node relid sets after pulling up
 * a subquery
 *
 * Find any PlaceHolderVar nodes in the given tree that reference the
 * pulled-up relid, and change them to reference the replacement relid(s).
 *
 * NOTE: although this has the form of a walker, we cheat and modify the
 * nodes in-place.  This should be OK since the tree was copied by
 * pullup_replace_vars earlier.  Avoid scribbling on the original values of
 * the bitmapsets, though, because expression_tree_mutator doesn't copy those.
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>subrelids</name></decl>;</decl_stmt>
}</block></struct></type> <name>substitute_multiple_relids_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>substitute_multiple_relids_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>substitute_multiple_relids_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>,
									<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>,
										 <argument><expr><name><name>context</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* fall through to examine children */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>substitute_multiple_relids_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Shouldn't need to handle planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AppendRelInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>substitute_multiple_relids_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>substitute_multiple_relids</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>subrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>substitute_multiple_relids_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subrelids</name></name> <operator>=</operator> <name>subrelids</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree.
	 */</comment>
	<expr_stmt><expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									<argument><expr><name>substitute_multiple_relids_walker</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fix_append_rel_relids: update RT-index fields of AppendRelInfo nodes
 *
 * When we pull up a subquery, any AppendRelInfo references to the subquery's
 * RT index have to be replaced by the substituted relid (and there had better
 * be only one).  We also need to apply substitute_multiple_relids to their
 * translated_vars lists, since those might contain PlaceHolderVars.
 *
 * We assume we may modify the AppendRelInfo nodes in-place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fix_append_rel_relids</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>append_rel_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>subrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subvarno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only want to extract the member relid once, but we mustn't fail
	 * immediately if there are multiple members; it could be that none of the
	 * AppendRelInfo nodes refer to it.  So compute it on first use. Note that
	 * bms_singleton_member will complain if set is not singleton.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* The parent_relid shouldn't ever be a pullup target */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>!=</operator> <name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>==</operator> <name>varno</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>subvarno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subvarno</name> <operator>=</operator> <call><name>bms_singleton_member</name><argument_list>(<argument><expr><name>subrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>=</operator> <name>subvarno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Also finish fixups for its translated vars */</comment>
		<expr_stmt><expr><call><name>substitute_multiple_relids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>,
								   <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>subrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_relids_in_jointree: get set of RT indexes present in a jointree
 *
 * If include_joins is true, join RT indexes are included; if false,
 * only base rels are included.
 */</comment>
<function><type><name>Relids</name></type>
<name>get_relids_in_jointree</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_joins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
							  <argument><expr><call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>include_joins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>include_joins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						  <argument><expr><call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>include_joins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>include_joins</name> <operator>&amp;&amp;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_relids_for_join: get set of base RT indexes making up a join
 */</comment>
<function><type><name>Relids</name></type>
<name>get_relids_for_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>joinrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jtnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <call><name>find_jointree_node_for_rel</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
										<argument><expr><name>joinrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>jtnode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find join node %d"</literal></expr></argument>, <argument><expr><name>joinrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_jointree_node_for_rel: locate jointree node for a base or join RT index
 *
 * Returns NULL if not found
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>find_jointree_node_for_rel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>varno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>jtnode</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <call><name>find_jointree_node_for_rel</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>jtnode</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>jtnode</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>jtnode</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <call><name>find_jointree_node_for_rel</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>jtnode</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>jtnode</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>jtnode</name> <operator>=</operator> <call><name>find_jointree_node_for_rel</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>jtnode</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>jtnode</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
