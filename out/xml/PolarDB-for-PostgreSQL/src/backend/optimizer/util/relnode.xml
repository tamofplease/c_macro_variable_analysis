<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/util/relnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * relnode.c
 *	  Relation-node lookup/construction routines
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/relnode.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>JoinHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>Relids</name></type>		<name>join_relids</name></decl>;</decl_stmt>	<comment type="block">/* hash key --- MUST BE FIRST */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>join_rel</name></decl>;</decl_stmt>
}</block></struct></type> <name>JoinHashEntry</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_joinrel_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>build_joinrel_restrictlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_joinrel_joinlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>subbuild_joinrel_restrictlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joininfo_list</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_restrictlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>subbuild_joinrel_joinlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joininfo_list</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_joininfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_foreign_rel_properties</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_joinrel_partition_info</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_child_join_reltarget</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>,
						   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * setup_simple_rel_arrays
 *	  Prepare the arrays we use for quickly accessing base relations.
 */</comment>
<function><type><name>void</name></type>
<name>setup_simple_rel_arrays</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Arrays are accessed using RT indexes (1..N) */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* simple_rel_array is initialized to all NULLs */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name></name> <operator>=</operator> <operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelOptInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* simple_rte_array is an array equivalent of the rtable list */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name></name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * setup_append_rel_array
 *		Populate the append_rel_array to allow direct lookups of
 *		AppendRelInfos by child relid.
 *
 * The array remains unallocated if there are no AppendRelInfos.
 */</comment>
<function><type><name>void</name></type>
<name>setup_append_rel_array</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name> <operator>=</operator> <operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AppendRelInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>child_relid</name> <init>= <expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Sanity check */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>child_relid</name> <operator>&lt;</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>child_relid</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"child relation already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name>child_relid</name></expr>]</index></name> <operator>=</operator> <name>appinfo</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * build_simple_rel
 *	  Construct a new RelOptInfo for a base relation or 'other' relation.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>build_simple_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Rel should not exist already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>relid</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"rel %d already exists"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch RTE for relation */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <ternary><condition><expr><name>parent</name></expr> ?</condition><then> <expr><name>RELOPT_OTHER_MEMBER_REL</name></expr> </then><else>: <expr><name>RELOPT_BASEREL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* cheap startup cost is interesting iff not all tuples to be retrieved */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_startup</name></name> <operator>=</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_param_startup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might get changed later */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* might get changed later */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>;</expr_stmt>
	<comment type="block">/* min_attr, max_attr, attr_needed, attr_widths are set below */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>allvisfrac</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>subplan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* set up in get_relation_info */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>unique_for_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>non_unique_for_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* might get changed later */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pass top parent's relids down the inheritance hierarchy. If the parent
	 * has top_parent_relids set, it's a direct or an indirect child of the
	 * top parent indicated by top_parent_relids. By extension this child is
	 * also an indirect child of that parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Check type of rtable entry */</comment>
	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<comment type="block">/* Table --- retrieve statistics from the system catalogs */</comment>
			<expr_stmt><expr><call><name>get_relation_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>

			<comment type="block">/*
			 * Subquery, function, tablefunc, values list, CTE, or ENR --- set
			 * up attr range and arrays
			 *
			 * Note: 0 is included in range to support whole-row Vars
			 */</comment>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name></name> <operator>=</operator> <operator>(</operator><name>Relids</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Save the finished struct in the query's simple_rel_array */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is a convenient spot at which to note whether rels participating
	 * in the query have any securityQuals attached.  If so, increase
	 * root-&gt;qual_security_level to ensure it's larger than the maximum
	 * security level needed for securityQuals.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name></expr></argument>,
										<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this rel is an appendrel parent, recurse to build "other rel"
	 * RelOptInfos for its children.  They are "other rels" because they are
	 * not in the main join tree, but we will need RelOptInfos to plan access
	 * to them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cnt_parts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>nparts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelOptInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl>;</decl_stmt>

			<comment type="block">/* append_rel_list contains all append rels; ignore others */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>,
										<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Nothing more to do for an unpartitioned table. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * The order of partition OIDs in append_rel_list is the same as
			 * the order in the PartitionDesc, so the order of part_rels will
			 * also match the PartitionDesc.  See expand_partitioned_rtentry.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cnt_parts</name> <operator>&lt;</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name> <operator>=</operator> <name>childrel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt_parts</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* We should have seen all the child partitions. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cnt_parts</name> <operator>==</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_base_rel
 *	  Find a base or other relation entry, which must already exist.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>find_base_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rel</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no relation entry for relid %d"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * build_join_rel_hash
 *	  Construct the auxiliary hash table for join relations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_join_rel_hash</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hashtab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Create the hash table */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relids</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JoinHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>bitmap_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>bitmap_match</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashtab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"JoinRelHashTable"</literal></expr></argument>,
						  <argument><expr><literal type="number">256L</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
						  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert all the already-existing joinrels */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>JoinHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>hashtab</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name><operator>)</operator></expr></argument>,
											   <argument><expr><name>HASH_ENTER</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>join_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_hash</name></name> <operator>=</operator> <name>hashtab</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find_join_rel
 *	  Returns relation entry corresponding to 'relids' (a set of RT indexes),
 *	  or NULL if none exists.  This is for join relations.
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>find_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Switch to using hash lookup when list grows "too long".  The threshold
	 * is arbitrary and is known only here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>join_rel_hash</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>build_join_rel_hash</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use either hashtable lookup or linear search, as appropriate.
	 *
	 * Note: the seemingly redundant hashkey variable is used to avoid taking
	 * the address of relids; unless the compiler is exceedingly smart, doing
	 * so would force relids out of a register and thus probably slow down the
	 * list-search case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_hash</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>hashkey</name> <init>= <expr><name>relids</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>JoinHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_hash</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>hashkey</name></expr></argument>,
											   <argument><expr><name>HASH_FIND</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hentry</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>hentry</name><operator>-&gt;</operator><name>join_rel</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>root-&gt;join_rel_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>rel</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_foreign_rel_properties
 *		Set up foreign-join fields if outer and inner relation are foreign
 *		tables (or joins) belonging to the same server and assigned to the same
 *		user to check access permissions as.
 *
 * In addition to an exact match of userid, we allow the case where one side
 * has zero userid (implying current user) and the other side has explicit
 * userid that happens to equal the current user; but in that case, pushdown of
 * the join is only valid for the current user.  The useridiscurrent field
 * records whether we had to make such an assumption for this join or any
 * sub-join.
 *
 * Otherwise these fields are left invalid, so GetForeignJoinPaths will not be
 * called for the join relation.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_foreign_rel_properties</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>inner_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>==</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>inner_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>==</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>||</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <name><name>outer_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>==</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <name><name>inner_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>==</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_join_rel
 *		Add given join relation to the list of join relations in the given
 *		PlannerInfo. Also add it to the auxiliary hashtable if there is one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* GEQO requires us to append the new joinrel to the end of the list! */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store it into the auxiliary hashtable if there is one. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_hash</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>JoinHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_hash</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name><operator>)</operator></expr></argument>,
											   <argument><expr><name>HASH_ENTER</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>join_rel</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_join_rel
 *	  Returns relation entry corresponding to the union of two given rels,
 *	  creating a new relation entry if none already exists.
 *
 * 'joinrelids' is the Relids set that uniquely identifies the join
 * 'outer_rel' and 'inner_rel' are relation nodes for the relations to be
 *		joined
 * 'sjinfo': join context info
 * 'restrictlist_ptr': result variable.  If not NULL, *restrictlist_ptr
 *		receives the list of RestrictInfo nodes that apply to this
 *		particular pair of joinable relations.
 *
 * restrictlist_ptr makes the routine's API a little grotty, but it saves
 * duplicated calculation of the restrictlist...
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>build_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
			   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
			   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>,
			   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>restrictlist_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>restrictlist</name></decl>;</decl_stmt>

	<comment type="block">/* This function should be used only for join between parents. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if we already have a joinrel for this set of base rels.
	 */</comment>
	<expr_stmt><expr><name>joinrel</name> <operator>=</operator> <call><name>find_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>joinrel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Yes, so we only need to figure the restrictlist for this particular
		 * pair of component relations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>restrictlist_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>restrictlist_ptr</name> <operator>=</operator> <call><name>build_joinrel_restrictlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														   <argument><expr><name>joinrel</name></expr></argument>,
														   <argument><expr><name>outer_rel</name></expr></argument>,
														   <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>joinrel</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Nope, so make one.
	 */</comment>
	<expr_stmt><expr><name>joinrel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_JOINREL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* cheap startup cost is interesting iff not all tuples to be retrieved */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_startup</name></name> <operator>=</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_param_startup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* init direct_lateral_relids from children; we'll finish it up below */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator>
		<call><name>bms_union</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>,
				  <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <call><name>min_join_parameterization</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
														<argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* indicates not a baserel */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>attr_needed</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>statlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>allvisfrac</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>subplan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>unique_for_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>non_unique_for_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* might get changed later */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partition_qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Compute information relevant to the foreign relations. */</comment>
	<expr_stmt><expr><call><name>set_foreign_rel_properties</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a new tlist containing just the vars that need to be output from
	 * this join (ie, are needed for higher joinclauses or final output).
	 *
	 * NOTE: the tlist order for a join rel will depend on which pair of outer
	 * and inner rels we first try to build it from.  But the contents should
	 * be the same regardless.
	 */</comment>
	<expr_stmt><expr><call><name>build_joinrel_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>build_joinrel_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_placeholders_to_joinrel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * add_placeholders_to_joinrel also took care of adding the ph_lateral
	 * sets of any PlaceHolderVars computed here to direct_lateral_relids, so
	 * now we can finish computing that.  This is much like the computation of
	 * the transitively-closed lateral_relids in min_join_parameterization,
	 * except that here we *do* have to consider the added PHVs.
	 */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator>
		<call><name>bms_del_members</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Construct restrict and join clause lists for the new joinrel. (The
	 * caller might or might not need the restrictlist, but I need it anyway
	 * for set_joinrel_size_estimates().)
	 */</comment>
	<expr_stmt><expr><name>restrictlist</name> <operator>=</operator> <call><name>build_joinrel_restrictlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
											  <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>restrictlist_ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>restrictlist_ptr</name> <operator>=</operator> <name>restrictlist</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>build_joinrel_joinlist</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is also the right place to check whether the joinrel has any
	 * pending EquivalenceClass joins.
	 */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <call><name>has_relevant_eclass_joinclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the partition information. */</comment>
	<expr_stmt><expr><call><name>build_joinrel_partition_info</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>,
								 <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set estimates of the joinrel's size.
	 */</comment>
	<expr_stmt><expr><call><name>set_joinrel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>,
							   <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the consider_parallel flag if this joinrel could potentially be
	 * scanned within a parallel worker.  If this flag is false for either
	 * inner_rel or outer_rel, then it must be false for the joinrel also.
	 * Even if both are true, there might be parallel-restricted expressions
	 * in the targetlist or quals.
	 *
	 * Note that if there are more than two rels in this relation, they could
	 * be divided between inner_rel and outer_rel in any arbitrary way.  We
	 * assume this doesn't matter, because we should hit all the same baserels
	 * and joinclauses while building up to this joinrel no matter which we
	 * take; therefore, we should make the same decision here however we get
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>inner_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>restrictlist</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add the joinrel to the PlannerInfo. */</comment>
	<expr_stmt><expr><call><name>add_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also, if dynamic-programming join search is active, add the new joinrel
	 * to the appropriate sublist.  Note: you might think the Assert on number
	 * of members should be for equality, but some of the level 1 rels might
	 * have been joinrels already, so we can only assert &lt;=.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_cur_level</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_cur_level</name></name> <operator>&lt;=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name><index>[<expr><name><name>root</name><operator>-&gt;</operator><name>join_cur_level</name></name></expr>]</index></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_level</name><index>[<expr><name><name>root</name><operator>-&gt;</operator><name>join_cur_level</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>joinrel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_child_join_rel
 *	  Builds RelOptInfo representing join between given two child relations.
 *
 * 'outer_rel' and 'inner_rel' are the RelOptInfos of child relations being
 *		joined
 * 'parent_joinrel' is the RelOptInfo representing the join between parent
 *		relations. Some of the members of new RelOptInfo are produced by
 *		translating corresponding members of this RelOptInfo
 * 'sjinfo': child-join context info
 * 'restrictlist': list of RestrictInfo nodes that apply to this particular
 *		pair of joinable relations
 * 'jointype' is the join type (inner, left, full, etc)
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>build_child_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_joinrel</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
					 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>

	<comment type="block">/* Only joins between "other" relations land here. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The parent joinrel should have consider_partitionwise_join set. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent_joinrel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_OTHER_JOINREL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* cheap startup cost is interesting iff not all tuples to be retrieved */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_startup</name></name> <operator>=</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_param_startup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* indicates not a baserel */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>attr_needed</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_referencers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>allvisfrac</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>subplan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* might get changed later */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partition_qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partitioned_child_rels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>top_parent_relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>,
										   <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute information relevant to foreign relations. */</comment>
	<expr_stmt><expr><call><name>set_foreign_rel_properties</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up reltarget struct */</comment>
	<expr_stmt><expr><call><name>build_child_join_reltarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parent_joinrel</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
							   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct joininfo list. */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parent_joinrel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>,
														<argument><expr><name>nappinfos</name></expr></argument>,
														<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lateral relids referred in child join will be same as that referred in
	 * the parent relation. Throw any partial result computed while building
	 * the targetlist.
	 */</comment>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name> <operator>=</operator> <operator>(</operator><name>Relids</name><operator>)</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parent_joinrel</name><operator>-&gt;</operator><name>direct_lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name> <operator>=</operator> <operator>(</operator><name>Relids</name><operator>)</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>parent_joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the parent joinrel has pending equivalence classes, so does the
	 * child.
	 */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name> <operator>=</operator> <name><name>parent_joinrel</name><operator>-&gt;</operator><name>has_eclass_joins</name></name></expr>;</expr_stmt>

	<comment type="block">/* Is the join between partitions itself partitioned? */</comment>
	<expr_stmt><expr><call><name>build_joinrel_partition_info</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>,
								 <argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Child joinrel is parallel safe if parent is parallel safe. */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name><name>parent_joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set estimates of the child-joinrel's size. */</comment>
	<expr_stmt><expr><call><name>set_joinrel_size_estimates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>,
							   <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We build the join only once. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>find_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the relation to the PlannerInfo. */</comment>
	<expr_stmt><expr><call><name>add_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>joinrel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * min_join_parameterization
 *
 * Determine the minimum possible parameterization of a joinrel, that is, the
 * set of other rels it contains LATERAL references to.  We save this value in
 * the join's RelOptInfo.  This function is split out of build_join_rel()
 * because join_is_legal() needs the value to check a prospective join.
 */</comment>
<function><type><name>Relids</name></type>
<name>min_join_parameterization</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Basically we just need the union of the inputs' lateral_relids, less
	 * whatever is already in the join.
	 *
	 * It's not immediately obvious that this is a valid way to compute the
	 * result, because it might seem that we're ignoring possible lateral refs
	 * of PlaceHolderVars that are due to be computed at the join but not in
	 * either input.  However, because create_lateral_join_info() already
	 * charged all such PHV refs to each member baserel of the join, they'll
	 * be accounted for already in the inputs' lateral_relids.  Likewise, we
	 * do not need to worry about doing transitive closure here, because that
	 * was already accounted for in the original baserel lateral_relids.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Maintain invariant that result is exactly NULL if empty */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_joinrel_tlist
 *	  Builds a join relation's target list from an input relation.
 *	  (This is invoked twice to handle the two input relations.)
 *
 * The join's targetlist includes all Vars of its member relations that
 * will still be needed above the join.  This subroutine adds all such
 * Vars from the specified input rel's tlist to the join rel's tlist.
 *
 * We also compute the expected width of the join's output, making use
 * of data that was cached at the baserel level by set_rel_width().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_joinrel_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids</name> <init>= <expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>vars</argument>, <argument>input_rel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore PlaceHolderVars in the input tlists; we'll make our own
		 * decisions about whether to copy them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, anything in a baserel or joinrel targetlist ought to be
		 * a Var.  (More general cases can only appear in appendrel child
		 * rels, which will never be seen here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type in rel targetlist: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Get the Var's original base rel */</comment>
		<expr_stmt><expr><name>baserel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Is it still needed above this joinrel? */</comment>
		<expr_stmt><expr><name>ndx</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name><name>baserel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>ndx</name></expr>]</index></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yup, add it to the output */</comment>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Vars have cost zero, so no need to adjust reltarget-&gt;cost */</comment>
			<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>+=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>attr_widths</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * build_joinrel_restrictlist
 * build_joinrel_joinlist
 *	  These routines build lists of restriction and join clauses for a
 *	  join relation from the joininfo lists of the relations it joins.
 *
 *	  These routines are separate because the restriction list must be
 *	  built afresh for each pair of input sub-relations we consider, whereas
 *	  the join list need only be computed once for any join RelOptInfo.
 *	  The join list is fully determined by the set of rels making up the
 *	  joinrel, so we should get the same results (up to ordering) from any
 *	  candidate pair of sub-relations.  But the restriction list is whatever
 *	  is not handled in the sub-relations, so it depends on which
 *	  sub-relations are considered.
 *
 *	  If a join clause from an input relation refers to base rels still not
 *	  present in the joinrel, then it is still a join clause for the joinrel;
 *	  we put it into the joininfo list for the joinrel.  Otherwise,
 *	  the clause is now a restrict clause for the joined relation, and we
 *	  return it to the caller of build_joinrel_restrictlist() to be stored in
 *	  join paths made from this pair of sub-relations.  (It will not need to
 *	  be considered further up the join tree.)
 *
 *	  In many cases we will find the same RestrictInfos in both input
 *	  relations' joinlists, so be careful to eliminate duplicates.
 *	  Pointer equality should be a sufficient test for dups, since all
 *	  the various joinlist entries ultimately refer to RestrictInfos
 *	  pushed into them by distribute_restrictinfo_to_rels().
 *
 * 'joinrel' is a join relation node
 * 'outer_rel' and 'inner_rel' are a pair of relations that can be joined
 *		to form joinrel.
 *
 * build_joinrel_restrictlist() returns a list of relevant restrictinfos,
 * whereas build_joinrel_joinlist() stores its results in the joinrel's
 * joininfo list.  One or the other must accept each given clause!
 *
 * NB: Formerly, we made deep(!) copies of each input RestrictInfo to pass
 * up to the join relation.  I believe this is no longer necessary, because
 * RestrictInfo nodes are no longer context-dependent.  Instead, just include
 * the original nodes in the lists made for the join relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_joinrel_restrictlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Collect all the clauses that syntactically belong at this level,
	 * eliminating any duplicates (important since we will see many of the
	 * same clauses arriving from both input relations).
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>subbuild_joinrel_restrictlist</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>subbuild_joinrel_restrictlist</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add on any clauses derived from EquivalenceClasses.  These cannot be
	 * redundant with the clauses in the joininfo lists, so don't bother
	 * checking.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><call><name>generate_join_implied_equalities</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
														  <argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
														  <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_joinrel_joinlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Collect all the clauses that syntactically belong above this level,
	 * eliminating any duplicates (important since we will see many of the
	 * same clauses arriving from both input relations).
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>subbuild_joinrel_joinlist</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>subbuild_joinrel_joinlist</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>subbuild_joinrel_restrictlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joininfo_list</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_restrictlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>joininfo_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This clause becomes a restriction clause for the joinrel, since
			 * it refers to no outside rels.  Add it to the list, being
			 * careful to eliminate duplicates. (Since RestrictInfo nodes in
			 * different joinlists will have been multiply-linked rather than
			 * copied, pointer equality should be a sufficient test.)
			 */</comment>
			<expr_stmt><expr><name>new_restrictlist</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>new_restrictlist</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This clause is still a join clause at this level, so we ignore
			 * it in this routine.
			 */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_restrictlist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>subbuild_joinrel_joinlist</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joininfo_list</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_joininfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Expected to be called only for join between parent relations. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_JOINREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>joininfo_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>, <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This clause becomes a restriction clause for the joinrel, since
			 * it refers to no outside rels.  So we can ignore it in this
			 * routine.
			 */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This clause is still a join clause at this level, so add it to
			 * the new joininfo list, being careful to eliminate duplicates.
			 * (Since RestrictInfo nodes in different joinlists will have been
			 * multiply-linked rather than copied, pointer equality should be
			 * a sufficient test.)
			 */</comment>
			<expr_stmt><expr><name>new_joininfo</name> <operator>=</operator> <call><name>list_append_unique_ptr</name><argument_list>(<argument><expr><name>new_joininfo</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_joininfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * build_empty_join_rel
 *		Build a dummy join relation describing an empty set of base rels.
 *
 * This is used for queries with empty FROM clauses, such as "SELECT 2+2" or
 * "INSERT INTO foo VALUES(...)".  We don't try very hard to make the empty
 * joinrel completely valid, since no real planning will be done with it ---
 * we just need it to carry a simple Result path out of query_planner().
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>build_empty_join_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl>;</decl_stmt>

	<comment type="block">/* The dummy join relation should be the only one ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>joinrel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_JOINREL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* empty set */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* we produce one row for such cases */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>join_rel_list</name></name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>joinrel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * fetch_upper_rel
 *		Build a RelOptInfo describing some post-scan/join query processing,
 *		or return a pre-existing one if somebody already built it.
 *
 * An "upper" relation is identified by an UpperRelationKind and a Relids set.
 * The meaning of the Relids set is not specified here, and very likely will
 * vary for different relation kinds.
 *
 * Most of the fields in an upper-level RelOptInfo are not used and are not
 * set here (though makeNode should ensure they're zeroes).  We basically only
 * care about fields that are of interest to add_path() and set_cheapest().
 */</comment>
<function><type><name>RelOptInfo</name> <modifier>*</modifier></type>
<name>fetch_upper_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperRelationKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>upperrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For the moment, our indexing data structure is just a List for each
	 * relation kind.  If we ever get so many of one kind that this stops
	 * working well, we can improve it.  No code outside this function should
	 * assume anything about how to find a particular upperrel.
	 */</comment>

	<comment type="block">/* If we already made this upperrel for the query, return it */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;upper_rels[kind]</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>upperrel</name> <operator>=</operator> <operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>upperrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>upperrel</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>upperrel</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_UPPER_REL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>relids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cheap startup cost is interesting iff not all tuples to be retrieved */</comment>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>consider_startup</name></name> <operator>=</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>consider_param_startup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might get changed later */</comment>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upperrel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_rels</name><index>[<expr><name>kind</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_rels</name><index>[<expr><name>kind</name></expr>]</index></name></expr></argument>, <argument><expr><name>upperrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>upperrel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_childrel_parents
 *		Compute the set of parent relids of an appendrel child rel.
 *
 * Since appendrels can be nested, a child could have multiple levels of
 * appendrel ancestors.  This function computes a Relids set of all the
 * parent relation IDs.
 */</comment>
<function><type><name>Relids</name></type>
<name>find_childrel_parents</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>prelid</name> <init>= <expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* traverse up to the parent rel, loop if it's also a child rel */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>prelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_baserel_parampathinfo
 *		Get the ParamPathInfo for a parameterized path for a base relation,
 *		constructing one if we don't have one already.
 *
 * This centralizes estimating the rowcounts for parameterized paths.
 * We need to cache those to be sure we use the same rowcount for all paths
 * of the same parameterization for a given rel.  This is also a convenient
 * place to determine which movable join clauses the parameterized path will
 * be responsible for evaluating.
 */</comment>
<function><type><name>ParamPathInfo</name> <modifier>*</modifier></type>
<name>get_baserel_parampathinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>,
						  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>ppi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>joinrelids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If rel has LATERAL refs, every path for it should account for them */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unparameterized paths have no ParamPathInfo */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we already have a PPI for this parameterization, just return it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ppi</name> <operator>=</operator> <call><name>find_param_path_info</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ppi</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identify all joinclauses that are movable to this base rel given this
	 * parameterization.
	 */</comment>
	<expr_stmt><expr><name>joinrelids</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>baserel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										<argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Add in joinclauses generated by EquivalenceClasses, too.  (These
	 * necessarily satisfy join_clause_is_movable_into.)
	 */</comment>
	<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pclauses</name></expr></argument>,
						   <argument><expr><call><name>generate_join_implied_equalities</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>joinrelids</name></expr></argument>,
															<argument><expr><name>required_outer</name></expr></argument>,
															<argument><expr><name>baserel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate the number of rows returned by the parameterized scan */</comment>
	<expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>get_parameterized_baserel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>pclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And now we can build the ParamPathInfo */</comment>
	<expr_stmt><expr><name>ppi</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ParamPathInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name> <operator>=</operator> <name>required_outer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name> <operator>=</operator> <name>pclauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>ppilist</name></name></expr></argument>, <argument><expr><name>ppi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ppi</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_joinrel_parampathinfo
 *		Get the ParamPathInfo for a parameterized path for a join relation,
 *		constructing one if we don't have one already.
 *
 * This centralizes estimating the rowcounts for parameterized paths.
 * We need to cache those to be sure we use the same rowcount for all paths
 * of the same parameterization for a given rel.  This is also a convenient
 * place to determine which movable join clauses the parameterized path will
 * be responsible for evaluating.
 *
 * outer_path and inner_path are a pair of input paths that can be used to
 * construct the join, and restrict_clauses is the list of regular join
 * clauses (including clauses derived from EquivalenceClasses) that must be
 * applied at the join node when using these inputs.
 *
 * Unlike the situation for base rels, the set of movable join clauses to be
 * enforced at a join varies with the selected pair of input paths, so we
 * must calculate that and pass it back, even if we already have a matching
 * ParamPathInfo.  We handle this by adding any clauses moved down to this
 * join to *restrict_clauses, which is an in/out parameter.  (The addition
 * is done in such a way as to not modify the passed-in List structure.)
 *
 * Note: when considering a nestloop join, the caller must have removed from
 * restrict_clauses any movable clauses that are themselves scheduled to be
 * pushed into the right-hand path.  We do not do that here since it's
 * unnecessary for other join types.
 */</comment>
<function><type><name>ParamPathInfo</name> <modifier>*</modifier></type>
<name>get_joinrel_parampathinfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
						  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
						  <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
						  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>ppi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>join_and_req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_and_req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_and_req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>eclauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dropped_ecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* If rel has LATERAL refs, every path for it should account for them */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unparameterized paths have no ParamPathInfo or extra join clauses */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify all joinclauses that are movable to this join rel given this
	 * parameterization.  These are the clauses that are movable into this
	 * join, but not movable into either input path.  Treat an unparameterized
	 * input path as not accepting parameterized clauses (because it won't,
	 * per the shortcut exit above), even though the joinclause movement rules
	 * might allow the same clauses to be moved into a parameterized path for
	 * that rel.
	 */</comment>
	<expr_stmt><expr><name>join_and_req</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>outer_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_and_req</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
								  <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>outer_and_req</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* outer path does not accept parameters */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>inner_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_and_req</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
								  <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>inner_and_req</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* inner path does not accept parameters */</comment>

	<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>joinrel-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										<argument><expr><name>join_and_req</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										 <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										 <argument><expr><name>outer_and_req</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										 <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										 <argument><expr><name>inner_and_req</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Consider joinclauses generated by EquivalenceClasses, too */</comment>
	<expr_stmt><expr><name>eclauses</name> <operator>=</operator> <call><name>generate_join_implied_equalities</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>join_and_req</name></expr></argument>,
												<argument><expr><name>required_outer</name></expr></argument>,
												<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We only want ones that aren't movable to lower levels */</comment>
	<expr_stmt><expr><name>dropped_ecs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In principle, join_clause_is_movable_into() should accept anything
		 * returned by generate_join_implied_equalities(); but because its
		 * analysis is only approximate, sometimes it doesn't.  So we
		 * currently cannot use this Assert; instead just assume it's okay to
		 * apply the joinclause at this level.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										   <argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										   <argument><expr><name>join_and_req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										<argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										<argument><expr><name>outer_and_req</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* drop if movable into LHS */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
										<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										<argument><expr><name>inner_and_req</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* drop if movable into RHS, but remember EC for use below */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>==</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dropped_ecs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropped_ecs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * EquivalenceClasses are harder to deal with than we could wish, because
	 * of the fact that a given EC can generate different clauses depending on
	 * context.  Suppose we have an EC {X.X, Y.Y, Z.Z} where X and Y are the
	 * LHS and RHS of the current join and Z is in required_outer, and further
	 * suppose that the inner_path is parameterized by both X and Z.  The code
	 * above will have produced either Z.Z = X.X or Z.Z = Y.Y from that EC,
	 * and in the latter case will have discarded it as being movable into the
	 * RHS.  However, the EC machinery might have produced either Y.Y = X.X or
	 * Y.Y = Z.Z as the EC enforcement clause within the inner_path; it will
	 * not have produced both, and we can't readily tell from here which one
	 * it did pick.  If we add no clause to this join, we'll end up with
	 * insufficient enforcement of the EC; either Z.Z or X.X will fail to be
	 * constrained to be equal to the other members of the EC.  (When we come
	 * to join Z to this X/Y path, we will certainly drop whichever EC clause
	 * is generated at that join, so this omission won't get fixed later.)
	 *
	 * To handle this, for each EC we discarded such a clause from, try to
	 * generate a clause connecting the required_outer rels to the join's LHS
	 * ("Z.Z = X.X" in the terms of the above example).  If successful, and if
	 * the clause can't be moved to the LHS, add it to the current join's
	 * restriction clauses.  (If an EC cannot generate such a clause then it
	 * has nothing that needs to be enforced here, while if the clause can be
	 * moved into the LHS then it should have been enforced within that path.)
	 *
	 * Note that we don't need similar processing for ECs whose clause was
	 * considered to be movable into the LHS, because the LHS can't refer to
	 * the RHS so there is no comparable ambiguity about what it might
	 * actually be enforcing internally.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dropped_ecs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>real_outer_and_req</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>real_outer_and_req</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									   <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>eclauses</name> <operator>=</operator>
			<call><name>generate_join_implied_equalities_for_ecs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>dropped_ecs</name></expr></argument>,
													 <argument><expr><name>real_outer_and_req</name></expr></argument>,
													 <argument><expr><name>required_outer</name></expr></argument>,
													 <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eclauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* As above, can't quite assert this here */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
											   <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											   <argument><expr><name>real_outer_and_req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
											 <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											 <argument><expr><name>outer_and_req</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now, attach the identified moved-down clauses to the caller's
	 * restrict_clauses list.  By using list_concat in this order, we leave
	 * the original list structure of restrict_clauses undamaged.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>restrict_clauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pclauses</name></expr></argument>, <argument><expr><operator>*</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we already have a PPI for this parameterization, just return it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ppi</name> <operator>=</operator> <call><name>find_param_path_info</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ppi</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Estimate the number of rows returned by the parameterized join */</comment>
	<expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>get_parameterized_joinrel_size</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>,
										  <argument><expr><name>outer_path</name></expr></argument>,
										  <argument><expr><name>inner_path</name></expr></argument>,
										  <argument><expr><name>sjinfo</name></expr></argument>,
										  <argument><expr><operator>*</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And now we can build the ParamPathInfo.  No point in saving the
	 * input-pair-dependent clause list, though.
	 *
	 * Note: in GEQO mode, we'll be called in a temporary memory context, but
	 * the joinrel structure is there too, so no problem.
	 */</comment>
	<expr_stmt><expr><name>ppi</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ParamPathInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name> <operator>=</operator> <name>required_outer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>joinrel</name><operator>-&gt;</operator><name>ppilist</name></name></expr></argument>, <argument><expr><name>ppi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ppi</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_appendrel_parampathinfo
 *		Get the ParamPathInfo for a parameterized path for an append relation.
 *
 * For an append relation, the rowcount estimate will just be the sum of
 * the estimates for its children.  However, we still need a ParamPathInfo
 * to flag the fact that the path requires parameters.  So this just creates
 * a suitable struct with zero ppi_rows (and no ppi_clauses either, since
 * the Append node isn't responsible for checking quals).
 */</comment>
<function><type><name>ParamPathInfo</name> <modifier>*</modifier></type>
<name>get_appendrel_parampathinfo</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>appendrel</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>ppi</name></decl>;</decl_stmt>

	<comment type="block">/* If rel has LATERAL refs, every path for it should account for them */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>appendrel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unparameterized paths have no ParamPathInfo */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>appendrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we already have a PPI for this parameterization, just return it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ppi</name> <operator>=</operator> <call><name>find_param_path_info</name><argument_list>(<argument><expr><name>appendrel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ppi</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else build the ParamPathInfo */</comment>
	<expr_stmt><expr><name>ppi</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ParamPathInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name> <operator>=</operator> <name>required_outer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendrel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>appendrel</name><operator>-&gt;</operator><name>ppilist</name></name></expr></argument>, <argument><expr><name>ppi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ppi</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a ParamPathInfo for the parameterization given by required_outer, if
 * already available in the given rel. Returns NULL otherwise.
 */</comment>
<function><type><name>ParamPathInfo</name> <modifier>*</modifier></type>
<name>find_param_path_info</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;ppilist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>ppi</name> <init>= <expr><operator>(</operator><name>ParamPathInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ppi</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_joinrel_partition_info
 *		If the two relations have same partitioning scheme, their join may be
 *		partitioned and will follow the same partitioning scheme as the joining
 *		relations. Set the partition scheme and partition key expressions in
 *		the join relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_joinrel_partition_info</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictlist</name></decl></parameter>,
							 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if partitionwise join technique is disabled. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_partitionwise_join</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can only consider this join as an input to further partitionwise
	 * joins if (a) the input relations are partitioned and have
	 * consider_partitionwise_join=true, (b) the partition schemes match, and
	 * (c) we can identify an equi-join between the partition keys.  Note that
	 * if it were possible for have_partkey_equi_join to return different
	 * answers for the same joinrel depending on which join ordering we try
	 * first, this logic would break.  That shouldn't happen, though, because
	 * of the way the query planner deduces implied equalities and reorders
	 * the joins.  Please see optimizer/README for details.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><name><name>outer_rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>||</operator>
		<operator>!</operator><name><name>inner_rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>||</operator>
		<name><name>outer_rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>!=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>||</operator>
		<operator>!</operator><call><name>have_partkey_equi_join</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>outer_rel</name></expr></argument>, <argument><expr><name>inner_rel</name></expr></argument>,
								<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>restrictlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>part_scheme</name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>REL_HAS_ALL_PART_PROPS</name><argument_list>(<argument><expr><name>outer_rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>REL_HAS_ALL_PART_PROPS</name><argument_list>(<argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, our partition matching algorithm can match partitions only
	 * when the partition bounds of the joining relations are exactly same.
	 * So, bail out otherwise.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outer_rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>!=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>||</operator>
		<operator>!</operator><call><name>partition_bounds_equal</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
								<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>,
								<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>,
								<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This function will be called only once for each joinrel, hence it
	 * should not have partition scheme, partition bounds, partition key
	 * expressions and array for storing child relations set.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>joinrel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>&amp;&amp;</operator>
		   <operator>!</operator><name><name>joinrel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>joinrel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>&amp;&amp;</operator>
		   <operator>!</operator><name><name>joinrel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Join relation is partitioned using the same partitioning scheme as the
	 * joining relations and has same bounds.
	 */</comment>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>=</operator> <name>part_scheme</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>boundinfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator>
		<operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>part_rels</name></name> <operator>=</operator>
		<operator>(</operator><name>RelOptInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelOptInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the consider_partitionwise_join flag.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>consider_partitionwise_join</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct partition keys for the join.
	 *
	 * An INNER join between two partitioned relations can be regarded as
	 * partitioned by either key expression.  For example, A INNER JOIN B ON
	 * A.a = B.b can be regarded as partitioned on A.a or on B.b; they are
	 * equivalent.
	 *
	 * For a SEMI or ANTI join, the result can only be regarded as being
	 * partitioned in the same manner as the outer side, since the inner
	 * columns are not retained.
	 *
	 * An OUTER join like (A LEFT JOIN B ON A.a = B.b) may produce rows with
	 * B.b NULL. These rows may not fit the partitioning conditions imposed on
	 * B.b. Hence, strictly speaking, the join is not partitioned by B.b and
	 * thus partition keys of an OUTER join should include partition key
	 * expressions from the OUTER side only.  However, because all
	 * commonly-used comparison operators are strict, the presence of nulls on
	 * the outer side doesn't cause any problem; they can't match anything at
	 * future join levels anyway.  Therefore, we track two sets of
	 * expressions: those that authentically partition the relation
	 * (partexprs) and those that partition the relation with the exception
	 * that extra nulls may be present (nullable_partexprs).  When the
	 * comparison operator is strict, the latter is just as good as the
	 * former.
	 */</comment>
	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outer_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outer_null_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inner_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inner_null_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexpr</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nullable_partexpr</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>outer_expr</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outer_null_expr</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>outer_rel</name><operator>-&gt;</operator><name>nullable_partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_expr</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_null_expr</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>nullable_partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
				<expr_stmt><expr><name>partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>outer_expr</name></expr></argument>, <argument><expr><name>inner_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>outer_null_expr</name></expr></argument>,
												<argument><expr><name>inner_null_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
			<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
				<expr_stmt><expr><name>partexpr</name> <operator>=</operator> <name>outer_expr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <name>outer_null_expr</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
				<expr_stmt><expr><name>partexpr</name> <operator>=</operator> <name>outer_expr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>inner_expr</name></expr></argument>,
												<argument><expr><name>outer_null_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>nullable_partexpr</name></expr></argument>,
												<argument><expr><name>inner_null_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>outer_expr</name></expr></argument>,
												<argument><expr><name>inner_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>nullable_partexpr</name></expr></argument>,
												<argument><expr><name>outer_null_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nullable_partexpr</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>nullable_partexpr</name></expr></argument>,
												<argument><expr><name>inner_null_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <name>partexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>joinrel</name><operator>-&gt;</operator><name>nullable_partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <name>nullable_partexpr</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * build_child_join_reltarget
 *	  Set up a child-join relation's reltarget from a parent-join relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_child_join_reltarget</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>childrel</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>nappinfos</name></decl></parameter>,
						   <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Build the targetlist */</comment>
	<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
							   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the cost and width fields */</comment>
	<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <name><name>parentrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
