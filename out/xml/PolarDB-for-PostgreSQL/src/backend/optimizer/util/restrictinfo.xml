<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/util/restrictinfo.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * restrictinfo.c
 *	  RestrictInfo node manipulation routines.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/restrictinfo.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type><name>make_restrictinfo_internal</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>orclause</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>outerjoin_delayed</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>required_relids</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>make_sub_restrictinfos</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>outerjoin_delayed</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl></parameter>,
					   <parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>required_relids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * make_restrictinfo
 *
 * Build a RestrictInfo node containing the given subexpression.
 *
 * The is_pushed_down, outerjoin_delayed, and pseudoconstant flags for the
 * RestrictInfo must be supplied by the caller, as well as the correct values
 * for security_level, outer_relids, and nullable_relids.
 * required_relids can be NULL, in which case it defaults to the actual clause
 * contents (i.e., clause_relids).
 *
 * We initialize fields that depend only on the given subexpression, leaving
 * others that depend on context (or may never be needed at all) to be filled
 * later.
 */</comment>
<function><type><name>RestrictInfo</name> <modifier>*</modifier></type>
<name>make_restrictinfo</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>outerjoin_delayed</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl></parameter>,
				  <parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
				  <parameter><decl><type><name>Relids</name></type> <name>required_relids</name></decl></parameter>,
				  <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
				  <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If it's an OR clause, build a modified copy with RestrictInfos inserted
	 * above each subclause of the top-level AND/OR structure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>make_sub_restrictinfos</name><argument_list>(<argument><expr><name>clause</name></expr></argument>,
													   <argument><expr><name>is_pushed_down</name></expr></argument>,
													   <argument><expr><name>outerjoin_delayed</name></expr></argument>,
													   <argument><expr><name>pseudoconstant</name></expr></argument>,
													   <argument><expr><name>security_level</name></expr></argument>,
													   <argument><expr><name>required_relids</name></expr></argument>,
													   <argument><expr><name>outer_relids</name></expr></argument>,
													   <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Shouldn't be an AND clause, else AND/OR flattening messed up */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>and_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>make_restrictinfo_internal</name><argument_list>(<argument><expr><name>clause</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>is_pushed_down</name></expr></argument>,
									  <argument><expr><name>outerjoin_delayed</name></expr></argument>,
									  <argument><expr><name>pseudoconstant</name></expr></argument>,
									  <argument><expr><name>security_level</name></expr></argument>,
									  <argument><expr><name>required_relids</name></expr></argument>,
									  <argument><expr><name>outer_relids</name></expr></argument>,
									  <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_restrictinfo_internal
 *
 * Common code for the main entry points and the recursive cases.
 */</comment>
<function><type><specifier>static</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type>
<name>make_restrictinfo_internal</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>orclause</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>outerjoin_delayed</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl></parameter>,
						   <parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>required_relids</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
						   <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <name>clause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>orclause</name></name> <operator>=</operator> <name>orclause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>is_pushed_down</name></name> <operator>=</operator> <name>is_pushed_down</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outerjoin_delayed</name></name> <operator>=</operator> <name>outerjoin_delayed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name> <operator>=</operator> <name>pseudoconstant</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* may get set below */</comment>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name> <operator>=</operator> <name>security_level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_relids</name></name> <operator>=</operator> <name>outer_relids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name> <operator>=</operator> <name>nullable_relids</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's potentially delayable by lower-level security quals, figure out
	 * whether it's leakproof.  We can skip testing this for level-zero quals,
	 * since they would never get delayed on security grounds anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>security_level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>leakproof</name></name> <operator>=</operator> <operator>!</operator><call><name>contain_leaked_vars</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>leakproof</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* really, "don't know" */</comment>

	<comment type="block">/*
	 * If it's a binary opclause, set up left/right relids info. In any case
	 * set up the total clause relids info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause_relids</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
												<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Does it look like a normal join clause, i.e., a binary operator
		 * relating expressions that come from distinct relations? If so we
		 * might be able to use it in a join algorithm.  Note that this is a
		 * purely syntactic test that is made regardless of context.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>,
						 <argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>can_join</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* pseudoconstant should certainly not be true */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>restrictinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not a binary opclause, so mark left/right relid sets as empty */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="block">/* and get the total relid set the hard way */</comment>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>clause_relids</name></name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* required_relids defaults to clause_relids */</comment>
	<if_stmt><if>if <condition>(<expr><name>required_relids</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator> <name>required_relids</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>required_relids</name></name> <operator>=</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Fill in all the cacheable fields with "not yet set" markers. None of
	 * these will be computed until/unless needed.  Note in particular that we
	 * don't mark a binary opclause as mergejoinable or hashjoinable here;
	 * that happens only if it appears in the right context (top level of a
	 * joinclause list).
	 */</comment>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>startup</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>norm_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_selec</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>mergeopfamilies</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_em</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>scansel_cache</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_bucketsize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_mcvfreq</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>restrictinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively insert sub-RestrictInfo nodes into a boolean expression.
 *
 * We put RestrictInfos above simple (non-AND/OR) clauses and above
 * sub-OR clauses, but not above sub-AND clauses, because there's no need.
 * This may seem odd but it is closely related to the fact that we use
 * implicit-AND lists at top level of RestrictInfo lists.  Only ORs and
 * simple clauses are valid RestrictInfos.
 *
 * The same is_pushed_down, outerjoin_delayed, and pseudoconstant flag
 * values can be applied to all RestrictInfo nodes in the result.  Likewise
 * for security_level, outer_relids, and nullable_relids.
 *
 * The given required_relids are attached to our top-level output,
 * but any OR-clause constituents are allowed to default to just the
 * contained rels.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>make_sub_restrictinfos</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>is_pushed_down</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>outerjoin_delayed</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl></parameter>,
					   <parameter><decl><type><name>Index</name></type> <name>security_level</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>required_relids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>outer_relids</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>nullable_relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>orlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>((BoolExpr *) clause)-&gt;args</argument>)</argument_list></macro>
			<expr_stmt><expr><name>orlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>,
							 <argument><expr><call><name>make_sub_restrictinfos</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>is_pushed_down</name></expr></argument>,
													<argument><expr><name>outerjoin_delayed</name></expr></argument>,
													<argument><expr><name>pseudoconstant</name></expr></argument>,
													<argument><expr><name>security_level</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>,
													<argument><expr><name>outer_relids</name></expr></argument>,
													<argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>make_restrictinfo_internal</name><argument_list>(<argument><expr><name>clause</name></expr></argument>,
												   <argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>orlist</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>is_pushed_down</name></expr></argument>,
												   <argument><expr><name>outerjoin_delayed</name></expr></argument>,
												   <argument><expr><name>pseudoconstant</name></expr></argument>,
												   <argument><expr><name>security_level</name></expr></argument>,
												   <argument><expr><name>required_relids</name></expr></argument>,
												   <argument><expr><name>outer_relids</name></expr></argument>,
												   <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>andlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>((BoolExpr *) clause)-&gt;args</argument>)</argument_list></macro>
			<expr_stmt><expr><name>andlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>,
							  <argument><expr><call><name>make_sub_restrictinfos</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>is_pushed_down</name></expr></argument>,
													 <argument><expr><name>outerjoin_delayed</name></expr></argument>,
													 <argument><expr><name>pseudoconstant</name></expr></argument>,
													 <argument><expr><name>security_level</name></expr></argument>,
													 <argument><expr><name>required_relids</name></expr></argument>,
													 <argument><expr><name>outer_relids</name></expr></argument>,
													 <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>make_andclause</name><argument_list>(<argument><expr><name>andlist</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>make_restrictinfo_internal</name><argument_list>(<argument><expr><name>clause</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>is_pushed_down</name></expr></argument>,
												   <argument><expr><name>outerjoin_delayed</name></expr></argument>,
												   <argument><expr><name>pseudoconstant</name></expr></argument>,
												   <argument><expr><name>security_level</name></expr></argument>,
												   <argument><expr><name>required_relids</name></expr></argument>,
												   <argument><expr><name>outer_relids</name></expr></argument>,
												   <argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * restriction_is_or_clause
 *
 * Returns t iff the restrictinfo node contains an 'or' clause.
 */</comment>
<function><type><name>bool</name></type>
<name>restriction_is_or_clause</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>orclause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * restriction_is_securely_promotable
 *
 * Returns true if it's okay to evaluate this clause "early", that is before
 * other restriction clauses attached to the specified relation.
 */</comment>
<function><type><name>bool</name></type>
<name>restriction_is_securely_promotable</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * It's okay if there are no baserestrictinfo clauses for the rel that
	 * would need to go before this one, *or* if this one is leakproof.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>security_level</name></name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>baserestrict_min_security</name></name> <operator>||</operator>
		<name><name>restrictinfo</name><operator>-&gt;</operator><name>leakproof</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_actual_clauses
 *
 * Returns a list containing the bare clauses from 'restrictinfo_list'.
 *
 * This is only to be used in cases where none of the RestrictInfos can
 * be pseudoconstant clauses (for instance, it's OK on indexqual lists).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_actual_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfo_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictinfo_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_actual_clauses
 *
 * Extract bare clauses from 'restrictinfo_list', returning either the
 * regular ones or the pseudoconstant ones per 'pseudoconstant'.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>extract_actual_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfo_list</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>pseudoconstant</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictinfo_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name> <operator>==</operator> <name>pseudoconstant</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_actual_join_clauses
 *
 * Extract bare clauses from 'restrictinfo_list', separating those that
 * semantically match the join level from those that were pushed down.
 * Pseudoconstant clauses are excluded from the results.
 *
 * This is only used at outer joins, since for plain joins we don't care
 * about pushed-down-ness.
 */</comment>
<function><type><name>void</name></type>
<name>extract_actual_join_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfo_list</name></decl></parameter>,
							<parameter><decl><type><name>Relids</name></type> <name>joinrelids</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>joinquals</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>otherquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>joinquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>otherquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictinfo_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RINFO_IS_PUSHED_DOWN</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>joinrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>otherquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>otherquals</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* joinquals shouldn't have been marked pseudoconstant */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>joinquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>joinquals</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * join_clause_is_movable_to
 *		Test whether a join clause is a safe candidate for parameterization
 *		of a scan on the specified base relation.
 *
 * A movable join clause is one that can safely be evaluated at a rel below
 * its normal semantic level (ie, its required_relids), if the values of
 * variables that it would need from other rels are provided.
 *
 * We insist that the clause actually reference the target relation; this
 * prevents undesirable movement of degenerate join clauses, and ensures
 * that there is a unique place that a clause can be moved down to.
 *
 * We cannot move an outer-join clause into the non-nullable side of its
 * outer join, as that would change the results (rows would be suppressed
 * rather than being null-extended).
 *
 * Also there must not be an outer join below the clause that would null the
 * Vars coming from the target relation.  Otherwise the clause might give
 * results different from what it would give at its normal semantic level.
 *
 * Also, the join clause must not use any relations that have LATERAL
 * references to the target relation, since we could not put such rels on
 * the outer side of a nestloop with the target relation.
 */</comment>
<function><type><name>bool</name></type>
<name>join_clause_is_movable_to</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Clause must physically reference target rel */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot move an outer-join clause into the join's outer side */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Target rel must not be nullable below the clause */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Clause must not use any rels with LATERAL references to this rel */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * join_clause_is_movable_into
 *		Test whether a join clause is movable and can be evaluated within
 *		the current join context.
 *
 * currentrelids: the relids of the proposed evaluation location
 * current_and_outer: the union of currentrelids and the required_outer
 *		relids (parameterization's outer relations)
 *
 * The API would be a bit clearer if we passed the current relids and the
 * outer relids separately and did bms_union internally; but since most
 * callers need to apply this function to multiple clauses, we make the
 * caller perform the union.
 *
 * Obviously, the clause must only refer to Vars available from the current
 * relation plus the outer rels.  We also check that it does reference at
 * least one current Var, ensuring that the clause will be pushed down to
 * a unique place in a parameterized join tree.  And we check that we're
 * not pushing the clause into its outer-join outer side, nor down into
 * a lower outer join's inner side.
 *
 * The check about pushing a clause down into a lower outer join's inner side
 * is only approximate; it sometimes returns "false" when actually it would
 * be safe to use the clause here because we're still above the outer join
 * in question.  This is okay as long as the answers at different join levels
 * are consistent: it just means we might sometimes fail to push a clause as
 * far down as it could safely be pushed.  It's unclear whether it would be
 * worthwhile to do this more precisely.  (But if it's ever fixed to be
 * exactly accurate, there's an Assert in get_joinrel_parampathinfo() that
 * should be re-enabled.)
 *
 * There's no check here equivalent to join_clause_is_movable_to's test on
 * lateral_referencers.  We assume the caller wouldn't be inquiring unless
 * it'd verified that the proposed outer rels don't have lateral references
 * to the current rel(s).  (If we are considering join paths with the outer
 * rels on the outside and the current rels on the inside, then this should
 * have been checked at the outset of such consideration; see join_is_legal
 * and the path parameterization checks in joinpath.c.)  On the other hand,
 * in join_clause_is_movable_to we are asking whether the clause could be
 * moved for some valid set of outer rels, so we don't have the benefit of
 * relying on prior checks for lateral-reference validity.
 *
 * Note: if this returns true, it means that the clause could be moved to
 * this join relation, but that doesn't mean that this is the lowest join
 * it could be moved to.  Caller may need to make additional calls to verify
 * that this doesn't succeed on either of the inputs of a proposed join.
 *
 * Note: get_joinrel_parampathinfo depends on the fact that if
 * current_and_outer is NULL, this function will always return false
 * (since one or the other of the first two tests must fail).
 */</comment>
<function><type><name>bool</name></type>
<name>join_clause_is_movable_into</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>,
							<parameter><decl><type><name>Relids</name></type> <name>currentrelids</name></decl></parameter>,
							<parameter><decl><type><name>Relids</name></type> <name>current_and_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Clause must be evaluable given available context */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>, <argument><expr><name>current_and_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Clause must physically reference at least one target rel */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>currentrelids</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot move an outer-join clause into the join's outer side */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>currentrelids</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Target rel(s) must not be nullable below the clause.  This is
	 * approximate, in the safe direction, because the current join might be
	 * above the join where the nulling would happen, in which case the clause
	 * would work correctly here.  But we don't have enough info to be sure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>currentrelids</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>nullable_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
