<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/util/var.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * var.c
 *	  Var node manipulation routines
 *
 * Note: for most purposes, PlaceHolderVar is considered a Var too,
 * even if its contained expression is variable-free.  Also, CurrentOfExpr
 * is treated as a Var for purposes of determining whether an expression
 * contains variables.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/var.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Relids</name></type>		<name>varnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>pull_varnos_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>varattnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name></decl>;</decl_stmt>
}</block></struct></type> <name>pull_varattnos_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>pull_vars_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>var_location</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>locate_var_of_level_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>varlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>pull_var_clause_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>possible_sublink</name></decl>;</decl_stmt>	<comment type="block">/* could aliases include a SubLink? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inserted_sublink</name></decl>;</decl_stmt>	<comment type="block">/* have we inserted a SubLink? */</comment>
}</block></struct></type> <name>flatten_join_alias_vars_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pull_varnos_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				   <parameter><decl><type><name>pull_varnos_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pull_varattnos_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pull_varattnos_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pull_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pull_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_var_clause_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_vars_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sublevels_up</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>locate_var_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>locate_var_of_level_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pull_var_clause_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					   <parameter><decl><type><name>pull_var_clause_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>flatten_join_alias_vars_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								<parameter><decl><type><name>flatten_join_alias_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>alias_relid_set</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * pull_varnos
 *		Create a set of all the distinct varnos present in a parsetree.
 *		Only varnos that reference level-zero rtable entries are considered.
 *
 * NOTE: this is used on not-yet-planned expressions.  It may therefore find
 * bare SubLinks, and if so it needs to recurse into them to look for uplevel
 * references to the desired rtable level!	But when we find a completed
 * SubPlan, we only need to look at the parameters passed to the subplan.
 */</comment>
<function><type><name>Relids</name></type>
<name>pull_varnos</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pull_varnos_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varnos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									<argument><expr><name>pull_varnos_walker</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>varnos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pull_varnos_of_level
 *		Create a set of all the distinct varnos present in a parsetree.
 *		Only Vars of the specified level are considered.
 */</comment>
<function><type><name>Relids</name></type>
<name>pull_varnos_of_level</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pull_varnos_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varnos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									<argument><expr><name>pull_varnos_walker</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>varnos</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pull_varnos_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pull_varnos_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name></expr></argument>, <argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A PlaceHolderVar acts as a variable of its syntactic scope, or
		 * lower than that if it references only a subset of the rels in its
		 * syntactic scope.  It might also contain lateral references, but we
		 * should ignore such references when computing the set of varnos in
		 * an expression tree.  Also, if the PHV contains no variables within
		 * its syntactic scope, it will be forced to be evaluated exactly at
		 * the syntactic scope, so take that as the relid set.
		 */</comment>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pull_varnos_context</name></type> <name>subcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>subcontext</name><operator>.</operator><name>varnos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subcontext</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pull_varnos_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>subcontext</name><operator>.</operator><name>varnos</name></name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name><name>subcontext</name><operator>.</operator><name>varnos</name></name></expr></argument>,
												<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>subcontext</name><operator>.</operator><name>varnos</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name></expr></argument>,
												  <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varnos</name></name></expr></argument>, <argument><expr><name><name>subcontext</name><operator>.</operator><name>varnos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into RTE subquery or not-yet-planned sublink subquery */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>pull_varnos_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pull_varnos_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pull_varattnos
 *		Find all the distinct attribute numbers present in an expression tree,
 *		and add them to the initial contents of *varattnos.
 *		Only Vars of the given varno and rtable level zero are considered.
 *
 * Attribute numbers are offset by FirstLowInvalidHeapAttributeNumber so that
 * we can include system attributes (e.g., OID) in the bitmap representation.
 *
 * Currently, this does not support unplanned subqueries; that is not needed
 * for current uses.  It will handle already-planned SubPlan nodes, though,
 * looking into only the "testexpr" and the "args" list.  (The subplan cannot
 * contain any other references to Vars of the current level.)
 */</comment>
<function><type><name>void</name></type>
<name>pull_varattnos</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>varattnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pull_varattnos_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varattnos</name></name> <operator>=</operator> <operator>*</operator><name>varattnos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pull_varattnos_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>varattnos</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>varattnos</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pull_varattnos_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pull_varattnos_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varattnos</name></name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varattnos</name></name></expr></argument>,
							   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Should not find an unplanned subquery */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pull_varattnos_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pull_vars_of_level
 *		Create a list of all Vars (and PlaceHolderVars) referencing the
 *		specified query level in the given parsetree.
 *
 * Caution: the Vars are not copied, only linked into the list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pull_vars_of_level</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pull_vars_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be prepared to start with a Query or a bare expression tree; if
	 * it's a Query, we don't want to increment sublevels_up.
	 */</comment>
	<expr_stmt><expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									<argument><expr><name>pull_vars_walker</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>vars</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pull_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pull_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* we don't want to look into the contained expression */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into RTE subquery or not-yet-planned sublink subquery */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>pull_vars_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pull_vars_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * contain_var_clause
 *	  Recursively scan a clause to discover whether it contains any Var nodes
 *	  (of the current query level).
 *
 *	  Returns true if any varnode found.
 *
 * Does not examine subqueries, therefore must only be used after reduction
 * of sublinks to subplans!
 */</comment>
<function><type><name>bool</name></type>
<name>contain_var_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_var_clause_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_var_clause_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort the tree traversal and return true */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort the tree traversal and return true */</comment>
		<comment type="block">/* else fall through to check the contained expr */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_var_clause_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * contain_vars_of_level
 *	  Recursively scan a clause to discover whether it contains any Var nodes
 *	  of the specified query level.
 *
 *	  Returns true if any such Var found.
 *
 * Will recurse into sublinks.  Also, may be invoked directly on a Query.
 */</comment>
<function><type><name>bool</name></type>
<name>contain_vars_of_level</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name> <init>= <expr><name>levelsup</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>contain_vars_of_level_walker</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>sublevels_up</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_vars_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sublevels_up</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>==</operator> <operator>*</operator><name>sublevels_up</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort tree traversal and return true */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sublevels_up</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>==</operator> <operator>*</operator><name>sublevels_up</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort the tree traversal and return true */</comment>
		<comment type="block">/* else fall through to check the contained expr */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sublevels_up</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>contain_vars_of_level_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sublevels_up</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sublevels_up</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>contain_vars_of_level_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * locate_var_of_level
 *	  Find the parse location of any Var of the specified query level.
 *
 * Returns -1 if no such Var is in the querytree, or if they all have
 * unknown parse location.  (The former case is probably caller error,
 * but we don't bother to distinguish it from the latter case.)
 *
 * Will recurse into sublinks.  Also, may be invoked directly on a Query.
 *
 * Note: it might seem appropriate to merge this functionality into
 * contain_vars_of_level, but that would complicate that function's API.
 * Currently, the only uses of this function are for error reporting,
 * and so shaving cycles probably isn't very important.
 */</comment>
<function><type><name>int</name></type>
<name>locate_var_of_level</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>locate_var_of_level_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>var_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* in case we find nothing */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <name>levelsup</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_or_expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
										   <argument><expr><name>locate_var_of_level_walker</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>var_location</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>locate_var_of_level_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>locate_var_of_level_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>var_location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>		<comment type="block">/* abort tree traversal and return true */</comment>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* since CurrentOfExpr doesn't carry location, nothing we can do */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* No extra code needed for PlaceHolderVar; just look in contained expr */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>locate_var_of_level_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>locate_var_of_level_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pull_var_clause
 *	  Recursively pulls all Var nodes from an expression clause.
 *
 *	  Aggrefs are handled according to these bits in 'flags':
 *		PVC_INCLUDE_AGGREGATES		include Aggrefs in output list
 *		PVC_RECURSE_AGGREGATES		recurse into Aggref arguments
 *		neither flag				throw error if Aggref found
 *	  Vars within an Aggref's expression are included in the result only
 *	  when PVC_RECURSE_AGGREGATES is specified.
 *
 *	  WindowFuncs are handled according to these bits in 'flags':
 *		PVC_INCLUDE_WINDOWFUNCS		include WindowFuncs in output list
 *		PVC_RECURSE_WINDOWFUNCS		recurse into WindowFunc arguments
 *		neither flag				throw error if WindowFunc found
 *	  Vars within a WindowFunc's expression are included in the result only
 *	  when PVC_RECURSE_WINDOWFUNCS is specified.
 *
 *	  PlaceHolderVars are handled according to these bits in 'flags':
 *		PVC_INCLUDE_PLACEHOLDERS	include PlaceHolderVars in output list
 *		PVC_RECURSE_PLACEHOLDERS	recurse into PlaceHolderVar arguments
 *		neither flag				throw error if PlaceHolderVar found
 *	  Vars within a PHV's expression are included in the result only
 *	  when PVC_RECURSE_PLACEHOLDERS is specified.
 *
 *	  GroupingFuncs are treated mostly like Aggrefs, and so do not need
 *	  their own flag bits.
 *
 *	  CurrentOfExpr nodes are ignored in all cases.
 *
 *	  Upper-level vars (with varlevelsup &gt; 0) should not be seen here,
 *	  likewise for upper-level Aggrefs and PlaceHolderVars.
 *
 *	  Returns list of nodes found.  Note the nodes themselves are not
 *	  copied, only referenced.
 *
 * Does not examine subqueries, therefore must only be used after reduction
 * of sublinks to subplans!
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pull_var_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pull_var_clause_context</name></type> <name>context</name></decl>;</decl_stmt>

	<comment type="block">/* Assert that caller has not specified inconsistent flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator> <name>PVC_RECURSE_AGGREGATES</name><operator>)</operator><operator>)</operator>
		   <operator>!=</operator> <operator>(</operator><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator> <name>PVC_RECURSE_AGGREGATES</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator> <name>PVC_RECURSE_WINDOWFUNCS</name><operator>)</operator><operator>)</operator>
		   <operator>!=</operator> <operator>(</operator><name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator> <name>PVC_RECURSE_WINDOWFUNCS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>PVC_INCLUDE_PLACEHOLDERS</name> <operator>|</operator> <name>PVC_RECURSE_PLACEHOLDERS</name><operator>)</operator><operator>)</operator>
		   <operator>!=</operator> <operator>(</operator><name>PVC_INCLUDE_PLACEHOLDERS</name> <operator>|</operator> <name>PVC_RECURSE_PLACEHOLDERS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pull_var_clause_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>context</name><operator>.</operator><name>varlist</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pull_var_clause_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>pull_var_clause_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Upper-level Var found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Upper-level Aggref found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_INCLUDE_AGGREGATES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we do NOT descend into the contained expression */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_RECURSE_AGGREGATES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fall through to recurse into the aggregate's arguments */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Aggref found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Upper-level GROUPING found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_INCLUDE_AGGREGATES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we do NOT descend into the contained expression */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_RECURSE_AGGREGATES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We do NOT descend into the contained expression, even if the
			 * caller asked for it, because we never actually evaluate it -
			 * the result is driven entirely off the associated GROUP BY
			 * clause, so we never need to extract the actual Vars here.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GROUPING found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* WindowFuncs have no levelsup field to check ... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_INCLUDE_WINDOWFUNCS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we do NOT descend into the contained expressions */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_RECURSE_WINDOWFUNCS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fall through to recurse into the windowfunc's arguments */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WindowFunc found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Upper-level PlaceHolderVar found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_INCLUDE_PLACEHOLDERS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>varlist</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we do NOT descend into the contained expression */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PVC_RECURSE_PLACEHOLDERS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fall through to recurse into the placeholder's expression */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PlaceHolderVar found where not expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pull_var_clause_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * flatten_join_alias_vars
 *	  Replace Vars that reference JOIN outputs with references to the original
 *	  relation variables instead.  This allows quals involving such vars to be
 *	  pushed down.  Whole-row Vars that reference JOIN relations are expanded
 *	  into RowExpr constructs that name the individual output Vars.  This
 *	  is necessary since we will not scan the JOIN as a base relation, which
 *	  is the only way that the executor can directly handle whole-row Vars.
 *
 * This also adjusts relid sets found in some expression node types to
 * substitute the contained base rels for any join relid.
 *
 * If a JOIN contains sub-selects that have been flattened, its join alias
 * entries might now be arbitrary expressions, not just Vars.  This affects
 * this function in one important way: we might find ourselves inserting
 * SubLink expressions into subqueries, and we must make sure that their
 * Query.hasSubLinks fields get set to true if so.  If there are any
 * SubLinks in the join alias lists, the outer Query should already have
 * hasSubLinks = true, so this is only relevant to un-flattened subqueries.
 *
 * NOTE: this is used on not-yet-planned expressions.  We do not expect it
 * to be applied directly to the whole Query, so if we see a Query to start
 * with, we do want to increment sublevels_up (this occurs for LATERAL
 * subqueries).
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>flatten_join_alias_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flatten_join_alias_vars_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* flag whether join aliases could possibly contain SubLinks */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>possible_sublink</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>;</expr_stmt>
	<comment type="block">/* if hasSubLinks is already true, no need to work hard */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>inserted_sublink</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>flatten_join_alias_vars_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>flatten_join_alias_vars_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								<parameter><decl><type><name>flatten_join_alias_vars_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newvar</name></decl>;</decl_stmt>

		<comment type="block">/* No change unless Var belongs to a JOIN of the target level */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* no need to copy, really */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Must expand whole-row reference */</comment>
			<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>forboth</name><argument_list>(<argument>lv</argument>, <argument>rte-&gt;joinaliasvars</argument>, <argument>ln</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>newvar</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* Ignore dropped columns */</comment>
				<if_stmt><if>if <condition>(<expr><name>newvar</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we are expanding an alias carried down from an upper
				 * query, must adjust its varlevelsup fields.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Preserve original Var's location, if possible */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>newvar</name><operator>)</operator><operator>-&gt;</operator><name>location</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Recurse in case join input is itself a join */</comment>
				<comment type="block">/* (also takes care of setting inserted_sublink if needed) */</comment>
				<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>flatten_join_alias_vars_mutator</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>newvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We need the names of non-dropped columns, too */</comment>
				<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>rowexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fields</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>colnames</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rowexpr</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Expand join alias reference */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newvar</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are expanding an alias carried down from an upper query, must
		 * adjust its varlevelsup fields.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Preserve original Var's location, if possible */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>newvar</name><operator>)</operator><operator>-&gt;</operator><name>location</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Recurse in case join input is itself a join */</comment>
		<expr_stmt><expr><name>newvar</name> <operator>=</operator> <call><name>flatten_join_alias_vars_mutator</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Detect if we are adding a sublink to query */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>possible_sublink</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><name>newvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>newvar</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Copy the PlaceHolderVar node with correct mutation of subnodes */</comment>
		<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>phv</name> <operator>=</operator> <operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
														 <argument><expr><name>flatten_join_alias_vars_mutator</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* now fix PlaceHolderVar's relid sets */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name> <operator>=</operator> <call><name>alias_relid_set</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
										  <argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into RTE subquery or not-yet-planned sublink subquery */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_inserted_sublink</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_inserted_sublink</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>hasSubLinks</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
									 <argument><expr><name>flatten_join_alias_vars_mutator</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
									 <argument><expr><name>QTW_IGNORE_JOINALIASES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>|=</operator> <name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>inserted_sublink</name></name> <operator>=</operator> <name>save_inserted_sublink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Already-planned tree not supported */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Shouldn't need to handle these planner auxiliary nodes here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SpecialJoinInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MinMaxAggInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>flatten_join_alias_vars_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * alias_relid_set: in a set of RT indexes, replace joins by their
 * underlying base relids
 */</comment>
<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>alias_relid_set</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>rtindex</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>get_relids_for_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
