<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/util/predtest.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * predtest.c
 *	  Routines to attempt to prove logical implications between predicate
 *	  expressions.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/predtest.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Proof attempts involving large arrays in ScalarArrayOpExpr nodes are
 * likely to require O(N^2) time, and more often than not fail anyway.
 * So we set an arbitrary limit on the number of array elements that
 * we will allow to be treated as an AND or OR clause.
 * XXX is it worth exposing this as a GUC knob?
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SAOP_ARRAY_SIZE</name></cpp:macro>		<cpp:value>100</cpp:value></cpp:define>

<comment type="block">/*
 * To avoid redundant coding in predicate_implied_by_recurse and
 * predicate_refuted_by_recurse, we need to abstract out the notion of
 * iterating over the components of an expression that is logically an AND
 * or OR structure.  There are multiple sorts of expression nodes that can
 * be treated as ANDs or ORs, and we don't want to code each one separately.
 * Hence, these types and support routines.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>CLASS_ATOM</name></decl>,					<comment type="block">/* expression that's not AND or OR */</comment>
	<decl><name>CLASS_AND</name></decl>,					<comment type="block">/* expression with AND semantics */</comment>
	<decl><name>CLASS_OR</name></decl>					<comment type="block">/* expression with OR semantics */</comment>
}</block></enum></type> <name>PredClass</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>PredIterInfoData</name></name> <modifier>*</modifier></type><name>PredIterInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>PredIterInfoData</name>
<block>{
	<comment type="block">/* node-type-specific iteration state */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<comment type="block">/* initialize to do the iteration */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>startup_fn</name>) <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
	<comment type="block">/* next-component iteration function */</comment>
	<function_decl><type><name>Node</name>	   <modifier>*</modifier></type>(<modifier>*</modifier><name>next_fn</name>) <parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
	<comment type="block">/* release resources when done with iteration */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>cleanup_fn</name>) <parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>PredIterInfoData</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iterate_begin</name><parameter_list>(<parameter><type><name>item</name></type></parameter>, <parameter><type><name>clause</name></type></parameter>, <parameter><type><name>info</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		Node   *item; \
		(info).startup_fn((clause), &amp;(info)); \
		while ((item = (info).next_fn(&amp;(info))) != NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iterate_end</name><parameter_list>(<parameter><type><name>info</name></type></parameter>)</parameter_list></cpp:macro>	\
		<cpp:value>(info).cleanup_fn(&amp;(info)); \
	} while (0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>predicate_implied_by_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>predicate_refuted_by_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PredClass</name></type> <name>predicate_classify</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>list_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>list_next_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>list_cleanup_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>boolexpr_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arrayconst_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>arrayconst_next_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arrayconst_cleanup_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arrayexpr_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>arrayexpr_next_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>arrayexpr_cleanup_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>predicate_implied_by_simple_clause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>predicate_refuted_by_simple_clause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>extract_not_arg</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>extract_strong_not_arg</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>clause_is_strict_for</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>subexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>operator_predicate_proof</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>operator_same_subexprs_proof</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>operator_same_subexprs_lookup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>get_btree_test_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateOprProofCacheCallBack</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * predicate_implied_by
 *	  Recursively checks whether the clauses in clause_list imply that the
 *	  given predicate is true.
 *
 * We support two definitions of implication:
 *
 * "Strong" implication: A implies B means that truth of A implies truth of B.
 * We use this to prove that a row satisfying one WHERE clause or index
 * predicate must satisfy another one.
 *
 * "Weak" implication: A implies B means that non-falsity of A implies
 * non-falsity of B ("non-false" means "either true or NULL").  We use this to
 * prove that a row satisfying one CHECK constraint must satisfy another one.
 *
 * Strong implication can also be used to prove that a WHERE clause implies a
 * CHECK constraint, although it will fail to prove a few cases where we could
 * safely conclude that the implication holds.  There's no support for proving
 * the converse case, since only a few kinds of CHECK constraint would allow
 * deducing anything.
 *
 * The top-level List structure of each list corresponds to an AND list.
 * We assume that eval_const_expressions() has been applied and so there
 * are no un-flattened ANDs or ORs (e.g., no AND immediately within an AND,
 * including AND just below the top-level List structure).
 * If this is not true we might fail to prove an implication that is
 * valid, but no worse consequences will ensue.
 *
 * We assume the predicate has already been checked to contain only
 * immutable functions and operators.  (In many current uses this is known
 * true because the predicate is part of an index predicate that has passed
 * CheckPredicate(); otherwise, the caller must check it.)  We dare not make
 * deductions based on non-immutable functions, because they might change
 * answers between the time we make the plan and the time we execute the plan.
 * Immutability of functions in the clause_list is checked here, if necessary.
 */</comment>
<function><type><name>bool</name></type>
<name>predicate_implied_by</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>predicate_list</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause_list</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>predicate_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no predicate: implication is vacuous */</comment>
	<if_stmt><if>if <condition>(<expr><name>clause_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no restriction: implication must fail */</comment>

	<comment type="block">/*
	 * If either input is a single-element list, replace it with its lone
	 * member; this avoids one useless level of AND-recursion.  We only need
	 * to worry about this at top level, since eval_const_expressions should
	 * have gotten rid of any trivial ANDs or ORs below that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>predicate_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>predicate_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>predicate_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>clause_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>clause_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And away we go ... */</comment>
	<return>return <expr><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * predicate_refuted_by
 *	  Recursively checks whether the clauses in clause_list refute the given
 *	  predicate (that is, prove it false).
 *
 * This is NOT the same as !(predicate_implied_by), though it is similar
 * in the technique and structure of the code.
 *
 * We support two definitions of refutation:
 *
 * "Strong" refutation: A refutes B means truth of A implies falsity of B.
 * We use this to disprove a CHECK constraint given a WHERE clause, i.e.,
 * prove that any row satisfying the WHERE clause would violate the CHECK
 * constraint.  (Observe we must prove B yields false, not just not-true.)
 *
 * "Weak" refutation: A refutes B means truth of A implies non-truth of B
 * (i.e., B must yield false or NULL).  We use this to detect mutually
 * contradictory WHERE clauses.
 *
 * Weak refutation can be proven in some cases where strong refutation doesn't
 * hold, so it's useful to use it when possible.  We don't currently have
 * support for disproving one CHECK constraint based on another one, nor for
 * disproving WHERE based on CHECK.  (As with implication, the last case
 * doesn't seem very practical.  CHECK-vs-CHECK might be useful, but isn't
 * currently needed anywhere.)
 *
 * The top-level List structure of each list corresponds to an AND list.
 * We assume that eval_const_expressions() has been applied and so there
 * are no un-flattened ANDs or ORs (e.g., no AND immediately within an AND,
 * including AND just below the top-level List structure).
 * If this is not true we might fail to prove an implication that is
 * valid, but no worse consequences will ensue.
 *
 * We assume the predicate has already been checked to contain only
 * immutable functions and operators.  We dare not make deductions based on
 * non-immutable functions, because they might change answers between the
 * time we make the plan and the time we execute the plan.
 * Immutability of functions in the clause_list is checked here, if necessary.
 */</comment>
<function><type><name>bool</name></type>
<name>predicate_refuted_by</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>predicate_list</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clause_list</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>predicate_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no predicate: no refutation is possible */</comment>
	<if_stmt><if>if <condition>(<expr><name>clause_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no restriction: refutation must fail */</comment>

	<comment type="block">/*
	 * If either input is a single-element list, replace it with its lone
	 * member; this avoids one useless level of AND-recursion.  We only need
	 * to worry about this at top level, since eval_const_expressions should
	 * have gotten rid of any trivial ANDs or ORs below that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>predicate_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>predicate_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>predicate_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>clause_list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>clause_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And away we go ... */</comment>
	<return>return <expr><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------
 * predicate_implied_by_recurse
 *	  Does the predicate implication test for non-NULL restriction and
 *	  predicate clauses.
 *
 * The logic followed here is ("=&gt;" means "implies"):
 *	atom A =&gt; atom B iff:			predicate_implied_by_simple_clause says so
 *	atom A =&gt; AND-expr B iff:		A =&gt; each of B's components
 *	atom A =&gt; OR-expr B iff:		A =&gt; any of B's components
 *	AND-expr A =&gt; atom B iff:		any of A's components =&gt; B
 *	AND-expr A =&gt; AND-expr B iff:	A =&gt; each of B's components
 *	AND-expr A =&gt; OR-expr B iff:	A =&gt; any of B's components,
 *									*or* any of A's components =&gt; B
 *	OR-expr A =&gt; atom B iff:		each of A's components =&gt; B
 *	OR-expr A =&gt; AND-expr B iff:	A =&gt; each of B's components
 *	OR-expr A =&gt; OR-expr B iff:		each of A's components =&gt; any of B's
 *
 * An "atom" is anything other than an AND or OR node.  Notice that we don't
 * have any special logic to handle NOT nodes; these should have been pushed
 * down or eliminated where feasible during eval_const_expressions().
 *
 * All of these rules apply equally to strong or weak implication.
 *
 * We can't recursively expand either side first, but have to interleave
 * the expansions per the above rules, to be sure we handle all of these
 * examples:
 *		(x OR y) =&gt; (x OR y OR z)
 *		(x AND y AND z) =&gt; (x AND y)
 *		(x AND y) =&gt; ((x AND y) OR z)
 *		((x OR y) AND z) =&gt; (x OR y)
 * This is still not an exhaustive test, but it handles most normal cases
 * under the assumption that both inputs have been AND/OR flattened.
 *
 * We have to be prepared to handle RestrictInfo nodes in the restrictinfo
 * tree, though not in the predicate tree.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>predicate_implied_by_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredIterInfoData</name></type> <name>clause_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PredIterInfoData</name></type> <name>pred_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PredClass</name></type>	<name>pclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* skip through RestrictInfo */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pclass</name> <operator>=</operator> <call><name>predicate_classify</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>predicate_classify</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clause_info</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CLASS_AND</name></expr>:</case>
			<switch>switch <condition>(<expr><name>pclass</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CLASS_AND</name></expr>:</case>

					<comment type="block">/*
					 * AND-clause =&gt; AND-clause if A implies each of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_OR</name></expr>:</case>

					<comment type="block">/*
					 * AND-clause =&gt; OR-clause if A implies any of B's items
					 *
					 * Needed to handle (x AND y) =&gt; ((x AND y) OR z)
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Also check if any of A's items implies B
					 *
					 * Needed to handle ((x OR y) AND z) =&gt; (x OR y)
					 */</comment>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

					<comment type="block">/*
					 * AND-clause =&gt; atom if any of A's items implies B
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>CLASS_OR</name></expr>:</case>
			<switch>switch <condition>(<expr><name>pclass</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CLASS_OR</name></expr>:</case>

					<comment type="block">/*
					 * OR-clause =&gt; OR-clause if each of A's items implies any
					 * of B's items.  Messy but can't do it any more simply.
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type>		<name>presult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

						<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
															 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>presult</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>presult</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* doesn't imply any of B's */</comment>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_AND</name></expr>:</case>
				<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

					<comment type="block">/*
					 * OR-clause =&gt; AND-clause if each of A's items implies B
					 *
					 * OR-clause =&gt; atom if each of A's items implies B
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>CLASS_ATOM</name></expr>:</case>
			<switch>switch <condition>(<expr><name>pclass</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CLASS_AND</name></expr>:</case>

					<comment type="block">/*
					 * atom =&gt; AND-clause if A implies each of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_OR</name></expr>:</case>

					<comment type="block">/*
					 * atom =&gt; OR-clause if A implies any of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

					<comment type="block">/*
					 * atom =&gt; atom is the base case
					 */</comment>
					<return>return
						<expr><call><name>predicate_implied_by_simple_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>predicate</name></expr></argument>,
														   <argument><expr><name>clause</name></expr></argument>,
														   <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* can't get here */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"predicate_classify returned a bogus value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------
 * predicate_refuted_by_recurse
 *	  Does the predicate refutation test for non-NULL restriction and
 *	  predicate clauses.
 *
 * The logic followed here is ("R=&gt;" means "refutes"):
 *	atom A R=&gt; atom B iff:			predicate_refuted_by_simple_clause says so
 *	atom A R=&gt; AND-expr B iff:		A R=&gt; any of B's components
 *	atom A R=&gt; OR-expr B iff:		A R=&gt; each of B's components
 *	AND-expr A R=&gt; atom B iff:		any of A's components R=&gt; B
 *	AND-expr A R=&gt; AND-expr B iff:	A R=&gt; any of B's components,
 *									*or* any of A's components R=&gt; B
 *	AND-expr A R=&gt; OR-expr B iff:	A R=&gt; each of B's components
 *	OR-expr A R=&gt; atom B iff:		each of A's components R=&gt; B
 *	OR-expr A R=&gt; AND-expr B iff:	each of A's components R=&gt; any of B's
 *	OR-expr A R=&gt; OR-expr B iff:	A R=&gt; each of B's components
 *
 * All of the above rules apply equally to strong or weak refutation.
 *
 * In addition, if the predicate is a NOT-clause then we can use
 *	A R=&gt; NOT B if:					A =&gt; B
 * This works for several different SQL constructs that assert the non-truth
 * of their argument, ie NOT, IS FALSE, IS NOT TRUE, IS UNKNOWN, although some
 * of them require that we prove strong implication.  Likewise, we can use
 *	NOT A R=&gt; B if:					B =&gt; A
 * but here we must be careful about strong vs. weak refutation and make
 * the appropriate type of implication proof (weak or strong respectively).
 *
 * Other comments are as for predicate_implied_by_recurse().
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>predicate_refuted_by_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PredIterInfoData</name></type> <name>clause_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PredIterInfoData</name></type> <name>pred_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PredClass</name></type>	<name>pclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>not_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* skip through RestrictInfo */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pclass</name> <operator>=</operator> <call><name>predicate_classify</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>predicate_classify</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clause_info</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CLASS_AND</name></expr>:</case>
			<switch>switch <condition>(<expr><name>pclass</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CLASS_AND</name></expr>:</case>

					<comment type="block">/*
					 * AND-clause R=&gt; AND-clause if A refutes any of B's items
					 *
					 * Needed to handle (x AND y) R=&gt; ((!x OR !y) AND z)
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Also check if any of A's items refutes B
					 *
					 * Needed to handle ((x OR y) AND z) R=&gt; (!x AND !y)
					 */</comment>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_OR</name></expr>:</case>

					<comment type="block">/*
					 * AND-clause R=&gt; OR-clause if A refutes each of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

					<comment type="block">/*
					 * If B is a NOT-type clause, A R=&gt; B if A =&gt; B's arg
					 *
					 * Since, for either type of refutation, we are starting
					 * with the premise that A is true, we can use a strong
					 * implication test in all cases.  That proves B's arg is
					 * true, which is more than we need for weak refutation if
					 * B is a simple NOT, but it allows not worrying about
					 * exactly which kind of negation clause we have.
					 */</comment>
					<expr_stmt><expr><name>not_arg</name> <operator>=</operator> <call><name>extract_not_arg</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>not_arg</name> <operator>&amp;&amp;</operator>
						<call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>not_arg</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * AND-clause R=&gt; atom if any of A's items refutes B
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>CLASS_OR</name></expr>:</case>
			<switch>switch <condition>(<expr><name>pclass</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CLASS_OR</name></expr>:</case>

					<comment type="block">/*
					 * OR-clause R=&gt; OR-clause if A refutes each of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_AND</name></expr>:</case>

					<comment type="block">/*
					 * OR-clause R=&gt; AND-clause if each of A's items refutes
					 * any of B's items.
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>bool</name></type>		<name>presult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

						<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
															 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>presult</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>presult</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* citem refutes nothing */</comment>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

					<comment type="block">/*
					 * If B is a NOT-type clause, A R=&gt; B if A =&gt; B's arg
					 *
					 * Same logic as for the AND-clause case above.
					 */</comment>
					<expr_stmt><expr><name>not_arg</name> <operator>=</operator> <call><name>extract_not_arg</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>not_arg</name> <operator>&amp;&amp;</operator>
						<call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>not_arg</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * OR-clause R=&gt; atom if each of A's items refutes B
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>citem</argument>, <argument>clause</argument>, <argument>clause_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>citem</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>clause_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

			<comment type="block">/*
			 * If A is a strong NOT-clause, A R=&gt; B if B =&gt; A's arg
			 *
			 * Since A is strong, we may assume A's arg is false (not just
			 * not-true).  If B weakly implies A's arg, then B can be neither
			 * true nor null, so that strong refutation is proven.  If B
			 * strongly implies A's arg, then B cannot be true, so that weak
			 * refutation is proven.
			 */</comment>
			<expr_stmt><expr><name>not_arg</name> <operator>=</operator> <call><name>extract_strong_not_arg</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>not_arg</name> <operator>&amp;&amp;</operator>
				<call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>not_arg</name></expr></argument>,
											 <argument><expr><operator>!</operator><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name>pclass</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CLASS_AND</name></expr>:</case>

					<comment type="block">/*
					 * atom R=&gt; AND-clause if A refutes any of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														 <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_OR</name></expr>:</case>

					<comment type="block">/*
					 * atom R=&gt; OR-clause if A refutes each of B's items
					 */</comment>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>iterate_begin</name><argument_list>(<argument>pitem</argument>, <argument>predicate</argument>, <argument>pred_info</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_refuted_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>,
														  <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
					<expr_stmt><expr><call><name>iterate_end</name><argument_list>(<argument><expr><name>pred_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>

				<case>case <expr><name>CLASS_ATOM</name></expr>:</case>

					<comment type="block">/*
					 * If B is a NOT-type clause, A R=&gt; B if A =&gt; B's arg
					 *
					 * Same logic as for the AND-clause case above.
					 */</comment>
					<expr_stmt><expr><name>not_arg</name> <operator>=</operator> <call><name>extract_not_arg</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>not_arg</name> <operator>&amp;&amp;</operator>
						<call><name>predicate_implied_by_recurse</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>not_arg</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * atom R=&gt; atom is the base case
					 */</comment>
					<return>return
						<expr><call><name>predicate_refuted_by_simple_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>predicate</name></expr></argument>,
														   <argument><expr><name>clause</name></expr></argument>,
														   <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></switch>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* can't get here */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"predicate_classify returned a bogus value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * predicate_classify
 *	  Classify an expression node as AND-type, OR-type, or neither (an atom).
 *
 * If the expression is classified as AND- or OR-type, then *info is filled
 * in with the functions needed to iterate over its components.
 *
 * This function also implements enforcement of MAX_SAOP_ARRAY_SIZE: if a
 * ScalarArrayOpExpr's array has too many elements, we just classify it as an
 * atom.  (This will result in its being passed as-is to the simple_clause
 * functions, which will fail to prove anything about it.)	Note that we
 * cannot just stop after considering MAX_SAOP_ARRAY_SIZE elements; in general
 * that would result in wrong proofs, rather than failing to prove anything.
 */</comment>
<function><type><specifier>static</specifier> <name>PredClass</name></type>
<name>predicate_classify</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Caller should not pass us NULL, nor a RestrictInfo clause */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we see a List, assume it's an implicit-AND list; this is the correct
	 * semantics for lists of RestrictInfo nodes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>startup_fn</name></name> <operator>=</operator> <name>list_startup_fn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>next_fn</name></name> <operator>=</operator> <name>list_next_fn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>cleanup_fn</name></name> <operator>=</operator> <name>list_cleanup_fn</name></expr>;</expr_stmt>
		<return>return <expr><name>CLASS_AND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Handle normal AND and OR boolean clauses */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>startup_fn</name></name> <operator>=</operator> <name>boolexpr_startup_fn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>next_fn</name></name> <operator>=</operator> <name>list_next_fn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>cleanup_fn</name></name> <operator>=</operator> <name>list_cleanup_fn</name></expr>;</expr_stmt>
		<return>return <expr><name>CLASS_AND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>startup_fn</name></name> <operator>=</operator> <name>boolexpr_startup_fn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>next_fn</name></name> <operator>=</operator> <name>list_next_fn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>cleanup_fn</name></name> <operator>=</operator> <name>list_cleanup_fn</name></expr>;</expr_stmt>
		<return>return <expr><name>CLASS_OR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Handle ScalarArrayOpExpr */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arraynode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can break this down into an AND or OR structure, but only if we
		 * know how to iterate through expressions for the array's elements.
		 * We can do that if the array operand is a non-null constant or a
		 * simple ArrayExpr.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>arraynode</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arraynode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arraynode</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arraynode</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&lt;=</operator> <name>MAX_SAOP_ARRAY_SIZE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>startup_fn</name></name> <operator>=</operator> <name>arrayconst_startup_fn</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>next_fn</name></name> <operator>=</operator> <name>arrayconst_next_fn</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>cleanup_fn</name></name> <operator>=</operator> <name>arrayconst_cleanup_fn</name></expr>;</expr_stmt>
				<return>return <expr><ternary><condition><expr><name><name>saop</name><operator>-&gt;</operator><name>useOr</name></name></expr> ?</condition><then> <expr><name>CLASS_OR</name></expr> </then><else>: <expr><name>CLASS_AND</name></expr></else></ternary></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>arraynode</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arraynode</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <operator>!</operator><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>arraynode</name><operator>)</operator><operator>-&gt;</operator><name>multidims</name> <operator>&amp;&amp;</operator>
				 <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>arraynode</name><operator>)</operator><operator>-&gt;</operator><name>elements</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>MAX_SAOP_ARRAY_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>startup_fn</name></name> <operator>=</operator> <name>arrayexpr_startup_fn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>next_fn</name></name> <operator>=</operator> <name>arrayexpr_next_fn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>cleanup_fn</name></name> <operator>=</operator> <name>arrayexpr_cleanup_fn</name></expr>;</expr_stmt>
			<return>return <expr><ternary><condition><expr><name><name>saop</name><operator>-&gt;</operator><name>useOr</name></name></expr> ?</condition><then> <expr><name>CLASS_OR</name></expr> </then><else>: <expr><name>CLASS_AND</name></expr></else></ternary></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* None of the above, so it's an atom */</comment>
	<return>return <expr><name>CLASS_ATOM</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PredIterInfo routines for iterating over regular Lists.  The iteration
 * state variable is the next ListCell to visit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>list_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>list_head</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>list_next_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>list_cleanup_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Nothing to clean up */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * BoolExpr needs its own startup function, but can use list_next_fn and
 * list_cleanup_fn.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>boolexpr_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>list_head</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PredIterInfo routines for iterating over a ScalarArrayOpExpr with a
 * constant array operand.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>OpExpr</name></type>		<name>opexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name></type>		<name>constexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
}</block></struct></type> <name>ArrayConstIterState</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arrayconst_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayConstIterState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>arrayconst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>

	<comment type="block">/* Create working state struct */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>ArrayConstIterState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayConstIterState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>

	<comment type="block">/* Deconstruct the array literal */</comment>
	<expr_stmt><expr><name>arrayconst</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>arrayconst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
					  <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>elem_values</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>elem_nulls</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>num_elems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up a dummy OpExpr to return as the per-item node */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>xpr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_OpExpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opno</name></name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opresulttype</name></name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>args</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up a dummy Const node to hold the per-element values */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>xpr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Const</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>consttype</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>consttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>constcollid</name></name> <operator>=</operator> <name><name>arrayconst</name><operator>-&gt;</operator><name>constcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>constlen</name></name> <operator>=</operator> <name>elmlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>constbyval</name></name> <operator>=</operator> <name>elmbyval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>constexpr</name></name></expr>;</expr_stmt>

	<comment type="block">/* Initialize iteration state */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_elem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>arrayconst_next_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayConstIterState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ArrayConstIterState</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>next_elem</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>num_elems</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>constvalue</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>next_elem</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>constexpr</name><operator>.</operator><name>constisnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>elem_nulls</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>next_elem</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_elem</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>opexpr</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arrayconst_cleanup_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayConstIterState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ArrayConstIterState</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>elem_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>elem_nulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PredIterInfo routines for iterating over a ScalarArrayOpExpr with a
 * one-dimensional ArrayExpr array operand.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>OpExpr</name></type>		<name>opexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>ArrayExprIterState</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arrayexpr_startup_fn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayExprIterState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name></decl>;</decl_stmt>

	<comment type="block">/* Create working state struct */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>ArrayExprIterState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayExprIterState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>

	<comment type="block">/* Set up a dummy OpExpr to return as the per-item node */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>xpr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_OpExpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opno</name></name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opresulttype</name></name> <operator>=</operator> <name>BOOLOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>opcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>args</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize iteration variable to first member of ArrayExpr */</comment>
	<expr_stmt><expr><name>arrayexpr</name> <operator>=</operator> <operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>arrayexpr_next_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayExprIterState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ArrayExprIterState</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>opexpr</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>arrayexpr_cleanup_fn</name><parameter_list>(<parameter><decl><type><name>PredIterInfo</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayExprIterState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ArrayExprIterState</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>opexpr</name><operator>.</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------
 * predicate_implied_by_simple_clause
 *	  Does the predicate implication test for a "simple clause" predicate
 *	  and a "simple clause" restriction.
 *
 * We return true if able to prove the implication, false if not.
 *
 * We have three strategies for determining whether one simple clause
 * implies another:
 *
 * A simple and general way is to see if they are equal(); this works for any
 * kind of expression, and for either implication definition.  (Actually,
 * there is an implied assumption that the functions in the expression are
 * immutable --- but this was checked for the predicate by the caller.)
 *
 * If the predicate is of the form "foo IS NOT NULL", and we are considering
 * strong implication, we can conclude that the predicate is implied if the
 * clause is strict for "foo", i.e., it must yield NULL when "foo" is NULL.
 * In that case truth of the clause requires that "foo" isn't NULL.
 * (Again, this is a safe conclusion because "foo" must be immutable.)
 * This doesn't work for weak implication, though.
 *
 * Finally, if both clauses are binary operator expressions, we may be able
 * to prove something using the system's knowledge about operators; those
 * proof rules are encapsulated in operator_predicate_proof().
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>predicate_implied_by_simple_clause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Allow interrupting long proof attempts */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First try the equal() test */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>predicate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Next try the IS NOT NULL case */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weak</name> <operator>&amp;&amp;</operator>
		<name>predicate</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* row IS NOT NULL does not act in the simple way we have in mind */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* strictness of clause for foo implies foo IS NOT NULL */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>clause_is_strict_for</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* we can't succeed below... */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else try operator-related knowledge */</comment>
	<return>return <expr><call><name>operator_predicate_proof</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*----------
 * predicate_refuted_by_simple_clause
 *	  Does the predicate refutation test for a "simple clause" predicate
 *	  and a "simple clause" restriction.
 *
 * We return true if able to prove the refutation, false if not.
 *
 * Unlike the implication case, checking for equal() clauses isn't helpful.
 * But relation_excluded_by_constraints() checks for self-contradictions in a
 * list of clauses, so that we may get here with predicate and clause being
 * actually pointer-equal, and that is worth eliminating quickly.
 *
 * When the predicate is of the form "foo IS NULL", we can conclude that
 * the predicate is refuted if the clause is strict for "foo" (see notes for
 * implication case), or is "foo IS NOT NULL".  That works for either strong
 * or weak refutation.
 *
 * A clause "foo IS NULL" refutes a predicate "foo IS NOT NULL" in all cases.
 * If we are considering weak refutation, it also refutes a predicate that
 * is strict for "foo", since then the predicate must yield NULL (and since
 * "foo" appears in the predicate, it's known immutable).
 *
 * (The main motivation for covering these IS [NOT] NULL cases is to support
 * using IS NULL/IS NOT NULL as partition-defining constraints.)
 *
 * Finally, if both clauses are binary operator expressions, we may be able
 * to prove something using the system's knowledge about operators; those
 * proof rules are encapsulated in operator_predicate_proof().
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>predicate_refuted_by_simple_clause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Allow interrupting long proof attempts */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A simple clause can't refute itself */</comment>
	<comment type="block">/* Worth checking because of relation_excluded_by_constraints() */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>predicate</name> <operator>==</operator> <name>clause</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try the predicate-IS-NULL case */</comment>
	<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name><operator>)</operator><operator>-&gt;</operator><name>nulltesttype</name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>isnullarg</name> <init>= <expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* row IS NULL does not act in the simple way we have in mind */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name><operator>)</operator><operator>-&gt;</operator><name>argisrow</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* strictness of clause for foo refutes foo IS NULL */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>clause_is_strict_for</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>isnullarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* foo IS NOT NULL refutes foo IS NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>nulltesttype</name> <operator>==</operator> <name>IS_NOT_NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>argisrow</name> <operator>&amp;&amp;</operator>
			<call><name>equal</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>isnullarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* we can't succeed below... */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Try the clause-IS-NULL case */</comment>
	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>nulltesttype</name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>isnullarg</name> <init>= <expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* row IS NULL does not act in the simple way we have in mind */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>argisrow</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* foo IS NULL refutes foo IS NOT NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name><operator>)</operator><operator>-&gt;</operator><name>nulltesttype</name> <operator>==</operator> <name>IS_NOT_NULL</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name><operator>)</operator><operator>-&gt;</operator><name>argisrow</name> <operator>&amp;&amp;</operator>
			<call><name>equal</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>predicate</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>isnullarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* foo IS NULL weakly refutes any predicate that is strict for foo */</comment>
		<if_stmt><if>if <condition>(<expr><name>weak</name> <operator>&amp;&amp;</operator>
			<call><name>clause_is_strict_for</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>predicate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>isnullarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* we can't succeed below... */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else try operator-related knowledge */</comment>
	<return>return <expr><call><name>operator_predicate_proof</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>weak</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * If clause asserts the non-truth of a subclause, return that subclause;
 * otherwise return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>extract_not_arg</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>bexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bexpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>bexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_TRUE</name> <operator>||</operator>
			<name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_FALSE</name> <operator>||</operator>
			<name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If clause asserts the falsity of a subclause, return that subclause;
 * otherwise return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>extract_strong_not_arg</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>bexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bexpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>bexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_FALSE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Can we prove that "clause" returns NULL if "subexpr" does?
 *
 * The base case is that clause and subexpr are equal().  (We assume that
 * the caller knows at least one of the input expressions is immutable,
 * as this wouldn't hold for volatile expressions.)
 *
 * We can also report success if the subexpr appears as a subexpression
 * of "clause" in a place where it'd force nullness of the overall result.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>clause_is_strict_for</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>subexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* safety checks */</comment>
	<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>subexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look through any RelabelType nodes, so that we can match, say,
	 * varcharcol with lower(varcharcol::text).  (In general we could recurse
	 * through any nullness-preserving, immutable operation.)  We should not
	 * see stacked RelabelTypes here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>subexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Base case */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have a strict operator or function, a NULL result is guaranteed
	 * if any input is forced NULL by subexpr.  This is OK even if the op or
	 * func isn't immutable, since it won't even be called on NULL input.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>op_strict</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((OpExpr *) clause)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>clause_is_strict_for</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>is_funcclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>func_strict</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>funcid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((FuncExpr *) clause)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>clause_is_strict_for</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Define "operator implication tables" for btree operators ("strategies"),
 * and similar tables for refutation.
 *
 * The strategy numbers defined by btree indexes (see access/stratnum.h) are:
 *		1 &lt;		2 &lt;=	3 =		4 &gt;=	5 &gt;
 * and in addition we use 6 to represent &lt;&gt;.  &lt;&gt; is not a btree-indexable
 * operator, but we assume here that if an equality operator of a btree
 * opfamily has a negator operator, the negator behaves as &lt;&gt; for the opfamily.
 * (This convention is also known to get_op_btree_interpretation().)
 *
 * BT_implies_table[] and BT_refutes_table[] are used for cases where we have
 * two identical subexpressions and we want to know whether one operator
 * expression implies or refutes the other.  That is, if the "clause" is
 * EXPR1 clause_op EXPR2 and the "predicate" is EXPR1 pred_op EXPR2 for the
 * same two (immutable) subexpressions:
 *		BT_implies_table[clause_op-1][pred_op-1]
 *			is true if the clause implies the predicate
 *		BT_refutes_table[clause_op-1][pred_op-1]
 *			is true if the clause refutes the predicate
 * where clause_op and pred_op are strategy numbers (from 1 to 6) in the
 * same btree opfamily.  For example, "x &lt; y" implies "x &lt;= y" and refutes
 * "x &gt; y".
 *
 * BT_implic_table[] and BT_refute_table[] are used where we have two
 * constants that we need to compare.  The interpretation of:
 *
 *		test_op = BT_implic_table[clause_op-1][pred_op-1]
 *
 * where test_op, clause_op and pred_op are strategy numbers (from 1 to 6)
 * of btree operators, is as follows:
 *
 *	 If you know, for some EXPR, that "EXPR clause_op CONST1" is true, and you
 *	 want to determine whether "EXPR pred_op CONST2" must also be true, then
 *	 you can use "CONST2 test_op CONST1" as a test.  If this test returns true,
 *	 then the predicate expression must be true; if the test returns false,
 *	 then the predicate expression may be false.
 *
 * For example, if clause is "Quantity &gt; 10" and pred is "Quantity &gt; 5"
 * then we test "5 &lt;= 10" which evals to true, so clause implies pred.
 *
 * Similarly, the interpretation of a BT_refute_table entry is:
 *
 *	 If you know, for some EXPR, that "EXPR clause_op CONST1" is true, and you
 *	 want to determine whether "EXPR pred_op CONST2" must be false, then
 *	 you can use "CONST2 test_op CONST1" as a test.  If this test returns true,
 *	 then the predicate expression must be false; if the test returns false,
 *	 then the predicate expression may be true.
 *
 * For example, if clause is "Quantity &gt; 10" and pred is "Quantity &lt; 5"
 * then we test "5 &lt;= 10" which evals to true, so clause refutes pred.
 *
 * An entry where test_op == 0 means the implication cannot be determined.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTLT</name></cpp:macro> <cpp:value>BTLessStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTLE</name></cpp:macro> <cpp:value>BTLessEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTEQ</name></cpp:macro> <cpp:value>BTEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTGE</name></cpp:macro> <cpp:value>BTGreaterEqualStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTGT</name></cpp:macro> <cpp:value>BTGreaterStrategyNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTNE</name></cpp:macro> <cpp:value>ROWCOMPARE_NE</cpp:value></cpp:define>

<comment type="block">/* We use "none" for 0/false to make the tables align nicely */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>none</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>BT_implies_table</name><index>[<expr><literal type="number">6</literal></expr>]</index><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*
 *			The predicate operator:
 *	 LT    LE	 EQ    GE	 GT    NE
 */</comment>
	<expr><block>{<expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>}</block></expr>,	<comment type="block">/* LT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* LE */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* EQ */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* GE */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>}</block></expr>,	<comment type="block">/* GT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>}</block></expr>	<comment type="block">/* NE */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name><name>BT_refutes_table</name><index>[<expr><literal type="number">6</literal></expr>]</index><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*
 *			The predicate operator:
 *	 LT    LE	 EQ    GE	 GT    NE
 */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* LT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* LE */</comment>
	<expr><block>{<expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>}</block></expr>,	<comment type="block">/* EQ */</comment>
	<expr><block>{<expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* GE */</comment>
	<expr><block>{<expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* GT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>true</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>	<comment type="block">/* NE */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>StrategyNumber</name></type> <name><name>BT_implic_table</name><index>[<expr><literal type="number">6</literal></expr>]</index><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*
 *			The predicate operator:
 *	 LT    LE	 EQ    GE	 GT    NE
 */</comment>
	<expr><block>{<expr><name>BTGE</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTGE</name></expr>}</block></expr>,	<comment type="block">/* LT */</comment>
	<expr><block>{<expr><name>BTGT</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTGT</name></expr>}</block></expr>,	<comment type="block">/* LE */</comment>
	<expr><block>{<expr><name>BTGT</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>BTEQ</name></expr>, <expr><name>BTLE</name></expr>, <expr><name>BTLT</name></expr>, <expr><name>BTNE</name></expr>}</block></expr>,	<comment type="block">/* EQ */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTLE</name></expr>, <expr><name>BTLT</name></expr>, <expr><name>BTLT</name></expr>}</block></expr>,	<comment type="block">/* GE */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTLE</name></expr>, <expr><name>BTLE</name></expr>, <expr><name>BTLE</name></expr>}</block></expr>,	<comment type="block">/* GT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTEQ</name></expr>}</block></expr>	<comment type="block">/* NE */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>StrategyNumber</name></type> <name><name>BT_refute_table</name><index>[<expr><literal type="number">6</literal></expr>]</index><index>[<expr><literal type="number">6</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*
 *			The predicate operator:
 *	 LT    LE	 EQ    GE	 GT    NE
 */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* LT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTGT</name></expr>, <expr><name>BTGT</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* LE */</comment>
	<expr><block>{<expr><name>BTLE</name></expr>, <expr><name>BTLT</name></expr>, <expr><name>BTNE</name></expr>, <expr><name>BTGT</name></expr>, <expr><name>BTGE</name></expr>, <expr><name>BTEQ</name></expr>}</block></expr>,	<comment type="block">/* EQ */</comment>
	<expr><block>{<expr><name>BTLE</name></expr>, <expr><name>BTLT</name></expr>, <expr><name>BTLT</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* GE */</comment>
	<expr><block>{<expr><name>BTLE</name></expr>, <expr><name>BTLE</name></expr>, <expr><name>BTLE</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>,	<comment type="block">/* GT */</comment>
	<expr><block>{<expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>BTEQ</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>, <expr><name>none</name></expr>}</block></expr>	<comment type="block">/* NE */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * operator_predicate_proof
 *	  Does the predicate implication or refutation test for a "simple clause"
 *	  predicate and a "simple clause" restriction, when both are operator
 *	  clauses using related operators and identical input expressions.
 *
 * When refute_it == false, we want to prove the predicate true;
 * when refute_it == true, we want to prove the predicate false.
 * (There is enough common code to justify handling these two cases
 * in one routine.)  We return true if able to make the proof, false
 * if not able to prove it.
 *
 * We mostly need not distinguish strong vs. weak implication/refutation here.
 * This depends on the assumption that a pair of related operators (i.e.,
 * commutators, negators, or btree opfamily siblings) will not return one NULL
 * and one non-NULL result for the same inputs.  Then, for the proof types
 * where we start with an assumption of truth of the clause, the predicate
 * operator could not return NULL either, so it doesn't matter whether we are
 * trying to make a strong or weak proof.  For weak implication, it could be
 * that the clause operator returned NULL, but then the predicate operator
 * would as well, so that the weak implication still holds.  This argument
 * doesn't apply in the case where we are considering two different constant
 * values, since then the operators aren't being given identical inputs.  But
 * we only support that for btree operators, for which we can assume that all
 * non-null inputs result in non-null outputs, so that it doesn't matter which
 * two non-null constants we consider.  If either constant is NULL, we have
 * to think harder, but sometimes the proof still works, as explained below.
 *
 * We can make proofs involving several expression forms (here "foo" and "bar"
 * represent subexpressions that are identical according to equal()):
 *	"foo op1 bar" refutes "foo op2 bar" if op1 is op2's negator
 *	"foo op1 bar" implies "bar op2 foo" if op1 is op2's commutator
 *	"foo op1 bar" refutes "bar op2 foo" if op1 is negator of op2's commutator
 *	"foo op1 bar" can imply/refute "foo op2 bar" based on btree semantics
 *	"foo op1 bar" can imply/refute "bar op2 foo" based on btree semantics
 *	"foo op1 const1" can imply/refute "foo op2 const2" based on btree semantics
 *
 * For the last three cases, op1 and op2 have to be members of the same btree
 * operator family.  When both subexpressions are identical, the idea is that,
 * for instance, x &lt; y implies x &lt;= y, independently of exactly what x and y
 * are.  If we have two different constants compared to the same expression
 * foo, we have to execute a comparison between the two constant values
 * in order to determine the result; for instance, foo &lt; c1 implies foo &lt; c2
 * if c1 &lt;= c2.  We assume it's safe to compare the constants at plan time
 * if the comparison operator is immutable.
 *
 * Note: all the operators and subexpressions have to be immutable for the
 * proof to be safe.  We assume the predicate expression is entirely immutable,
 * so no explicit check on the subexpressions is needed here, but in some
 * cases we need an extra check of operator immutability.  In particular,
 * btree opfamilies can contain cross-type operators that are merely stable,
 * and we dare not make deductions with those.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>operator_predicate_proof</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>weak</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>pred_opexpr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>clause_opexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pred_collation</name></decl>,
				<decl><type ref="prev"/><name>clause_collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pred_op</name></decl>,
				<decl><type ref="prev"/><name>clause_op</name></decl>,
				<decl><type ref="prev"/><name>test_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pred_leftop</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pred_rightop</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>clause_leftop</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>clause_rightop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>pred_const</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>clause_const</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>test_expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>test_exprstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>test_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Both expressions must be binary opclauses, else we can't do anything.
	 *
	 * Note: in future we might extend this logic to other operator-based
	 * constructs such as DistinctExpr.  But the planner isn't very smart
	 * about DistinctExpr in general, and this probably isn't the first place
	 * to fix if you want to improve that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pred_opexpr</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>predicate</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pred_opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>clause_opexpr</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>clause_opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If they're marked with different collations then we can't do anything.
	 * This is a cheap test so let's get it out of the way early.
	 */</comment>
	<expr_stmt><expr><name>pred_collation</name> <operator>=</operator> <name><name>pred_opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>clause_collation</name> <operator>=</operator> <name><name>clause_opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pred_collation</name> <operator>!=</operator> <name>clause_collation</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Grab the operator OIDs now too.  We may commute these below. */</comment>
	<expr_stmt><expr><name>pred_op</name> <operator>=</operator> <name><name>pred_opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>clause_op</name> <operator>=</operator> <name><name>clause_opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to match up at least one pair of input expressions.
	 */</comment>
	<expr_stmt><expr><name>pred_leftop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>pred_opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pred_rightop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>pred_opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clause_leftop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause_opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clause_rightop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause_opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>pred_leftop</name></expr></argument>, <argument><expr><name>clause_leftop</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>pred_rightop</name></expr></argument>, <argument><expr><name>clause_rightop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We have x op1 y and x op2 y */</comment>
			<return>return <expr><call><name>operator_same_subexprs_proof</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name>refute_it</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Fail unless rightops are both Consts */</comment>
			<if_stmt><if>if <condition>(<expr><name>pred_rightop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>pred_rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pred_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>pred_rightop</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>clause_rightop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>clause_rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>clause_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause_rightop</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>pred_rightop</name></expr></argument>, <argument><expr><name>clause_rightop</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fail unless leftops are both Consts */</comment>
		<if_stmt><if>if <condition>(<expr><name>pred_leftop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>pred_leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pred_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>pred_leftop</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>clause_leftop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>clause_leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>clause_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause_leftop</name></expr>;</expr_stmt>
		<comment type="block">/* Commute both operators so we can assume Consts are on the right */</comment>
		<expr_stmt><expr><name>pred_op</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>clause_op</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>pred_leftop</name></expr></argument>, <argument><expr><name>clause_rightop</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>pred_rightop</name></expr></argument>, <argument><expr><name>clause_leftop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We have x op1 y and y op2 x */</comment>
			<comment type="block">/* Commute pred_op that we can treat this like a straight match */</comment>
			<expr_stmt><expr><name>pred_op</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><call><name>operator_same_subexprs_proof</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name>refute_it</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Fail unless pred_rightop/clause_leftop are both Consts */</comment>
			<if_stmt><if>if <condition>(<expr><name>pred_rightop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>pred_rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pred_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>pred_rightop</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>clause_leftop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>clause_leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>clause_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause_leftop</name></expr>;</expr_stmt>
			<comment type="block">/* Commute clause_op so we can assume Consts are on the right */</comment>
			<expr_stmt><expr><name>clause_op</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>pred_rightop</name></expr></argument>, <argument><expr><name>clause_leftop</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fail unless pred_leftop/clause_rightop are both Consts */</comment>
		<if_stmt><if>if <condition>(<expr><name>pred_leftop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>pred_leftop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pred_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>pred_leftop</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>clause_rightop</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>clause_rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>clause_const</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause_rightop</name></expr>;</expr_stmt>
		<comment type="block">/* Commute pred_op so we can assume Consts are on the right */</comment>
		<expr_stmt><expr><name>pred_op</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Failed to match up any of the subexpressions, so we lose */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We have two identical subexpressions, and two other subexpressions that
	 * are not identical but are both Consts; and we have commuted the
	 * operators if necessary so that the Consts are on the right.  We'll need
	 * to compare the Consts' values.  If either is NULL, we can't do that, so
	 * usually the proof fails ... but in some cases we can claim success.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>clause_const</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If clause_op isn't strict, we can't prove anything */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * At this point we know that the clause returns NULL.  For proof
		 * types that assume truth of the clause, this means the proof is
		 * vacuously true (a/k/a "false implies anything").  That's all proof
		 * types except weak implication.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>weak</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>refute_it</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For weak implication, it's still possible for the proof to succeed,
		 * if the predicate can also be proven NULL.  In that case we've got
		 * NULL =&gt; NULL which is valid for this proof type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pred_const</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Else the proof fails */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pred_const</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the pred_op is strict, we know the predicate yields NULL, which
		 * means the proof succeeds for either weak implication or weak
		 * refutation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>weak</name> <operator>&amp;&amp;</operator> <call><name>op_strict</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Else the proof fails */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lookup the constant-comparison operator using the system catalogs and
	 * the operator implication tables.
	 */</comment>
	<expr_stmt><expr><name>test_op</name> <operator>=</operator> <call><name>get_btree_test_op</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name>refute_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>test_op</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* couldn't find a suitable comparison operator */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Evaluate the test.  For this we need an EState.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can use the estate's working context to avoid memory leaks. */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build expression tree */</comment>
	<expr_stmt><expr><name>test_expr</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>test_op</name></expr></argument>,
							  <argument><expr><name>BOOLOID</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>pred_const</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause_const</name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>,
							  <argument><expr><name>pred_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill in opfuncids */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>test_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare it for execution */</comment>
	<expr_stmt><expr><name>test_exprstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>test_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And execute it. */</comment>
	<expr_stmt><expr><name>test_result</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>test_exprstate</name></expr></argument>,
											<argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get back to outer memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release all the junk we just created */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Treat a null result as non-proof ... but it's a tad fishy ... */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"null predicate test result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test_result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * operator_same_subexprs_proof
 *	  Assuming that EXPR1 clause_op EXPR2 is true, try to prove or refute
 *	  EXPR1 pred_op EXPR2.
 *
 * Return true if able to make the proof, false if not able to prove it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>operator_same_subexprs_proof</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * A simple and general rule is that the predicate is proven if clause_op
	 * and pred_op are the same, or refuted if they are each other's negators.
	 * We need not check immutability since the pred_op is already known
	 * immutable.  (Actually, by this point we may have the commutator of a
	 * known-immutable pred_op, but that should certainly be immutable too.
	 * Likewise we don't worry whether the pred_op's negator is immutable.)
	 *
	 * Note: the "same" case won't get here if we actually had EXPR1 clause_op
	 * EXPR2 and EXPR1 pred_op EXPR2, because the overall-expression-equality
	 * test in predicate_implied_by_simple_clause would have caught it.  But
	 * we can see the same operator after having commuted the pred_op.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>refute_it</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>get_negator</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>clause_op</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>pred_op</name> <operator>==</operator> <name>clause_op</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Otherwise, see if we can determine the implication by finding the
	 * operators' relationship via some btree opfamily.
	 */</comment>
	<return>return <expr><call><name>operator_same_subexprs_lookup</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name>refute_it</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * We use a lookaside table to cache the result of btree proof operator
 * lookups, since the actual lookup is pretty expensive and doesn't change
 * for any given pair of operators (at least as long as pg_amop doesn't
 * change).  A single hash entry stores both implication and refutation
 * results for a given pair of operators; but note we may have determined
 * only one of those sets of results as yet.
 */</comment>
<typedef>typedef <type><struct>struct <name>OprProofCacheKey</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pred_op</name></decl>;</decl_stmt>		<comment type="block">/* predicate operator */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>clause_op</name></decl>;</decl_stmt>		<comment type="block">/* clause operator */</comment>
}</block></struct></type> <name>OprProofCacheKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>OprProofCacheEntry</name>
<block>{
	<comment type="block">/* the hash lookup key MUST BE FIRST */</comment>
	<decl_stmt><decl><type><name>OprProofCacheKey</name></type> <name>key</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>have_implic</name></decl>;</decl_stmt>	<comment type="block">/* do we know the implication result? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_refute</name></decl>;</decl_stmt>	<comment type="block">/* do we know the refutation result? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>same_subexprs_implies</name></decl>;</decl_stmt>	<comment type="block">/* X clause_op Y implies X pred_op Y? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>same_subexprs_refutes</name></decl>;</decl_stmt>	<comment type="block">/* X clause_op Y refutes X pred_op Y? */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>implic_test_op</name></decl>;</decl_stmt> <comment type="block">/* OID of the test operator, or 0 if none */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>refute_test_op</name></decl>;</decl_stmt> <comment type="block">/* OID of the test operator, or 0 if none */</comment>
}</block></struct></type> <name>OprProofCacheEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>OprProofCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * lookup_proof_cache
 *	  Get, and fill in if necessary, the appropriate cache entry.
 */</comment>
<function><type><specifier>static</specifier> <name>OprProofCacheEntry</name> <modifier>*</modifier></type>
<name>lookup_proof_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OprProofCacheKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OprProofCacheEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cfound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>same_subexprs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>test_op</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pred_op_infos</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>clause_op_infos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find or make a cache entry for this pair of operators.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>OprProofCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OprProofCacheKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OprProofCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>OprProofCacheHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Btree proof lookup cache"</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Arrange to flush cache on pg_amop changes */</comment>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
									  <argument><expr><name>InvalidateOprProofCacheCallBack</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>pred_op</name></name> <operator>=</operator> <name>pred_op</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>clause_op</name></name> <operator>=</operator> <name>clause_op</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cache_entry</name> <operator>=</operator> <operator>(</operator><name>OprProofCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>OprProofCacheHash</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
													 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cfound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cfound</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* new cache entry, set it invalid */</comment>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>have_implic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>have_refute</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* pre-existing cache entry, see if we know the answer yet */</comment>
		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>refute_it</name></expr> ?</condition><then> <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>have_refute</name></name></expr> </then><else>: <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>have_implic</name></name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cache_entry</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Try to find a btree opfamily containing the given operators.
	 *
	 * We must find a btree opfamily that contains both operators, else the
	 * implication can't be determined.  Also, the opfamily must contain a
	 * suitable test operator taking the operators' righthand datatypes.
	 *
	 * If there are multiple matching opfamilies, assume we can use any one to
	 * determine the logical relationship of the two operators and the correct
	 * corresponding test operator.  This should work for any logically
	 * consistent opfamilies.
	 *
	 * Note that we can determine the operators' relationship for
	 * same-subexprs cases even from an opfamily that lacks a usable test
	 * operator.  This can happen in cases with incomplete sets of cross-type
	 * comparison operators.
	 */</comment>
	<expr_stmt><expr><name>clause_op_infos</name> <operator>=</operator> <call><name>get_op_btree_interpretation</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>clause_op_infos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pred_op_infos</name> <operator>=</operator> <call><name>get_op_btree_interpretation</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* no point in looking */</comment>
		<expr_stmt><expr><name>pred_op_infos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lcp</argument>, <argument>pred_op_infos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>pred_op_info</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily_id</name> <init>= <expr><name><name>pred_op_info</name><operator>-&gt;</operator><name>opfamily_id</name></name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lcc</argument>, <argument>clause_op_infos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>clause_op_info</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>pred_strategy</name></decl>,
						<decl><type ref="prev"/><name>clause_strategy</name></decl>,
						<decl><type ref="prev"/><name>test_strategy</name></decl>;</decl_stmt>

			<comment type="block">/* Must find them in same opfamily */</comment>
			<if_stmt><if>if <condition>(<expr><name>opfamily_id</name> <operator>!=</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>opfamily_id</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Lefttypes should match */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>clause_op_info</name><operator>-&gt;</operator><name>oplefttype</name></name> <operator>==</operator> <name><name>pred_op_info</name><operator>-&gt;</operator><name>oplefttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pred_strategy</name> <operator>=</operator> <name><name>pred_op_info</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clause_strategy</name> <operator>=</operator> <name><name>clause_op_info</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check to see if we can make a proof for same-subexpressions
			 * cases based on the operators' relationship in this opfamily.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>refute_it</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>same_subexprs</name> <operator>|=</operator> <name><name>BT_refutes_table</name><index>[<expr><name>clause_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>pred_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>same_subexprs</name> <operator>|=</operator> <name><name>BT_implies_table</name><index>[<expr><name>clause_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>pred_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Look up the "test" strategy number in the implication table
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>refute_it</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>test_strategy</name> <operator>=</operator> <name><name>BT_refute_table</name><index>[<expr><name>clause_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>pred_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>test_strategy</name> <operator>=</operator> <name><name>BT_implic_table</name><index>[<expr><name>clause_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><name>pred_strategy</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>test_strategy</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Can't determine implication using this interpretation */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * See if opfamily has an operator for the test strategy and the
			 * datatypes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>test_strategy</name> <operator>==</operator> <name>BTNE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>test_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily_id</name></expr></argument>,
											  <argument><expr><name><name>pred_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr></argument>,
											  <argument><expr><name><name>clause_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr></argument>,
											  <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>test_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>test_op</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>test_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>test_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily_id</name></expr></argument>,
											  <argument><expr><name><name>pred_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr></argument>,
											  <argument><expr><name><name>clause_op_info</name><operator>-&gt;</operator><name>oprighttype</name></name></expr></argument>,
											  <argument><expr><name>test_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>test_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Last check: test_op must be immutable.
			 *
			 * Note that we require only the test_op to be immutable, not the
			 * original clause_op.  (pred_op is assumed to have been checked
			 * immutable by the caller.)  Essentially we are assuming that the
			 * opfamily is consistent even if it contains operators that are
			 * merely stable.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>op_volatile</name><argument_list>(<argument><expr><name>test_op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>pred_op_infos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>clause_op_infos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* couldn't find a suitable comparison operator */</comment>
		<expr_stmt><expr><name>test_op</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we think we were able to prove something about same-subexpressions
	 * cases, check to make sure the clause_op is immutable before believing
	 * it completely.  (Usually, the clause_op would be immutable if the
	 * pred_op is, but it's not entirely clear that this must be true in all
	 * cases, so let's check.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>same_subexprs</name> <operator>&amp;&amp;</operator>
		<call><name>op_volatile</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>same_subexprs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Cache the results, whether positive or negative */</comment>
	<if_stmt><if>if <condition>(<expr><name>refute_it</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>refute_test_op</name></name> <operator>=</operator> <name>test_op</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>same_subexprs_refutes</name></name> <operator>=</operator> <name>same_subexprs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>have_refute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>implic_test_op</name></name> <operator>=</operator> <name>test_op</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>same_subexprs_implies</name></name> <operator>=</operator> <name>same_subexprs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache_entry</name><operator>-&gt;</operator><name>have_implic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>cache_entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * operator_same_subexprs_lookup
 *	  Convenience subroutine to look up the cached answer for
 *	  same-subexpressions cases.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>operator_same_subexprs_lookup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OprProofCacheEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cache_entry</name> <operator>=</operator> <call><name>lookup_proof_cache</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name>refute_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>refute_it</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>same_subexprs_refutes</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>same_subexprs_implies</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_btree_test_op
 *	  Identify the comparison operator needed for a btree-operator
 *	  proof or refutation involving comparison of constants.
 *
 * Given the truth of a clause "var clause_op const1", we are attempting to
 * prove or refute a predicate "var pred_op const2".  The identities of the
 * two operators are sufficient to determine the operator (if any) to compare
 * const2 to const1 with.
 *
 * Returns the OID of the operator to use, or InvalidOid if no proof is
 * possible.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_btree_test_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pred_op</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>refute_it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OprProofCacheEntry</name> <modifier>*</modifier></type><name>cache_entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cache_entry</name> <operator>=</operator> <call><name>lookup_proof_cache</name><argument_list>(<argument><expr><name>pred_op</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name>refute_it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>refute_it</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>refute_test_op</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>cache_entry</name><operator>-&gt;</operator><name>implic_test_op</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Callback for pg_amop inval events
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateOprProofCacheCallBack</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OprProofCacheEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>OprProofCacheHash</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Currently we just reset all entries; hard to be smarter ... */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>OprProofCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>hentry</name> <operator>=</operator> <operator>(</operator><name>OprProofCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>have_implic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>have_refute</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
</unit>
