<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/util/plancat.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * plancat.c
 *	   routines for accessing the system catalogs
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/plancat.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>

<comment type="block">/* GUC parameter */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>constraint_exclusion</name> <init>= <expr><name>CONSTRAINT_EXCLUSION_PARTITION</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control in get_relation_info() */</comment>
<decl_stmt><decl><type><name>get_relation_info_hook_type</name></type> <name>get_relation_info_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_relation_foreign_keys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>infer_collation_opclass_match</name><parameter_list>(<parameter><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>idxExprs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>get_rel_data_width</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_relation_constraints</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>include_noinherit</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>include_notnull</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>include_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>build_index_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_relation_statistics</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_relation_partition_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionScheme</name></type> <name>find_partition_scheme</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_baserel_partition_key_exprs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * get_relation_info -
 *	  Retrieves catalog information for a given relation.
 *
 * Given the Oid of the relation, return the following info into fields
 * of the RelOptInfo struct:
 *
 *	min_attr	lowest valid AttrNumber
 *	max_attr	highest valid AttrNumber
 *	indexlist	list of IndexOptInfos for relation's indexes
 *	statlist	list of StatisticExtInfo for relation's statistic objects
 *	serverid	if it's a foreign table, the server OID
 *	fdwroutine	if it's a foreign table, the FDW function pointers
 *	pages		number of pages
 *	tuples		number of tuples
 *	rel_parallel_workers user-defined number of parallel workers
 *
 * Also, add information about the relation's foreign keys to root-&gt;fkey_list.
 *
 * Also, initialize the attr_needed[] and attr_widths[] arrays.  In most
 * cases these are left as zeroes, but sometimes we need to compute attr
 * widths here, and we may as well cache the results for costsize.c.
 *
 * If inhparent is true, all we need to do is set up the attr arrays:
 * the RelOptInfo actually represents the appendrel formed by an inheritance
 * tree, and so the parent rel's physical size and index information isn't
 * important for it.
 */</comment>
<function><type><name>void</name></type>
<name>get_relation_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>,
				  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need not lock the relation since it was already locked, either by
	 * the rewriter or when expand_inherited_rtentry() added it to the query's
	 * rangetable.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Temporary and unlogged relations are inaccessible during recovery. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary or unlogged relations during recovery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <call><name>RelationGetForm</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltablespace</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name></name> <operator>=</operator> <operator>(</operator><name>Relids</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relids</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate relation size --- unless it's an inheritance parent, in which
	 * case the size will be computed later in set_append_rel_pathlist, and we
	 * must leave it zero for now to avoid bollixing the total_table_pages
	 * calculation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inhparent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>estimate_rel_size</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_widths</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>allvisfrac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Retrieve the parallel_workers reloption, or -1 if not set. */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name> <operator>=</operator> <call><name>RelationGetParallelWorkers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make list of indexes.  Ignore indexes on system catalogs if told to.
	 * Don't bother with indexes for an inheritance parent, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inhparent</name> <operator>||</operator>
		<operator>(</operator><name>IgnoreSystemIndexes</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hasindex</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>hasindex</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lmode</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For each index, we get the same type of lock that the executor will
		 * need, and do not release it.  This saves a couple of trips to the
		 * shared lock manager while not creating any real loss of
		 * concurrency, because no schema changes could be happening on the
		 * index while we hold lock on the parent rel, and neither lock type
		 * blocks any other kind of index operation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRelation</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>,
						<decl><type ref="prev"/><name>nkeycolumns</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Extract info from the relation descriptor for the index.
			 */</comment>
			<expr_stmt><expr><name>indexRelation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>lmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Ignore invalid indexes, since they can't safely be used for
			 * queries.  Note that this is OK because the data structure we
			 * are constructing is only used by the planner --- the executor
			 * still needs to insert into "invalid" indexes, if they're marked
			 * IndexIsReady.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Ignore partitioned indexes, since they are not usable for
			 * queries.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the index is valid, but cannot yet be used, ignore it; but
			 * mark the plan we are generating as transient. See
			 * src/backend/access/heap/README.HOT for discussion.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>TransactionXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indexoid</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator>
				<call><name>RelationGetForm</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltablespace</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>=</operator> <name>nkeycolumns</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indexkeys</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indexcollations</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>opfamily</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>canreturn</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>canreturn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>index_can_return</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>

			<comment type="block">/* We copy just the fields we need, not all of rd_amroutine */</comment>
			<expr_stmt><expr><name>amroutine</name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanparallel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amhasgettuple</name></name> <operator>=</operator> <operator>(</operator><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amhasgetbitmap</name></name> <operator>=</operator> <operator>(</operator><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fetch the ordering information for the index, if any.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If it's a btree index, we can use its opfamily OIDs
				 * directly as the sort ordering opfamily OIDs.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>opfamily</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int16</name></type>		<name>opt</name> <init>= <expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Otherwise, identify the corresponding btree opfamilies by
				 * trying to map this index's "&lt;" operators into btree.  Since
				 * "&lt;" uniquely defines the behavior of a sort order, this is
				 * a sufficient test.
				 *
				 * XXX This method is rather slow and also requires the
				 * undesirable assumption that the other index AM numbers its
				 * strategies the same as btree.  It'd be better to have a way
				 * to explicitly declare the corresponding btree opfamily for
				 * each opfamily of the other index type.  But given the lack
				 * of current or foreseeable amcanorder index types, it's not
				 * worth expending more effort on now.
				 */</comment>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeycolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeycolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int16</name></type>		<name>opt</name> <init>= <expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>ltopr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>btopfamily</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>btopcintype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int16</name></type>		<name>btstrategy</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nulls_first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name>ltopr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												<argument><expr><name><name>info</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												<argument><expr><name><name>info</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												<argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>btopfamily</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>btopcintype</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>btstrategy</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<name>btopcintype</name> <operator>==</operator> <name><name>info</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name>btstrategy</name> <operator>==</operator> <name>BTLessStrategyNumber</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Successful mapping */</comment>
						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>btopfamily</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Fail ... quietly treat index as unordered */</comment>
						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>sortopfamily</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reverse_sort</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Fetch the index expressions and predicate, if any.  We must
			 * modify the copies we obtain from the relcache to have the
			 * correct varno for the parent relation, so that they match up
			 * correctly against qual clauses.
			 */</comment>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>=</operator> <call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indpred</name></name> <operator>=</operator> <call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>indexprs</name></name> <operator>&amp;&amp;</operator> <name>varno</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>indpred</name></name> <operator>&amp;&amp;</operator> <name>varno</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>indpred</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Build targetlist using the completed indexprs data */</comment>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indextlist</name></name> <operator>=</operator> <call><name>build_index_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>indrestrictinfo</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>	<comment type="block">/* set later, in indxpath.c */</comment>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>predOK</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* set later, in indxpath.c */</comment>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>immediate</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>hypothetical</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Estimate the index size.  If it's not a partial index, we lock
			 * the number-of-tuples estimate to equal the parent table; if it
			 * is partial then we have to use the same methods as we would for
			 * a table, except we can be sure that the index is not larger
			 * than the table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * POLAR: Getting file status from shared storage is costly
				 * try to use statistical values
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_use_statistical_relpages</name> <operator>&amp;&amp;</operator>
					<name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>BlockNumber</name></type> <name>tmp_pages</name> <init>= <expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><name>tmp_pages</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>-&gt;</operator><name>pages</name></name> <operator>&amp;&amp;</operator>
							<operator>(</operator><name>tmp_pages</name><operator>/</operator><literal type="number">2</literal> <operator>&gt;</operator> <name><name>info</name><operator>-&gt;</operator><name>pages</name></name> <operator>||</operator>
							<name><name>info</name><operator>-&gt;</operator><name>pages</name></name><operator>/</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>tmp_pages</name><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"relation %s difference between the statistical value %u and the real pages %u is too large"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><name>tmp_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* it has storage, ok to call the smgr */</comment>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>double</name></type>		<name>allvisfrac</name></decl>;</decl_stmt> <comment type="block">/* dummy */</comment>

				<expr_stmt><expr><call><name>estimate_rel_size</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allvisfrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* For btrees, get tree height while we have the index open */</comment>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <call><name>_bt_getrootheight</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* For other index types, just set it to "unknown" for now */</comment>
				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>indexinfos</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>indexinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>=</operator> <name>indexinfos</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name> <operator>=</operator> <call><name>get_relation_statistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Grab foreign-table info using the relcache, while we have it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <call><name>GetForeignServerIdByRelId</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Collect info about relation's foreign keys, if relevant */</comment>
	<expr_stmt><expr><call><name>get_relation_foreign_keys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>inhparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect info about relation's partitioning scheme, if any. Only
	 * inheritance parents may be partitioned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inhparent</name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_relation_partition_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow a plugin to editorialize on the info we obtained from the
	 * catalogs.  Actions might include altering the assumed relation size,
	 * removing an index, or adding a hypothetical index to the indexlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>get_relation_info_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>get_relation_info_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_foreign_keys -
 *	  Retrieves foreign key information for a given relation.
 *
 * ForeignKeyOptInfos for relevant foreign keys are created and added to
 * root-&gt;fkey_list.  We do this now while we have the relcache entry open.
 * We could sometimes avoid making useless ForeignKeyOptInfos if we waited
 * until all RelOptInfos have been built, but the cost of re-opening the
 * relcache entries would probably exceed any savings.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_relation_foreign_keys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cachedfkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's not a baserel, we don't care about its FKs.  Also, if the query
	 * references only a single relation, we can skip the lookup since no FKs
	 * could satisfy the requirements below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's the parent of an inheritance tree, ignore its FKs.  We could
	 * make useful FK-based deductions if we found that all members of the
	 * inheritance tree have equivalent FK constraints, but detecting that
	 * would require code that hasn't been written.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inhparent</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract data about relation's FKs from the relcache.  Note that this
	 * list belongs to the relcache and might disappear in a cache flush, so
	 * we must not do any further catalog access within this function.
	 */</comment>
	<expr_stmt><expr><name>cachedfkeys</name> <operator>=</operator> <call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out which FKs are of interest for this query, and create
	 * ForeignKeyOptInfos for them.  We want only FKs that reference some
	 * other RTE of the current query.  In queries containing self-joins,
	 * there might be more than one other RTE for a referenced table, and we
	 * should make a ForeignKeyOptInfo for each occurrence.
	 *
	 * Ideally, we would ignore RTEs that correspond to non-baserels, but it's
	 * too hard to identify those here, so we might end up making some useless
	 * ForeignKeyOptInfos.  If so, match_foreign_keys_to_quals() will remove
	 * them again.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cachedfkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>cachedfk</name> <init>= <expr><operator>(</operator><name>ForeignKeyCacheInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* conrelid should always be that of the table we're considering */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cachedfk</name><operator>-&gt;</operator><name>conrelid</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Scan to find other RTEs matching confrelid */</comment>
		<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ForeignKeyOptInfo</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* Ignore if not the correct table */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>cachedfk</name><operator>-&gt;</operator><name>confrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Ignore if it's an inheritance parent; doesn't really match */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Ignore self-referential FKs; we only care about joins */</comment>
			<if_stmt><if>if <condition>(<expr><name>rti</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* OK, let's make an entry */</comment>
			<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignKeyOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>con_relid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>ref_relid</name></name> <operator>=</operator> <name>rti</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>cachedfk</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>conkey</name></name></expr></argument>, <argument><expr><name><name>cachedfk</name><operator>-&gt;</operator><name>conkey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>conkey</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>confkey</name></name></expr></argument>, <argument><expr><name><name>cachedfk</name><operator>-&gt;</operator><name>confkey</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>confkey</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>conpfeqop</name></name></expr></argument>, <argument><expr><name><name>cachedfk</name><operator>-&gt;</operator><name>conpfeqop</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>conpfeqop</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* zero out fields to be filled by match_foreign_keys_to_quals */</comment>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nmatched_ec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nmatched_rcols</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>nmatched_ri</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>eclass</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>eclass</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>rinfos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>rinfos</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>fkey_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>fkey_list</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * infer_arbiter_indexes -
 *	  Determine the unique indexes used to arbitrate speculative insertion.
 *
 * Uses user-supplied inference clause expressions and predicate to match a
 * unique index from those defined and ready on the heap relation (target).
 * An exact match is required on columns/expressions (although they can appear
 * in any order).  However, the predicate given by the user need only restrict
 * insertion to a subset of some part of the table covered by some particular
 * unique index (in particular, a partial unique index) in order to be
 * inferred.
 *
 * The implementation does not consider which B-Tree operator class any
 * particular available unique index attribute uses, unless one was specified
 * in the inference specification. The same is true of collations.  In
 * particular, there is no system dependency on the default operator class for
 * the purposes of inference.  If no opclass (or collation) is specified, then
 * all matching indexes (that may or may not match the default in terms of
 * each attribute opclass/collation) are used for inference.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>infer_arbiter_indexes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Iteration state */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relationObjectId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOidFromConstraint</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Normalized inference attributes and inference expressions: */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>inferAttrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inferElems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Results */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>results</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Quickly return NIL for ON CONFLICT DO NOTHING without an inference
	 * specification or named constraint.  ON CONFLICT DO UPDATE statements
	 * must always provide one or the other (but parser ought to have caught
	 * that already).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onconflict</name><operator>-&gt;</operator><name>arbiterElems</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<name><name>onconflict</name><operator>-&gt;</operator><name>constraint</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need not lock the relation since it was already locked, either by
	 * the rewriter or when expand_inherited_rtentry() added it to the query's
	 * rangetable.
	 */</comment>
	<expr_stmt><expr><name>relationObjectId</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
								<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build normalized/BMS representation of plain indexed attributes, as
	 * well as a separate list of expression items.  This simplifies matching
	 * the cataloged definition of indexes.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>onconflict-&gt;arbiterElems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If not a plain Var, just shove it in inferElems for now */</comment>
			<expr_stmt><expr><name>inferElems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inferElems</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"whole row unique index inference specifications are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>inferAttrs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>inferAttrs</name></expr></argument>,
									<argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Lookup named constraint's index.  This is not immediately returned
	 * because some additional sanity checks are required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onconflict</name><operator>-&gt;</operator><name>constraint</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexOidFromConstraint</name> <operator>=</operator> <call><name>get_constraint_index</name><argument_list>(<argument><expr><name><name>onconflict</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexOidFromConstraint</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint in ON CONFLICT clause has no associated index"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Using that representation, iterate through the list of indexes on the
	 * target relation to try and find a match
	 */</comment>
	<expr_stmt><expr><name>indexList</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>idxForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>indexedAttrs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxExprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>predExprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>natt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>el</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Extract info from the relation descriptor for the index.  We know
		 * that this is a target, so get lock type it is known will ultimately
		 * be required by the executor.
		 *
		 * Let executor complain about !indimmediate case directly, because
		 * enforcement needs to occur there anyway when an inference clause is
		 * omitted.
		 */</comment>
		<expr_stmt><expr><name>idxRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idxForm</name> <operator>=</operator> <name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>idxForm</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note that we do not perform a check against indcheckxmin (like e.g.
		 * get_relation_info()) here to eliminate candidates, because
		 * uniqueness checking only cares about the most recently committed
		 * tuple versions.
		 */</comment>

		<comment type="block">/*
		 * Look for match on "ON constraint_name" variant, which may not be
		 * unique constraint.  This can only be a constraint name.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>indexOidFromConstraint</name> <operator>==</operator> <name><name>idxForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>idxForm</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON CONFLICT DO UPDATE not supported with exclusion constraints"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name><name>idxForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>results</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>indexOidFromConstraint</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No point in further work for index in named constraint case */</comment>
			<goto>goto <name>next</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Only considering conventional inference at this point (not named
		 * constraints), so index under consideration can be immediately
		 * skipped if it's not unique
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>idxForm</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Build BMS representation of plain (non expression) index attrs */</comment>
		<expr_stmt><expr><name>indexedAttrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>idxForm</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>indexedAttrs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>indexedAttrs</name></expr></argument>,
											  <argument><expr><name>attno</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Non-expression attributes (if any) must match */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name>indexedAttrs</name></expr></argument>, <argument><expr><name>inferAttrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Expression attributes (if any) must match */</comment>
		<expr_stmt><expr><name>idxExprs</name> <operator>=</operator> <call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>el</argument>, <argument>onconflict-&gt;arbiterElems</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ensure that collation/opclass aspects of inference expression
			 * element match.  Even though this loop is primarily concerned
			 * with matching expressions, it is a convenient point to check
			 * this for both expressions and ordinary (non-expression)
			 * attributes appearing as inference elements.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>infer_collation_opclass_match</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>idxExprs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Plain Vars don't factor into count of expression elements, and
			 * the question of whether or not they satisfy the index
			 * definition has already been considered (they must).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Might as well avoid redundant check in the rare cases where
			 * infer_collation_opclass_match() is required to do real work.
			 * Otherwise, check that element expression appears in cataloged
			 * index definition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>infercollid</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>||</operator>
				<name><name>elem</name><operator>-&gt;</operator><name>inferopclass</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>||</operator>
				<call><name>list_member</name><argument_list>(<argument><expr><name>idxExprs</name></expr></argument>, <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<goto>goto <name>next</name>;</goto>
		</block_content>}</block>

		<comment type="block">/*
		 * Now that all inference elements were matched, ensure that the
		 * expression elements from inference clause are not missing any
		 * cataloged expressions.  This does the right thing when unique
		 * indexes redundantly repeat the same attribute, or if attributes
		 * redundantly appear multiple times within an inference clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_difference</name><argument_list>(<argument><expr><name>idxExprs</name></expr></argument>, <argument><expr><name>inferElems</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a partial index, its predicate must be implied by the ON
		 * CONFLICT's WHERE clause.
		 */</comment>
		<expr_stmt><expr><name>predExprs</name> <operator>=</operator> <call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by</name><argument_list>(<argument><expr><name>predExprs</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name><name>idxForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>next</name>:</label>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>results</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no unique or exclusion constraint matching the ON CONFLICT specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>results</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * infer_collation_opclass_match - ensure infer element opclass/collation match
 *
 * Given unique index inference element from inference specification, if
 * collation was specified, or if opclass was specified, verify that there is
 * at least one matching indexed attribute (occasionally, there may be more).
 * Skip this in the common case where inference specification does not include
 * collation or opclass (instead matching everything, regardless of cataloged
 * collation/opclass of indexed attribute).
 *
 * At least historically, Postgres has not offered collations or opclasses
 * with alternative-to-default notions of equality, so these additional
 * criteria should only be required infrequently.
 *
 * Don't give up immediately when an inference element matches some attribute
 * cataloged as indexed but not matching additional opclass/collation
 * criteria.  This is done so that the implementation is as forgiving as
 * possible of redundancy within cataloged index attributes (or, less
 * usefully, within inference specification elements).  If collations actually
 * differ between apparently redundantly indexed attributes (redundant within
 * or across indexes), then there really is no redundancy as such.
 *
 * Note that if an inference element specifies an opclass and a collation at
 * once, both must match in at least one particular attribute within index
 * catalog definition in order for that inference element to be considered
 * inferred/satisfied.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>infer_collation_opclass_match</name><parameter_list>(<parameter><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>idxExprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>natt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inferopfamily</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt> <comment type="block">/* OID of opclass opfamily */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inferopcinputtype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt> <comment type="block">/* OID of opclass input type */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nplain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* # plain attrs observed */</comment>

	<comment type="block">/*
	 * If inference specification element lacks collation/opclass, then no
	 * need to check for exact match.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>infercollid</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>elem</name><operator>-&gt;</operator><name>inferopclass</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lookup opfamily and input type, for matching indexes
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>inferopclass</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>inferopfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inferopcinputtype</name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;=</operator> <name><name>idxRel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>natt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opcinputtype</name> <init>= <expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>natt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>natt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>natt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nplain</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>inferopclass</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>inferopfamily</name> <operator>!=</operator> <name>opfamily</name> <operator>||</operator> <name>inferopcinputtype</name> <operator>!=</operator> <name>opcinputtype</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Attribute needed to match opclass, but didn't */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>infercollid</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<name><name>elem</name><operator>-&gt;</operator><name>infercollid</name></name> <operator>!=</operator> <name>collation</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Attribute needed to match collation, but didn't */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If one matching index att found, good enough -- return true */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>elem</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>attno</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>nattExpr</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>idxExprs</name></expr></argument>, <argument><expr><operator>(</operator><name>natt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>nplain</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Note that unlike routines like match_index_to_operand() we
			 * don't need to care about RelabelType.  Neither the index
			 * definition nor the inference clause should contain them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>nattExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_rel_size - estimate # pages and # tuples in a table or index
 *
 * We also estimate the fraction of the pages that are marked all-visible in
 * the visibility map, for use in estimation of index-only scans.
 *
 * If attr_widths isn't NULL, it points to the zero-index entry of the
 * relation's attr_widths[] cache; we fill this in if we have need to compute
 * the attribute widths for estimation purposes.
 */</comment>
<function><type><name>void</name></type>
<name>estimate_rel_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>,
				  <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>allvisfrac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>curpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>density</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>

			<comment type="block">/*
			 * POLAR: Getting file status from shared storage is costly
			 * try to use statistical values.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>polar_use_statistical_relpages</name> <operator>&amp;&amp;</operator>
				<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>curpages</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>polar_enable_debug</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>BlockNumber</name></type> <name>tmp_pages</name> <init>= <expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>tmp_pages</name> <operator>&amp;&amp;</operator> <name>curpages</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><name>tmp_pages</name><operator>/</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>curpages</name> <operator>||</operator>
						<name>curpages</name><operator>/</operator><literal type="number">2</literal> <operator>&gt;</operator> <name>tmp_pages</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"relation %s difference between the statistical value %u and the real pages %u is too large"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>curpages</name></expr></argument>, <argument><expr><name>tmp_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* it has storage, ok to call the smgr */</comment>
				<expr_stmt><expr><name>curpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * HACK: if the relation has never yet been vacuumed, use a
			 * minimum size estimate of 10 pages.  The idea here is to avoid
			 * assuming a newly-created table is really small, even if it
			 * currently is, because that may not be true once some data gets
			 * loaded into it.  Once a vacuum or analyze cycle has been done
			 * on it, it's more reasonable to believe the size is somewhat
			 * stable.
			 *
			 * (Note that this is only an issue if the plan gets cached and
			 * used again after the table has been filled.  What we're trying
			 * to avoid is using a nestloop-type plan on a table that has
			 * grown substantially since the plan was made.  Normally,
			 * autovacuum/autoanalyze will occur once enough inserts have
			 * happened and cause cached-plan invalidation; but that doesn't
			 * happen instantaneously, and it won't happen at all for cases
			 * such as temporary tables.)
			 *
			 * We approximate "never vacuumed" by "has relpages = 0", which
			 * means this will also fire on genuinely empty relations.  Not
			 * great, but fortunately that's a seldom-seen case in the real
			 * world, and it shouldn't degrade the quality of the plan too
			 * much anyway to err in this direction.
			 *
			 * There are two exceptions wherein we don't apply this heuristic.
			 * One is if the table has inheritance children.  Totally empty
			 * parent tables are quite common, so we should be willing to
			 * believe that they are empty.  Also, we don't apply the 10-page
			 * minimum to indexes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>curpages</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
				<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>&amp;&amp;</operator>
				<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>curpages</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* report estimated # pages */</comment>
			<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <name>curpages</name></expr>;</expr_stmt>
			<comment type="block">/* quick exit if rel is clearly empty */</comment>
			<if_stmt><if>if <condition>(<expr><name>curpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* coerce values in pg_class to more desirable types */</comment>
			<expr_stmt><expr><name>relpages</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>relallvisible</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If it's an index, discount the metapage while estimating the
			 * number of tuples.  This is a kluge because it assumes more than
			 * it ought to about index structure.  Currently it's OK for
			 * btree, hash, and GIN indexes but suspect for GiST indexes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
				<name>relpages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>curpages</name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>relpages</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* estimate number of tuples from previous tuple density */</comment>
			<if_stmt><if>if <condition>(<expr><name>relpages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>density</name> <operator>=</operator> <name>reltuples</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * When we have no data because the relation was truncated,
				 * estimate tuple width from attribute datatypes.  We assume
				 * here that the pages are completely full, which is OK for
				 * tables (since they've presumably not been VACUUMed yet) but
				 * is probably an overestimate for indexes.  Fortunately
				 * get_relation_info() can clamp the overestimate to the
				 * parent table's size.
				 *
				 * Note: this code intentionally disregards alignment
				 * considerations, because (a) that would be gilding the lily
				 * considering how crude the estimate is, and (b) it creates
				 * platform dependencies in the default plans which are kind
				 * of a headache for regression testing.
				 */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_width</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tuple_width</name> <operator>=</operator> <call><name>get_rel_data_width</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attr_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<comment type="block">/* note: integer division is intentional here */</comment>
				<expr_stmt><expr><name>density</name> <operator>=</operator> <operator>(</operator><name>BLCKSZ</name> <operator>-</operator> <name>SizeOfPageHeaderData</name><operator>)</operator> <operator>/</operator> <name>tuple_width</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>density</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>curpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We use relallvisible as-is, rather than scaling it up like we
			 * do for the pages and tuples counts, on the theory that any
			 * pages added since the last VACUUM are most likely not marked
			 * all-visible.  But costsize.c wants it converted to a fraction.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>relallvisible</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>curpages</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>double</name><operator>)</operator> <name>relallvisible</name> <operator>&gt;=</operator> <name>curpages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relallvisible</name> <operator>/</operator> <name>curpages</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<comment type="block">/* Sequences always have a known size */</comment>
			<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<comment type="block">/* Just use whatever's in pg_class */</comment>
			<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* else it has no disk storage; probably shouldn't get here? */</comment>
			<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * get_rel_data_width
 *
 * Estimate the average width of (the data part of) the relation's tuples.
 *
 * If attr_widths isn't NULL, it points to the zero-index entry of the
 * relation's attr_widths[] cache; use and update that cache as appropriate.
 *
 * Currently we ignore dropped columns.  Ideally those should be included
 * in the result, but we haven't got any way to get info about them; and
 * since they might be mostly NULLs, treating them as zero-width is not
 * necessarily the wrong thing anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>get_rel_data_width</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>item_width</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* use previously cached data, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>attr_widths</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>attr_widths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name><name>attr_widths</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* This should match set_rel_width() in costsize.c */</comment>
		<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_attavgwidth</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>item_width</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>item_width</name> <operator>=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attr_widths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attr_widths</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>item_width</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <name>item_width</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>tuple_width</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_data_width
 *
 * External API for get_rel_data_width: same behavior except we have to
 * open the relcache entry.
 */</comment>
<function><type><name>int32</name></type>
<name>get_relation_data_width</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

	<comment type="block">/* As above, assume relation is already locked */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_rel_data_width</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>attr_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_relation_constraints
 *
 * Retrieve the applicable constraint expressions of the given relation.
 *
 * Returns a List (possibly empty) of constraint expressions.  Each one
 * has been canonicalized, and its Vars are changed to have the varno
 * indicated by rel-&gt;relid.  This allows the expressions to be easily
 * compared to expressions taken from WHERE.
 *
 * If include_noinherit is true, it's okay to include constraints that
 * are marked NO INHERIT.
 *
 * If include_notnull is true, "col IS NOT NULL" expressions are generated
 * and added to the result for each column that's marked attnotnull.
 *
 * If include_partition is true, and the relation is a partition,
 * also include the partitioning constraints.
 *
 * Note: at present this is invoked at most once per relation per planner
 * run, and in many cases it won't be invoked at all, so there seems no
 * point in caching the data in RelOptInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_relation_constraints</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>include_noinherit</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>include_notnull</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>include_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We assume the relation has already been safely locked.
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_check</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_check</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this constraint hasn't been fully validated yet, we must
			 * ignore it here.  Also ignore if NO INHERIT and we weren't told
			 * that that's safe.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>include_noinherit</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Run each expression through const-simplification and
			 * canonicalization.  This is not just an optimization, but is
			 * necessary, because we will be comparing it to
			 * similarly-processed qual clauses, and may fail to detect valid
			 * matches without this.  This must match the processing done to
			 * qual clauses in preprocess_expression()!  (We can skip the
			 * stuff involving subqueries, however, since we don't allow any
			 * in check constraints.)
			 */</comment>
			<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fix Vars to have the desired varno */</comment>
			<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Finally, convert to implicit-AND format (that is, a List) and
			 * append the resulting item(s) to our output list.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
								 <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Add NOT NULL constraints in expression form, if requested */</comment>
		<if_stmt><if>if <condition>(<expr><name>include_notnull</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
												  <argument><expr><name>i</name></expr></argument>,
												  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
												  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
												  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * argisrow=false is correct even for a composite column,
					 * because attnotnull does not represent a SQL-spec IS NOT
					 * NULL test in such a case, just IS DISTINCT FROM NULL.
					 */</comment>
					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add partitioning constraints, if requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>include_partition</name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pcqual</name> <init>= <expr><call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pcqual</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Run the partition quals through const-simplification similar to
			 * check constraints.  We skip canonicalize_qual, though, because
			 * partition quals should be in canonical form already; also,
			 * since the qual is in implicit-AND format, we'd have to
			 * explicitly convert it to explicit-AND format and back again.
			 */</comment>
			<expr_stmt><expr><name>pcqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pcqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fix Vars to have the desired varno */</comment>
			<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pcqual</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pcqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_statistics
 *		Retrieve extended statistics defined on the table.
 *
 * Returns a List (possibly empty) of StatisticExtInfo objects describing
 * the statistics.  Note that this doesn't load the actual statistics data,
 * just the identifying metadata.  Only stats actually built are considered.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_relation_statistics</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>statoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stainfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>statoidlist</name> <operator>=</operator> <call><name>RelationGetStatExtList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>statoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>statOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>staForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>keys</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>statOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>statOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>staForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * First, build the array of columns covered.  This is ultimately
		 * wasted if no stats within the object have actually been built, but
		 * it doesn't seem worth troubling over that case.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>staForm</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name><name>staForm</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* add one StatisticExtInfo for each kind built */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>statext_is_kind_built</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>STATS_EXT_NDISTINCT</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>StatisticExtInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>statOid</name></name> <operator>=</operator> <name>statOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>STATS_EXT_NDISTINCT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>stainfos</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>stainfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>statext_is_kind_built</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>StatisticExtInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>statOid</name></name> <operator>=</operator> <name>statOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>STATS_EXT_DEPENDENCIES</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>stainfos</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>stainfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>statoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stainfos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * relation_excluded_by_constraints
 *
 * Detect whether the relation need not be scanned because it has either
 * self-inconsistent restrictions, or restrictions inconsistent with the
 * relation's applicable constraints.
 *
 * Note: this examines only rel-&gt;relid, rel-&gt;reloptkind, and
 * rel-&gt;baserestrictinfo; therefore it can be called before filling in
 * other fields of the RelOptInfo.
 */</comment>
<function><type><name>bool</name></type>
<name>relation_excluded_by_constraints</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>include_noinherit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>include_notnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>include_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>safe_restrictions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraint_pred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>safe_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* As of now, constraint exclusion works only with simple relations. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no base restriction clauses, we have no hope of proving
	 * anything below, so fall out quickly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Regardless of the setting of constraint_exclusion, detect
	 * constant-FALSE-or-NULL restriction clauses.  Because const-folding will
	 * reduce "anything AND FALSE" to just "FALSE", any such case should
	 * result in exactly one baserestrictinfo entry.  This doesn't fire very
	 * often, but it seems cheap enough to be worth doing anyway.  (Without
	 * this, we'd miss some optimizations that 9.5 and earlier found via much
	 * more roundabout methods.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>clause</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name> <operator>||</operator>
			 <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Partition pruning will not have been applied to an inherited target
	 * relation, so if enable_partition_pruning is true, force consideration
	 * of the rel's partition constraints.  (Thus constraint_exclusion will be
	 * effectively forced 'on' for this case.  This is done better in v12.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_partition_pruning</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
		<name><name>root</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>!=</operator> <name>INHKIND_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>include_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Skip further tests, depending on constraint_exclusion.
	 */</comment>
	<switch>switch <condition>(<expr><name>constraint_exclusion</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>:</case>

			<comment type="block">/*
			 * In 'off' mode, never make any further tests, except if forcing
			 * include_partition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>include_partition</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>CONSTRAINT_EXCLUSION_PARTITION</name></expr>:</case>

			<comment type="block">/*
			 * When constraint_exclusion is set to 'partition' we only handle
			 * appendrel members.  Normally, they are RELOPT_OTHER_MEMBER_REL
			 * relations, but we also consider inherited target relations as
			 * appendrel members for the purposes of constraint exclusion.
			 *
			 * In the former case, partition pruning was already applied, so
			 * there is no need to consider the rel's partition constraints
			 * here.  In the latter case, we already set include_partition
			 * properly (i.e., do it if enable_partition_pruning).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name> <operator>||</operator>
				<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
				 <name><name>root</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>!=</operator> <name>INHKIND_NONE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* appendrel member, so process it */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>:</case>

			<comment type="block">/*
			 * In 'on' mode, always apply constraint exclusion.  If we are
			 * considering a baserel that is a partition (i.e., it was
			 * directly named rather than expanded from a parent table), then
			 * its partition constraints haven't been considered yet, so
			 * include them in the processing here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>include_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>				<comment type="block">/* always try to exclude */</comment>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Check for self-contradictory restriction clauses.  We dare not make
	 * deductions with non-immutable functions, but any immutable clauses that
	 * are self-contradictory allow us to conclude the scan is unnecessary.
	 *
	 * Note: strip off RestrictInfo because predicate_refuted_by() isn't
	 * expecting to see any in its predicate argument.
	 */</comment>
	<expr_stmt><expr><name>safe_restrictions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>safe_restrictions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>safe_restrictions</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We can use weak refutation here, since we're comparing restriction
	 * clauses with restriction clauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by</name><argument_list>(<argument><expr><name>safe_restrictions</name></expr></argument>, <argument><expr><name>safe_restrictions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Only plain relations have constraints, so stop here for other rtekinds.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In a partitioning hierarchy, but not with regular table inheritance,
	 * it's OK to assume that any constraints that hold for the parent also
	 * hold for every child; for instance, table inheritance allows the parent
	 * to have constraints marked NO INHERIT, but table partitioning does not.
	 * We choose to check whether the partitioning parents can be excluded
	 * here; doing so consumes some cycles, but potentially saves us the work
	 * of excluding each child individually.
	 *
	 * This is unnecessarily stupid, but making it smarter seems out of scope
	 * for v11.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Given the above restriction, we can always include NO INHERIT and NOT
	 * NULL constraints.
	 */</comment>
	<expr_stmt><expr><name>include_noinherit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>include_notnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the appropriate set of constraint expressions.
	 */</comment>
	<expr_stmt><expr><name>constraint_pred</name> <operator>=</operator> <call><name>get_relation_constraints</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
											   <argument><expr><name>include_noinherit</name></expr></argument>,
											   <argument><expr><name>include_notnull</name></expr></argument>,
											   <argument><expr><name>include_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do not currently enforce that CHECK constraints contain only
	 * immutable functions, so it's necessary to check here. We daren't draw
	 * conclusions from plan-time evaluation of non-immutable functions. Since
	 * they're ANDed, we can just ignore any mutable constraints in the list,
	 * and reason about the rest.
	 */</comment>
	<expr_stmt><expr><name>safe_constraints</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint_pred</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pred</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>safe_constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>safe_constraints</name></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * The constraints are effectively ANDed together, so we can just try to
	 * refute the entire collection at once.  This may allow us to make proofs
	 * that would fail if we took them individually.
	 *
	 * Note: we use rel-&gt;baserestrictinfo, not safe_restrictions as might seem
	 * an obvious optimization.  Some of the clauses might be OR clauses that
	 * have volatile and nonvolatile subclauses, and it's OK to make
	 * deductions with the nonvolatile parts.
	 *
	 * We need strong refutation because we have to prove that the constraints
	 * would yield false, not just NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>predicate_refuted_by</name><argument_list>(<argument><expr><name>safe_constraints</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * build_physical_tlist
 *
 * Build a targetlist consisting of exactly the relation's user attributes,
 * in order.  The executor can special-case such tlists to avoid a projection
 * step at runtime, so we use such tlists preferentially for scan nodes.
 *
 * Exception: if there are any dropped or missing columns, we punt and return
 * NIL.  Ideally we would like to handle these cases too.  However this
 * creates problems for ExecTypeFromTL, which may be asked to build a tupdesc
 * for a tlist that includes vars of no-longer-existent types.  In theory we
 * could dig out the required info from the pg_attribute entries of the
 * relation, but that data is not readily available to ExecTypeFromTL.
 * For now, we don't apply the physical-tlist optimization when there are
 * dropped cols.
 *
 * We also support building a "physical" tlist for subqueries, functions,
 * values lists, table expressions, and CTEs, since the same optimization can
 * occur in SubqueryScan, FunctionScan, ValuesScan, CteScan, TableFunc,
 * NamedTuplestoreScan, and WorkTableScan nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_physical_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>,
				<decl><type ref="prev"/><name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colvars</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<comment type="block">/* Assume we already have adequate lock */</comment>
			<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>numattrs</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
														  <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* found a dropped or missing col, so punt */</comment>
					<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
							  <argument><expr><name>attrno</name></expr></argument>,
							  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
							  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
							  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
												<argument><expr><name>attrno</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<expr_stmt><expr><name>subquery</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * A resjunk column of the subquery can be reflected as
				 * resjunk in the physical tlist; we need not punt.
				 */</comment>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
												<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<comment type="block">/* Not all of these can have dropped cols, but share code anyway */</comment>
			<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* include dropped */</comment> ,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>colvars</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * A non-Var in expandRTE's output means a dropped column;
				 * must punt.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
								<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
												<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* caller error */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported RTE kind %d in build_physical_tlist"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_index_tlist
 *
 * Build a targetlist representing the columns of the specified index.
 * Each column is represented by a Var for the corresponding base-relation
 * column, or an expression in base-relation Vars, as appropriate.
 *
 * There are never any dropped columns in indexes, so unlike
 * build_physical_tlist, we need no failure case.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_index_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>indexkey</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>indexvar</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexkey</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* simple column */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexkey</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>,
													<argument><expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>indexkey</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>indexvar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
										<argument><expr><name>indexkey</name></expr></argument>,
										<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
										<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
										<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* expression column */</comment>
			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexvar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
						<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>indexvar</name></expr></argument>,
										<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * restriction_selectivity
 *
 * Returns the selectivity of a specified restriction operator clause.
 * This code executes registered procedures stored in the
 * operator relation, by calling the function manager.
 *
 * See clause_selectivity() for the meaning of the additional parameters.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>restriction_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>operatorid</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>oprrest</name> <init>= <expr><call><name>get_oprrest</name><argument_list>(<argument><expr><name>operatorid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if the oprrest procedure is missing for whatever reason, use a
	 * selectivity of 0.5
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oprrest</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>OidFunctionCall4Coll</name><argument_list>(<argument><expr><name>oprrest</name></expr></argument>,
												 <argument><expr><name>inputcollid</name></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operatorid</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0.0</literal> <operator>||</operator> <name>result</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid restriction selectivity: %f"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * join_selectivity
 *
 * Returns the selectivity of a specified join operator clause.
 * This code executes registered procedures stored in the
 * operator relation, by calling the function manager.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>join_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name></type> <name>operatorid</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>,
				 <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
				 <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>oprjoin</name> <init>= <expr><call><name>get_oprjoin</name><argument_list>(<argument><expr><name>operatorid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if the oprjoin procedure is missing for whatever reason, use a
	 * selectivity of 0.5
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oprjoin</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>OidFunctionCall5Coll</name><argument_list>(<argument><expr><name>oprjoin</name></expr></argument>,
												 <argument><expr><name>inputcollid</name></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operatorid</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0.0</literal> <operator>||</operator> <name>result</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid join selectivity: %f"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * has_unique_index
 *
 * Detect whether there is a unique index on the specified attribute
 * of the specified relation, thus allowing us to conclude that all
 * the (non-null) values of the attribute are distinct.
 *
 * This function does not check the index's indimmediate property, which
 * means that uniqueness may transiently fail to hold intra-transaction.
 * That's appropriate when we are making statistical estimates, but beware
 * of using this for any correctness proofs.
 */</comment>
<function><type><name>bool</name></type>
<name>has_unique_index</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ilist</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>ilist</argument>, <argument>rel-&gt;indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>(</operator><name>IndexOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ilist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: ignore partial indexes, since they don't allow us to conclude
		 * that all attr values are distinct, *unless* they are marked predOK
		 * which means we know the index's predicate is satisfied by the
		 * query. We don't take any interest in expressional indexes either.
		 * Also, a multicolumn unique index doesn't allow us to conclude that
		 * just the specified attr is unique.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator>
			<name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>attno</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>predOK</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * has_row_triggers
 *
 * Detect whether the specified relation has any row-level triggers for event.
 */</comment>
<function><type><name>bool</name></type>
<name>has_row_triggers</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assume we already have adequate lock */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trigDesc</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>trigDesc</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_insert_after_row</name></name> <operator>||</operator>
				 <name><name>trigDesc</name><operator>-&gt;</operator><name>trig_insert_before_row</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>trigDesc</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name> <operator>||</operator>
				 <name><name>trigDesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>trigDesc</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name> <operator>||</operator>
				 <name><name>trigDesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_relation_partition_info
 *
 * Set partitioning scheme and related information for a partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_relation_partition_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>=</operator> <call><name>find_partition_scheme</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partdesc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>part_scheme</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <call><name>partition_bounds_copy</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_baserel_partition_key_exprs</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partition_qual</name></name> <operator>=</operator> <call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * find_partition_scheme
 *
 * Find or create a PartitionScheme for this Relation.
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionScheme</name></type>
<name>find_partition_scheme</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionScheme</name></type> <name>part_scheme</name></decl>;</decl_stmt>

	<comment type="block">/* A partitioned table should have a partition key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partkey</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Search for a matching partition scheme and return if found one. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;part_schemes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>part_scheme</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Match partitioning strategy and number of keys. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partkey</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>||</operator>
			<name>partnatts</name> <operator>!=</operator> <name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Match partition key type properties. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partopfamily</name></name></expr></argument>, <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partopcintype</name></name></expr></argument>, <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Length and byval information should match when partopcintype
		 * matches.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>, <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>, <argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If partopfamily and partopcintype matched, must have the same
		 * partition comparison functions.  Note that we cannot reliably
		 * Assert the equality of function structs themselves for they might
		 * be different across PartitionKey's, so just Assert for the function
		 * OIDs.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>==</operator>
				   <name><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Found matching partition scheme. */</comment>
		<return>return <expr><name>part_scheme</name></expr>;</return>
	</block_content>}</block>

	<comment type="block">/*
	 * Did not find matching partition scheme. Create one copying relevant
	 * information from the relcache. We need to copy the contents of the
	 * array since the relcache entry may not survive after we have closed the
	 * relation.
	 */</comment>
	<expr_stmt><expr><name>part_scheme</name> <operator>=</operator> <operator>(</operator><name>PartitionScheme</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionSchemeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopfamily</name></name></expr></argument>, <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partopfamily</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partopcintype</name></name></expr></argument>, <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partopcintype</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttyplen</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>, <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttypbyval</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>, <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part_scheme</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>partkey</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Add the partitioning scheme to PlannerInfo. */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>part_schemes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>part_schemes</name></name></expr></argument>, <argument><expr><name>part_scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>part_scheme</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_baserel_partition_key_exprs
 *
 * Builds partition key expressions for the given base relation and sets them
 * in given RelOptInfo.  Any single column partition keys are converted to Var
 * nodes.  All Var nodes are restamped with the relid of given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_baserel_partition_key_exprs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>varno</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A partitioned table should have a partition key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partkey</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Single column partition key is stored as a Var node. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>partexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>,
										<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Re-stamp the expression with given varno. */</comment>
			<expr_stmt><expr><name>partexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partexpr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>partexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <name>partexprs</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * A base relation can not have nullable partition key expressions. We
	 * still allocate array of empty expressions lists to keep partition key
	 * expression handling code simple. See build_joinrel_partition_info() and
	 * match_expr_to_partition_keys().
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>nullable_partexprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * px_estimate_rel_size - estimate # pages and # tuples in a table or index
 *
 * If attr_widths isn't NULL, it points to the zero-index entry of the
 * relation's attr_width[] cache; we fill this in if we have need to compute
 * the attribute widths for estimation purposes.
 */</comment>
<function><type><name>void</name></type>
<name>px_estimate_rel_size</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name>   <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>,
                      <parameter><decl><type><name>Relation</name></type>      <name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>int32</name>        <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>,
				      <parameter><decl><type><name>BlockNumber</name>  <modifier>*</modifier></type><name>pages</name></decl></parameter>,
                      <parameter><decl><type><name>double</name>       <modifier>*</modifier></type><name>tuples</name></decl></parameter>,
                      <parameter><decl><type><name>double</name>       <modifier>*</modifier></type><name>allvisfrac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>estimate_rel_size</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attr_widths</name></expr></argument>, <argument><expr><name>pages</name></expr></argument>, <argument><expr><name>tuples</name></expr></argument>, <argument><expr><name>allvisfrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * POLAR px
 * Get the total size of a partitioned table, including all partitions.
 *
 * Only used with PXOPT, currently. This is slightly different from
 * px_estimate_rel_size(), in that if the relation is a partitioned table
 * (or general inherited table, but PXOPT doesn't deal with general general
 * inheritance), this sums up the estimates from the child tables. Also, if
 * px_optimizer_enable_relsize_collection is off, and none of the partitions have been
 * analyzed, this returns 0 rather than the default constant estimate.
 */</comment>
<function><type><name>double</name></type>
<name>px_estimate_partitioned_numtuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inheritors</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totaltuples</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>inheritors</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>AccessShareLock</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>totaltuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>inheritors</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>childtuples</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>childid</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>polar_px_try_heap_open</name><argument_list>(<argument><expr><name>childid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>childtuples</name> <operator>=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_enable_relsize_collection</name> <operator>&amp;&amp;</operator> <name>childtuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>dummy_reloptinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type>	<name>numpages</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>allvisfrac</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>dummy_reloptinfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>px_estimate_rel_size</name><argument_list>(<argument><expr><name>dummy_reloptinfo</name></expr></argument>,
								  <argument><expr><name>childrel</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>numpages</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>childtuples</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>allvisfrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dummy_reloptinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>totaltuples</name> <operator>+=</operator> <name>childtuples</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>childrel</name> <operator>!=</operator> <name>rel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>totaltuples</name></expr>;</return>
</block_content>}</block></function></unit>
