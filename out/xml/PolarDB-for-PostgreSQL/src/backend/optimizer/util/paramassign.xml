<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/util/paramassign.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * paramassign.c
 *		Functions for assigning PARAM_EXEC slots during planning.
 *
 * This module is responsible for managing three planner data structures:
 *
 * root-&gt;glob-&gt;paramExecTypes: records actual assignments of PARAM_EXEC slots.
 * The i'th list element holds the data type OID of the i'th parameter slot.
 * (Elements can be InvalidOid if they represent slots that are needed for
 * chgParam signaling, but will never hold a value at runtime.)  This list is
 * global to the whole plan since the executor has only one PARAM_EXEC array.
 * Assignments are permanent for the plan: we never remove entries once added.
 *
 * root-&gt;plan_params: a list of PlannerParamItem nodes, recording Vars and
 * PlaceHolderVars that the root's query level needs to supply to lower-level
 * subqueries, along with the PARAM_EXEC number to use for each such value.
 * Elements are added to this list while planning a subquery, and the list
 * is reset to empty after completion of each subquery.
 *
 * root-&gt;curOuterParams: a list of NestLoopParam nodes, recording Vars and
 * PlaceHolderVars that some outer level of nestloop needs to pass down to
 * a lower-level plan node in its righthand side.  Elements are added to this
 * list as createplan.c creates lower Plan nodes that need such Params, and
 * are removed when it creates a NestLoop Plan node that will supply those
 * values.
 *
 * The latter two data structures are used to prevent creating multiple
 * PARAM_EXEC slots (each requiring work to fill) when the same upper
 * SubPlan or NestLoop supplies a value that is referenced in more than
 * one place in its child plan nodes.  However, when the same Var has to
 * be supplied to different subplan trees by different SubPlan or NestLoop
 * parent nodes, we don't recognize any commonality; a fresh plan_params or
 * curOuterParams entry will be made (since the old one has been removed
 * when we finished processing the earlier SubPlan or NestLoop) and a fresh
 * PARAM_EXEC number will be assigned.  At one time we tried to avoid
 * allocating duplicate PARAM_EXEC numbers in such cases, but it's harder
 * than it seems to avoid bugs due to overlapping Param lifetimes, so we
 * don't risk that anymore.  Minimizing the number of PARAM_EXEC slots
 * doesn't really save much executor work anyway.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/util/paramassign.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paramassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Select a PARAM_EXEC number to identify the given Var as a parameter for
 * the current subquery.  (It might already have one.)
 * Record the need for the Var in the proper upper-level root-&gt;plan_params.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assign_param_for_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ppl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>

	<comment type="block">/* Find the query level the Var belongs to */</comment>
	<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* If there's already a matching PlannerParamItem there, just use it */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ppl</argument>, <argument>root-&gt;plan_params</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ppl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>pvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * This comparison must match _equalVar(), except for ignoring
			 * varlevelsup.  Note that _equalVar() ignores the location.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
				<name><name>pvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
				<name><name>pvar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>&amp;&amp;</operator>
				<name><name>pvar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>&amp;&amp;</operator>
				<name><name>pvar</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>&amp;&amp;</operator>
				<name><name>pvar</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>&amp;&amp;</operator>
				<name><name>pvar</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Nope, so make a new one */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given Var,
 * which is expected to have varlevelsup &gt; 0 (ie, it is not local).
 * Record the need for the Var in the proper upper-level root-&gt;plan_params.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the Var in the appropriate plan_params, or add it if not present */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>assign_param_for_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select a PARAM_EXEC number to identify the given PlaceHolderVar as a
 * parameter for the current subquery.  (It might already have one.)
 * Record the need for the PHV in the proper upper-level root-&gt;plan_params.
 *
 * This is just like assign_param_for_var, except for PlaceHolderVars.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assign_param_for_placeholdervar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ppl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>

	<comment type="block">/* Find the query level the PHV belongs to */</comment>
	<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* If there's already a matching PlannerParamItem there, just use it */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ppl</argument>, <argument>root-&gt;plan_params</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ppl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>pphv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* We assume comparing the PHIDs is sufficient */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pphv</name><operator>-&gt;</operator><name>phid</name></name> <operator>==</operator> <name><name>phv</name><operator>-&gt;</operator><name>phid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Nope, so make a new one */</comment>
	<expr_stmt><expr><name>phv</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given PlaceHolderVar,
 * which is expected to have phlevelsup &gt; 0 (ie, it is not local).
 * Record the need for the PHV in the proper upper-level root-&gt;plan_params.
 *
 * This is just like replace_outer_var, except for PlaceHolderVars.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_placeholdervar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the PHV in the appropriate plan_params, or add it if not present */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>assign_param_for_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given Aggref
 * which is expected to have agglevelsup &gt; 0 (ie, it is not local).
 * Record the need for the Aggref in the proper upper-level root-&gt;plan_params.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the query level the Aggref belongs to */</comment>
	<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * It does not seem worthwhile to try to de-duplicate references to outer
	 * aggs.  Just make a new slot every time.
	 */</comment>
	<expr_stmt><expr><name>agg</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given GroupingFunc expression which is
 * expected to have agglevelsup &gt; 0 (ie, it is not local).
 * Record the need for the GroupingFunc in the proper upper-level
 * root-&gt;plan_params.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the query level the GroupingFunc belongs to */</comment>
	<for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * It does not seem worthwhile to try to de-duplicate references to outer
	 * aggs.  Just make a new slot every time.
	 */</comment>
	<expr_stmt><expr><name>grp</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>grp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grp</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>grp</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given Var,
 * which is expected to come from some upper NestLoop plan node.
 * Record the need for the Var in root-&gt;curOuterParams.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>replace_nestloop_param_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Is this Var already listed in root-&gt;curOuterParams? */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, so just make a Param referencing this NLP's slot */</comment>
			<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
			<return>return <expr><name>param</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* No, so assign a PARAM_EXEC slot for a new NLP */</comment>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
									<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>,
									<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add it to the list of required NLPs */</comment>
	<expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And return the replacement Param */</comment>
	<return>return <expr><name>param</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given PlaceHolderVar,
 * which is expected to come from some upper NestLoop plan node.
 * Record the need for the PHV in root-&gt;curOuterParams.
 *
 * This is just like replace_nestloop_param_var, except for PlaceHolderVars.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>replace_nestloop_param_placeholdervar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Is this PHV already listed in root-&gt;curOuterParams? */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>phv</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, so just make a Param referencing this NLP's slot */</comment>
			<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<return>return <expr><name>param</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* No, so assign a PARAM_EXEC slot for a new NLP */</comment>
	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add it to the list of required NLPs */</comment>
	<expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And return the replacement Param */</comment>
	<return>return <expr><name>param</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * process_subquery_nestloop_params
 *	  Handle params of a parameterized subquery that need to be fed
 *	  from an outer nestloop.
 *
 * Currently, that would be *all* params that a subquery in FROM has demanded
 * from the current query level, since they must be LATERAL references.
 *
 * subplan_params is a list of PlannerParamItems that we intend to pass to
 * a subquery-in-FROM.  (This was constructed in root-&gt;plan_params while
 * planning the subquery, but isn't there anymore when this is called.)
 *
 * The subplan's references to the outer variables are already represented
 * as PARAM_EXEC Params, since that conversion was done by the routines above
 * while planning the subquery.  So we need not modify the subplan or the
 * PlannerParamItems here.  What we do need to do is add entries to
 * root-&gt;curOuterParams to signal the parent nestloop plan node that it must
 * provide these values.  This differs from replace_nestloop_param_var in
 * that the PARAM_EXEC slots to use have already been determined.
 *
 * Note that we also use root-&gt;curOuterRels as an implicit parameter for
 * sanity checks.
 */</comment>
<function><type><name>void</name></type>
<name>process_subquery_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplan_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan_params</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* If not from a nestloop outer rel, complain */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-LATERAL parameter required by subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Is this param already listed in root-&gt;curOuterParams? */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Present, so nothing to do */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No, so add it */</comment>
				<expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* If not from a nestloop outer rel, complain */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>,
							   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-LATERAL parameter required by subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Is this param already listed in root-&gt;curOuterParams? */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>phv</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Present, so nothing to do */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No, so add it */</comment>
				<expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected type of subquery parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Identify any NestLoopParams that should be supplied by a NestLoop plan
 * node with the specified lefthand rels.  Remove them from the active
 * root-&gt;curOuterParams list and return them as the result list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>identify_current_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>leftrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are looking for Vars and PHVs that can be supplied by the
		 * lefthand rels.  The "bms_overlap" test is just an optimization to
		 * allow skipping find_placeholder_info() if the PHV couldn't match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>leftrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>,
													<argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>bms_overlap</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name><operator>)</operator><operator>-&gt;</operator><name>phrels</name></expr></argument>,
							 <argument><expr><name>leftrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>,
							   <argument><expr><name>leftrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>,
													<argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a new Param node that will not conflict with any other.
 *
 * This is used to create Params representing subplan outputs or
 * NestLoop parameters.
 *
 * We don't need to build a PlannerParamItem for such a Param, but we do
 * need to make sure we record the type in paramExecTypes (otherwise,
 * there won't be a slot allocated for it).
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>generate_new_exec_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>paramcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>paramtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name>paramtypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>paramcollation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a (nonnegative) PARAM_EXEC ID for a special parameter (one that
 * is not actually used to carry a value at runtime).  Such parameters are
 * used for special runtime signaling purposes, such as connecting a
 * recursive union node to its worktable scan node or forcing plan
 * re-evaluation within the EvalPlanQual mechanism.  No actual Param node
 * exists with this ID, however.
 */</comment>
<function><type><name>int</name></type>
<name>assign_special_exec_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paramId</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>,
											 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>paramId</name></expr>;</return>
</block_content>}</block></function>
</unit>
