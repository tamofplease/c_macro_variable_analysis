<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/plan/subselect.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * subselect.c
 *	  Planning routines for subselects.
 *
 * This module deals with SubLinks and CTEs, but not subquery RTEs (i.e.,
 * not sub-SELECT-in-FROM cases).
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/subselect.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paramassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><name>bool</name></type> <name>polar_enable_inline_cte</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>convert_testexpr_context</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subst_nodes</name></decl>;</decl_stmt>	<comment type="block">/* Nodes to substitute for Params */</comment>
}</block></struct></type> <name>convert_testexpr_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>process_sublinks_context</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isTopQual</name></decl>;</decl_stmt>
}</block></struct></type> <name>process_sublinks_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>finalize_primnode_context</name>
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>		<comment type="block">/* Non-local PARAM_EXEC paramids found */</comment>
}</block></struct></type> <name>finalize_primnode_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>inline_cte_walker_context</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ctename</name></decl>;</decl_stmt>		<comment type="block">/* name and relative level of target CTE */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>refcount</name></decl>;</decl_stmt>		<comment type="block">/* number of remaining references */</comment>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>ctequery</name></decl>;</decl_stmt>		<comment type="block">/* query to substitute */</comment>
}</block></struct></type> <name>inline_cte_walker_context</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>build_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plan_params</name></decl></parameter>,
			  <parameter><decl><type><name>SubLinkType</name></type> <name>subLinkType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subLinkId</name></decl></parameter>,
			  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>adjust_testexpr</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>unknownEqFalse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_subquery_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_subquery_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_testexpr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subst_nodes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_testexpr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>convert_testexpr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>subplan_is_hashable</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>testexpr_is_hashable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hash_ok_operator</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_dml</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_dml_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_outer_selfref</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_outer_selfref_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>depth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inline_cte</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>inline_cte_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>inline_cte_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>simplify_EXISTS_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>convert_EXISTS_to_ANY</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>,
					  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_correlation_vars_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>process_sublinks_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>process_sublinks_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>finalize_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>gather_param</name></decl></parameter>,
			  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>valid_params</name></decl></parameter>,
			  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>scan_params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_agg_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Assign a (nonnegative) PARAM_EXEC ID for a special parameter (one that
 * is not actually used to carry a value at runtime).  Such parameters are
 * used for special runtime signaling purposes, such as connecting a
 * recursive union node to its worktable scan node or forcing plan
 * re-evaluation within the EvalPlanQual mechanism.  No actual Param node
 * exists with this ID, however.
 *
 * XXX deprecated: use assign_special_exec_param directly, instead.  We are
 * keeping this in v11 and below only to avoid API breaks.
 */</comment>
<function><type><name>int</name></type>
<name>SS_assign_special_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the datatype/typmod/collation of the first column of the plan's output.
 *
 * This information is stored for ARRAY_SUBLINK execution and for
 * exprType()/exprTypmod()/exprCollation(), which have no way to get at the
 * plan associated with a SubPlan node.  We really only need the info for
 * EXPR_SUBLINK and ARRAY_SUBLINK subplans, but for consistency we save it
 * always.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_first_col_type</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>coltype</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>coltypmod</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>colcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* In cases such as EXISTS, tlist might be empty; arbitrarily use VOID */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>coltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>coltypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>colcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>coltype</name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>coltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>colcollation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a SubLink (as created by the parser) into a SubPlan.
 *
 * We are given the SubLink's contained query, type, ID, and testexpr.  We are
 * also told if this expression appears at top level of a WHERE/HAVING qual.
 *
 * Note: we assume that the testexpr has been AND/OR flattened (actually,
 * it's been through eval_const_expressions), but not converted to
 * implicit-AND form; and any SubLinks in it should already have been
 * converted to SubPlans.  The subquery is as yet untouched, however.
 *
 * The result is whatever we need to substitute in place of the SubLink node
 * in the executable expression.  If we're going to do the subplan as a
 * regular subplan, this will be the constructed SubPlan node.  If we're going
 * to do the subplan as an InitPlan, the SubPlan node instead goes into
 * root-&gt;init_plans, and what we return here is an expression tree
 * representing the InitPlan's result: usually just a Param node representing
 * a single scalar result, but possibly a row comparison tree containing
 * multiple Param nodes, or for a MULTIEXPR subquery a simple NULL constant
 * (since the real output Params are elsewhere in the tree, and the MULTIEXPR
 * subquery itself is in a resjunk tlist entry whose value is uninteresting).
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>orig_subquery</name></decl></parameter>,
			 <parameter><decl><type><name>SubLinkType</name></type> <name>subLinkType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subLinkId</name></decl></parameter>,
			 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>simple_exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuple_fraction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>plan_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Copy the source Query node.  This is a quick and dirty kluge to resolve
	 * the fact that the parser can generate trees with multiple links to the
	 * same sub-Query node, but the planner wants to scribble on the Query.
	 * Try to clean this up when we do querytree redesign...
	 */</comment>
	<expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>orig_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's an EXISTS subplan, we might be able to simplify it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>simple_exists</name> <operator>=</operator> <call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For an EXISTS subplan, tell lower-level planner to expect that only the
	 * first tuple will be retrieved.  For ALL and ANY subplans, we will be
	 * able to stop evaluating if the test condition fails or matches, so very
	 * often not all the tuples will be retrieved; for lack of a better idea,
	 * specify 50% retrieval.  For EXPR, MULTIEXPR, and ROWCOMPARE subplans,
	 * use default behavior (we're only expecting one row out, anyway).
	 *
	 * NOTE: if you change these numbers, also change cost_subplan() in
	 * path/costsize.c.
	 *
	 * XXX If an ANY subplan is uncorrelated, build_subplan may decide to hash
	 * its output.  In that case it would've been better to specify full
	 * retrieval.  At present, however, we can only check hashability after
	 * we've made the subplan :-(.  (Determining whether it'll fit in work_mem
	 * is the really hard part.)  Therefore, we don't want to be too
	 * optimistic about the percentage of tuples retrieved, for fear of
	 * selecting a plan that's bad for the materialization case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* just like a LIMIT 1 */</comment>
	<if type="elseif">else if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ALL_SUBLINK</name> <operator>||</operator>
			 <name>subLinkType</name> <operator>==</operator> <name>ANY_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* 50% */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* default behavior */</comment>

	<comment type="block">/* plan_params should not be in use in current query level */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate Paths for the subquery */</comment>
	<expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
							   <argument><expr><name>root</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Isolate the params needed by this specific subplan */</comment>
	<expr_stmt><expr><name>plan_params</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select best Path and turn it into a Plan.  At least for now, there
	 * seems no reason to postpone doing that.
	 */</comment>
	<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>get_cheapest_fractional_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And convert to SubPlan or InitPlan format. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>build_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>plan_params</name></expr></argument>,
						   <argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>subLinkId</name></expr></argument>,
						   <argument><expr><name>testexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>isTopQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a correlated EXISTS with an unimportant targetlist, we might be
	 * able to transform it to the equivalent of an IN and then implement it
	 * by hashing.  We don't have enough information yet to tell which way is
	 * likely to be better (it depends on the expected number of executions of
	 * the EXISTS qual, and we are much too early in planning the outer query
	 * to be able to guess that).  So we generate both plans, if possible, and
	 * leave it to the executor to decide which to use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>simple_exists</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newtestexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>paramIds</name></decl>;</decl_stmt>

		<comment type="block">/* Make a second copy of the original subquery */</comment>
		<expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>orig_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* and re-simplify */</comment>
		<expr_stmt><expr><name>simple_exists</name> <operator>=</operator> <call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>simple_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* See if it can be converted to an ANY query */</comment>
		<expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>convert_EXISTS_to_ANY</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>newtestexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subquery</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Generate Paths for the ANY subquery; we'll need all rows */</comment>
			<expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
									   <argument><expr><name>root</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Isolate the params needed by this specific subplan */</comment>
			<expr_stmt><expr><name>plan_params</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

			<comment type="block">/* Select best Path and turn it into a Plan */</comment>
			<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>best_path</name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now we can check if it'll fit in work_mem */</comment>
			<comment type="block">/* XXX can we check this at the Path stage? */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>subplan_is_hashable</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>hashplan</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name></decl>;</decl_stmt>

				<comment type="block">/* OK, convert to SubPlan format. */</comment>
				<expr_stmt><expr><name>hashplan</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>,
									<argument><expr><call><name>build_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>,
												  <argument><expr><name>plan_params</name></expr></argument>,
												  <argument><expr><name>ANY_SUBLINK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
												  <argument><expr><name>newtestexpr</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Check we got what we expected */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* build_subplan won't have filled in paramIds */</comment>
				<expr_stmt><expr><name><name>hashplan</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <name>paramIds</name></expr>;</expr_stmt>

				<comment type="block">/* Leave it to the executor to decide which plan to use */</comment>
				<expr_stmt><expr><name>asplan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>hashplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>asplan</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a SubPlan node given the raw inputs --- subroutine for make_subplan
 *
 * Returns either the SubPlan, or a replacement expression if we decide to
 * make it an InitPlan, as explained in the comments for make_subplan.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>build_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plan_params</name></decl></parameter>,
			  <parameter><decl><type><name>SubLinkType</name></type> <name>subLinkType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subLinkId</name></decl></parameter>,
			  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>adjust_testexpr</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>unknownEqFalse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>splan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isInitPlan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize the SubPlan node.  Note plan_id, plan_name, and cost fields
	 * are set further down.
	 */</comment>
	<expr_stmt><expr><name>splan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>subLinkType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_first_col_type</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>unknownEqFalse</name></name> <operator>=</operator> <name>unknownEqFalse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make parParam and args lists of param IDs and expressions that current
	 * query level will pass to this child plan.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan_params</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The Var, PlaceHolderVar, or Aggref has already been adjusted to
		 * have the correct varlevelsup, phlevelsup, or agglevelsup.
		 *
		 * If it's a PlaceHolderVar or Aggref, its arguments might contain
		 * SubLinks, which have not yet been processed (see the comments for
		 * SS_replace_correlation_vars).  Do that now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>SS_process_sublinks</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name></expr></argument>, <argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Un-correlated or undirect correlated plans of EXISTS, EXPR, ARRAY,
	 * ROWCOMPARE, or MULTIEXPR types can be used as initPlans.  For EXISTS,
	 * EXPR, or ARRAY, we return a Param referring to the result of evaluating
	 * the initPlan.  For ROWCOMPARE, we must modify the testexpr tree to
	 * contain PARAM_EXEC Params instead of the PARAM_SUBLINK Params emitted
	 * by the parser, and then return that tree.  For MULTIEXPR, we return a
	 * null constant: the resjunk targetlist item containing the SubLink does
	 * not need to return anything useful, since the referencing Params are
	 * elsewhere.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prm</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prm</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>arraytype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arraytype</name> <operator>=</operator> <call><name>get_promoted_array_type</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>arraytype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find array type for datatype %s"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>arraytype</name></expr></argument>,
									  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prm</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>ROWCOMPARE_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adjust the Params */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>generate_subquery_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>testexpr</name></expr></argument>,
								  <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The executable expression is returned to become part of the outer
		 * plan's expression tree; it is not kept in the initplan node.
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Whether it's an initplan or not, it needs to set a PARAM_EXEC Param
		 * for each output column.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>generate_subquery_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Save the list of replacement Params in the n'th cell of
		 * root-&gt;multiexpr_params; setrefs.c will use it to replace
		 * PARAM_MULTIEXPR Params.
		 */</comment>
		<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>subLinkId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>, <argument><expr><name>subLinkId</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>params</name></expr>;</expr_stmt>

		<comment type="block">/* It can be an initplan if there are no parParams. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>splan</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Adjust the Params in the testexpr, unless caller said it's not
		 * needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>testexpr</name> <operator>&amp;&amp;</operator> <name>adjust_testexpr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>generate_subquery_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>testexpr</name></expr></argument>,
											   <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>testexpr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * We can't convert subplans of ALL_SUBLINK or ANY_SUBLINK types to
		 * initPlans, even when they are uncorrelated or undirect correlated,
		 * because we need to scan the output of the subplan for each outer
		 * tuple.  But if it's a not-direct-correlated IN (= ANY) test, we
		 * might be able to use a hashtable to avoid comparing all the tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ANY_SUBLINK</name> <operator>&amp;&amp;</operator>
			<name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>subplan_is_hashable</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>testexpr_is_hashable</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/*
		 * Otherwise, we have the option to tack a Material node onto the top
		 * of the subplan, to reduce the cost of reading it repeatedly.  This
		 * is pointless for a direct-correlated subplan, since we'd have to
		 * recompute its results each time anyway.  For uncorrelated/undirect
		 * correlated subplans, we add Material unless the subplan's top plan
		 * node would materialize its output anyway.  Also, if enable_material
		 * is false, then the user does not want us to materialize anything
		 * unnecessarily, so we don't.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>enable_material</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>ExecMaterializesOutput</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>materialize_finished_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>splan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Add the subplan and its PlannerInfo to the global lists.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isInitPlan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr></argument>, <argument><expr><name>splan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A parameterless subplan (not initplan) should be prepared to handle
	 * REWIND efficiently.  If it has direct parameters then there's no point
	 * since it'll be reset on each scan anyway; and if it's an initplan then
	 * there's no point since it won't get re-run without parameter changes
	 * anyway.  The input of a hashed subplan doesn't need REWIND either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isInitPlan</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name></expr></argument>,
												   <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Label the subplan for EXPLAIN purposes */</comment>
	<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">32</literal> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>, <argument><expr><literal type="string">"%s %d"</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><name>isInitPlan</name></expr> ?</condition><then> <expr><literal type="string">"InitPlan"</literal></expr> </then><else>: <expr><literal type="string">"SubPlan"</literal></expr></else></ternary></expr></argument>,
			<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">" (returns "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>splan-&gt;setParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"$%d%s"</literal></expr></argument>,
						   <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><ternary><condition><expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">")"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Lastly, fill in the cost estimates for use later */</comment>
	<expr_stmt><expr><call><name>cost_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>splan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_subquery_params: build a list of Params representing the output
 * columns of a sublink's sub-select, given the sub-select's targetlist.
 *
 * We also return an integer list of the paramids of the Params.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_subquery_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>ids</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>paramIds</name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_subquery_vars: build a list of Vars representing the output
 * columns of a sublink's sub-select, given the sub-select's targetlist.
 * The Vars have the specified varno (RTE index).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_subquery_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>tent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_testexpr: convert the testexpr given by the parser into
 * actually executable form.  This entails replacing PARAM_SUBLINK Params
 * with Params or Vars representing the results of the sub-select.  The
 * nodes to be substituted are passed in as the List result from
 * generate_subquery_params or generate_subquery_vars.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>convert_testexpr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subst_nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>convert_testexpr_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subst_nodes</name></name> <operator>=</operator> <name>subst_nodes</name></expr>;</expr_stmt>
	<return>return <expr><call><name>convert_testexpr_mutator</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>convert_testexpr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						 <parameter><decl><type><name>convert_testexpr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subst_nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected PARAM_SUBLINK ID: %d"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We copy the list item to avoid having doubly-linked
			 * substructure in the modified parse tree.  This is probably
			 * unnecessary when it's a Param, but be safe.
			 */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subst_nodes</name></name></expr></argument>,
												<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we come across a nested SubLink, it is neither necessary nor
		 * correct to recurse into it: any PARAM_SUBLINKs we might find inside
		 * belong to the inner SubLink not the outer. So just return it as-is.
		 *
		 * This reasoning depends on the assumption that nothing will pull
		 * subexpressions into or out of the testexpr field of a SubLink, at
		 * least not without replacing PARAM_SUBLINKs first.  If we did want
		 * to do that we'd need to rethink the parser-output representation
		 * altogether, since currently PARAM_SUBLINKs are only unique per
		 * SubLink not globally across the query.  The whole point of
		 * replacing them with Vars or PARAM_EXEC nodes is to make them
		 * globally unique before they escape from the SubLink's testexpr.
		 *
		 * Note: this can't happen when called during SS_process_sublinks,
		 * because that recursively processes inner SubLinks first.  It can
		 * happen when called from convert_ANY_sublink_to_join, though.
		 */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>convert_testexpr_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * subplan_is_hashable: can we implement an ANY subplan by hashing?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>subplan_is_hashable</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>subquery_size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The estimated size of the subquery result must fit in work_mem. (Note:
	 * we use heap tuple overhead here even though the tuples will actually be
	 * stored as MinimalTuples; this provides some fudge factor for hashtable
	 * overhead.)
	 */</comment>
	<expr_stmt><expr><name>subquery_size</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>*</operator>
		<operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>subquery_size</name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * testexpr_is_hashable: is an ANY SubLink's test expression hashable?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>testexpr_is_hashable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The testexpr must be a single OpExpr, or an AND-clause containing only
	 * OpExprs.
	 *
	 * The combining operators must be hashable and strict. The need for
	 * hashability is obvious, since we want to use hashing. Without
	 * strictness, behavior in the presence of nulls is too unpredictable.  We
	 * actually must assume even more than plain strictness: they can't yield
	 * NULL for non-null inputs, either (see nodeSubplan.c).  However, hash
	 * indexes and hash joins assume that too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>testexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>hash_ok_operator</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>testexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) testexpr)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>andarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>andarg</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_ok_operator</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>andarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check expression is hashable + strict
 *
 * We could use op_hashjoinable() and op_strict(), but do it like this to
 * avoid a redundant cache lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hash_ok_operator</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opid</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* quick out if not a binary operator */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>opid</name> <operator>==</operator> <name>ARRAY_EQ_OP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* array_eq is strict, but must check input type to ensure hashable */</comment>
		<comment type="block">/* XXX record_eq will need same treatment when it becomes hashable */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftarg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* else must look up the operator properties */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>optup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>optup</name><operator>-&gt;</operator><name>oprcanhash</name></name> <operator>||</operator> <operator>!</operator><call><name>func_strict</name><argument_list>(<argument><expr><name><name>optup</name><operator>-&gt;</operator><name>oprcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SS_process_ctes: process a query's WITH list
 *
 * Consider each CTE in the WITH list and either ignore it (if it's an
 * unreferenced SELECT), "inline" it to create a regular sub-SELECT-in-FROM,
 * or convert it to an initplan.
 *
 * A side effect is to fill in root-&gt;cte_plan_ids with a list that
 * parallels root-&gt;parse-&gt;cteList and provides the subplan ID for
 * each CTE's initplan, or a dummy ID (-1) if we didn't make an initplan.
 */</comment>
<function><type><name>void</name></type>
<name>SS_process_ctes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CmdType</name></type>		<name>cmdType</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name><operator>)</operator><operator>-&gt;</operator><name>commandType</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>splan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore SELECT CTEs that are not actually referenced anywhere.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmdType</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Make a dummy entry in cte_plan_ids */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Consider inlining the CTE (creating RTE_SUBQUERY RTE(s)) instead of
		 * implementing it as a separately-planned CTE.
		 *
		 * We cannot inline if any of these conditions hold:
		 *
		 * 1. The user said not to (the CTEMaterializeAlways option).
		 *
		 * 2. The CTE is recursive.
		 *
		 * 3. The CTE has side-effects; this includes either not being a plain
		 * SELECT, or containing volatile functions.  Inlining might change
		 * the side-effects, which would be bad.
		 *
		 * 4. The CTE is multiply-referenced and contains a self-reference to
		 * a recursive CTE outside itself.  Inlining would result in multiple
		 * recursive self-references, which we don't support.
		 *
		 * Otherwise, we have an option whether to inline or not.  That should
		 * always be a win if there's just a single reference, but if the CTE
		 * is multiply-referenced then it's unclear: inlining adds duplicate
		 * computations, but the ability to absorb restrictions from the outer
		 * query level could outweigh that.  We do not have nearly enough
		 * information at this point to tell whether that's true, so we let
		 * the user express a preference.  Our default behavior is to inline
		 * only singly-referenced CTEs, but a CTE marked CTEMaterializeNever
		 * will be inlined even if multiply referenced.
		 *
		 * Note: we check for volatile functions last, because that's more
		 * expensive than the other tests needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_inline_cte</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name> <operator>==</operator> <name>CTEMaterializeNever</name> <operator>||</operator>
			 <operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name> <operator>==</operator> <name>CTEMaterializeDefault</name> <operator>&amp;&amp;</operator>
			  <name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>cte</name><operator>-&gt;</operator><name>cterecursive</name></name> <operator>&amp;&amp;</operator>
			<name>cmdType</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_dml</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>
			 <operator>!</operator><call><name>contain_outer_selfref</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>inline_cte</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make a dummy entry in cte_plan_ids */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy the source Query node.  Probably not necessary, but let's keep
		 * this similar to make_subplan.
		 */</comment>
		<expr_stmt><expr><name>subquery</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan_params should not be in use in current query level */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate Paths for the CTE query.  Always plan for full retrieval
		 * --- we don't have enough info to predict otherwise.
		 */</comment>
		<expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
								   <argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>cterecursive</name></name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since the current query level doesn't yet contain any RTEs, it
		 * should not be possible for the CTE to have requested parameters of
		 * this level.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected outer reference in CTE query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Select best Path and turn it into a Plan.  At least for now, there
		 * seems no reason to postpone doing that.
		 */</comment>
		<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>best_path</name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make a SubPlan node for it.  This is just enough unlike
		 * build_subplan that we can't share code.
		 *
		 * Note plan_id, plan_name, and cost fields are set further down.
		 */</comment>
		<expr_stmt><expr><name>splan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>CTE_SUBLINK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_first_col_type</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>unknownEqFalse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * CTE scans are not considered for parallelism (cf
		 * set_rel_consider_parallel), and even if they were, initPlans aren't
		 * parallel-safe.
		 */</comment>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The node can't have any inputs (since it's an initplan), so the
		 * parParam and args lists remain empty.  (It could contain references
		 * to earlier CTEs' output param IDs, but CTE outputs are not
		 * propagated via the args list.)
		 */</comment>

		<comment type="block">/*
		 * Assign a param ID to represent the CTE's output.  No ordinary
		 * "evaluation" of this param slot ever happens, but we use the param
		 * ID for setParam/chgParam signaling just as if the CTE plan were
		 * returning a simple scalar output.  (Also, the executor abuses the
		 * ParamExecData slot for this param ID for communication among
		 * multiple CteScan nodes that might be scanning this CTE.)
		 */</comment>
		<expr_stmt><expr><name>paramid</name> <operator>=</operator> <call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the subplan and its PlannerInfo to the global lists.
		 */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr></argument>, <argument><expr><name>splan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Label the subplan for EXPLAIN purposes */</comment>
		<expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"CTE %s"</literal></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Lastly, fill in the cost estimates for use later */</comment>
		<expr_stmt><expr><call><name>cost_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>splan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * contain_dml: is any subquery not a plain SELECT?
 *
 * We reject SELECT FOR UPDATE/SHARE as well as INSERT etc.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_dml</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_dml_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_dml_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
			<name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>contain_dml_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_dml_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * contain_outer_selfref: is there an external recursive self-reference?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_outer_selfref</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should be starting with a Query, so that depth will be 1 while
	 * examining its immediate contents.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>contain_outer_selfref_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_outer_selfref_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for a self-reference to a CTE that's above the Query that our
		 * search started at.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>&gt;=</operator> <operator>*</operator><name>depth</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* allow range_table_walker to continue */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subquery, tracking nesting depth properly */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>depth</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>contain_outer_selfref_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>depth</name></expr></argument>, <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>depth</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_outer_selfref_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>depth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inline_cte: convert RTE_CTE references to given CTE into RTE_SUBQUERYs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inline_cte</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>inline_cte_walker_context</name></name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ctename</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr>;</expr_stmt>
	<comment type="block">/* Start at levelsup = -1 because we'll immediately increment it */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>levelsup</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>refcount</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ctequery</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>inline_cte_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assert we replaced all references */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inline_cte_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>inline_cte_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Visit the query's RTE nodes after their contents; otherwise
		 * query_tree_walker would descend into the newly inlined CTE query,
		 * which we don't want.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>inline_cte_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								 <argument><expr><name>QTW_EXAMINE_RTES_AFTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found a reference to replace.  Generate a copy of the CTE query
			 * with appropriate level adjustment for outer references (e.g.,
			 * to other CTEs).
			 */</comment>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newquery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newquery</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Convert the RTE_CTE RTE into a RTE_SUBQUERY.
			 *
			 * Historically, a FOR UPDATE clause has been treated as extending
			 * into views and subqueries, but not into CTEs.  We preserve this
			 * distinction by not trying to push rowmarks into the new
			 * subquery.
			 */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>newquery</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>security_barrier</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* Zero out CTE-specific fields */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

			<comment type="block">/* Count the number of replacements we've done */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>inline_cte_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * convert_ANY_sublink_to_join: try to convert an ANY SubLink to a join
 *
 * The caller has found an ANY SubLink at the top level of one of the query's
 * qual clauses, but has not checked the properties of the SubLink further.
 * Decide whether it is appropriate to process this SubLink in join style.
 * If so, form a JoinExpr and return it.  Return NULL if the SubLink cannot
 * be converted to a join.
 *
 * The only non-obvious input parameter is available_rels: this is the set
 * of query rels that can safely be referenced in the sublink expression.
 * (We must restrict this to avoid changing the semantics when a sublink
 * is present in an outer join's ON qual.)  The conversion must fail if
 * the converted qual would reference any but these parent-query relids.
 *
 * On success, the returned JoinExpr has larg = NULL and rarg = the jointree
 * item representing the pulled-up subquery.  The caller must set larg to
 * represent the relation(s) on the lefthand side of the new join, and insert
 * the JoinExpr into the upper query's jointree at an appropriate place
 * (typically, where the lefthand relation(s) had been).  Note that the
 * passed-in SubLink must also be removed from its original position in the
 * query quals, since the quals of the returned JoinExpr replace it.
 * (Notionally, we replace the SubLink with a constant TRUE, then elide the
 * redundant constant from the qual.)
 *
 * On success, the caller is also responsible for recursively applying
 * pull_up_sublinks processing to the rarg and quals of the returned JoinExpr.
 * (On failure, there is no need to do anything, since pull_up_sublinks will
 * be applied when we recursively plan the sub-select.)
 *
 * Side effects of a successful conversion include adding the SubLink's
 * subselect to the query's rangetable, so that it can be referenced in
 * the JoinExpr's rarg.
 */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_ANY_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>,
							<parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>upper_varnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subquery_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The sub-select must not refer to any Vars of the parent query. (Vars of
	 * higher levels should be okay, though.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The test expression must contain some Vars of the parent query, else
	 * it's not gonna be a join.  (Note that it won't have Vars referring to
	 * the subquery, rather Params.)
	 */</comment>
	<expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * However, it can't refer to anything outside available_rels.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The combining operators and left-hand expressions mustn't be volatile.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Create a dummy ParseState for addRangeTableEntryForSubquery */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay, pull up the sub-select into upper range table.
	 *
	 * We rely here on the assumption that the outer query has no references
	 * to the inner (necessarily true, other than the Vars that we build
	 * below). Therefore this is a lot easier than what pull_up_subqueries has
	 * to go through.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>subselect</name></expr></argument>,
										<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"ANY_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form a RangeTblRef for the pulled-up sub-select.
	 */</comment>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a list of Vars representing the subselect outputs.
	 */</comment>
	<expr_stmt><expr><name>subquery_vars</name> <operator>=</operator> <call><name>generate_subquery_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										   <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the new join's qual expression, replacing Params with these Vars.
	 */</comment>
	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>subquery_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And finally, build the JoinExpr node.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_SEMI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* caller must fill this in */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* we don't need an RTE for it */</comment>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_EXISTS_sublink_to_join: try to convert an EXISTS SubLink to a join
 *
 * The API of this function is identical to convert_ANY_sublink_to_join's,
 * except that we also support the case where the caller has found NOT EXISTS,
 * so we need an additional input parameter "under_not".
 */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_EXISTS_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>under_not</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>clause_varnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>upper_varnos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Can't flatten if it contains WITH.  (We could arrange to pull up the
	 * WITH into the parent query's cteList, but that risks changing the
	 * semantics, since a WITH ought to be executed once per associated query
	 * call.)  Note that convert_ANY_sublink_to_join doesn't have to reject
	 * this case, since it just produces a subquery RTE that doesn't have to
	 * get flattened into the parent query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy the subquery so we can modify it safely (see comments in
	 * make_subplan).
	 */</comment>
	<expr_stmt><expr><name>subselect</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if the subquery can be simplified based on the knowledge that it's
	 * being used in EXISTS().  If we aren't able to get rid of its
	 * targetlist, we have to fail, because the pullup operation leaves us
	 * with noplace to evaluate the targetlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The subquery must have a nonempty jointree, else we won't have a join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Separate out the WHERE clause.  (We could theoretically also remove
	 * top-level plain JOIN/ON clauses, but it's probably not worth the
	 * trouble.)
	 */</comment>
	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The rest of the sub-select must not refer to any Vars of the parent
	 * query.  (Vars of higher levels should be okay, though.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On the other hand, the WHERE clause must contain some Vars of the
	 * parent query, else it's not gonna be a join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't risk optimizing if the WHERE clause is volatile, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prepare to pull up the sub-select into top range table.
	 *
	 * We rely here on the assumption that the outer query has no references
	 * to the inner (necessarily true). Therefore this is a lot easier than
	 * what pull_up_subqueries has to go through.
	 *
	 * In fact, it's even easier than what convert_ANY_sublink_to_join has to
	 * do.  The machinations of simplify_EXISTS_query ensured that there is
	 * nothing interesting in the subquery except an rtable and jointree, and
	 * even the jointree FromExpr no longer has quals.  So we can just append
	 * the rtable to our own and use the FromExpr in our jointree. But first,
	 * adjust all level-zero varnos in the subquery to account for the rtable
	 * merger.
	 */</comment>
	<expr_stmt><expr><name>rtoffset</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Upper-level vars in subquery will now be one level closer to their
	 * parent than before; in particular, anything that had been level 1
	 * becomes level zero.
	 */</comment>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that the WHERE clause is adjusted to match the parent query
	 * environment, we can easily identify all the level-zero rels it uses.
	 * The ones &lt;= rtoffset belong to the upper query; the ones &gt; rtoffset do
	 * not.
	 */</comment>
	<expr_stmt><expr><name>clause_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>varno</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>varno</name> <operator>&lt;=</operator> <name>rtoffset</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we've got the set of upper-level varnos, we can make the last
	 * check: only available_rels can be referenced.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Now we can attach the modified subquery rtable to the parent */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And finally, build the JoinExpr node.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <ternary><condition><expr><name>under_not</name></expr> ?</condition><then> <expr><name>JOIN_ANTI</name></expr> </then><else>: <expr><name>JOIN_SEMI</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* caller must fill this in */</comment>
	<comment type="block">/* flatten out the FromExpr node if it's useless */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* we don't need an RTE for it */</comment>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * simplify_EXISTS_query: remove any useless stuff in an EXISTS's subquery
 *
 * The only thing that matters about an EXISTS query is whether it returns
 * zero or more than zero rows.  Therefore, we can remove certain SQL features
 * that won't affect that.  The only part that is really likely to matter in
 * typical usage is simplifying the targetlist: it's a common habit to write
 * "SELECT * FROM" even though there is no need to evaluate any columns.
 *
 * Note: by suppressing the targetlist we could cause an observable behavioral
 * change, namely that any errors that might occur in evaluating the tlist
 * won't occur, nor will other side-effects of volatile functions.  This seems
 * unlikely to bother anyone in practice.
 *
 * Returns true if was able to discard the targetlist, else false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>simplify_EXISTS_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't try to simplify at all if the query uses set operations,
	 * aggregates, grouping sets, SRFs, modifying CTEs, HAVING, OFFSET, or FOR
	 * UPDATE/SHARE; none of these seem likely in normal usage and their
	 * possible effects are complex.  (Note: we could ignore an "OFFSET 0"
	 * clause, but that traditionally is used as an optimization fence, so we
	 * don't.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * LIMIT with a constant positive (or NULL) value doesn't affect the
	 * semantics of EXISTS, so let's ignore such clauses.  This is worth doing
	 * because people accustomed to certain other DBMSes may be in the habit
	 * of writing EXISTS(SELECT ... LIMIT 1) as an optimization.  If there's a
	 * LIMIT with anything else as argument, though, we can't simplify.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The LIMIT clause has not yet been through eval_const_expressions,
		 * so we have to apply that here.  It might seem like this is a waste
		 * of cycles, since the only case plausibly worth worrying about is
		 * "LIMIT 1" ... but what we'll actually see is "LIMIT int8(1::int4)",
		 * so we have to fold constants or we're not going to recognize it.
		 */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>limit</name></decl>;</decl_stmt>

		<comment type="block">/* Might as well update the query if we simplified the clause. */</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>limit</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INT8OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>limit</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>limit</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Whether or not the targetlist is safe, we can drop the LIMIT. */</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we can throw away the targetlist, as well as any GROUP,
	 * WINDOW, DISTINCT, and ORDER BY clauses; none of those clauses will
	 * change a nonzero-rows result to zero rows or vice versa.  (Furthermore,
	 * since our parsetree representation of these clauses depends on the
	 * targetlist, we'd better throw them away if we drop the targetlist.)
	 */</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_EXISTS_to_ANY: try to convert EXISTS to a hashable ANY sublink
 *
 * The subselect is expected to be a fresh copy that we can munge up,
 * and to have been successfully passed through simplify_EXISTS_query.
 *
 * On success, the modified subselect is returned, and we store a suitable
 * upper-level test expression at *testexpr, plus a list of the subselect's
 * output Params at *paramIds.  (The test expression is already Param-ified
 * and hence need not go through convert_testexpr, which is why we have to
 * deal with the Param IDs specially.)
 *
 * On failure, returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>convert_EXISTS_to_ANY</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>,
					  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>leftargs</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rightargs</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>opids</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>opcollations</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>newWhere</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>testlist</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>oc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>resno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Query must not require a targetlist, since we have to insert a new one.
	 * Caller should have dealt with the case already.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Separate out the WHERE clause.  (We could theoretically also remove
	 * top-level plain JOIN/ON clauses, but it's probably not worth the
	 * trouble.)
	 */</comment>
	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The rest of the sub-select must not refer to any Vars of the parent
	 * query.  (Vars of higher levels should be okay, though.)
	 *
	 * Note: we need not check for Aggrefs separately because we know the
	 * sub-select is as yet unoptimized; any uplevel Aggref must therefore
	 * contain an uplevel Var reference.  This is not the case below ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't risk optimizing if the WHERE clause is volatile, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Clean up the WHERE clause by doing const-simplification etc on it.
	 * Aside from simplifying the processing we're about to do, this is
	 * important for being able to pull chunks of the WHERE clause up into the
	 * parent query.  Since we are invoked partway through the parent's
	 * preprocess_expression() work, earlier steps of preprocess_expression()
	 * wouldn't get applied to the pulled-up stuff unless we do them here. For
	 * the parts of the WHERE clause that get put back into the child query,
	 * this work is partially duplicative, but it shouldn't hurt.
	 *
	 * Note: we do not run flatten_join_alias_vars.  This is OK because any
	 * parent aliases were flattened already, and we're not going to pull any
	 * child Vars (of any description) into the parent.
	 *
	 * Note: passing the parent's root to eval_const_expressions is
	 * technically wrong, but we can get away with it since only the
	 * boundParams (if any) are used, and those would be the same in a
	 * subroot.
	 */</comment>
	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>whereClause</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We now have a flattened implicit-AND list of clauses, which we try to
	 * break apart into "outervar = innervar" hash clauses. Anything that
	 * can't be broken apart just goes back into the newWhere list.  Note that
	 * we aren't trying hard yet to ensure that we have only outer or only
	 * inner on each side; we'll check that if we get to the end.
	 */</comment>
	<expr_stmt><expr><name>leftargs</name> <operator>=</operator> <name>rightargs</name> <operator>=</operator> <name>opids</name> <operator>=</operator> <name>opcollations</name> <operator>=</operator> <name>newWhere</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) whereClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>hash_ok_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>leftargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>leftargs</name></expr></argument>, <argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rightargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rightargs</name></expr></argument>, <argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>opids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opids</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>opcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opcollations</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We must commute the clause to put the outer var on the
				 * left, because the hashing code in nodeSubplan.c expects
				 * that.  This probably shouldn't ever fail, since hashable
				 * operators ought to have commutators, but be paranoid.
				 */</comment>
				<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hash_ok_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>leftargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>leftargs</name></expr></argument>, <argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>rightargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rightargs</name></expr></argument>, <argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>opids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opids</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>opcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opcollations</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* If no commutator, no chance to optimize the WHERE clause */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Couldn't handle it as a hash clause */</comment>
		<expr_stmt><expr><name>newWhere</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newWhere</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we didn't find anything we could convert, fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * There mustn't be any parent Vars or Aggs in the stuff that we intend to
	 * put back into the child query.  Note: you might think we don't need to
	 * check for Aggs separately, because an uplevel Agg must contain an
	 * uplevel Var in its argument.  But it is possible that the uplevel Var
	 * got optimized away by eval_const_expressions.  Consider
	 *
	 * SUM(CASE WHEN false THEN uplevelvar ELSE 0 END)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newWhere</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightargs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newWhere</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightargs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And there can't be any child Vars in the stuff we intend to pull up.
	 * (Note: we'd need to check for child Aggs too, except we know the child
	 * has no aggs at all because of simplify_EXISTS_query's check. The same
	 * goes for window functions.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftargs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also reject sublinks in the stuff we intend to pull up.  (It might be
	 * possible to support this, but doesn't seem worth the complication.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_subplans</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Okay, adjust the sublevelsup in the stuff we're pulling up.
	 */</comment>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftargs</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put back any child-level-only WHERE clauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newWhere</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>newWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build a new targetlist for the child that emits the expressions we
	 * need.  Concurrently, build a testexpr for the parent using Params to
	 * reference the child outputs.  (Since we generate Params directly here,
	 * there will be no need to convert the testexpr in build_subplan.)
	 */</comment>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>testlist</name> <operator>=</operator> <name>paramids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* there's no "forfour" so we have to chase one of the lists manually */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>opcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>lc</argument>, <argument>leftargs</argument>, <argument>rc</argument>, <argument>rightargs</argument>, <argument>oc</argument>, <argument>opids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opcollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
						<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rightarg</name></expr></argument>,
										<argument><expr><name>resno</name><operator>++</operator></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>testlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>testlist</name></expr></argument>,
						   <argument><expr><call><name>make_opclause</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>leftarg</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>param</name></expr></argument>,
										 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>opcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>paramids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>paramids</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Put everything where it should go, and we're done */</comment>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>testexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>testlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>paramIds</name> <operator>=</operator> <name>paramids</name></expr>;</expr_stmt>

	<return>return <expr><name>subselect</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Replace correlation vars (uplevel vars) with Params.
 *
 * Uplevel PlaceHolderVars and aggregates are replaced, too.
 *
 * Note: it is critical that this runs immediately after SS_process_sublinks.
 * Since we do not recurse into the arguments of uplevel PHVs and aggregates,
 * they will get copied to the appropriate subplan args list in the parent
 * query with uplevel vars not replaced by Params, but only adjusted in level
 * (see replace_outer_placeholdervar and replace_outer_agg).  That's exactly
 * what we want for the vars of the parent level --- but if a PHV's or
 * aggregate's argument contains any further-up variables, they have to be
 * replaced with Params in their turn. That will happen when the parent level
 * runs SS_replace_correlation_vars.  Therefore it must do so after expanding
 * its sublinks to subplans.  And we don't want any steps in between, else
 * those steps would never get applied to the argument expressions, either in
 * the parent or the child level.
 *
 * Another fairly tricky thing going on here is the handling of SubLinks in
 * the arguments of uplevel PHVs/aggregates.  Those are not touched inside the
 * intermediate query level, either.  Instead, SS_process_sublinks recurses on
 * them after copying the PHV or Aggref expression into the parent plan level
 * (this is actually taken care of in build_subplan).
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>SS_replace_correlation_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No setup needed for tree walk, so away we go */</comment>
	<return>return <expr><call><name>replace_correlation_vars_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_correlation_vars_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_agg</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>replace_correlation_vars_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expand SubLinks to SubPlans in the given expression.
 *
 * The isQual argument tells whether or not this expression is a WHERE/HAVING
 * qualifier expression.  If it is, any sublinks appearing at top level need
 * not distinguish FALSE from UNKNOWN return values.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>SS_process_sublinks</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>process_sublinks_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name>isQual</name></expr>;</expr_stmt>
	<return>return <expr><call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>process_sublinks_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>process_sublinks_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>process_sublinks_context</name></type> <name>locContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>testexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, recursively process the lefthand-side expressions, if any.
		 * They're not top-level anymore.
		 */</comment>
		<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>testexpr</name> <operator>=</operator> <call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now build the SubPlan node and make the expr to return.
		 */</comment>
		<return>return <expr><call><name>make_subplan</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>,
							<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></argument>,
							<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name></expr></argument>,
							<argument><expr><name>testexpr</name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>isTopQual</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't recurse into the arguments of an outer PHV or aggregate here. Any
	 * SubLinks in the arguments have to be dealt with at the outer query
	 * level; they'll be handled when build_subplan collects the PHV or Aggref
	 * into the arguments to be passed down to the current subplan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We should never see a SubPlan expression in the input (since this is
	 * the very routine that creates 'em to begin with).  We shouldn't find
	 * ourselves invoked directly on a Query, either.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Because make_subplan() could return an AND or OR clause, we have to
	 * take steps to preserve AND/OR flatness of a qual.  We assume the input
	 * has been AND/OR flattened and so we need no recursion here.
	 *
	 * (Due to the coding here, we will not get called on the List subnodes of
	 * an AND; and the input is *not* yet in implicit-AND format.  So no check
	 * is needed for a bare List.)
	 *
	 * Anywhere within the top-level AND/OR clause structure, we can tell
	 * make_subplan() that NULL and FALSE are interchangeable.  So isTopQual
	 * propagates down in both cases.  (Note that this is unlike the meaning
	 * of "top level qual" used in most other places in Postgres.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Still at qual top-level */</comment>
		<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>isTopQual</name></name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) node)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newarg</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>newarg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Still at qual top-level */</comment>
		<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>isTopQual</name></name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) node)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newarg</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>newarg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_orclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we recurse down through anything other than an AND or OR node, we
	 * are definitely not at top qual level anymore.
	 */</comment>
	<expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name>process_sublinks_mutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SS_identify_outer_params - identify the Params available from outer levels
 *
 * This must be run after SS_replace_correlation_vars and SS_process_sublinks
 * processing is complete in a given query level as well as all of its
 * descendant levels (which means it's most practical to do it at the end of
 * processing the query level).  We compute the set of paramIds that outer
 * levels will make available to this level+descendants, and record it in
 * root-&gt;outer_params for use while computing extParam/allParam sets in final
 * plan cleanup.  (We can't just compute it then, because the upper levels'
 * plan_params lists are transient and will be gone by then.)
 */</comment>
<function><type><name>void</name></type>
<name>SS_identify_outer_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>outer_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>proot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If no parameters have been assigned anywhere in the tree, we certainly
	 * don't need to do anything here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan all query levels above this one to see which parameters are due to
	 * be available from them, either because lower query levels have
	 * requested them (via plan_params) or because they will be available from
	 * initPlans of those levels.
	 */</comment>
	<expr_stmt><expr><name>outer_params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>proot</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</init> <condition><expr><name>proot</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>proot</name> <operator>=</operator> <name><name>proot</name><operator>-&gt;</operator><name>parent_root</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Include ordinary Var/PHV/Aggref params */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>proot-&gt;plan_params</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>outer_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>, <argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/* Include any outputs of outer-level initPlans */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>proot-&gt;init_plans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>initsubplan-&gt;setParam</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>outer_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
		<comment type="block">/* Include worktable ID, if a recursive query is being planned */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proot</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>outer_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>, <argument><expr><name><name>proot</name><operator>-&gt;</operator><name>wt_param_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>outer_params</name></name> <operator>=</operator> <name>outer_params</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SS_charge_for_initplans - account for initplans in Path costs &amp; parallelism
 *
 * If any initPlans have been created in the current query level, they will
 * get attached to the Plan tree created from whichever Path we select from
 * the given rel.  Increment all that rel's Paths' costs to account for them,
 * and make sure the paths get marked as parallel-unsafe, since we can't
 * currently transmit initPlans to parallel workers.
 *
 * This is separate from SS_attach_initplans because we might conditionally
 * create more initPlans during create_plan(), depending on which Path we
 * select.  However, Paths that would generate such initPlans are expected
 * to have included their cost already.
 */</comment>
<function><type><name>void</name></type>
<name>SS_charge_for_initplans</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>initplan_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if no initPlans */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute the cost increment just once, since it will be the same for all
	 * Paths.  We assume each initPlan gets run once during top plan startup.
	 * This is a conservative overestimate, since in fact an initPlan might be
	 * executed later than plan startup, or even not at all.
	 */</comment>
	<expr_stmt><expr><name>initplan_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;init_plans</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>initplan_cost</name> <operator>+=</operator> <name><name>initsubplan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator> <name><name>initsubplan</name><operator>-&gt;</operator><name>per_call_cost</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now adjust the costs and parallel_safe flags.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name>initplan_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>initplan_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Forget about any partial paths and clear consider_parallel, too;
	 * they're not usable if we attached an initPlan.
	 */</comment>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* We needn't do set_cheapest() here, caller will do it */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SS_attach_initplans - attach initplans to topmost plan node
 *
 * Attach any initplans created in the current query level to the specified
 * plan node, which should normally be the topmost node for the query level.
 * (In principle the initPlans could go in any node at or above where they're
 * referenced; but there seems no reason to put them any lower than the
 * topmost node, so we don't bother to track exactly where they came from.)
 * We do not touch the plan node's cost; the initplans should have been
 * accounted for in path costing.
 */</comment>
<function><type><name>void</name></type>
<name>SS_attach_initplans</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SS_finalize_plan - do final parameter processing for a completed Plan.
 *
 * This recursively computes the extParam and allParam sets for every Plan
 * node in the given plan tree.  (Oh, and RangeTblFunction.funcparams too.)
 *
 * We assume that SS_finalize_plan has already been run on any initplans or
 * subplans the plan tree could reference.
 */</comment>
<function><type><name>void</name></type>
<name>SS_finalize_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No setup needed, just recurse through plan tree. */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>outer_params</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive processing of all nodes in the plan tree
 *
 * gather_param is the rescan_param of an ancestral Gather/GatherMerge,
 * or -1 if there is none.
 *
 * valid_params is the set of param IDs supplied by outer plan levels
 * that are valid to reference in this plan node or its children.
 *
 * scan_params is a set of param IDs to force scan plan nodes to reference.
 * This is for EvalPlanQual support, and is always NULL at the top of the
 * recursion.
 *
 * The return value is the computed allParam set for the given Plan node.
 * This is just an internal notational convenience: we can add a child
 * plan's allParams to the set of param IDs of interest to this level
 * in the same statement that recurses to that child.
 *
 * Do not scribble on caller's values of valid_params or scan_params!
 *
 * Note: although we attempt to deal with initPlans anywhere in the tree, the
 * logic is not really right.  The problem is that a plan node might return an
 * output Param of its initPlan as a targetlist item, in which case it's valid
 * for the parent plan level to reference that same Param; the parent's usage
 * will be converted into a Var referencing the child plan node by setrefs.c.
 * But this function would see the parent's reference as out of scope and
 * complain about it.  For now, this does not matter because the planner only
 * attaches initPlans to the topmost plan node in a query level, so the case
 * doesn't arise.  If we ever merge this processing into setrefs.c, maybe it
 * can be handled more cleanly.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>finalize_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>gather_param</name></decl></parameter>,
			  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>valid_params</name></decl></parameter>,
			  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>scan_params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>finalize_primnode_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>locally_added_param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>nestloop_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>initExtParam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>initSetParam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>child_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* initialize set to empty */</comment>
	<expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* there isn't one */</comment>
	<expr_stmt><expr><name>nestloop_params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* there aren't any */</comment>

	<comment type="block">/*
	 * Examine any initPlans to determine the set of external params they
	 * reference and the set of output params they supply.  (We assume
	 * SS_finalize_plan was run on them already.)
	 */</comment>
	<expr_stmt><expr><name>initExtParam</name> <operator>=</operator> <name>initSetParam</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plan-&gt;initPlan</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>initplan</name> <init>= <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>initsubplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>initExtParam</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>initExtParam</name></expr></argument>, <argument><expr><name><name>initplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>initsubplan-&gt;setParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>initSetParam</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>initSetParam</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* Any setParams are validly referenceable in this node and children */</comment>
	<if_stmt><if>if <condition>(<expr><name>initSetParam</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When we call finalize_primnode, context.paramids sets are automatically
	 * merged together.  But when recursing to self, we have to do it the hard
	 * way.  We want the paramids set to include params in subplans as well as
	 * at this level.
	 */</comment>

	<comment type="block">/* Find params in targetlist and qual */</comment>
	<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a parallel-aware scan node, mark it as dependent on the parent
	 * Gather/GatherMerge's rescan Param.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>gather_param</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel-aware plan node is not below a Gather"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
			<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>gather_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check additional node-type-specific fields */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tablesample</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexorderby</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we need not look at indexqualorig, since it will have the same
			 * param references as indexqual.  Likewise, we can ignore
			 * indexorderbyorig.
			 */</comment>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexorderby</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we need not look at indextlist, since it cannot contain Params.
			 */</comment>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we need not look at indexqualorig, since it will have the same
			 * param references as indexqual.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapqualorig</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tidquals</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>sscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subquery_params</name></decl>;</decl_stmt>

				<comment type="block">/* We must run finalize_plan on the subquery */</comment>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subquery_params</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name><operator>-&gt;</operator><name>outer_params</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>gather_param</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>subquery_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>subquery_params</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>gather_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>gather_param</name></expr></argument>,
							  <argument><expr><name>subquery_params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Now we can add its extParams to the parent's params */</comment>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
												   <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We need scan_params too, though */</comment>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
												   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>fscan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Call finalize_primnode independently on each function
				 * expression, so that we can record which params are
				 * referenced in each, in order to decide which need
				 * re-evaluating during rescan.
				 */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fscan-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>finalize_primnode_context</name></type> <name>funccontext</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>funccontext</name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>funccontext</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* remember results for execution */</comment>
					<expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcparams</name></name> <operator>=</operator> <name><name>funccontext</name><operator>.</operator><name>paramids</name></name></expr>;</expr_stmt>

					<comment type="block">/* add the function's params to the overall set */</comment>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
													   <argument><expr><name><name>funccontext</name><operator>.</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
												   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tablefunc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>values_lists</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CteScan</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * You might think we should add the node's cteParam to
				 * paramids, but we shouldn't because that param is just a
				 * linkage mechanism for multiple CteScan nodes for the same
				 * CTE; it is never used for changed-param signaling.  What we
				 * have to do instead is to find the referenced CTE plan and
				 * incorporate its external paramids, so that the correct
				 * things will happen if the CTE references outer-level
				 * variables.  See test cases for bug #4902.  (We assume
				 * SS_finalize_plan was run on the CTE plan already.)
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>plan_id</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>ctePlanId</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>cteplan</name></decl>;</decl_stmt>

				<comment type="block">/* so, do this ... */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>plan_id</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>plan_id</name></expr></argument> &gt;</argument_list></name> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CteScan referencing plan ID %d"</literal></expr></argument>,
						 <argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>cteplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
					<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name><name>cteplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
				<comment type="block">/* ... but not this */</comment>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
					<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>cteParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
												   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
							   <argument><expr><operator>(</operator><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* We assume fdw_scan_tlist cannot contain Params */</comment>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
												   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We assume custom_scan_tlist cannot contain Params */</comment>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
					<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* child nodes if any */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cscan-&gt;custom_plans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
						<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										<argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
													  <argument><expr><name>valid_params</name></expr></argument>,
													  <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mtplan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<comment type="block">/* Force descendant scan nodes to reference epqParam */</comment>
				<expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>epqParam</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>scan_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* exclRelTlist contains only Vars, doesn't need examination */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>mtplan-&gt;plans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
						<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										<argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
													  <argument><expr><name>valid_params</name></expr></argument>,
													  <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((Append *) plan)-&gt;appendplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
						<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										<argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
													  <argument><expr><name>valid_params</name></expr></argument>,
													  <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((MergeAppend *) plan)-&gt;mergeplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
						<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										<argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
													  <argument><expr><name>valid_params</name></expr></argument>,
													  <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BitmapAnd *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
						<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										<argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
													  <argument><expr><name>valid_params</name></expr></argument>,
													  <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BitmapOr *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
						<call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										<argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
													  <argument><expr><name>valid_params</name></expr></argument>,
													  <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* collect set of params that will be passed to right child */</comment>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((NestLoop *) plan)-&gt;nestParams</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>nestloop_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nestloop_params</name></expr></argument>,
													 <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeclauses</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>hashclauses</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Limit</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limitOffset</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limitCount</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<comment type="block">/* child nodes are allowed to reference wtParam */</comment>
			<expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RecursiveUnion</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>wtParam</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* wtParam does *not* get added to scan_params */</comment>
			<break>break;</break>

		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<comment type="block">/* Force descendant scan nodes to reference epqParam */</comment>
			<expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>epqParam</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scan_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Agg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * AGG_HASHED plans need to know which Params are referenced
				 * in aggregate calls.  Do a separate scan to identify them.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>finalize_primnode_context</name></type> <name>aggcontext</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>aggcontext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>aggcontext</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>finalize_agg_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>finalize_agg_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggParams</name></name> <operator>=</operator> <name><name>aggcontext</name><operator>.</operator><name>paramids</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>startOffset</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>endOffset</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Gather</name></expr>:</case>
			<comment type="block">/* child nodes are allowed to reference rescan_param, if any */</comment>
			<expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>rescan_param</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>locally_added_param</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We currently don't support nested Gathers.  The issue so
				 * far as this function is concerned would be how to identify
				 * which child nodes depend on which Gather.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gather_param</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Pass down rescan_param to child parallel-aware nodes */</comment>
				<expr_stmt><expr><name>gather_param</name> <operator>=</operator> <name>locally_added_param</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* rescan_param does *not* get added to scan_params */</comment>
			<break>break;</break>

		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<comment type="block">/* child nodes are allowed to reference rescan_param, if any */</comment>
			<expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>GatherMerge</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>rescan_param</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>locally_added_param</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We currently don't support nested Gathers.  The issue so
				 * far as this function is concerned would be how to identify
				 * which child nodes depend on which Gather.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gather_param</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Pass down rescan_param to child parallel-aware nodes */</comment>
				<expr_stmt><expr><name>gather_param</name> <operator>=</operator> <name>locally_added_param</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* rescan_param does *not* get added to scan_params */</comment>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_Group</name></expr>:</case>
			<comment type="block">/* no node-type-specific fields need fixing */</comment>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Process left and right child plans, if any */</comment>
	<expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
								 <argument><expr><name>gather_param</name></expr></argument>,
								 <argument><expr><name>valid_params</name></expr></argument>,
								 <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>child_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nestloop_params</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* right child can reference nestloop_params as well as valid_params */</comment>
		<expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>,
									 <argument><expr><name>gather_param</name></expr></argument>,
									 <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name>nestloop_params</name></expr></argument>, <argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... and they don't count as parameters used at my level */</comment>
		<expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>child_params</name></expr></argument>, <argument><expr><name>nestloop_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>nestloop_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* easy case */</comment>
		<expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>,
									 <argument><expr><name>gather_param</name></expr></argument>,
									 <argument><expr><name>valid_params</name></expr></argument>,
									 <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>child_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Any locally generated parameter doesn't count towards its generating
	 * plan node's external dependencies.  (Note: if we changed valid_params
	 * and/or scan_params, we leak those bitmapsets; not worth the notational
	 * trouble to clean them up.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>locally_added_param</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
										  <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now we have all the paramids referenced in this node and children */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan should not reference subplan's variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The plan node's allParam and extParam fields should include all its
	 * referenced paramids, plus contributions from any child initPlans.
	 * However, any setParams of the initPlans should not be present in the
	 * parent node's extParams, only in its allParams.  (It's possible that
	 * some initPlans have extParams that are setParams of other initPlans.)
	 */</comment>

	<comment type="block">/* allParam must include initplans' extParams and setParams */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>initExtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* extParam must include any initplan extParams */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>initExtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* but not any initplan setParams */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For speed at execution time, make sure extParam/allParam are actually
	 * NULL if they are empty sets.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_primnode: add IDs of all PARAM_EXEC params appearing in the given
 * expression tree to the result set.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>finalize_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramid</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* no more to do here */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subparamids</name></decl>;</decl_stmt>

		<comment type="block">/* Recurse into the testexpr, but not into the Plan */</comment>
		<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remove any param IDs of output parameters of the subplan that were
		 * referenced in the testexpr.  These are not interesting for
		 * parameter change signaling since we always re-evaluate the subplan.
		 * Note that this wouldn't work too well if there might be uses of the
		 * same param IDs elsewhere in the plan, but that can't happen because
		 * generate_new_exec_param never tries to merge params.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;paramIds</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>,
											   <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Also examine args list */</comment>
		<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add params needed by the subplan to paramids, but excluding those
		 * we will pass down to it.  (We assume SS_finalize_plan was run on
		 * the subplan already.)
		 */</comment>
		<expr_stmt><expr><name>subparamids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;parParam</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>subparamids</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>subparamids</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>subparamids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* no more to do here */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>finalize_primnode</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_agg_primnode: find all Aggref nodes in the given expression tree,
 * and add IDs of all PARAM_EXEC params appearing within their aggregated
 * arguments to the result set.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>finalize_agg_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we should not consider the direct arguments, if any */</comment>
		<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* there can't be any Aggrefs below here */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>finalize_agg_primnode</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SS_make_initplan_output_param - make a Param for an initPlan's output
 *
 * The plan is expected to return a scalar value of the given type/collation.
 *
 * Note that in some cases the initplan may not ever appear in the finished
 * plan tree.  If that happens, we'll have wasted a PARAM_EXEC slot, which
 * is no big deal.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>SS_make_initplan_output_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>resulttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>resulttypmod</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>resultcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>generate_new_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>resulttype</name></expr></argument>,
								   <argument><expr><name>resulttypmod</name></expr></argument>, <argument><expr><name>resultcollation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SS_make_initplan_from_plan - given a plan tree, make it an InitPlan
 *
 * We build an EXPR_SUBLINK SubPlan node and put it into the initplan
 * list for the outer query level.  A Param that represents the initplan's
 * output has already been assigned using SS_make_initplan_output_param.
 */</comment>
<function><type><name>void</name></type>
<name>SS_make_initplan_from_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
						   <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>prm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Add the subplan and its PlannerInfo to the global lists.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a SubPlan node and add it to the outer list of InitPlans. Note
	 * it has to appear after any other InitPlans it might depend on (see
	 * comments in ExecReScan).
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>EXPR_SUBLINK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"InitPlan %d (returns $%d)"</literal></expr></argument>,
							   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_first_col_type</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The node can't have any inputs (since it's an initplan), so the
	 * parParam and args lists remain empty.
	 */</comment>

	<comment type="block">/* Set costs of SubPlan using info from the plan tree */</comment>
	<expr_stmt><expr><call><name>cost_subplan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
