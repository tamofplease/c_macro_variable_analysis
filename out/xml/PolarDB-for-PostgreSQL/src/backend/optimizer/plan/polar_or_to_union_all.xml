<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/plan/polar_or_to_union_all.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_or_to_union_all.c
 *	  Consider whether join OR clauses can be converted to UNION ALL queries.
 *
 * This module looks for OR clauses whose arms each reference a single
 * query relation (but not all the same rel), and tries to generate a path
 * representing conversion of such an OR clause into a UNION ALL operation.
 * For example,
 *		SELECT ... FROM a, b WHERE (cond-on-A OR cond-on-B) AND other-conds
 * can be implemented as
 *		SELECT ... FROM a, b WHERE cond-on-A AND other-conds
 *		UNION ALL
 *		SELECT ... FROM a, b WHERE cond-on-B AND other-conds
 *			AND (NOT (cond-on-A) OR (cond-on-A) IS NULL)
 * given a suitable definition of "UNION ALL" (one that won't merge rows that
 * would have been separate in the original query output).  Since this change
 * converts join clauses into restriction clauses, the modified query can be
 * much faster to run than the original, despite the duplication of effort
 * involved and the extra UNION ALL processing.  It's particularly useful for
 * star-schema queries where the OR arms reference different dimension tables;
 * each separated query may be able to remove joins to all but one dimension
 * table, and arrange that join to use an inner indexscan on the fact table.
 *
 * We must insist that the WHERE and JOIN/ON clauses contain no volatile
 * functions, because of the likelihood that qual clauses will be evaluated
 * more times than a naive programmer would expect.  We need not restrict
 * the SELECT's tlist, because that will be evaluated after the UNION ALL.
 *
 * Portions Copyright (c) 2020, Alibaba inc.
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/polar_or_to_union_all.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_is_suitable_join_or_clause</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>orclause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_is_query_safe_for_union_or_transform</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>polar_create_union_or_subpaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>orclause</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>armrelids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_union_or_qp_callback</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * split_join_or_clauses - create paths based on splitting join OR clauses
 *
 * This should be called by grouping_planner() just before it's ready to call
 * query_planner(), because we generate simplified join paths by cloning the
 * planner's state and invoking query_planner() on a modified version of
 * the query parsetree.  Thus, all preprocessing needed before query_planner()
 * must already be done.  Note however that we repeat reduce_outer_joins()
 * because of the possibility that the simplified WHERE clause allows reduction
 * of an outer join to inner-join form.  That's okay for now, but maybe we
 * * should move the reduce_outer_joins() call into query_planner()?
 *
 * The result is a list (one entry per potential union OR path) of sublists of
 * best paths for the inputs to the UNION ALL step.  Adding the UNION ALL 
 * processing is retty mechanical, but we can't do it until we have a RelOptInfo 
 * for the top-level join rel.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>polar_split_join_or_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>results</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checked_query</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * At least for now, we restrict this optimization to plain SELECTs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>||</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The query must reference multiple tables, else we certainly aren't
	 * going to find any suitable OR clauses.  Do a quick check that there's
	 * more than one RTE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan the top-level WHERE clause looking for suitable OR clauses, and
	 * for each one, generate paths for the UNION ALL input sub-queries. There
	 * might be more than one suitable OR clause, in which case we can try the
	 * transformation for each one of them separately and add that list of
	 * paths to the results.
	 *
	 * XXX we should also search the JOIN/ON clauses of any top-level inner
	 * JOIN nodes, since those are semantically equivalent to WHERE.  But it's
	 * hard to see how to do that without either copying the whole JOIN tree
	 * in advance or repeating the search after copying, and neither of those
	 * options seems attractive.
	 */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) parse-&gt;jointree-&gt;quals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>armrelids</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>polar_is_suitable_join_or_clause</name><argument_list>(<argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>armrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Check that the query as a whole is safe for this optimization.
			 * We only need to do this once, but it's somewhat expensive, so
			 * don't do it till we find a candidate OR clause.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>checked_query</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_query_safe_for_union_or_transform</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>checked_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* OK, transform the query and create a list of sub-paths */</comment>
			<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <call><name>polar_create_union_or_subpaths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>,
												<argument><expr><name>n</name></expr></argument>, <argument><expr><name>armrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>results</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finish constructing Paths representing the UNION ALL implementation of join
 * OR clause(s), and attach them to "joinrel", which is the final scan/join
 * relation returned by query_planner() for the conventional implementation of
 * the query.  "union_or_subpaths" is the output of split_join_or_clauses().
 */</comment>
<function><type><name>void</name></type>
<name>polar_finish_union_or_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>union_or_subpaths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* This loop iterates once per splittable OR clause */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>union_or_subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>common_exprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>common_target</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>appendpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This coding assumes that the commonly available Vars will appear in
		 * the same order in each subpath target, which should be true but
		 * it's surely an implementation artifact.  If it stops being true, we
		 * could fall back on list_intersection(), but that'd be O(N^3).
		 */</comment>
		<expr_stmt><expr><name>common_exprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>for_each_cell</name><argument_list>(<argument>lc2</argument>, <argument>lnext(list_head(subpaths))</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prevc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lcs</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prevc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lcc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>common_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>lcc</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nextc</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>lcs</name> <operator>&amp;&amp;</operator> <call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>lcs</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>prevc</name> <operator>=</operator> <name>lcc</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<comment type="block">/*no cover line*/</comment>
					<expr_stmt><expr><name>common_exprs</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>common_exprs</name></expr></argument>, <argument><expr><name>lcc</name></expr></argument>, <argument><expr><name>prevc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>lcc</name> <operator>=</operator> <name>nextc</name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block>
		<expr_stmt><expr><name>common_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>common_target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <name>common_exprs</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>common_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Now forcibly apply this target to each subpath */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>joinrel</name></expr></argument>,
												 <argument><expr><name>subpath</name></expr></argument>,
												 <argument><expr><name>common_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Generate Append path combining the sub-paths for this UNION.  The
		 * Append path's pathtarget has to match what is actually coming out
		 * of the subpaths, since Append can't project.
		 */</comment>
		<expr_stmt><expr><name>appendpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrel</name></expr></argument>, <argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendpath</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name>common_target</name></expr>;</expr_stmt>

		<comment type="block">/* Attach it to the joinrel */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>appendpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* We need to refigure which is the cheapest path for the joinrel */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>joinrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is this OR clause a suitable clause for splitting?
 *
 * Each of its arms must reference just one rel, and they must not all be
 * the same rel.
 * On success, pass back a list of the relids referenced by each OR arm,
 * so we don't have to repeat the pull_varnos() work later.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_is_suitable_join_or_clause</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>orclause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relidlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstrelid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>				<comment type="block">/* prevent uninitialized-variable warnings */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>orclause-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>varnos</name> <init>= <expr><call><name>pull_varnos</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>relid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_get_singleton_member</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this arm fails the sine qua non */</comment>
		<if_stmt><if>if <condition>(<expr><name>relidlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>firstrelid</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>firstrelid</name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* arms reference more than one relid */</comment>
		<expr_stmt><expr><name>relidlist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>relidlist</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <name>relidlist</name></expr>;</expr_stmt>
	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is query as a whole safe to apply union OR transformation to?
 * This checks relatively-expensive conditions that we don't want to
 * worry about until we've found a candidate OR clause.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_is_query_safe_for_union_or_transform</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>allbaserels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must not have any volatile functions in FROM or WHERE (see notes at
	 * head of file).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>allbaserels</name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* ignore RTEs that aren't referenced baserels */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>allbaserels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* disallow TABLESAMPLE (might be okay if repeatable?) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* check for volatiles in security barrier quals */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* OK to proceed */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Split the query and the given OR clause into one UNION ALL arm per relation
 * mentioned in the OR clause, and make a list of best paths for the UNION ALL
 * arms.  (Since the UNION ALL step will lose any ordering or fast-start
 * properties of the paths, there's no need to consider any but the
 * cheapest-total path for each arm; hence it's okay to return just one path
 * per arm.)
 *
 * "n" is the OR clause's index in the query's WHERE list.
 * "armrelids" is the OR-arm-to-referenced-rel mapping.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>polar_create_union_or_subpaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>orclause</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>armrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>orrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dedup_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * There might be multiple OR arms referring to the same rel, which we
	 * should combine into a restriction OR clause.  So first identify the set
	 * of rels used in the OR.
	 */</comment>
	<expr_stmt><expr><name>orrels</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>armrelids</argument>)</argument_list></macro>
		<expr_stmt><expr><name>orrels</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>orrels</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now, for each such rel, generate a path for a UNION ALL arm */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>orrels</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>orarms</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subquery_quals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasOuterJoins</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>not_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>isnull_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>dedup_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Extract the OR arms for this rel, making copies for safety */</comment>
		<expr_stmt><expr><name>orarms</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>orclause-&gt;args</argument>, <argument>lc2</argument>, <argument>armrelids</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>qualrelid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>qualrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>orarms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>orarms</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>orarms</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>orarms</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When there's just a single arm for this rel (the typical case),
			 * it goes directly into the subquery's WHERE list.  But it might
			 * be a sub-AND, in which case we must flatten it into a qual list
			 * to preserve AND/OR flatness.
			 */</comment>
			<expr_stmt><expr><name>orarms</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>orarms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * When there's more than one arm, convert back to an OR clause.
			 * No flatness worries here; the arms were already valid OR-list
			 * elements.
			 */</comment>
			<expr_stmt><expr><name>orarms</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>orarms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Clone the planner's state */</comment>
		<expr_stmt><expr><name>subroot</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>parse</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Making copies of these might be overkill, but be safe */</comment>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Tell query_planner to expect full retrieval of UNION input */</comment>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remove the subquery's copy of the original OR clause, which we
		 * identify by its index in the WHERE clause list.
		 */</comment>
		<expr_stmt><expr><name>subquery_quals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subquery_quals</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <name>n</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>subquery_quals</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>subquery_quals</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* make NOT qual, it must before list_concat() modifiy orarms */</comment>
		<expr_stmt><expr><name>not_qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>orarms</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And instead add the qual or quals we extracted from the OR clause */</comment>
		<expr_stmt><expr><name>subquery_quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subquery_quals</name></expr></argument>, <argument><expr><name>orarms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subquery_quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subquery_quals</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>dedup_quals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make IS NULL qual */</comment>
		<expr_stmt><expr><name>isnull_qual</name> <operator>=</operator> <operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull_qual</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>orarms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull_qual</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull_qual</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>dedup_qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, 
										   <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>not_qual</name></expr></argument>, <argument><expr><name>isnull_qual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dedup_quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dedup_quals</name></expr></argument>, <argument><expr><name>dedup_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subquery_quals</name></expr>;</expr_stmt>

		<comment type="block">/* Re-apply reduce_outer_joins() in case we can now reduce some */</comment>
		<comment type="block">/* (XXX would be better if this just got moved into query_planner) */</comment>
		<expr_stmt><expr><name>hasOuterJoins</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>hasOuterJoins</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>hasOuterJoins</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>reduce_outer_joins</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Plan the modified query */</comment>
		<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>query_planner</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>,
								  <argument><expr><name>polar_union_or_qp_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the cheapest-total path for the subquery; there's little value
		 * in considering any others.
		 */</comment>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add cheapest-total path to subpaths list */</comment>
		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>subpaths</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute query_pathkeys and other pathkeys during plan generation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_union_or_qp_callback</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since the output of the subquery is going to go through a UNION ALL step
	 * that destroys ordering, there's little need to worry about what its
	 * output order is.  Hence, don't bother telling it about pathkeys that
	 * might apply to these later execution steps.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
