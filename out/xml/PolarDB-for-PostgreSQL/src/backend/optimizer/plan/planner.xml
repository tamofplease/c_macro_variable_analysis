<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/optimizer/plan/planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * planner.c
 *	  The query optimizer external interface.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/optimizer/plan/planner.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/bipartite_match.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/knapsack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paramassign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/px_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>


<comment type="block">/* GUC parameters */</comment>
<decl_stmt><decl><type><name>double</name></type>		<name>cursor_tuple_fraction</name> <init>= <expr><name>DEFAULT_CURSOR_TUPLE_FRACTION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>force_parallel_mode</name> <init>= <expr><name>FORCE_PARALLEL_OFF</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>parallel_leader_participation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control in planner() */</comment>
<decl_stmt><decl><type><name>planner_hook_type</name></type> <name>planner_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control when grouping_planner() plans upper rels */</comment>
<decl_stmt><decl><type><name>create_upper_paths_hook_type</name></type> <name>create_upper_paths_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Bool for Insert PX Planner */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>found_insert_select</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Expression kind codes for preprocess_expression */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_QUAL</name></cpp:macro>				<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TARGET</name></cpp:macro>				<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_RTFUNC</name></cpp:macro>				<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_RTFUNC_LATERAL</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_VALUES</name></cpp:macro>				<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_VALUES_LATERAL</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_LIMIT</name></cpp:macro>				<cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_APPINFO</name></cpp:macro>			<cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_PHV</name></cpp:macro>				<cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TABLESAMPLE</name></cpp:macro>		<cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_ARBITER_ELEM</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TABLEFUNC</name></cpp:macro>			<cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TABLEFUNC_LATERAL</name></cpp:macro>	<cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* Passthrough data for standard_qp_callback */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>			<comment type="block">/* preprocessed query targetlist */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>activeWindows</name></decl>;</decl_stmt>	<comment type="block">/* active windows, if any */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClause</name></decl>;</decl_stmt>	<comment type="block">/* overrides parse-&gt;groupClause */</comment>
}</block></struct></type> <name>standard_qp_extra</name>;</typedef>

<comment type="block">/*
 * Data specific to grouping sets
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rollups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hash_sets_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumHashGroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>any_hashable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>unsortable_refs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>unhashable_refs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>unsortable_sets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tleref_to_colnum_map</name></decl>;</decl_stmt>
}</block></struct></type> <name>grouping_sets_data</name>;</typedef>

<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>preprocess_expression</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>preprocess_qual_conditions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inheritance_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>grouping_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inheritance_update</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>grouping_sets_data</name> <modifier>*</modifier></type><name>preprocess_grouping_sets</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>remap_to_groupclause_idx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gsets</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tleref_to_colnum_map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>preprocess_rowmarks</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>preprocess_limit</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>count_est</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_useless_groupby_columns</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>preprocess_groupclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>extract_rollup_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>reorder_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortclause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_qp_callback</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>get_number_of_groups</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>path_rows</name></decl></parameter>,
					 <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>estimate_hashagg_tablesize</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
					  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_degenerate_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_degenerate_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>make_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
				  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_ordinary_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
							   <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							   <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>partially_grouped_rel_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consider_groupingsets_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
							<parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
							<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_window_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
					<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>output_target_parallel_safe</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					<parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_one_window_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>window_rel</name></decl></parameter>,
					   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_distinct_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_ordered_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_group_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_partial_grouping_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>postprocess_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>select_active_windows</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_window_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_pathkeys_for_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_sort_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_postponed_srfs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjust_paths_for_srfs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets_contain_srfs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_paths_to_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
						  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
						  <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>,
						  <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_partial_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
							  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							  <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>force_rel_creation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gather_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_partial_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apply_scanjoin_target_to_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanjoin_targets</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanjoin_targets_contain_srfs</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>scanjoin_target_parallel_safe</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>tlist_same_exprs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_partitionwise_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
									<parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
									<parameter><decl><type><name>PartitionwiseAggregateType</name></type> <name>patype</name></decl></parameter>,
									<parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>group_by_has_partkey</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR px */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tag_should_jit</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pxopt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_hit_function_oid</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_disable_px_planner_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_ignore_functions_checker</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>func_oid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_returns_set_func</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_not_supported_func</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_supported_func_checker</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* refer from trigger.c */</comment>
<function_decl><type><name>Datum</name></type> <name>pg_trigger_depth</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* POLAR end */</comment>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	   Query optimizer entry point
 *
 * To support loadable plugins that monitor or modify planner behavior,
 * we provide a hook variable that lets a plugin get control before and
 * after the standard planning process.  The plugin would normally call
 * standard_planner().
 *
 * Note to plugin authors: standard_planner() scribbles on its Query input,
 * so you'd better copy that data structure if you want to plan more than once.
 *
 *****************************************************************************/</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planner_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>planner_hook</name>) <argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>standard_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tuple_fraction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>top_plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * POLAR px: Entry of using PXOPT planner. should_px_planner make some
	 * rules, only the parse tree matches the rules can go to PXOPT and get a
	 * parallel planner.
	 */</comment>
	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name>local_px_insert_dop_num</name> <operator>=</operator> <name>px_insert_dop_num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_workerid_funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_PX_OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>should_px_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>px_is_planning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>px_optimize_query</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>px_enable_executor</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tag_should_jit</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>px_is_planning</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* POLAR px: Get a NON-PX plan, but it force to get a PX plan */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_PX_FORCE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected a PX plan but get a normal PG plan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * POLAR px: Reset the CURSOR_OPT_PX_OK option to make the
	 * context consistent
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_PX_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cursorOptions</name> <operator>&amp;=</operator> <operator>~</operator><name>CURSOR_OPT_PX_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_use_global_function</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only support polar_global_function under px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up global state for this planner invocation.  This data is needed
	 * across all levels of sub-Query that might exist in the given command,
	 * so we keep it in a separate struct that's linked to by each per-Query
	 * PlannerInfo.
	 */</comment>
	<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>boundParams</name></name> <operator>=</operator> <name>boundParams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>lastPHId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>lastRowMarkId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>lastPlanNodeId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assess whether it's feasible to use parallel mode for this query. We
	 * can't do this in a standalone backend, or if the command will try to
	 * modify any data, or if this is a cursor operation, or if GUCs are set
	 * to values that don't permit parallelism, or if parallel-unsafe
	 * functions are present in the query tree.
	 *
	 * (Note that we do allow CREATE TABLE AS, SELECT INTO, and CREATE
	 * MATERIALIZED VIEW to use parallel plans, but this is safe only because
	 * the command is writing into a completely new table which workers won't
	 * be able to see.  If the workers could see the table, the fact that
	 * group locking would cause them to ignore the leader's heavyweight
	 * relation extension lock and GIN page locks would make this unsafe.
	 * We'll have to fix that somehow if we want to allow parallel inserts in
	 * general; updates and deletes have additional problems especially around
	 * combo CIDs.)
	 *
	 * For now, we don't try to use parallel mode if we're running inside a
	 * parallel worker.  We might eventually be able to relax this
	 * restriction, but for now it seems best not to have parallel workers
	 * trying to create their own parallel workers.
	 *
	 * We can't use parallelism in serializable mode because the predicate
	 * locking code is not parallel-aware.  It's not catastrophic if someone
	 * tries to run a parallel plan in serializable mode; it just won't get
	 * any workers and will run serially.  But it seems like a good heuristic
	 * to assume that the same serialization level will be in effect at plan
	 * time and execution time, so don't generate a parallel plan if we're in
	 * serializable mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_PARALLEL_OK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
		<name>dynamic_shared_memory_type</name> <operator>!=</operator> <name>DSM_IMPL_NONE</name> <operator>&amp;&amp;</operator>
		<name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>&amp;&amp;</operator>
		<name>max_parallel_workers_per_gather</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all the cheap tests pass, so scan the query tree */</comment>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>=</operator> <call><name>max_parallel_hazard</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>=</operator> <operator>(</operator><name><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* skip the query tree scan, just assume it's unsafe */</comment>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>=</operator> <name>PROPARALLEL_UNSAFE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * glob-&gt;parallelModeNeeded is normally set to false here and changed to
	 * true during plan creation if a Gather or Gather Merge plan is actually
	 * created (cf. create_gather_plan, create_gather_merge_plan).
	 *
	 * However, if force_parallel_mode = on or force_parallel_mode = regress,
	 * then we impose parallel mode whenever it's safe to do so, even if the
	 * final plan doesn't use parallelism.  It's not safe to do so if the
	 * query contains anything parallel-unsafe; parallelModeOK will be false
	 * in that case.  Note that parallelModeOK can't change after this point.
	 * Otherwise, everything in the query is either parallel-safe or
	 * parallel-restricted, and in either case it should be OK to impose
	 * parallel-mode restrictions.  If that ends up breaking something, then
	 * either some function the user included in the query is incorrectly
	 * labelled as parallel-safe or parallel-restricted when in reality it's
	 * parallel-unsafe, or else the query planner itself has a bug.
	 */</comment>
	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>force_parallel_mode</name> <operator>!=</operator> <name>FORCE_PARALLEL_OFF</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Determine what fraction of the plan is likely to be scanned */</comment>
	<if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_FAST_PLAN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have no real idea how many tuples the user will ultimately FETCH
		 * from a cursor, but it is often the case that he doesn't want 'em
		 * all, or would prefer a fast-start plan anyway so that he can
		 * process some of the tuples sooner.  Use a GUC parameter to decide
		 * what fraction to optimize for.
		 */</comment>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>cursor_tuple_fraction</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We document cursor_tuple_fraction as simply being a fraction, which
		 * means the edge cases 0 and 1 have to be treated specially here.  We
		 * convert 1 to 0 ("all the tuples") and 0 to a very small fraction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>tuple_fraction</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">1e-10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Default assumption is we need all the tuples */</comment>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* primary planning entry point (may recurse for subqueries) */</comment>
	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select best Path and turn it into a Plan */</comment>
	<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>get_cheapest_fractional_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If creating a plan for a scrollable cursor, make sure it can run
	 * backwards on demand.  Add a Material node at the top at need.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>materialize_finished_plan</name><argument_list>(<argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Optionally add a Gather node for testing purposes, provided this is
	 * actually a safe thing to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>force_parallel_mode</name> <operator>!=</operator> <name>FORCE_PARALLEL_OFF</name> <operator>&amp;&amp;</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Gather</name>	   <modifier>*</modifier></type><name>gather</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there are any initPlans attached to the formerly-top plan node,
		 * move them up to the Gather node; same as we do for Material node in
		 * materialize_finished_plan.
		 */</comment>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>initPlan</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>top_plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>top_plan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>invisible</name></name> <operator>=</operator> <operator>(</operator><name>force_parallel_mode</name> <operator>==</operator> <name>FORCE_PARALLEL_REGRESS</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since this Gather has no parallel-aware descendants to signal to,
		 * we don't need a rescan Param.
		 */</comment>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>rescan_param</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ideally we'd use cost_gather here, but setting up dummy path data
		 * to satisfy it doesn't seem much cleaner than knowing what it does.
		 */</comment>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
			<name>parallel_setup_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
			<name>parallel_setup_cost</name> <operator>+</operator> <name>parallel_tuple_cost</name> <operator>*</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* use parallel mode for parallel plans. */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>top_plan</name> <operator>=</operator> <operator>&amp;</operator><name><name>gather</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If any Params were generated, run through the plan tree and compute
	 * each plan node's extParam/allParam sets.  Ideally we'd merge this into
	 * set_plan_references' tree traversal, but for now it has to be separate
	 * because we need to visit subplans before not after main plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SS_finalize_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>SS_finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* final cleanup of the plan */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>set_plan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... and the subplans (both regular subplans and initplans) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_references</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* build the PlannedStmt result */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>transientPlan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <name>top_plan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>paramExecTypes</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr>;</expr_stmt>
	<comment type="block">/* utilityStmt should be null, but we might as well copy it */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tag_should_jit</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*--------------------
 * subquery_planner
 *	  Invokes the planner on a subquery.  We recurse to here for each
 *	  sub-SELECT found in the query tree.
 *
 * glob is the global state for the current planner run.
 * parse is the querytree produced by the parser &amp; rewriter.
 * parent_root is the immediate parent Query's info (NULL at the top level).
 * hasRecursion is true if this is a recursive WITH query.
 * tuple_fraction is the fraction of tuples we expect will be retrieved.
 * tuple_fraction is interpreted as explained for grouping_planner, below.
 *
 * Basically, this routine does the stuff that should only be done once
 * per Query object.  It then calls grouping_planner.  At one time,
 * grouping_planner could be invoked recursively on the same Query object;
 * that's not currently true, but we keep the separation between the two
 * routines anyway, in case we need it again someday.
 *
 * subquery_planner will be called recursively to handle sub-Query nodes
 * found within the query's expressions and rangetable.
 *
 * Returns the PlannerInfo struct ("root") that contains all data generated
 * while planning the subquery.  In particular, the Path(s) attached to
 * the (UPPERREL_FINAL, NULL) upperrel represent our conclusions about the
 * cheapest way(s) to implement the query.  The top level will select the
 * best Path and pass it through createplan.c to produce a finished Plan.
 *--------------------
 */</comment>
<function><type><name>PlannerInfo</name> <modifier>*</modifier></type>
<name>subquery_planner</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
				 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>parent_root</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>hasRecursion</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newWithCheckOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newHaving</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasOuterJoins</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Create a PlannerInfo data structure for this subquery */</comment>
	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>parse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <ternary><condition><expr><name>parent_root</name></expr> ?</condition><then> <expr><name><name>parent_root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name> <operator>=</operator> <name>parent_root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>outer_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_rels</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_rels</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>=</operator> <name>INHKIND_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name> <operator>=</operator> <name>hasRecursion</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasRecursion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a WITH list, process each WITH query and either convert it
	 * to RTE_SUBQUERY RTE(s) or build an initplan SubPlan structure for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SS_process_ctes</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look for ANY and EXISTS SubLinks in WHERE and JOIN/ON clauses, and try
	 * to transform them into joins.  Note that this step does not descend
	 * into subqueries; if we pull up any subqueries below, their SubLinks are
	 * processed just before pulling them up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pull_up_sublinks</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan the rangetable for set-returning functions, and inline them if
	 * possible (producing subqueries that might get pulled up next).
	 * Recursion issues here are handled in the same way as for SubLinks.
	 */</comment>
	<expr_stmt><expr><call><name>inline_set_returning_functions</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if any subqueries in the jointree can be merged into this
	 * query.
	 */</comment>
	<expr_stmt><expr><call><name>pull_up_subqueries</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a simple UNION ALL query, flatten it into an appendrel. We
	 * do this now because it requires applying pull_up_subqueries to the leaf
	 * queries of the UNION ALL, which weren't touched above because they
	 * weren't referenced by the jointree (they will be after we do this).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>flatten_simple_union_all</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Detect whether any rangetable entries are RTE_JOIN kind; if not, we can
	 * avoid the expense of doing flatten_join_alias_vars().  Also check for
	 * outer joins --- if none, we can skip reduce_outer_joins().  And check
	 * for LATERAL RTEs, too.  This must be done after we have done
	 * pull_up_subqueries(), of course.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasOuterJoins</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasOuterJoins</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Preprocess RowMark information.  We need to do this after subquery
	 * pullup (so that all non-inherited RTEs are present) and before
	 * inheritance expansion (so that the info is available for
	 * expand_inherited_tables to examine and modify).
	 */</comment>
	<expr_stmt><expr><call><name>preprocess_rowmarks</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Expand any rangetable entries that are inheritance sets into "append
	 * relations".  This can add entries to the rangetable, but they must be
	 * plain base relations not joins, so it's OK (and marginally more
	 * efficient) to do it after checking for join RTEs.  We must do it after
	 * pulling up subqueries, else we'd fail to handle inherited tables in
	 * subqueries.
	 */</comment>
	<expr_stmt><expr><call><name>expand_inherited_tables</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set hasHavingQual to remember if HAVING clause is present.  Needed
	 * because preprocess_expression will reduce a constant-true condition to
	 * an empty qual list ... but "HAVING TRUE" is not a semantic no-op.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Clear this flag; might get set in distribute_qual_to_rels */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do expression preprocessing on targetlist and quals, as well as other
	 * random expressions in the querytree.  Note that we do not need to
	 * handle sort/group expressions explicitly, because they are actually
	 * part of the targetlist.
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							  <argument><expr><name>EXPRKIND_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Constant-folding might have removed all set-returning functions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newWithCheckOptions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;withCheckOptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
										  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newWithCheckOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newWithCheckOptions</name></expr></argument>, <argument><expr><name>wco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name> <operator>=</operator> <name>newWithCheckOptions</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>,
							  <argument><expr><name>EXPRKIND_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
											  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* partitionClause/orderClause are sort/group expressions */</comment>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
												<argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
											  <argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
											   <argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
											  <argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterElems</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_ARBITER_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name> <operator>=</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* exclRelTlist contains only Vars, so no preprocessing needed */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>,
							  <argument><expr><name>EXPRKIND_APPINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also need to preprocess expressions within RTEs */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>kind</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcsq</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator>
					<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>,
										  <argument><expr><name>EXPRKIND_TABLESAMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We don't want to do all preprocessing yet on the subquery's
			 * expressions, since that will happen when we plan it.  But if it
			 * contains any join aliases of our level, those have to get
			 * expanded now, because planning of the subquery won't do it.
			 * That's only possible if the subquery is LATERAL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator>
					<call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Preprocess the function expression(s) fully */</comment>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then> <expr><name>EXPRKIND_RTFUNC_LATERAL</name></expr> </then><else>: <expr><name>EXPRKIND_RTFUNC</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
				<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Preprocess the function expression(s) fully */</comment>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then> <expr><name>EXPRKIND_TABLEFUNC_LATERAL</name></expr> </then><else>: <expr><name>EXPRKIND_TABLEFUNC</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator>
				<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Preprocess the values lists fully */</comment>
			<expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then> <expr><name>EXPRKIND_VALUES_LATERAL</name></expr> </then><else>: <expr><name>EXPRKIND_VALUES</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
				<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Process each element of the securityQuals list as if it were a
		 * separate qual expression (as indeed it is).  We need to do it this
		 * way to get proper canonicalization of AND/OR structure.  Note that
		 * this converts each element into an implicit-AND sublist.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lcsq</argument>, <argument>rte-&gt;securityQuals</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcsq</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcsq</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * Now that we are done preprocessing expressions, and in particular done
	 * flattening join alias variables, get rid of the joinaliasvars lists.
	 * They no longer match what expressions in the rest of the tree look
	 * like, because we have not preprocessed expressions in those lists (and
	 * do not want to; for example, expanding a SubLink there would result in
	 * a useless unreferenced subplan).  Leaving them in place simply creates
	 * a hazard for later scans of the tree.  We could try to prevent that by
	 * using QTW_IGNORE_JOINALIASES in every tree scan done after this point,
	 * but that doesn't sound very reliable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In some cases we may want to transfer a HAVING clause into WHERE. We
	 * cannot do so if the HAVING clause contains aggregates (obviously) or
	 * volatile functions (since a HAVING clause is supposed to be executed
	 * only once per group).  We also can't do this if there are any nonempty
	 * grouping sets; moving such a clause into WHERE would potentially change
	 * the results, if any referenced column isn't present in all the grouping
	 * sets.  (If there are only empty grouping sets, then the HAVING clause
	 * must be degenerate as discussed below.)
	 *
	 * Also, it may be that the clause is so expensive to execute that we're
	 * better off doing it only once per group, despite the loss of
	 * selectivity.  This is hard to estimate short of doing the entire
	 * planning process twice, so we use a heuristic: clauses containing
	 * subplans are left in HAVING.  Otherwise, we move or copy the HAVING
	 * clause into WHERE, in hopes of eliminating tuples before aggregation
	 * instead of after.
	 *
	 * If the query has explicit grouping then we can simply move such a
	 * clause into WHERE; any group that fails the clause will not be in the
	 * output because none of its tuples will reach the grouping or
	 * aggregation stage.  Otherwise we must have a degenerate (variable-free)
	 * HAVING clause, which we put in WHERE so that query_planner() can use it
	 * in a gating Result node, but also keep in HAVING to ensure that we
	 * don't emit a bogus aggregated row. (This could be done better, but it
	 * seems not worth optimizing.)
	 *
	 * Note that both havingQual and parse-&gt;jointree-&gt;quals are in
	 * implicitly-ANDed-list form at this point, even though they are declared
	 * as Node *.
	 */</comment>
	<expr_stmt><expr><name>newHaving</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) parse-&gt;havingQual</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>havingclause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name><operator>)</operator> <operator>||</operator>
			<call><name>contain_agg_clause</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>contain_subplans</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* keep it in HAVING */</comment>
			<expr_stmt><expr><name>newHaving</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newHaving</name></expr></argument>, <argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* move it to WHERE */</comment>
			<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* put a copy in WHERE, keep it in HAVING */</comment>
			<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
						<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newHaving</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newHaving</name></expr></argument>, <argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newHaving</name></expr>;</expr_stmt>

	<comment type="block">/* Remove any redundant GROUP BY columns */</comment>
	<expr_stmt><expr><call><name>remove_useless_groupby_columns</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have any outer joins, try to reduce them to plain inner joins.
	 * This step is most easily done after we've done expression
	 * preprocessing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasOuterJoins</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>reduce_outer_joins</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do the main planning.  If we have an inherited target relation, that
	 * needs special processing, else go straight to grouping_planner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
		<call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>inheritance_planner</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>grouping_planner</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Capture the set of outer-level param IDs we have access to, for use in
	 * extParam/allParam calculations later.
	 */</comment>
	<expr_stmt><expr><call><name>SS_identify_outer_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If any initPlans were created in this query level, adjust the surviving
	 * Paths' costs and parallel-safety flags to account for them.  The
	 * initPlans won't actually get attached to the plan tree till
	 * create_plan() runs, but we must include their effects now.
	 */</comment>
	<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SS_charge_for_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure we've identified the cheapest Path for the final rel.  (By
	 * doing this here not in grouping_planner, we include initPlan costs in
	 * the decision, though it's unlikely that will change anything.)
	 */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_expression
 *		Do subquery_planner's preprocessing work for an expression,
 *		which can be a targetlist, a WHERE clause (including JOIN/ON
 *		conditions), a HAVING clause, or a few other things.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>preprocess_expression</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Fall out quickly if expression is empty.  This occurs often enough to
	 * be worth checking.  Note that null-&gt;null is the correct conversion for
	 * implicit-AND result format, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the query has any join RTEs, replace join alias variables with
	 * base-relation variables.  We must do this first, since any expressions
	 * we may extract from the joinaliasvars lists have not been preprocessed.
	 * For example, if we did this after sublink processing, sublinks expanded
	 * out from join aliases would not get processed.  But we can skip this in
	 * non-lateral RTE functions, VALUES lists, and TABLESAMPLE clauses, since
	 * they can't contain any Vars of the current query level.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>kind</name> <operator>==</operator> <name>EXPRKIND_RTFUNC</name> <operator>||</operator>
		  <name>kind</name> <operator>==</operator> <name>EXPRKIND_VALUES</name> <operator>||</operator>
		  <name>kind</name> <operator>==</operator> <name>EXPRKIND_TABLESAMPLE</name> <operator>||</operator>
		  <name>kind</name> <operator>==</operator> <name>EXPRKIND_TABLEFUNC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Simplify constant expressions.
	 *
	 * Note: an essential effect of this is to convert named-argument function
	 * calls to positional notation and insert the current actual values of
	 * any default arguments for functions.  To ensure that happens, we *must*
	 * process all expressions here.  Previous PG versions sometimes skipped
	 * const-simplification if it didn't seem worth the trouble, but we can't
	 * do that anymore.
	 *
	 * Note: this also flattens nested AND and OR expressions into N-argument
	 * form.  All processing of a qual expression after this point must be
	 * careful to maintain AND/OR flatness --- that is, do not generate a tree
	 * with AND directly under AND, nor OR directly under OR.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a qual or havingQual, canonicalize it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>EXPRKIND_QUAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"After canonicalize_qual()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pprint</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Expand SubLinks to SubPlans */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>SS_process_sublinks</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>EXPRKIND_QUAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * XXX do not insert anything here unless you have grokked the comments in
	 * SS_replace_correlation_vars ...
	 */</comment>

	<comment type="block">/* Replace uplevel vars with Param nodes (this IS possible in VALUES) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>SS_replace_correlation_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a qual or havingQual, convert it to implicit-AND format. (We
	 * don't want to do this before eval_const_expressions, since the latter
	 * would be unable to simplify a top-level AND correctly. Also,
	 * SS_process_sublinks expects explicit-AND format.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>EXPRKIND_QUAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_qual_conditions
 *		Recursively scan the query's jointree and do subquery_planner's
 *		preprocessing work on each qual condition found therein.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>preprocess_qual_conditions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_phv_expression
 *	  Do preprocessing on a PlaceHolderVar expression that's been pulled up.
 *
 * If a LATERAL subquery references an output of another subquery, and that
 * output must be wrapped in a PlaceHolderVar because of an intermediate outer
 * join, then we'll push the PlaceHolderVar expression down into the subquery
 * and later pull it back up during find_lateral_references, which runs after
 * subquery_planner has preprocessed all the expressions that were in the
 * current query level to start with.  So we need to preprocess it then.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>preprocess_phv_expression</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>EXPRKIND_PHV</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inheritance_planner
 *	  Generate Paths in the case where the result relation is an
 *	  inheritance set.
 *
 * We have to handle this case differently from cases where a source relation
 * is an inheritance set. Source inheritance is expanded at the bottom of the
 * plan tree (see allpaths.c), but target inheritance has to be expanded at
 * the top.  The reason is that for UPDATE, each target relation needs a
 * different targetlist matching its own column set.  Fortunately,
 * the UPDATE/DELETE target can never be the nullable side of an outer join,
 * so it's OK to generate the plan this way.
 *
 * Returns nothing; the useful output is in the Paths we attach to
 * the (UPPERREL_FINAL, NULL) upperrel stored in *root.
 *
 * Note that we have not done set_cheapest() on the final rel; it's convenient
 * to leave this to the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inheritance_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>top_parentRTindex</name> <init>= <expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subqueryRTindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiableARIindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nominalRelation</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_rtable</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_rel_array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>save_rel_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>save_append_rel_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subroots</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultRelations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>withCheckOptionLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rowMarks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>rti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parent_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>partitioned_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partitioned_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>parent_root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parent_parse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>parent_relids</name> <init>= <expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>top_parentRTindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parent_roots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We generate a modified instance of the original Query for each target
	 * relation, plan that, and put all the plans into a list that will be
	 * controlled by a single ModifyTable node.  All the instances share the
	 * same rangetable, but each instance must have its own set of subquery
	 * RTEs within the finished rangetable because (1) they are likely to get
	 * scribbled on during planning, and (2) it's not inconceivable that
	 * subqueries could get planned differently in different cases.  We need
	 * not create duplicate copies of other RTE kinds, in particular not the
	 * target relations, because they don't have either of those issues.  Not
	 * having to duplicate the target relations is important because doing so
	 * (1) would result in a rangetable of length O(N^2) for N targets, with
	 * at least O(N^3) work expended here; and (2) would greatly complicate
	 * management of the rowMarks list.
	 *
	 * To begin with, generate a bitmapset of the relids of the subquery RTEs.
	 */</comment>
	<expr_stmt><expr><name>subqueryRTindexes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subqueryRTindexes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>subqueryRTindexes</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Next, we want to identify which AppendRelInfo items contain references
	 * to any of the aforesaid subquery RTEs.  These items will need to be
	 * copied and modified to adjust their subquery references; whereas the
	 * other ones need not be touched.  It's worth being tense over this
	 * because we can usually avoid processing most of the AppendRelInfo
	 * items, thereby saving O(N^2) space and time when the target is a large
	 * inheritance tree.  We can identify AppendRelInfo items by their
	 * child_relid, since that should be unique within the list.
	 */</comment>
	<expr_stmt><expr><name>modifiableARIindexes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>subqueryRTindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>modifiableARIindexes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>modifiableARIindexes</name></expr></argument>,
													  <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the parent RTE is a partitioned table, we should use that as the
	 * nominal relation, because the RTEs added for partitioned tables
	 * (including the root parent) as child members of the inheritance set do
	 * not appear anywhere else in the plan.  The situation is exactly the
	 * opposite in the case of non-partitioned inheritance parent as described
	 * below. For the same reason, collect the list of descendant partitioned
	 * tables to be saved in ModifyTable node, so that executor can lock those
	 * as well.
	 */</comment>
	<expr_stmt><expr><name>parent_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>top_parentRTindex</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nominalRelation</name> <operator>=</operator> <name>top_parentRTindex</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Root parent's RT index is always present in the partitioned_rels of
		 * the ModifyTable node, if one is needed at all.
		 */</comment>
		<expr_stmt><expr><name>partitioned_relids</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>top_parentRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The PlannerInfo for each child is obtained by translating the relevant
	 * members of the PlannerInfo for its immediate parent, which we find
	 * using the parent_relid in its AppendRelInfo.  We save the PlannerInfo
	 * for each parent in an array indexed by relid for fast retrieval. Since
	 * the maximum number of parents is limited by the number of RTEs in the
	 * query, we use that number to allocate the array. An extra entry is
	 * needed since relids start from 1.
	 */</comment>
	<expr_stmt><expr><name>parent_roots</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent_roots</name><index>[<expr><name>top_parentRTindex</name></expr>]</index></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * And now we can get on with generating a plan for each child table.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>child_rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>sub_final_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>

		<comment type="block">/* append_rel_list contains all append rels; ignore others */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * expand_inherited_rtentry() always processes a parent before any of
		 * that parent's children, so the parent_root for this relation should
		 * already be available.
		 */</comment>
		<expr_stmt><expr><name>parent_root</name> <operator>=</operator> <name><name>parent_roots</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parent_root</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_parse</name> <operator>=</operator> <name><name>parent_root</name><operator>-&gt;</operator><name>parse</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need a working copy of the PlannerInfo so that we can control
		 * propagation of information back to the main copy.
		 */</comment>
		<expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>parent_root</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate modified query with this rel as target.  We first apply
		 * adjust_appendrel_attrs, which copies the Query and changes
		 * references to the parent RTE to refer to the current child RTE,
		 * then fool around with subquery RTEs.
		 */</comment>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>parent_root</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parent_parse</name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are securityQuals attached to the parent, move them to the
		 * child rel (they've already been transformed properly for that).
		 */</comment>
		<expr_stmt><expr><name>parent_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name><name>parent_rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * HACK: setting this to a value other than INHKIND_NONE signals to
		 * relation_excluded_by_constraints() to treat the result relation as
		 * being an appendrel member.
		 */</comment>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>inhTargetKind</name></name> <operator>=</operator>
			<ternary><condition><expr><name>partitioned_relids</name></expr> ?</condition><then> <expr><name>INHKIND_PARTITIONED</name></expr> </then><else>: <expr><name>INHKIND_INHERITED</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this child is further partitioned, remember it as a parent.
		 * Since a partitioned table does not have any data, we don't need to
		 * create a plan for it, and we can stop processing it here.  We do,
		 * however, need to remember its modified PlannerInfo for use when
		 * processing its children, since we'll update their varnos based on
		 * the delta from immediate parent to child, not from top to child.
		 *
		 * Note: a very non-obvious point is that we have not yet added
		 * duplicate subquery RTEs to the subroot's rtable.  We mustn't,
		 * because then its children would have two sets of duplicates,
		 * confusing matters.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>child_rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>child_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parent_roots</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>]</index></name> <operator>=</operator> <name>subroot</name></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set the nominal target relation of the ModifyTable node if not
		 * already done.  We use the inheritance parent RTE as the nominal
		 * target relation if it's a partitioned table (see just above this
		 * loop).  In the non-partitioned parent case, we'll use the first
		 * child relation (even if it's excluded) as the nominal target
		 * relation.  Because of the way expand_inherited_rtentry works, the
		 * latter should be the RTE representing the parent table in its role
		 * as a simple member of the inheritance set.
		 *
		 * It would be logically cleaner to *always* use the inheritance
		 * parent RTE as the nominal relation; but that RTE is not otherwise
		 * referenced in the plan in the non-partitioned inheritance case.
		 * Instead the duplicate child RTE created by expand_inherited_rtentry
		 * is used elsewhere in the plan, so using the original parent RTE
		 * would give rise to confusing use of multiple aliases in EXPLAIN
		 * output for what the user will think is the "same" table.  OTOH,
		 * it's not a problem in the partitioned inheritance case, because the
		 * duplicate child RTE added for the parent does not appear anywhere
		 * else in the plan tree.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nominalRelation</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nominalRelation</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The rowMarks list might contain references to subquery RTEs, so
		 * make a copy that we can apply ChangeVarNodes to.  (Fortunately, the
		 * executor doesn't need to see the modified copies --- we can just
		 * pass it the original rowMarks list.)
		 */</comment>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>parent_root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The append_rel_list likewise might contain references to subquery
		 * RTEs (if any subqueries were flattenable UNION ALLs).  So prepare
		 * to apply ChangeVarNodes to that, too.  As explained above, we only
		 * want to copy items that actually contain such references; the rest
		 * can just get linked into the subroot's append_rel_list.
		 *
		 * If we know there are no such references, we can just use the outer
		 * append_rel_list unmodified.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>modifiableARIindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>parent_root-&gt;append_rel_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo2</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo2</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name>modifiableARIindexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>appinfo2</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>appinfo2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>,
												   <argument><expr><name>appinfo2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add placeholders to the child Query's rangetable list to fill the
		 * RT indexes already reserved for subqueries in previous children.
		 * These won't be referenced, so there's no need to make them very
		 * valid-looking.
		 */</comment>
		<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
											 <argument><expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * If this isn't the first child Query, generate duplicates of all
		 * subquery RTEs, and adjust Var numbering to reference the
		 * duplicates. To simplify the loop logic, we scan the original rtable
		 * not the copy just made by adjust_appendrel_attrs; that should be OK
		 * since subquery RTEs couldn't contain any references to the target
		 * rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>final_rtable</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subqueryRTindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lr</argument>, <argument>parent_parse-&gt;rtable</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Index</name></type>		<name>newrti</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * The RTE can't contain any references to its own RT
					 * index, except in its securityQuals, so we can save a
					 * few cycles by applying ChangeVarNodes to the rest of
					 * the rangetable before we append the RTE to it.
					 */</comment>
					<expr_stmt><expr><name>newrti</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Skip processing unchanging parts of append_rel_list */</comment>
					<if_stmt><if>if <condition>(<expr><name>modifiableARIindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

						<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>subroot-&gt;append_rel_list</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo2</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AppendRelInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo2</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>,
											  <argument><expr><name>modifiableARIindexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>appinfo2</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													 <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* There shouldn't be any OJ info to translate, as yet */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* and we haven't created PlaceHolderInfos, either */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate Path(s) for accessing this result relation */</comment>
		<expr_stmt><expr><call><name>grouping_planner</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument> <comment type="block">/* retrieve all tuples */</comment> )</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select cheapest path in case there's more than one.  We always run
		 * modification queries to conclusion, so we care only for the
		 * cheapest-total path.
		 */</comment>
		<expr_stmt><expr><name>sub_final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>sub_final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <name><name>sub_final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this child rel was excluded by constraint exclusion, exclude it
		 * from the result plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>sub_final_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Add the current parent's RT index to the partitioned_relids set if
		 * we're creating the ModifyTable path for a partitioned root table.
		 * (We only care about parents of non-excluded children.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitioned_relids</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partitioned_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>partitioned_relids</name></expr></argument>,
												<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this is the first non-excluded child, its post-planning rtable
		 * becomes the initial contents of final_rtable; otherwise, append
		 * just its modified subquery RTEs to final_rtable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>final_rtable</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>final_rtable</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>final_rtable</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>,
									   <argument><expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * We need to collect all the RelOptInfos from all child plans into
		 * the main PlannerInfo, since setrefs.c will need them.  We use the
		 * last child's simple_rel_array (previous ones are too short), so we
		 * have to propagate forward the RelOptInfos that were already built
		 * in previous children.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&gt;=</operator> <name>save_rel_array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name>save_rel_array_size</name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>save_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>brel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>=</operator> <name>brel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>save_rel_array_size</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_rel_array</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_append_rel_array</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>append_rel_array</name></name></expr>;</expr_stmt>

		<comment type="block">/* Make sure any initplans from this rel get into the outer list */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>init_plans</name></name></expr>;</expr_stmt>

		<comment type="block">/* Build list of sub-paths */</comment>
		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build list of modified subroots, too */</comment>
		<expr_stmt><expr><name>subroots</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build list of target-relation RT indexes */</comment>
		<expr_stmt><expr><name>resultRelations</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build lists of per-relation WCO and RETURNING targetlists */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>,
										   <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>returningLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>,
									 <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Result path must go into outer query's FINAL upperrel */</comment>
	<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't currently worry about setting final_rel's consider_parallel
	 * flag in this case, nor about allowing FDWs or create_upper_paths_hook
	 * to get control here.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>subpaths</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We managed to exclude every child rel, so generate a dummy path
		 * representing the empty set.  Although it's clear that no data will
		 * be updated or deleted, we will still need to have a ModifyTable
		 * node so that any statement triggers are executed.  (This could be
		 * cleaner if we fixed nodeModifyTable.c to support zero child nodes,
		 * but that probably wouldn't be a net win.)
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>dummy_path</name></decl>;</decl_stmt>

		<comment type="block">/* tlist processing never got done, either */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <call><name>preprocess_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make a dummy path, cf set_dummy_rel_pathlist() */</comment>
		<expr_stmt><expr><name>dummy_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_append_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* These lists must be nonempty to make a valid ModifyTable node */</comment>
		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>dummy_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subroots</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelations</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>returningLists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Since no tuples will be updated, don't require ModifyTable to
		 * create tuple-routing info that will be left unused.  In fact it's
		 * necessary to do so, because we're cheating here by putting the root
		 * table into resultRelations list, which the tuple-routing code is
		 * not expecting to be there.
		 */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Put back the final adjusted rtable into the master copy of the
		 * Query.  (We mustn't do this if we found no non-excluded children,
		 * since we never saved an adjusted rtable at all.)
		 */</comment>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>final_rtable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>=</operator> <name>save_rel_array_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name></name> <operator>=</operator> <name>save_rel_array</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name> <operator>=</operator> <name>save_append_rel_array</name></expr>;</expr_stmt>

		<comment type="block">/* Must reconstruct master's simple_rte_array, too */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name></name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If there was a FOR [KEY] UPDATE/SHARE clause, the LockRows node will
	 * have dealt with fetching non-locked marked rows, else we need to have
	 * ModifyTable do that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partitioned_relids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>partitioned_relids</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partitioned_rels</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * If we're going to create ModifyTable at all, the list should
		 * contain at least one member, that is, the root parent's index.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitioned_rels</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Create Path representing a ModifyTable to do the UPDATE/DELETE work */</comment>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			 <call><name>create_modifytable_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>,
									 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
									 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
									 <argument><expr><name>nominalRelation</name></expr></argument>,
									 <argument><expr><name>partitioned_rels</name></expr></argument>,
									 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr></argument>,
									 <argument><expr><name>resultRelations</name></expr></argument>,
									 <argument><expr><name>subpaths</name></expr></argument>,
									 <argument><expr><name>subroots</name></expr></argument>,
									 <argument><expr><name>withCheckOptionLists</name></expr></argument>,
									 <argument><expr><name>returningLists</name></expr></argument>,
									 <argument><expr><name>rowMarks</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*--------------------
 * grouping_planner
 *	  Perform planning steps related to grouping, aggregation, etc.
 *
 * This function adds all required top-level processing to the scan/join
 * Path(s) produced by query_planner.
 *
 * If inheritance_update is true, we're being called from inheritance_planner
 * and should not include a ModifyTable step in the resulting Path(s).
 * (inheritance_planner will create a single ModifyTable node covering all the
 * target tables.)
 *
 * tuple_fraction is the fraction of tuples we expect will be retrieved.
 * tuple_fraction is interpreted as follows:
 *	  0: expect all tuples to be retrieved (normal case)
 *	  0 &lt; tuple_fraction &lt; 1: expect the given fraction of tuples available
 *		from the plan to be retrieved
 *	  tuple_fraction &gt;= 1: tuple_fraction is the absolute number of tuples
 *		expected to be retrieved (ie, a LIMIT specification)
 *
 * Returns nothing; the useful output is in the Paths we attach to the
 * (UPPERREL_FINAL, NULL) upperrel in *root.  In addition,
 * root-&gt;processed_tlist contains the final processed targetlist.
 *
 * Note that we have not done set_cheapest() on the final rel; it's convenient
 * to leave this to the caller.
 *--------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>grouping_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inheritance_update</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>offset_est</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>count_est</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>limit_tuples</name> <init>= <expr><operator>-</operator><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_postponed_srfs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_targets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_targets_contain_srfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>final_target_parallel_safe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>current_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Tweak caller-supplied tuple_fraction if have LIMIT/OFFSET */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <call><name>preprocess_limit</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>offset_est</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count_est</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have a known LIMIT, and don't have an unknown OFFSET, we can
		 * estimate the effects of using a bounded sort.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>count_est</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset_est</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>limit_tuples</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>count_est</name> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>offset_est</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make tuple_fraction accessible to lower-level routines */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <name>tuple_fraction</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there's a top-level ORDER BY, assume we have to fetch all the
		 * tuples.  This might be too simplistic given all the hackery below
		 * to possibly avoid the sort; but the odds of accurate estimates here
		 * are pretty low anyway.  XXX try to get rid of this in favor of
		 * letting plan_set_operations generate both fast-start and
		 * cheapest-total paths.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Construct Paths for set operations.  The results will not need any
		 * work except perhaps a top-level sort and/or LIMIT.  Note that any
		 * special work for recursive unions is the responsibility of
		 * plan_set_operations.
		 */</comment>
		<expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>plan_set_operations</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should not need to call preprocess_targetlist, since we must be
		 * in a SELECT query node.  Instead, use the targetlist returned by
		 * plan_set_operations (since this tells whether it returned any
		 * resjunk columns!), and transfer any sort key information from the
		 * original tlist.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr>;</expr_stmt>	<comment type="block">/* from plan_set_operations */</comment>

		<comment type="block">/* for safety, copy processed_tlist instead of modifying in-place */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>postprocess_setop_tlist</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save aside the final decorated tlist */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

		<comment type="block">/* Also extract the PathTarget form of the setop result tlist */</comment>
		<expr_stmt><expr><name>final_target</name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>

		<comment type="block">/* And check whether it's parallel safe */</comment>
		<expr_stmt><expr><name>final_target_parallel_safe</name> <operator>=</operator>
			<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>final_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The setop result tlist couldn't contain any SRFs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>final_targets</name> <operator>=</operator> <name>final_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Can't handle FOR [KEY] UPDATE/SHARE here (parser should have
		 * checked already, but let's make sure).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/*------
			  translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
							<argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>,
													   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Calculate pathkeys that represent result ordering requirements
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
															<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No set operations, do regular planning */</comment>
		<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>sort_input_target</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sort_input_targets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sort_input_targets_contain_srfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sort_input_target_parallel_safe</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grouping_targets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grouping_targets_contain_srfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>grouping_target_parallel_safe</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>scanjoin_target</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>scanjoin_targets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>scanjoin_targets_contain_srfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>scanjoin_target_parallel_safe</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>scanjoin_target_same_exprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>have_grouping</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>agg_costs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>activeWindows</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gset_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>standard_qp_extra</name></type> <name>qp_extra</name></decl>;</decl_stmt>
		<comment type="block">/* POLAR */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>polar_union_or_subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* A recursive query should always have setOperations */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Preprocess grouping sets and GROUP BY clause, if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>gset_data</name> <operator>=</operator> <call><name>preprocess_grouping_sets</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Preprocess regular GROUP BY clause, if any */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Preprocess targetlist */</comment>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>preprocess_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are now done hacking up the query's targetlist.  Most of the
		 * remaining planning work will be done with the PathTarget
		 * representation of tlists, but save aside the full representation so
		 * that we can transfer its decoration (resnames etc) to the topmost
		 * tlist of the finished Plan.
		 */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Collect statistics about aggregates for estimating costs, and mark
		 * all the aggregates with resolved aggtranstypes.  We must do this
		 * before slicing and dicing the tlist into various pathtargets, else
		 * some copies of the Aggref nodes might escape being marked with the
		 * correct transtypes.
		 *
		 * Note: currently, we do not detect duplicate aggregates here.  This
		 * may result in somewhat-overestimated cost, which is fine for our
		 * purposes since all Paths will get charged the same.  But at some
		 * point we might wish to do that detection in the planner, rather
		 * than during executor startup.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tlist</name></expr></argument>, <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Locate any window functions in the tlist.  (We don't need to look
		 * anywhere else, since expressions used in ORDER BY will be in there
		 * too.)  Note that they could all have been eliminated by constant
		 * folding, in which case we don't need to do any more work.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>wflists</name> <operator>=</operator> <call><name>find_window_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tlist</name></expr></argument>,
											<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>wflists</name><operator>-&gt;</operator><name>numWindowFuncs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>activeWindows</name> <operator>=</operator> <call><name>select_active_windows</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>wflists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Preprocess MIN/MAX aggregates, if any.  Note: be careful about
		 * adding logic between here and the query_planner() call.  Anything
		 * that is needed in MIN/MAX-optimizable cases will have to be
		 * duplicated in planagg.c.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>preprocess_minmax_aggregates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * POLAR: Preprocess join OR clauses that might be better handled as
		 * UNION ALLs. This likewise needs to be close to the query_planner()
		 * call.  But it doesn't matter which of preprocess_minmax_aggregates()
		 * and this function we call first, because they treat disjoint sets
		 * of cases.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_convert_or_to_union_all</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>polar_union_or_subpaths</name> <operator>=</operator> <call><name>polar_split_join_or_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Figure out whether there's a hard limit on the number of rows that
		 * query_planner's result subplan needs to return.  Even if we know a
		 * hard limit overall, it doesn't apply if the query has any
		 * grouping/aggregation operations, or SRFs in the tlist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
			<name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
			<name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
			<name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
			<name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
			<name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
			<name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <name>limit_tuples</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Set up data needed by standard_qp_callback */</comment>
		<expr_stmt><expr><name><name>qp_extra</name><operator>.</operator><name>tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qp_extra</name><operator>.</operator><name>activeWindows</name></name> <operator>=</operator> <name>activeWindows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qp_extra</name><operator>.</operator><name>groupClause</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>gset_data</name></expr>
								?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>gset_data</name><operator>-&gt;</operator><name>rollups</name></name></expr> ?</condition><then> <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name><name>gset_data</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>groupClause</name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>
								</then><else>: <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate the best unsorted and presorted paths for the scan/join
		 * portion of this Query, ie the processing represented by the
		 * FROM/WHERE clauses.  (Note there may not be any presorted paths.)
		 * We also generate (in standard_qp_callback) pathkey representations
		 * of the query's sort clause, distinct clause, etc.
		 */</comment>
		<expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>query_planner</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>,
									<argument><expr><name>standard_qp_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qp_extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we found any way to convert a join OR clause to a union, finish
		 * up generating the path(s) for that, and add them into the topmost
		 * scan/join relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_union_or_subpaths</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_finish_union_or_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>, <argument><expr><name>polar_union_or_subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Convert the query's result tlist into PathTarget format.
		 *
		 * Note: it's desirable to not do this till after query_planner(),
		 * because the target width estimates can use per-Var width numbers
		 * that were obtained within query_planner().
		 */</comment>
		<expr_stmt><expr><name>final_target</name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>final_target_parallel_safe</name> <operator>=</operator>
			<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>final_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If ORDER BY was given, consider whether we should use a post-sort
		 * projection, and compute the adjusted target for preceding steps if
		 * so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sort_input_target</name> <operator>=</operator> <call><name>make_sort_input_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>final_target</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>have_postponed_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_input_target_parallel_safe</name> <operator>=</operator>
				<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sort_input_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sort_input_target</name> <operator>=</operator> <name>final_target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_input_target_parallel_safe</name> <operator>=</operator> <name>final_target_parallel_safe</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we have window functions to deal with, the output from any
		 * grouping step needs to be what the window functions want;
		 * otherwise, it should be sort_input_target.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>activeWindows</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>grouping_target</name> <operator>=</operator> <call><name>make_window_input_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>final_target</name></expr></argument>,
													   <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouping_target_parallel_safe</name> <operator>=</operator>
				<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>grouping_target</name> <operator>=</operator> <name>sort_input_target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouping_target_parallel_safe</name> <operator>=</operator> <name>sort_input_target_parallel_safe</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we have grouping or aggregation to do, the topmost scan/join
		 * plan node must emit what the grouping step wants; otherwise, it
		 * should emit grouping_target.
		 */</comment>
		<expr_stmt><expr><name>have_grouping</name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
						 <name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>have_grouping</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <call><name>make_group_input_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_target_parallel_safe</name> <operator>=</operator>
				<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scanjoin_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <name>grouping_target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_target_parallel_safe</name> <operator>=</operator> <name>grouping_target_parallel_safe</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If there are any SRFs in the targetlist, we must separate each of
		 * these PathTargets into SRF-computing and SRF-free targets.  Replace
		 * each of the named targets with a SRF-free version, and remember the
		 * list of additional projection steps we need to add afterwards.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* final_target doesn't recompute any SRFs in sort_input_target */</comment>
			<expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>sort_input_target</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>final_targets</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>final_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>final_target</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>final_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>final_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* likewise for sort_input_target vs. grouping_target */</comment>
			<expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort_input_target</name></expr></argument>, <argument><expr><name>grouping_target</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>sort_input_targets</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>sort_input_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_input_target</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>sort_input_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>sort_input_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* likewise for grouping_target vs. scanjoin_target */</comment>
			<expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>scanjoin_target</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>grouping_targets</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>grouping_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouping_target</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>grouping_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>grouping_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* scanjoin_target will not have any SRFs precomputed for it */</comment>
			<expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scanjoin_target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>scanjoin_targets</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>scanjoin_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>scanjoin_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>scanjoin_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* initialize lists; for most of these, dummy values are OK */</comment>
			<expr_stmt><expr><name>final_targets</name> <operator>=</operator> <name>final_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_input_targets</name> <operator>=</operator> <name>sort_input_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouping_targets</name> <operator>=</operator> <name>grouping_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_targets</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>scanjoin_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Apply scan/join target. */</comment>
		<expr_stmt><expr><name>scanjoin_target_same_exprs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>scanjoin_targets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
			<operator>&amp;&amp;</operator> <call><name>equal</name><argument_list>(<argument><expr><name><name>scanjoin_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>current_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>apply_scanjoin_target_to_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>, <argument><expr><name>scanjoin_targets</name></expr></argument>,
									   <argument><expr><name>scanjoin_targets_contain_srfs</name></expr></argument>,
									   <argument><expr><name>scanjoin_target_parallel_safe</name></expr></argument>,
									   <argument><expr><name>scanjoin_target_same_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Save the various upper-rel PathTargets we just computed into
		 * root-&gt;upper_targets[].  The core code doesn't use this, but it
		 * provides a convenient place for extensions to get at the info.  For
		 * consistency, we save all the intermediate targets, even though some
		 * of the corresponding upperrels might not be needed for this query.
		 */</comment>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_FINAL</name></expr>]</index></name> <operator>=</operator> <name>final_target</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_WINDOW</name></expr>]</index></name> <operator>=</operator> <name>sort_input_target</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_GROUP_AGG</name></expr>]</index></name> <operator>=</operator> <name>grouping_target</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have grouping and/or aggregation, consider ways to implement
		 * that.  We build a new upperrel representing the output of this
		 * phase.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>have_grouping</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>current_rel</name></expr></argument>,
												<argument><expr><name>grouping_target</name></expr></argument>,
												<argument><expr><name>grouping_target_parallel_safe</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>,
												<argument><expr><name>gset_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Fix things up if grouping_target contains SRFs */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
									  <argument><expr><name>grouping_targets</name></expr></argument>,
									  <argument><expr><name>grouping_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we have window functions, consider ways to implement those.  We
		 * build a new upperrel representing the output of this phase.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>activeWindows</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_window_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>current_rel</name></expr></argument>,
											  <argument><expr><name>grouping_target</name></expr></argument>,
											  <argument><expr><name>sort_input_target</name></expr></argument>,
											  <argument><expr><name>sort_input_target_parallel_safe</name></expr></argument>,
											  <argument><expr><name>tlist</name></expr></argument>,
											  <argument><expr><name>wflists</name></expr></argument>,
											  <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Fix things up if sort_input_target contains SRFs */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
									  <argument><expr><name>sort_input_targets</name></expr></argument>,
									  <argument><expr><name>sort_input_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there is a DISTINCT clause, consider ways to implement that. We
		 * build a new upperrel representing the output of this phase.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_distinct_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>current_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>							<comment type="block">/* end of if (setOperations) */</comment>

	<comment type="block">/*
	 * If ORDER BY was given, consider ways to implement that, and generate a
	 * new upperrel containing only paths that emit the correct ordering and
	 * project the correct final_target.  We can apply the original
	 * limit_tuples limit in sort costing here, but only if there are no
	 * postponed SRFs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_ordered_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>current_rel</name></expr></argument>,
										   <argument><expr><name>final_target</name></expr></argument>,
										   <argument><expr><name>final_target_parallel_safe</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>have_postponed_srfs</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.0</literal></expr> </then><else>:
										   <expr><name>limit_tuples</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fix things up if final_target contains SRFs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
								  <argument><expr><name>final_targets</name></expr></argument>,
								  <argument><expr><name>final_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now we are prepared to build the final-output upperrel.
	 */</comment>
	<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input rel is marked consider_parallel and there's nothing that's
	 * not parallel-safe in the LIMIT clause, then the final_rel can be marked
	 * consider_parallel as well.  Note that if the query has rowMarks or is
	 * not a SELECT, consider_parallel will be false for every relation in the
	 * query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>current_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the current_rel belongs to a single FDW, so does the final_rel.
	 */</comment>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate paths for the final_rel.  Insert all surviving paths, with
	 * LockRows, Limit, and/or ModifyTable steps added if needed.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If there is a FOR [KEY] UPDATE/SHARE clause, add the LockRows node.
		 * (Note: we intentionally test parse-&gt;rowMarks not root-&gt;rowMarks
		 * here.  If there are only non-locking rowmarks, they should be
		 * handled by the ModifyTable node instead.  However, root-&gt;rowMarks
		 * is what goes into the LockRows node.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_lockrows_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>,
												 <argument><expr><call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there is a LIMIT/OFFSET clause, add the LIMIT node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>limit_needed</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_limit_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
											  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
											  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
											  <argument><expr><name>offset_est</name></expr></argument>, <argument><expr><name>count_est</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If this is an INSERT/UPDATE/DELETE, and we're not being called from
		 * inheritance_planner, add the ModifyTable node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inheritance_update</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>withCheckOptionLists</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>returningLists</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rowMarks</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Set up the WITH CHECK OPTION and RETURNING lists-of-lists, if
			 * needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>returningLists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>returningLists</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * If there was a FOR [KEY] UPDATE/SHARE clause, the LockRows node
			 * will have dealt with fetching non-locked marked rows, else we
			 * need to have ModifyTable do that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_modifytable_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>,
										<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
										<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
										<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>withCheckOptionLists</name></expr></argument>,
										<argument><expr><name>returningLists</name></expr></argument>,
										<argument><expr><name>rowMarks</name></expr></argument>,
										<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>,
										<argument><expr><call><name>assign_special_exec_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And shove it into final_rel */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Generate partial paths for final_rel, too, if outer query levels might
	 * be able to make use of them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>limit_needed</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>partial_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>,
													<argument><expr><name>current_rel</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>,
									<argument><expr><name>current_rel</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note: currently, we leave it to callers to do set_cheapest() */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Do preprocessing for groupingSets clause and related data.  This handles the
 * preliminary steps of expanding the grouping sets, organizing them into lists
 * of rollups, and preparing annotations which will later be filled in with
 * size estimates.
 */</comment>
<function><type><specifier>static</specifier> <name>grouping_sets_data</name> <modifier>*</modifier></type>
<name>preprocess_grouping_sets</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>grouping_sets_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <call><name>expand_grouping_sets</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>maxref</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxref</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gc</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate workspace array for remapping */</comment>
	<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>maxref</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have any unsortable sets, we must extract them before trying to
	 * prepare rollups. Unsortable sets don't go through
	 * reorder_grouping_sets, so we must apply the GroupingSetData annotation
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortable_sets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupingSets</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_overlap_list</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>gset</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We must enforce here that an unsortable set is hashable;
				 * later code assumes this.  Parse analysis only checks that
				 * every individual column is either hashable or sortable.
				 *
				 * Note that passing this test doesn't guarantee we can
				 * generate a plan; there might be other showstoppers.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>bms_overlap_list</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement GROUP BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sortable_sets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortable_sets</name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>sortable_sets</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sets</name> <operator>=</operator> <call><name>extract_rollup_sets</name><argument_list>(<argument><expr><name>sortable_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sets</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sets</name> <operator>=</operator> <call><name>extract_rollup_sets</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc_set</argument>, <argument>sets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_sets</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_set</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reorder the current list of grouping sets into correct prefix
		 * order.  If only one aggregation pass is needed, try to make the
		 * list match the ORDER BY clause; if more than one pass is needed, we
		 * don't bother with that.
		 *
		 * Note that this reorders the sets from smallest-member-first to
		 * largest-member-first, and applies the GroupingSetData annotations,
		 * though the data will be filled in later.
		 */</comment>
		<expr_stmt><expr><name>current_sets</name> <operator>=</operator> <call><name>reorder_grouping_sets</name><argument_list>(<argument><expr><name>current_sets</name></expr></argument>,
											 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>
											  ?</condition><then> <expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>
											  </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the initial (and therefore largest) grouping set.
		 */</comment>
		<expr_stmt><expr><name>gs</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>, <argument><expr><name>current_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Order the groupClause appropriately.  If the first grouping set is
		 * empty, then the groupClause must also be empty; otherwise we have
		 * to force the groupClause to match that grouping set's order.
		 *
		 * (The first grouping set can be empty even though parse-&gt;groupClause
		 * is not empty only if all non-empty grouping sets are unsortable.
		 * The groupClauses for hashed grouping sets are built later on.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Is it hashable? We pretend empty sets are hashable even though we
		 * actually force them not to be hashed later. But don't bother if
		 * there's nothing but empty sets (since in that case we can't hash
		 * anything).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_overlap_list</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now that we've pinned down an order for the groupClause for this
		 * list of grouping sets, we need to remap the entries in the grouping
		 * sets from sortgrouprefs to plain indices (0-based) into the
		 * groupClause for this collection of grouping sets. We keep the
		 * original form for later use, though.
		 */</comment>
		<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												 <argument><expr><name>current_sets</name></expr></argument>,
												 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <name>current_sets</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have not yet pinned down a groupclause for this, but we will
		 * need index-based lists for estimation purposes. Construct
		 * hash_sets_idx based on the entire original groupclause for now.
		 */</comment>
		<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>hash_sets_idx</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>,
													 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>gd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a groupclause and a list of GroupingSetData, return equivalent sets
 * (without annotation) mapped to indexes into the given groupclause.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>remap_to_groupclause_idx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gsets</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tleref_to_colnum_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tleref_to_colnum_map</name><index>[<expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>]</index></name> <operator>=</operator> <name>ref</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gsets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>set</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>gs-&gt;set</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name><name>tleref_to_colnum_map</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Detect whether a plan node is a "dummy" plan created when a relation
 * is deemed not to need scanning due to constraint exclusion.
 *
 * Currently, such dummy plans are Result nodes with constant FALSE
 * filter quals (see set_dummy_rel_pathlist and create_append_plan).
 *
 * XXX this probably ought to be somewhere else, but not clear where.
 */</comment>
<function><type><name>bool</name></type>
<name>is_dummy_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rcqual</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rcqual</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>constqual</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rcqual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>constqual</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>constqual</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constqual</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>constqual</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_rowmarks - set up PlanRowMarks if needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>preprocess_rowmarks</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>prowmarks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've got trouble if FOR [KEY] UPDATE/SHARE appears inside
		 * grouping, since grouping renders a reference to individual tuple
		 * CTIDs invalid.  This is also checked at parse time, but that's
		 * insufficient because of rule substitution, query pullup, etc.
		 */</comment>
		<expr_stmt><expr><call><name>CheckSelectLocking</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>,
												<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We only need rowmarks for UPDATE, DELETE, or FOR [KEY]
		 * UPDATE/SHARE.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
			<name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We need to have rowmarks for all base relations except the target. We
	 * make a bitmapset of all base rels and then remove the items we don't
	 * need or have FOR [KEY] UPDATE/SHARE marks for.
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert RowMarkClauses to PlanRowMark representation.
	 */</comment>
	<expr_stmt><expr><name>prowmarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rowMarks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>newrc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Currently, it is syntactically impossible to have FOR UPDATE et al
		 * applied to an update/delete target rel.  If that ever becomes
		 * possible, we should drop the target from the PlanRowMark list.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ignore RowMarkClauses for subqueries; they aren't real tables and
		 * can't support true locking.  Subqueries that got flattened into the
		 * main query should be ignored completely.  Any that didn't will get
		 * ROW_MARK_COPY items in the next loop.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newrc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>newrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastRowMarkId</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <call><name>select_rowmark_type</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>prowmarks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prowmarks</name></expr></argument>, <argument><expr><name>newrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now, add rowmarks for any non-target, non-locked base relations.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>newrc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newrc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>newrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastRowMarkId</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <call><name>select_rowmark_type</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>LCS_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>LCS_NONE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name>LockWaitBlock</name></expr>;</expr_stmt>	<comment type="block">/* doesn't matter */</comment>
		<expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>prowmarks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prowmarks</name></expr></argument>, <argument><expr><name>newrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>prowmarks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Select RowMarkType to use for a given table
 */</comment>
<function><type><name>RowMarkType</name></type>
<name>select_rowmark_type</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's not a table at all, use ROW_MARK_COPY */</comment>
		<return>return <expr><name>ROW_MARK_COPY</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Let the FDW select the rowmark type, if it wants to */</comment>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><call><name>GetFdwRoutineByRelId</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRowMarkType</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRowMarkType</name></name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Otherwise, use ROW_MARK_COPY by default */</comment>
		<return>return <expr><name>ROW_MARK_COPY</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Regular table, apply the appropriate lock type */</comment>
		<switch>switch <condition>(<expr><name>strength</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>LCS_NONE</name></expr>:</case>

				<comment type="block">/*
				 * We don't need a tuple lock, only the ability to re-fetch
				 * the row.
				 */</comment>
				<return>return <expr><name>ROW_MARK_REFERENCE</name></expr>;</return>
				<break>break;</break>
			<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
				<return>return <expr><name>ROW_MARK_KEYSHARE</name></expr>;</return>
				<break>break;</break>
			<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
				<return>return <expr><name>ROW_MARK_SHARE</name></expr>;</return>
				<break>break;</break>
			<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
				<return>return <expr><name>ROW_MARK_NOKEYEXCLUSIVE</name></expr>;</return>
				<break>break;</break>
			<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
				<return>return <expr><name>ROW_MARK_EXCLUSIVE</name></expr>;</return>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LockClauseStrength %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ROW_MARK_EXCLUSIVE</name></expr>;</return>	<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_limit - do pre-estimation for LIMIT and/or OFFSET clauses
 *
 * We try to estimate the values of the LIMIT/OFFSET clauses, and pass the
 * results back in *count_est and *offset_est.  These variables are set to
 * 0 if the corresponding clause is not present, and -1 if it's present
 * but we couldn't estimate the value for it.  (The "0" convention is OK
 * for OFFSET but a little bit bogus for LIMIT: effectively we estimate
 * LIMIT 0 as though it were LIMIT 1.  But this is in line with the planner's
 * usual practice of never estimating less than one row.)  These values will
 * be passed to create_limit_path, which see if you change this code.
 *
 * The return value is the suitably adjusted tuple_fraction to use for
 * planning the query.  This adjustment is not overridable, since it reflects
 * plan actions that grouping_planner() will certainly take, not assumptions
 * about context.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>preprocess_limit</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>count_est</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>est</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>limit_fraction</name></decl>;</decl_stmt>

	<comment type="block">/* Should not be called unless LIMIT or OFFSET */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to obtain the clause values.  We use estimate_expression_value
	 * primarily because it can sometimes do something useful with Params.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>est</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>est</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>est</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* NULL indicates LIMIT ALL, ie, no limit */</comment>
				<expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* treat as not present */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>count_est</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* force to at least 1 */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* can't estimate */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* not present */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>est</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>est</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>est</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Treat NULL as no offset; the executor will too */</comment>
				<expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* treat as not present */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset_est</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* treat as not present */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* can't estimate */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* not present */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>count_est</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A LIMIT clause limits the absolute number of tuples returned.
		 * However, if it's not a constant LIMIT then we have to guess; for
		 * lack of a better idea, assume 10% of the plan's result is wanted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>count_est</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>offset_est</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* LIMIT or OFFSET is an expression ... punt ... */</comment>
			<expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <literal type="number">0.10</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* LIMIT (plus OFFSET, if any) is max number of tuples needed */</comment>
			<expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>count_est</name> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>offset_est</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we have absolute limits from both caller and LIMIT, use the
		 * smaller value; likewise if they are both fractional.  If one is
		 * fractional and the other absolute, we can't easily determine which
		 * is smaller, but we use the heuristic that the absolute will usually
		 * be smaller.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* both absolute */</comment>
				<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>tuple_fraction</name></expr></argument>, <argument><expr><name>limit_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* caller absolute, limit fractional; use caller's value */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* caller fractional, limit absolute; use limit */</comment>
				<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* both fractional */</comment>
				<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>tuple_fraction</name></expr></argument>, <argument><expr><name>limit_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no info from caller, just use limit */</comment>
			<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>offset_est</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tuple_fraction</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have an OFFSET but no LIMIT.  This acts entirely differently
		 * from the LIMIT case: here, we need to increase rather than decrease
		 * the caller's tuple_fraction, because the OFFSET acts to cause more
		 * tuples to be fetched instead of fewer.  This only matters if we got
		 * a tuple_fraction &gt; 0, however.
		 *
		 * As above, use 10% if OFFSET is present but unestimatable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset_est</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <literal type="number">0.10</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>offset_est</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If we have absolute counts from both caller and OFFSET, add them
		 * together; likewise if they are both fractional.  If one is
		 * fractional and the other absolute, we want to take the larger, and
		 * we heuristically assume that's the fractional one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* both absolute, so add them together */</comment>
				<expr_stmt><expr><name>tuple_fraction</name> <operator>+=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* caller absolute, limit fractional; use limit */</comment>
				<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* caller fractional, limit absolute; use caller's value */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* both fractional, so add them together */</comment>
				<expr_stmt><expr><name>tuple_fraction</name> <operator>+=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* assume fetch all */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>tuple_fraction</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * limit_needed - do we actually need a Limit plan node?
 *
 * If we have constant-zero OFFSET and constant-null LIMIT, we can skip adding
 * a Limit node.  This is worth checking for because "OFFSET 0" is a common
 * locution for an optimization fence.  (Because other places in the planner
 * merely check whether parse-&gt;limitOffset isn't NULL, it will still work as
 * an optimization fence --- we're just suppressing unnecessary run-time
 * overhead.)
 *
 * This might look like it could be merged into preprocess_limit, but there's
 * a key distinction: here we need hard constants in OFFSET/LIMIT, whereas
 * in preprocess_limit it's good enough to consider estimated values.
 */</comment>
<function><type><name>bool</name></type>
<name>limit_needed</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* NULL indicates LIMIT ALL, ie, no limit */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* LIMIT with a constant value */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* non-constant LIMIT */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Treat NULL as no offset; the executor would too */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OFFSET with a nonzero value */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* non-constant OFFSET */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* don't need a Limit plan node */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * remove_useless_groupby_columns
 *		Remove any columns in the GROUP BY clause that are redundant due to
 *		being functionally dependent on other GROUP BY columns.
 *
 * Since some other DBMSes do not allow references to ungrouped columns, it's
 * not unusual to find all columns listed in GROUP BY even though listing the
 * primary-key columns would be sufficient.  Deleting such excess columns
 * avoids redundant sorting work, so it's worth doing.  When we do this, we
 * must mark the plan as dependent on the pkey constraint (compare the
 * parser's check_ungrouped_columns() and check_functional_grouping()).
 *
 * In principle, we could treat any NOT-NULL columns appearing in a UNIQUE
 * index as the determining columns.  But as with check_functional_grouping(),
 * there's currently no way to represent dependency on a NOT NULL constraint,
 * so we consider only the pkey for now.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_useless_groupby_columns</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>groupbyattnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>surplusvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relid</name></decl>;</decl_stmt>

	<comment type="block">/* No chance to do anything if there are less than two GROUP BY items */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't fiddle with the GROUP BY clause if the query has grouping sets */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan the GROUP BY clause to find GROUP BY items that are simple Vars.
	 * Fill groupbyattnos[k] with a bitmapset of the column attnos of RTE k
	 * that are GROUP BY items.
	 */</comment>
	<expr_stmt><expr><name>groupbyattnos</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										   <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore non-Vars and Vars from other query levels.
		 *
		 * XXX in principle, stable expressions containing Vars could also be
		 * removed, if all the Vars are functionally dependent on other GROUP
		 * BY items.  But it's not clear that such cases occur often enough to
		 * be worth troubling over.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, remember we have this Var */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>groupbyattnos</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>groupbyattnos</name><index>[<expr><name>relid</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Consider each relation and see if it is possible to remove some of its
	 * Vars from GROUP BY.  For simplicity and speed, we do the actual removal
	 * in a separate pass.  Here, we just fill surplusvars[k] with a bitmapset
	 * of the column attnos of RTE k that are removable GROUP BY items.
	 */</comment>
	<expr_stmt><expr><name>surplusvars</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* don't allocate array unless required */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>relattnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>pkattnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Only plain relations could have primary-key constraints */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We must skip inheritance parent tables as some of the child rels
		 * may cause duplicate rows.  This cannot happen with partitioned
		 * tables, however.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Nothing to do unless this rel has multiple Vars in GROUP BY */</comment>
		<expr_stmt><expr><name>relattnos</name> <operator>=</operator> <name><name>groupbyattnos</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name>relattnos</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_MULTIPLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Can't remove any columns for this rel if there is no suitable
		 * (i.e., nondeferrable) primary key constraint.
		 */</comment>
		<expr_stmt><expr><name>pkattnos</name> <operator>=</operator> <call><name>get_primary_key_attnos</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pkattnos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the primary key is a proper subset of relattnos then we have
		 * some items in the GROUP BY that can be removed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_subset_compare</name><argument_list>(<argument><expr><name>pkattnos</name></expr></argument>, <argument><expr><name>relattnos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_SUBSET1</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * To easily remember whether we've found anything to do, we don't
			 * allocate the surplusvars[] array until we find something.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>surplusvars</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>surplusvars</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
													 <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Remember the attnos of the removable columns */</comment>
			<expr_stmt><expr><name><name>surplusvars</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>relattnos</name></expr></argument>, <argument><expr><name>pkattnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Also, mark the resulting plan as dependent on this constraint */</comment>
			<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>constraintDeps</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>constraintDeps</name></name></expr></argument>,
												<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we found any surplus Vars, build a new GROUP BY clause without them.
	 * (Note: this may leave some TLEs with unreferenced ressortgroupref
	 * markings, but that's harmless.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>surplusvars</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_groupby</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * New list must include non-Vars, outer Vars, and anything not
			 * marked as surplus.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
							   <argument><expr><name><name>surplusvars</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_groupby</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupby</name></expr></argument>, <argument><expr><name>sgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>new_groupby</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_groupclause - do preparatory work on GROUP BY clause
 *
 * The idea here is to adjust the ordering of the GROUP BY elements
 * (which in itself is semantically insignificant) to match ORDER BY,
 * thereby allowing a single sort operation to both implement the ORDER BY
 * requirement and set up for a Unique step that implements GROUP BY.
 *
 * In principle it might be interesting to consider other orderings of the
 * GROUP BY elements, which could match the sort ordering of other
 * possible plans (eg an indexscan) and thereby reduce cost.  We don't
 * bother with that, though.  Hashed grouping will frequently win anyway.
 *
 * Note: we need no comparable processing of the distinctClause because
 * the parser already enforced that that matches ORDER BY.
 *
 * For grouping sets, the order of items is instead forced to agree with that
 * of the grouping set (and items not in the grouping set are skipped). The
 * work of sorting the order of grouping set elements to match the ORDER BY if
 * possible is done elsewhere.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>preprocess_groupclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_groupclause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partial_match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

	<comment type="block">/* For grouping sets, we need to force the ordering */</comment>
	<if_stmt><if>if <condition>(<expr><name>force</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>sl</argument>, <argument>force</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>get_sortgroupref_clause</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<return>return <expr><name>new_groupclause</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If no ORDER BY, nothing useful to do here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan the ORDER BY clause and construct a list of matching GROUP BY
	 * items, but only as far as we can make a matching prefix.
	 *
	 * This code assumes that the sortClause contains no duplicate items.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>sl</argument>, <argument>parse-&gt;sortClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>gl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* no match, so stop scanning */</comment>
	</block_content>}</block>

	<comment type="block">/* Did we match all of the ORDER BY list, or just some of it? */</comment>
	<expr_stmt><expr><name>partial_match</name> <operator>=</operator> <operator>(</operator><name>sl</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* If no match at all, no point in reordering GROUP BY */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_groupclause</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add any remaining GROUP BY items to the new list, but only if we were
	 * able to make a complete match.  In other words, we only rearrange the
	 * GROUP BY list if the result is that one list is a prefix of the other
	 * --- otherwise there's no possibility of a common sort.  Also, give up
	 * if there are any non-sortable GROUP BY items, since then there's no
	 * hope anyway.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* it matched an ORDER BY item */</comment>
		<if_stmt><if>if <condition>(<expr><name>partial_match</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* give up, no common sort possible */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* give up, GROUP BY can't be sorted */</comment>
		<expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Success --- install the rearranged GROUP BY list */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>new_groupclause</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract lists of grouping sets that can be implemented using a single
 * rollup-type aggregate pass each. Returns a list of lists of grouping sets.
 *
 * Input must be sorted with smallest sets first. Result has each sublist
 * sorted with smallest sets first.
 *
 * We want to produce the absolute minimum possible number of lists here to
 * avoid excess sorts. Fortunately, there is an algorithm for this; the problem
 * of finding the minimal partition of a partially-ordered set into chains
 * (which is what we need, taking the list of grouping sets as a poset ordered
 * by set inclusion) can be mapped to the problem of finding the maximum
 * cardinality matching on a bipartite graph, which is solvable in polynomial
 * time with a worst case of no worse than O(n^2.5) and usually much
 * better. Since our N is at most 4096, we don't need to consider fallbacks to
 * heuristic or approximate methods.  (Planning time for a 12-d cube is under
 * half a second on my modest system even with optimization off and assertions
 * on.)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>extract_rollup_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_sets_raw</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_sets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* distinct sets */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_chains</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>orig_sets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>set_masks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>chains</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>adjacency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name>	   <modifier>*</modifier></type><name>adjacency_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BipartiteMatchState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start by stripping out empty sets.  The algorithm doesn't require this,
	 * but the planner currently needs all empty sets to be returned in the
	 * first list, so we strip them here and add them back after.
	 */</comment>
	<while>while <condition>(<expr><name>lc1</name> <operator>&amp;&amp;</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>++</operator><name>num_empty</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* bail out now if it turns out that all we had were empty sets. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 * We don't strictly need to remove duplicate sets here, but if we don't,
	 * they tend to become scattered through the result, which is a bit
	 * confusing (and irritating if we ever decide to optimize them out).
	 * So we remove them here and add them back after.
	 *
	 * For each non-duplicate set, we fill in the following:
	 *
	 * orig_sets[i] = list of the original set lists
	 * set_masks[i] = bitmapset for testing inclusion
	 * adjacency[i] = array [n, v1, v2, ... vn] of adjacency indices
	 *
	 * chains[i] will be the result group this set is assigned to.
	 *
	 * We index all of these from 1 rather than 0 because it is convenient
	 * to leave 0 free for the NIL node in the graph algorithm.
	 *----------
	 */</comment>
	<expr_stmt><expr><name>orig_sets</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>set_masks</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>adjacency</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>adjacency_buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>j_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lc1</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>candidate</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>candidate_set</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>dup_of</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>candidate</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>candidate_set</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>candidate_set</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* we can only be a dup if we're the same length as a previous set */</comment>
		<if_stmt><if>if <condition>(<expr><name>j_size</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>set_masks</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate_set</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>dup_of</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>j_size</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>j_size</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dup_of</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>orig_sets</name><index>[<expr><name>dup_of</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>orig_sets</name><index>[<expr><name>dup_of</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>candidate_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>n_adj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>orig_sets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>set_masks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>candidate_set</name></expr>;</expr_stmt>

			<comment type="block">/* fill in adjacency list; no need to compare equal-size sets */</comment>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>k</name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>set_masks</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate_set</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>adjacency_buf</name><index>[<expr><operator>++</operator><name>n_adj</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>n_adj</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>adjacency_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>n_adj</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>n_adj</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>adjacency_buf</name></expr></argument>, <argument><expr><operator>(</operator><name>n_adj</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>num_sets</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the graph matching algorithm to do the work.
	 */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>BipartiteMatch</name><argument_list>(<argument><expr><name>num_sets</name></expr></argument>, <argument><expr><name>num_sets</name></expr></argument>, <argument><expr><name>adjacency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now, the state-&gt;pair* fields have the info we need to assign sets to
	 * chains. Two sets (u,v) belong to the same chain if pair_uv[u] = v or
	 * pair_vu[v] = u (both will be true, but we check both so that we can do
	 * it in one pass)
	 */</comment>
	<expr_stmt><expr><name>chains</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>u</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pair_vu</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>v</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pair_uv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>u</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>chains</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>chains</name><index>[<expr><name>v</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>num_chains</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* build result lists. */</comment>
	<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_chains</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>c</name> <init>= <expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>results</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>orig_sets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* push any empty sets back on the first list. */</comment>
	<while>while <condition>(<expr><name>num_empty</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* make result list */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_chains</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Free all the things.
	 *
	 * (This is over-fussy for small sets but for large sets we could have
	 * tied up a nontrivial amount of memory.)
	 */</comment>
	<expr_stmt><expr><call><name>BipartiteMatchFree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>adjacency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>adjacency_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>orig_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>set_masks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>set_masks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reorder the elements of a list of grouping sets such that they have correct
 * prefix relationships. Also inserts the GroupingSetData annotations.
 *
 * The input must be ordered with smallest sets first; the result is returned
 * with largest sets first.  Note that the result shares no list substructure
 * with the input, so it's safe for the caller to modify it later.
 *
 * If we're passed in a sortclause, we follow its order of columns to the
 * extent possible, to minimize the chance that we add unnecessary sorts.
 * (We're trying here to ensure that GROUPING SETS ((a,b,c),(c)) ORDER BY c,b,a
 * gets implemented in one pass.)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>reorder_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingsets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortclause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>previous</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupingsets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>candidate</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_elems</name> <init>= <expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sortclause</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <call><name>list_length</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>sortclause</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ref</name> <init>= <expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>previous</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_elems</name> <operator>=</operator> <call><name>list_delete_int</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* diverged from the sortclause; give up on it */</comment>
				<expr_stmt><expr><name>sortclause</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Safe to use list_concat (which shares cells of the second arg)
		 * because we know that new_elems does not share cells with anything.
		 */</comment>
		<expr_stmt><expr><name>previous</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><name>new_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute query_pathkeys and other pathkeys during plan generation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>standard_qp_callback</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>standard_qp_extra</name> <modifier>*</modifier></type><name>qp_extra</name> <init>= <expr><operator>(</operator><name>standard_qp_extra</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>qp_extra</name><operator>-&gt;</operator><name>tlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>activeWindows</name> <init>= <expr><name><name>qp_extra</name><operator>-&gt;</operator><name>activeWindows</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Calculate pathkeys that represent grouping/ordering requirements.  The
	 * sortClause is certainly sort-able, but GROUP BY and DISTINCT might not
	 * be, in which case we just leave their pathkeys empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qp_extra</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
		<call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>qp_extra</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>=</operator>
			<call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>qp_extra</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										  <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* We consider only the first (bottom) window in pathkeys logic */</comment>
	<if_stmt><if>if <condition>(<expr><name>activeWindows</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name> <operator>=</operator> <call><name>make_pathkeys_for_window</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>wc</name></expr></argument>,
														 <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>&amp;&amp;</operator>
		<call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name> <operator>=</operator>
			<call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
										  <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>=</operator>
		<call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
									  <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out whether we want a sorted result from query_planner.
	 *
	 * If we have a sortable GROUP BY clause, then we want a result sorted
	 * properly for grouping.  Otherwise, if we have window functions to
	 * evaluate, we try to sort for the first window.  Otherwise, if there's a
	 * sortable DISTINCT clause that's more rigorous than the ORDER BY clause,
	 * we try to produce output that's sufficiently well sorted for the
	 * DISTINCT.  Otherwise, if there is an ORDER BY clause, we want to sort
	 * by the ORDER BY clause.
	 *
	 * Note: if we have both ORDER BY and GROUP BY, and ORDER BY is a superset
	 * of GROUP BY, it would be tempting to request sort by ORDER BY --- but
	 * that might just leave us failing to exploit an available sort order at
	 * all.  Needs more thought.  The choice for DISTINCT versus ORDER BY is
	 * much easier, since we know that the parser ensured that one is a
	 * superset of the other.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
			 <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate number of groups produced by grouping clauses (1 if not grouping)
 *
 * path_rows: number of output rows from scan/join step
 * gd: grouping sets data including list of grouping sets and their clauses
 * target_list: target list containing group clause references
 *
 * If doing grouping sets, we also annotate the gsets data with the estimates
 * for each set and each individual rollup list, with a view to later
 * determining whether some combination of them could be hashed instead.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>get_number_of_groups</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>path_rows</name></decl></parameter>,
					 <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupExprs</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Add up the estimates for each grouping set */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep Coverity happy */</comment>

			<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gd-&gt;rollups</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name>target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

				<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>rollup-&gt;gsets</argument>, <argument>lc2</argument>, <argument>rollup-&gt;gsets_data</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>double</name></type>		<name>numGroups</name> <init>= <expr><call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																<argument><expr><name>groupExprs</name></expr></argument>,
																<argument><expr><name>path_rows</name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>gset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>+=</operator> <name>numGroups</name></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>dNumGroups</name> <operator>+=</operator> <name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name><name>gd</name><operator>-&gt;</operator><name>hash_sets_idx</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name>target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>gd-&gt;hash_sets_idx</argument>, <argument>lc2</argument>, <argument>gd-&gt;unsortable_sets</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>double</name></type>		<name>numGroups</name> <init>= <expr><call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																<argument><expr><name>groupExprs</name></expr></argument>,
																<argument><expr><name>path_rows</name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>gset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name> <operator>+=</operator> <name>numGroups</name></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>dNumGroups</name> <operator>+=</operator> <name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Plain GROUP BY */</comment>
			<expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												 <argument><expr><name>target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupExprs</name></expr></argument>, <argument><expr><name>path_rows</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Empty grouping sets ... one result row for each one */</comment>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Plain aggregation, one result row */</comment>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not grouping */</comment>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>dNumGroups</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_hashagg_tablesize
 *	  estimate the number of bytes that a hash aggregate hashtable will
 *	  require based on the agg_costs, path width and dNumGroups.
 *
 * XXX this may be over-estimating the size now that hashagg knows to omit
 * unneeded columns from the hashtable. Also for mixed-mode grouping sets,
 * grouping columns not in the hashed set are counted here even though hashagg
 * won't store them. Is this a problem?
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>estimate_hashagg_tablesize</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>

	<comment type="block">/* Estimate per-hash-entry space at tuple width... */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* plus space for pass-by-ref transition values... */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>transitionSpace</name></name></expr>;</expr_stmt>
	<comment type="block">/* plus the per-hash-entry overhead */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <call><name>hash_agg_entry_size</name><argument_list>(<argument><expr><name><name>agg_costs</name><operator>-&gt;</operator><name>numAggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that this disregards the effect of fill-factor and growth policy
	 * of the hash-table. That's probably ok, given default the default
	 * fill-factor is relatively high. It'd be hard to meaningfully factor in
	 * "double-in-size" growth policies here.
	 */</comment>
	<return>return <expr><name>hashentrysize</name> <operator>*</operator> <name>dNumGroups</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_grouping_paths
 *
 * Build a new upperrel containing Paths for grouping and/or aggregation.
 * Along the way, we also build an upperrel for Paths which are partially
 * grouped and/or aggregated.  A partially grouped and/or aggregated path
 * needs a FinalizeAggregate node to complete the aggregation.  Currently,
 * the only partially grouped paths we build are also partial paths; that
 * is, they need a Gather and then a FinalizeAggregate.
 *
 * input_rel: contains the source-data Paths
 * target: the pathtarget for the result Paths to compute
 * agg_costs: cost info about all aggregates in query (in AGGSPLIT_SIMPLE mode)
 * gd: grouping sets data including list of grouping sets and their clauses
 *
 * Note: all Paths in input_rel are expected to return the target computed
 * by make_group_input_target.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
					  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create grouping relation to hold fully aggregated grouping and/or
	 * aggregation paths.
	 */</comment>
	<expr_stmt><expr><name>grouped_rel</name> <operator>=</operator> <call><name>make_grouping_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
									<argument><expr><name>target_parallel_safe</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create either paths for a degenerate grouping or paths for ordinary
	 * grouping, as appropriate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_degenerate_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>create_degenerate_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupPathExtraData</name></type> <name>extra</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Determine whether it's possible to perform sort-based
		 * implementations of grouping.  (Note that if groupClause is empty,
		 * grouping_is_sortable() is trivially true, and all the
		 * pathkeys_contained_in() tests will succeed too, so that we'll
		 * consider every surviving input path.)
		 *
		 * If we have grouping sets, we might be able to sort some but not all
		 * of them; in this case, we need can_sort to be true as long as we
		 * must consider any sorted-input plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>gd</name> <operator>&amp;&amp;</operator> <name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator>
			<operator>||</operator> <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>GROUPING_CAN_USE_SORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Determine whether we should consider hash-based implementations of
		 * grouping.
		 *
		 * Hashed aggregation only applies if we're grouping. If we have
		 * grouping sets, some groups might be hashable but others not; in
		 * this case we set can_hash true as long as there is nothing globally
		 * preventing us from hashing (and we should therefore consider plans
		 * with hashes).
		 *
		 * Executor doesn't support hashed aggregation with DISTINCT or ORDER
		 * BY aggregates.  (Doing so would imply storing *all* the input
		 * values in the hash table, and/or running many sorts in parallel,
		 * either of which seems like a certain loser.)  We similarly don't
		 * support ordered-set aggregates in hashed aggregation, but that case
		 * is also included in the numOrderedAggs count.
		 *
		 * Note: grouping_is_hashable() is much more expensive to check than
		 * the other gating conditions, so we want to do it last.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			 <name><name>agg_costs</name><operator>-&gt;</operator><name>numOrderedAggs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <operator>(</operator><ternary><condition><expr><name>gd</name></expr> ?</condition><then> <expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name></expr> </then><else>: <expr><call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>GROUPING_CAN_USE_HASH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Determine whether partial aggregation is possible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>can_partial_agg</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>GROUPING_CAN_PARTIAL_AGG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>target_parallel_safe</name></name> <operator>=</operator> <name>target_parallel_safe</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>havingQual</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>targetList</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>partial_costs_set</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine whether partitionwise aggregation is in theory possible.
		 * It can be disabled by the user, and for now, we don't try to
		 * support grouping sets.  create_ordinary_grouping_paths() will check
		 * additional conditions, such as whether input_rel is partitioned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_partitionwise_aggregate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>patype</name></name> <operator>=</operator> <name>PARTITIONWISE_AGGREGATE_FULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>extra</name><operator>.</operator><name>patype</name></name> <operator>=</operator> <name>PARTITIONWISE_AGGREGATE_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>create_ordinary_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
									   <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>gd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>grouped_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_grouping_rel
 *
 * Create a new grouping rel and set basic properties.
 *
 * input_rel represents the underlying scan/join relation.
 * target is the output expected from the grouping relation.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>make_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
				  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>grouped_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>,
									  <argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_OTHER_UPPER_REL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * By tradition, the relids set for the main grouping relation is
		 * NULL.  (This could be changed, but might require adjustments
		 * elsewhere.)
		 */</comment>
		<expr_stmt><expr><name>grouped_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set target. */</comment>
	<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input relation is not parallel-safe, then the grouped relation
	 * can't be parallel-safe, either.  Otherwise, it's parallel-safe if the
	 * target list and HAVING quals are parallel-safe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>target_parallel_safe</name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>havingQual</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the grouped rel.
	 */</comment>
	<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<return>return <expr><name>grouped_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_degenerate_grouping
 *
 * A degenerate grouping is one in which the query has a HAVING qual and/or
 * grouping sets, but no aggregates and no GROUP BY (which implies that the
 * grouping sets are all empty).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_degenerate_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_degenerate_grouping_paths
 *
 * When the grouping is degenerate (see is_degenerate_grouping), we are
 * supposed to emit either zero or one row for each grouping set depending on
 * whether HAVING succeeds.  Furthermore, there cannot be any variables in
 * either HAVING or the targetlist, so we actually do not need the FROM table
 * at all! We can just throw away the plan-so-far and generate a Result node.
 * This is a sufficiently unusual corner case that it's not worth contorting
 * the structure of this module to avoid having to generate the earlier paths
 * in the first place.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_degenerate_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Doesn't seem worthwhile writing code to cons up a generate_series
		 * or a values scan to emit multiple rows. Instead just make N clones
		 * and append them.  (With a volatile HAVING clause, this means you
		 * might get between 0 and N output rows. Offhand I think that's
		 * desired.)
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>paths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>--</operator><name>nrows</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_result_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
								   <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>paths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_append_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							   <argument><expr><name>grouped_rel</name></expr></argument>,
							   <argument><expr><name>paths</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No grouping sets, or just one, so one output row */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_result_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
							   <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
							   <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_ordinary_grouping_paths
 *
 * Create grouping paths for the ordinary (that is, non-degenerate) case.
 *
 * We need to consider sorted and hashed aggregation in the same function,
 * because otherwise (1) it would be harder to throw an appropriate error
 * message if neither way works, and (2) we should not allow hashtable size
 * considerations to dissuade us from using hashing if sorting is not possible.
 *
 * *partially_grouped_rel_p will be set to the partially grouped rel which this
 * function creates, or to NULL if it doesn't create one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_ordinary_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
							   <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							   <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>partially_grouped_rel_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionwiseAggregateType</name></type> <name>patype</name> <init>= <expr><name>PARTITIONWISE_AGGREGATE_NONE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is the topmost grouping relation or if the parent relation is
	 * doing some form of partitionwise aggregation, then we may be able to do
	 * it at this level also.  However, if the input relation is not
	 * partitioned, partitionwise aggregate is impossible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>!=</operator> <name>PARTITIONWISE_AGGREGATE_NONE</name> <operator>&amp;&amp;</operator>
		<call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is the topmost relation or if the parent relation is doing
		 * full partitionwise aggregation, then we can do full partitionwise
		 * aggregation provided that the GROUP BY clause contains all of the
		 * partitioning columns at this level.  Otherwise, we can do at most
		 * partial partitionwise aggregation.  But if partial aggregation is
		 * not supported in general then we can't use it for partitionwise
		 * aggregation either.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_FULL</name> <operator>&amp;&amp;</operator>
			<call><name>group_by_has_partkey</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>patype</name> <operator>=</operator> <name>PARTITIONWISE_AGGREGATE_FULL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GROUPING_CAN_PARTIAL_AGG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>patype</name> <operator>=</operator> <name>PARTITIONWISE_AGGREGATE_PARTIAL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>patype</name> <operator>=</operator> <name>PARTITIONWISE_AGGREGATE_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Before generating paths for grouped_rel, we first generate any possible
	 * partially grouped paths; that way, later code can easily consider both
	 * parallel and non-parallel approaches to grouping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GROUPING_CAN_PARTIAL_AGG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>force_rel_creation</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we're doing partitionwise aggregation at this level, force
		 * creation of a partially_grouped_rel so we can add partitionwise
		 * paths to it.
		 */</comment>
		<expr_stmt><expr><name>force_rel_creation</name> <operator>=</operator> <operator>(</operator><name>patype</name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_PARTIAL</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>partially_grouped_rel</name> <operator>=</operator>
			<call><name>create_partial_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>grouped_rel</name></expr></argument>,
										  <argument><expr><name>input_rel</name></expr></argument>,
										  <argument><expr><name>gd</name></expr></argument>,
										  <argument><expr><name>extra</name></expr></argument>,
										  <argument><expr><name>force_rel_creation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set out parameter. */</comment>
	<expr_stmt><expr><operator>*</operator><name>partially_grouped_rel_p</name> <operator>=</operator> <name>partially_grouped_rel</name></expr>;</expr_stmt>

	<comment type="block">/* Apply partitionwise aggregation technique, if possible. */</comment>
	<if_stmt><if>if <condition>(<expr><name>patype</name> <operator>!=</operator> <name>PARTITIONWISE_AGGREGATE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>create_partitionwise_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
											<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>,
											<argument><expr><name>gd</name></expr></argument>, <argument><expr><name>patype</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we are doing partial aggregation only, return. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_PARTIAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Gather any partially grouped partial paths. */</comment>
	<if_stmt><if>if <condition>(<expr><name>partially_grouped_rel</name> <operator>&amp;&amp;</operator> <name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gather_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Estimate number of groups.
	 */</comment>
	<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
									  <argument><expr><name>gd</name></expr></argument>,
									  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build final grouping paths */</comment>
	<expr_stmt><expr><call><name>add_paths_to_grouping_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
							  <argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>gd</name></expr></argument>,
							  <argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Give a helpful error if we failed to find any implementation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement GROUP BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>,
													  <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
													  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
									<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For a given input path, consider the possible ways of doing grouping sets on
 * it, by combinations of hashing and sorting.  This can be called multiple
 * times, so it's important that it not scribble on input.  No result is
 * returned, but any generated paths are added to grouped_rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consider_groupingsets_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
							<parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
							<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're not being offered sorted input, then only consider plans that
	 * can be done entirely by hashing.
	 *
	 * We can hash everything if it looks like it'll fit in work_mem. But if
	 * the input is actually sorted despite not being advertised as such, we
	 * prefer to make use of that in order to use less memory.
	 *
	 * If none of the grouping sets are sortable, then ignore the work_mem
	 * limit and generate a path anyway, since otherwise we'll just fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_rollups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>unhashed_rollup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sets_data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>empty_sets_data</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>empty_sets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l_start</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStrategy</name></type> <name>strat</name> <init>= <expr><name>AGG_HASHED</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>exclude_groups</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>can_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the input is coincidentally sorted usefully (which can happen
		 * even if is_sorted is false, since that only means that our caller
		 * has set up the sorting for us), then save some hashtable space by
		 * making use of that. But we need to watch out for degenerate cases:
		 *
		 * 1) If there are any empty grouping sets, then group_pathkeys might
		 * be NIL if all non-empty grouping sets are unsortable. In this case,
		 * there will be a rollup containing only empty groups, and the
		 * pathkeys_contained_in test is vacuously true; this is ok.
		 *
		 * XXX: the above relies on the fact that group_pathkeys is generated
		 * from the first rollup. If we add the ability to consider multiple
		 * sort orders for grouping input, this assumption might fail.
		 *
		 * 2) If there are no empty sets and only unsortable sets, then the
		 * rollups list will be empty (and thus l_start == NULL), and
		 * group_pathkeys will be NIL; we must ensure that the vacuously-true
		 * pathkeys_contain_in test doesn't cause us to crash.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>l_start</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unhashed_rollup</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>l_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>exclude_groups</name> <operator>=</operator> <name><name>unhashed_rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>l_start</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hashsize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
											  <argument><expr><name>agg_costs</name></expr></argument>,
											  <argument><expr><name>dNumGroups</name> <operator>-</operator> <name>exclude_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * gd-&gt;rollups is empty if we have only unsortable columns to work
		 * with.  Override work_mem in that case; otherwise, we'll rely on the
		 * sorted-input case to generate usable mixed paths.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hashsize</name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>				<comment type="block">/* nope, won't fit */</comment>

		<comment type="block">/*
		 * We need to burst the existing rollups list into individual grouping
		 * sets and recompute a groupClause for each set.
		 */</comment>
		<expr_stmt><expr><name>sets_data</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>l_start</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we find an unhashable rollup that's not been skipped by the
			 * "actually sorted" check above, we can't cope; we'd need sorted
			 * input (with a different sort order) but we can't get that here.
			 * So bail out; we'll get a valid path from the is_sorted case
			 * instead.
			 *
			 * The mere presence of empty grouping sets doesn't make a rollup
			 * unhashable (see preprocess_grouping_sets), we handle those
			 * specially below.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sets_data</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>sets_data</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sets_data</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gset</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>gset</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Empty grouping sets can't be hashed. */</comment>
				<expr_stmt><expr><name>empty_sets_data</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>empty_sets_data</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>empty_sets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>empty_sets</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>rollup</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
														 <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>,
														 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we didn't find anything nonempty to hash, then bail.  We'll
		 * generate a path from the is_sorted case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_rollups</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there were empty grouping sets they should have been in the
		 * first rollup.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>unhashed_rollup</name> <operator>||</operator> <operator>!</operator><name>empty_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>unhashed_rollup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>new_rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_rollups</name></expr></argument>, <argument><expr><name>unhashed_rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_MIXED</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>empty_sets</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <name>empty_sets_data</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <name>empty_sets</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>empty_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_MIXED</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>grouped_rel</name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										  <argument><expr><name>strat</name></expr></argument>,
										  <argument><expr><name>new_rollups</name></expr></argument>,
										  <argument><expr><name>agg_costs</name></expr></argument>,
										  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have sorted input but nothing we can do with it, bail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Given sorted input, we try and make two paths: one sorted and one mixed
	 * sort/hash. (We need to try both because hashagg might be disabled, or
	 * some columns might not be sortable.)
	 *
	 * can_hash is passed in as false if some obstacle elsewhere (such as
	 * ordered aggs) means that we shouldn't consider hashing at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>can_hash</name> <operator>&amp;&amp;</operator> <name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rollups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hash_sets</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>availspace</name> <init>= <expr><operator>(</operator><name>work_mem</name> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Account first for space needed for groups we can't sort at all.
		 */</comment>
		<expr_stmt><expr><name>availspace</name> <operator>-=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
														  <argument><expr><name>agg_costs</name></expr></argument>,
														  <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>availspace</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>scale</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_rollups</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>k_capacity</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>k_weights</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>num_rollups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>hash_items</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We treat this as a knapsack problem: the knapsack capacity
			 * represents work_mem, the item weights are the estimated memory
			 * usage of the hashtables needed to implement a single rollup,
			 * and we really ought to use the cost saving as the item value;
			 * however, currently the costs assigned to sort nodes don't
			 * reflect the comparison costs well, and so we treat all items as
			 * of equal value (each rollup we hash instead saves us one sort).
			 *
			 * To use the discrete knapsack, we need to scale the values to a
			 * reasonably small bounded range.  We choose to allow a 5% error
			 * margin; we have no more than 4096 rollups in the worst possible
			 * case, which with a 5% error margin will require a bit over 42MB
			 * of workspace. (Anyone wanting to plan queries that complex had
			 * better have the memory for it.  In more reasonable cases, with
			 * no more than a couple of dozen rollups, the memory usage will
			 * be negligible.)
			 *
			 * k_capacity is naturally bounded, but we clamp the values for
			 * scale and weight (below) to avoid overflows or underflows (or
			 * uselessly trying to use a scale factor less than 1 byte).
			 */</comment>
			<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>availspace</name> <operator>/</operator> <operator>(</operator><literal type="number">20.0</literal> <operator>*</operator> <name>num_rollups</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>k_capacity</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>floor</name><argument_list>(<argument><expr><name>availspace</name> <operator>/</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We leave the first rollup out of consideration since it's the
			 * one that matches the input sort order.  We assign indexes "i"
			 * to only those entries considered for hashing; the second loop,
			 * below, must use the same condition.
			 */</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(list_head(gd-&gt;rollups))</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>sz</name> <init>= <expr><call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
																<argument><expr><name>agg_costs</name></expr></argument>,
																<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * If sz is enormous, but work_mem (and hence scale) is
					 * small, avoid integer overflow here.
					 */</comment>
					<expr_stmt><expr><name><name>k_weights</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>floor</name><argument_list>(<argument><expr><name>sz</name> <operator>/</operator> <name>scale</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>k_capacity</name> <operator>+</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * Apply knapsack algorithm; compute the set of items which
			 * maximizes the value stored (in this case the number of sorts
			 * saved) while keeping the total size (approximately) within
			 * capacity.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hash_items</name> <operator>=</operator> <call><name>DiscreteKnapsack</name><argument_list>(<argument><expr><name>k_capacity</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k_weights</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>hash_items</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(list_head(gd-&gt;rollups))</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>hash_items</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>hash_sets</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>hash_sets</name></expr></argument>,
													<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rollups</name> <operator>&amp;&amp;</operator> <name>hash_sets</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hash_sets</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>,
													 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>rollup</name></expr></argument>, <argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>rollups</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>grouped_rel</name></expr></argument>,
											  <argument><expr><name>path</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
											  <argument><expr><name>AGG_MIXED</name></expr></argument>,
											  <argument><expr><name>rollups</name></expr></argument>,
											  <argument><expr><name>agg_costs</name></expr></argument>,
											  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now try the simple sorted case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>grouped_rel</name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										  <argument><expr><name>AGG_SORTED</name></expr></argument>,
										  <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>,
										  <argument><expr><name>agg_costs</name></expr></argument>,
										  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_window_paths
 *
 * Build a new upperrel containing Paths for window-function evaluation.
 *
 * input_rel: contains the source-data Paths
 * input_target: result of make_window_input_target
 * output_target: what the topmost WindowAggPath should return
 * tlist: query's target list (needed to look up pathkeys)
 * wflists: result of find_window_functions
 * activeWindows: result of select_active_windows
 *
 * Note: all Paths in input_rel are expected to return input_target.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_window_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
					<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>output_target_parallel_safe</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					<parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>window_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* For now, do all work in the (WINDOW, NULL) upperrel */</comment>
	<expr_stmt><expr><name>window_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_WINDOW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input relation is not parallel-safe, then the window relation
	 * can't be parallel-safe, either.  Otherwise, we need to examine the
	 * target list and active windows for non-parallel-safe constructs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>output_target_parallel_safe</name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>activeWindows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the window rel.
	 */</comment>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Consider computing window functions starting from the existing
	 * cheapest-total path (which will likely require a sort) as well as any
	 * existing paths that satisfy root-&gt;window_pathkeys (which won't).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>||</operator>
			<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>create_one_window_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name>window_rel</name></expr></argument>,
								   <argument><expr><name>path</name></expr></argument>,
								   <argument><expr><name>input_target</name></expr></argument>,
								   <argument><expr><name>output_target</name></expr></argument>,
								   <argument><expr><name>tlist</name></expr></argument>,
								   <argument><expr><name>wflists</name></expr></argument>,
								   <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_WINDOW</name></expr></argument>,
													 <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_WINDOW</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now choose the best path(s) */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>window_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>window_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stack window-function implementation steps atop the given Path, and
 * add the result to window_rel.
 *
 * window_rel: upperrel to contain result
 * path: input Path to use (must return input_target)
 * input_target: result of make_window_input_target
 * output_target: what the topmost WindowAggPath should return
 * tlist: query's target list (needed to look up pathkeys)
 * wflists: result of find_window_functions
 * activeWindows: result of select_active_windows
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_one_window_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>window_rel</name></decl></parameter>,
					   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>window_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since each window clause could require a different sort order, we stack
	 * up a WindowAgg node for each clause, with sort steps between them as
	 * needed.  (We assume that select_active_windows chose a good order for
	 * executing the clauses in.)
	 *
	 * input_target should contain all Vars and Aggs needed for the result.
	 * (In some cases we wouldn't need to propagate all of these all the way
	 * to the top, since they might only be needed as inputs to WindowFuncs.
	 * It's probably not worth trying to optimize that though.)  It must also
	 * contain all window partitioning and sorting expressions, to ensure
	 * they're computed only once at the bottom of the stack (that's critical
	 * for volatile functions).  As we climb up the stack, we'll add outputs
	 * for the WindowFuncs computed at each level.
	 */</comment>
	<expr_stmt><expr><name>window_target</name> <operator>=</operator> <name>input_target</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeWindows</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>window_pathkeys</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>window_pathkeys</name> <operator>=</operator> <call><name>make_pathkeys_for_window</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>wc</name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Sort if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>window_pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name>window_pathkeys</name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Add the current WindowFuncs to the output target for this
			 * intermediate WindowAggPath.  We must copy window_target to
			 * avoid changing the previous path's target.
			 *
			 * Note: a WindowFunc adds nothing to the target's eval costs; but
			 * we do need to account for the increase in tlist width.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>window_target</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name>window_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>wflists-&gt;windowFuncs[wc-&gt;winref]</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>window_target</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>wfunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>window_target</name><operator>-&gt;</operator><name>width</name></name> <operator>+=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Install the goal target in the topmost WindowAgg */</comment>
			<expr_stmt><expr><name>window_target</name> <operator>=</operator> <name>output_target</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_windowagg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>window_target</name></expr></argument>,
								  <argument><expr><name><name>wflists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>window_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_distinct_paths
 *
 * Build a new upperrel containing Paths for SELECT DISTINCT evaluation.
 *
 * input_rel: contains the source-data Paths
 *
 * Note: input paths should already compute the desired pathtarget, since
 * Sort/Unique won't project anything.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_distinct_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_input_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>distinct_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numDistinctRows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* For now, do all work in the (DISTINCT, NULL) upperrel */</comment>
	<expr_stmt><expr><name>distinct_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_DISTINCT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't compute anything at this level, so distinct_rel will be
	 * parallel-safe if the input rel is parallel-safe.  In particular, if
	 * there is a DISTINCT ON (...) clause, any path for the input_rel will
	 * output those expressions, and will not be parallel-safe unless those
	 * expressions are parallel-safe.
	 */</comment>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the distinct_rel.
	 */</comment>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<comment type="block">/* Estimate number of distinct rows there will be */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there was grouping or aggregation, use the number of input rows
		 * as the estimated number of DISTINCT rows (ie, assume the input is
		 * already mostly unique).
		 */</comment>
		<expr_stmt><expr><name>numDistinctRows</name> <operator>=</operator> <name><name>cheapest_input_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise, the UNIQUE filter has effects comparable to GROUP BY.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>distinctExprs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>distinctExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
												<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDistinctRows</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinctExprs</name></expr></argument>,
											  <argument><expr><name><name>cheapest_input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Consider sort-based implementations of DISTINCT, if possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First, if we have any adequately-presorted paths, just stick a
		 * Unique node on those.  Then consider doing an explicit sort of the
		 * cheapest input path and Unique'ing that.
		 *
		 * When we have DISTINCT ON, we must sort by the more rigorous of
		 * DISTINCT and ORDER BY, else it won't have the desired behavior.
		 * Also, if we do have to do an explicit sort, we might as well use
		 * the more rigorous ordering to avoid a second sort later.  (Note
		 * that the parser will have ensured that one clause is a prefix of
		 * the other.)
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>needed_pathkeys</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>needed_pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
												  <argument><expr><name>path</name></expr></argument>,
												  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>numDistinctRows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* For explicit-sort case, always use the more rigorous clause */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt>
			<comment type="block">/* Assert checks that parser didn't mess up... */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>,
										 <argument><expr><name>needed_pathkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <name>cheapest_input_path</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>needed_pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name>needed_pathkeys</name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
										  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>numDistinctRows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Consider hash-based implementations of DISTINCT, if possible.
	 *
	 * If we were not able to make any other types of path, we *must* hash or
	 * die trying.  If we do have other choices, there are several things that
	 * should prevent selection of hashing: if the query uses DISTINCT ON
	 * (because it won't really have the expected behavior if we hash), or if
	 * enable_hashagg is off, or if it looks like the hashtable will exceed
	 * work_mem.
	 *
	 * Note: grouping_is_hashable() is much more expensive to check than the
	 * other gating conditions, so we want to do it last.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* we have no alternatives */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator> <operator>!</operator><name>enable_hashagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* policy-based decision not to hash */</comment>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>

		<comment type="block">/* Estimate per-hash-entry space at tuple width... */</comment>
		<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>cheapest_input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* plus the per-hash-entry overhead */</comment>
		<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <call><name>hash_agg_entry_size</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Allow hashing only if hashtable is predicted to fit in work_mem */</comment>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <operator>(</operator><name>hashentrysize</name> <operator>*</operator> <name>numDistinctRows</name> <operator>&lt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>allow_hash</name> <operator>&amp;&amp;</operator> <call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate hashed aggregate path --- no sort needed */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>distinct_rel</name></expr></argument>,
								 <argument><expr><name>cheapest_input_path</name></expr></argument>,
								 <argument><expr><name><name>cheapest_input_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>,
								 <argument><expr><name>AGG_HASHED</name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
								 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>numDistinctRows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Give a helpful error if we failed to find any implementation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement DISTINCT"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_DISTINCT</name></expr></argument>,
													   <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_DISTINCT</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now choose the best path(s) */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distinct_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_ordered_paths
 *
 * Build a new upperrel containing Paths for ORDER BY evaluation.
 *
 * All paths in the result must satisfy the ORDER BY ordering.
 * The only new path we need consider is an explicit sort on the
 * cheapest-total existing path.
 *
 * input_rel: contains the source-data Paths
 * target: the output tlist the result Paths must emit
 * limit_tuples: estimated bound on the number of output tuples,
 *		or -1 if no LIMIT or couldn't estimate
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_ordered_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_input_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>ordered_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* For now, do all work in the (ORDERED, NULL) upperrel */</comment>
	<expr_stmt><expr><name>ordered_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_ORDERED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input relation is not parallel-safe, then the ordered relation
	 * can't be parallel-safe, either.  Otherwise, it's parallel-safe if the
	 * target list is parallel-safe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>target_parallel_safe</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the ordered_rel.
	 */</comment>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
										  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_input_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* An explicit sort here can take advantage of LIMIT */</comment>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>ordered_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
												 <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Add projection step if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>!=</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
												<argument><expr><name>path</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>ordered_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * generate_gather_paths() will have already generated a simple Gather
	 * path for the best parallel path, if any, and the loop above will have
	 * considered sorting it.  Similarly, generate_gather_paths() will also
	 * have generated order-preserving Gather Merge plans which can be used
	 * without sorting if they happen to match the sort_pathkeys, and the loop
	 * above will have handled those as well.  However, there's one more
	 * possibility: it may make sense to sort the cheapest partial path
	 * according to the required output order and then use Gather Merge.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cheapest_partial_path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If cheapest partial path doesn't need a sort, this is redundant
		 * with what's already been tried.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
								   <argument><expr><name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>ordered_rel</name></expr></argument>,
											 <argument><expr><name>cheapest_partial_path</name></expr></argument>,
											 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
											 <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator>
				<name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_gather_merge_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>,
										 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add projection step if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>!=</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
												<argument><expr><name>path</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>ordered_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_ORDERED</name></expr></argument>,
													  <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_ORDERED</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No need to bother with set_cheapest here; grouping_planner does not
	 * need us to do it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ordered_rel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make_group_input_target
 *	  Generate appropriate PathTarget for initial input to grouping nodes.
 *
 * If there is grouping or aggregation, the scan/join subplan cannot emit
 * the query's final targetlist; for example, it certainly can't emit any
 * aggregate function calls.  This routine generates the correct target
 * for the scan/join subplan.
 *
 * The query target list passed from the parser already contains entries
 * for all ORDER BY and GROUP BY expressions, but it will not have entries
 * for variables used only in HAVING clauses; so we need to add those
 * variables to the subplan target list.  Also, we flatten all expressions
 * except GROUP BY items into their component variables; other expressions
 * will be computed by the upper plan nodes rather than by the subplan.
 * For example, given a query like
 *		SELECT a+b,SUM(c+d) FROM table GROUP BY a+b;
 * we want to pass this targetlist to the subplan:
 *		a+b,c,d
 * where the a+b target will be used by the Sort/Group steps, and the
 * other targets will be used for computing the final results.
 *
 * 'final_target' is the query's final target list (in PathTarget form)
 *
 * The result is the PathTarget to be computed by the Paths returned from
 * query_planner().
 */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_group_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must build a target containing all grouping columns, plus any other
	 * Vars mentioned in the query's targetlist and HAVING qual.
	 */</comment>
	<expr_stmt><expr><name>input_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
			<call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's a grouping column, so add it to the input target as-is.
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-grouping column, so just remember the expression for later
			 * call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's a HAVING clause, we'll need the Vars it uses, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pull out all the Vars mentioned in non-group cols (plus HAVING), and
	 * add them to the input target if not already present.  (A Var used
	 * directly as a GROUP BY item will be present already.)  Note this
	 * includes Vars used in resjunk items, so we are covering the needs of
	 * ORDER BY and window specifications.  Vars used within Aggrefs and
	 * WindowFuncs will be pulled out here, too.
	 */</comment>
	<expr_stmt><expr><name>non_group_vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>non_group_cols</name></expr></argument>,
									 <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
									 <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
									 <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>non_group_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_partial_grouping_target
 *	  Generate appropriate PathTarget for output of partial aggregate
 *	  (or partial grouping, if there are no aggregates) nodes.
 *
 * A partial aggregation node needs to emit all the same aggregates that
 * a regular aggregation node would, plus any aggregates used in HAVING;
 * except that the Aggref nodes should be marked as partial aggregates.
 *
 * In addition, we'd better emit any Vars and PlaceholderVars that are
 * used outside of Aggrefs in the aggregation tlist and HAVING.  (Presumably,
 * these would be Vars that are grouped by or used in grouping expressions.)
 *
 * grouping_target is the tlist to be emitted by the topmost aggregation step.
 * havingQual represents the HAVING clause.
 */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_partial_grouping_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partial_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>grouping_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
			<call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's a grouping column, so add it to the partial_target as-is.
			 * (This allows the upper agg step to repeat the grouping calcs.)
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>partial_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-grouping column, so just remember the expression for later
			 * call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's a HAVING clause, we'll need the Vars/Aggrefs it uses, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>havingQual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pull out all the Vars, PlaceHolderVars, and Aggrefs mentioned in
	 * non-group cols (plus HAVING), and add them to the partial_target if not
	 * already present.  (An expression used directly as a GROUP BY item will
	 * be present already.)  Note this includes Vars used in resjunk items, so
	 * we are covering the needs of ORDER BY and window specifications.
	 */</comment>
	<expr_stmt><expr><name>non_group_exprs</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>non_group_cols</name></expr></argument>,
									  <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									  <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
									  <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>partial_target</name></expr></argument>, <argument><expr><name>non_group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust Aggrefs to put them in partial mode.  At this point all Aggrefs
	 * are at the top level of the target list, so we can just scan the list
	 * rather than recursing through the expression trees.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partial_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>newaggref</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We shouldn't need to copy the substructure of the Aggref node,
			 * but flat-copy the node itself to avoid damaging other trees.
			 */</comment>
			<expr_stmt><expr><name>newaggref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newaggref</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* For now, assume serialization is required */</comment>
			<expr_stmt><expr><call><name>mark_partial_aggref</name><argument_list>(<argument><expr><name>newaggref</name></expr></argument>, <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newaggref</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>partial_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mark_partial_aggref
 *	  Adjust an Aggref to make it represent a partial-aggregation step.
 *
 * The Aggref node is modified in-place; caller must do any copying required.
 */</comment>
<function><type><name>void</name></type>
<name>mark_partial_aggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* aggtranstype should be computed by this point */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... but aggsplit should still be as the parser left it */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the Aggref with the intended partial-aggregation mode */</comment>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust result type if needed.  Normally, a partial aggregate returns
	 * the aggregate's transition type; but if that's INTERNAL and we're
	 * serializing, it returns BYTEA instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator> <call><name>DO_AGGSPLIT_SERIALIZE</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * postprocess_setop_tlist
 *	  Fix up targetlist returned by plan_set_operations().
 *
 * We need to transpose sort key info from the orig_tlist into new_tlist.
 * NOTE: this would not be good enough if we supported resjunk sort keys
 * for results of set operations --- then, we'd need to project a whole
 * new tlist to evaluate the resjunk columns.  For now, just ereport if we
 * find any resjunk columns in orig_tlist.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>postprocess_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>orig_tlist_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>orig_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>new_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>new_tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>orig_tle</name></decl>;</decl_stmt>

		<comment type="block">/* ignore resjunk columns in setop result */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>new_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>orig_tlist_item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orig_tle</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>orig_tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orig_tlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>orig_tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>orig_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"resjunk output columns are not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>orig_tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>orig_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>orig_tlist_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"resjunk output columns are not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>new_tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * select_active_windows
 *		Create a list of the "active" window clauses (ie, those referenced
 *		by non-deleted WindowFuncs) in the order they are to be executed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>select_active_windows</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actives</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* First, make a list of the active windows */</comment>
	<expr_stmt><expr><name>actives</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* It's only active if wflists shows some related WindowFuncs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name> <operator>&lt;=</operator> <name><name>wflists</name><operator>-&gt;</operator><name>maxWinRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wflists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>actives</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>actives</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now, ensure that windows with identical partitioning/ordering clauses
	 * are adjacent in the list.  This is required by the SQL standard, which
	 * says that only one sort is to be used for such windows, even if they
	 * are otherwise distinct (eg, different names or framing clauses).
	 *
	 * There is room to be much smarter here, for example detecting whether
	 * one window's sort keys are a prefix of another's (so that sorting for
	 * the latter would do for the former), or putting windows first that
	 * match a sort order available for the underlying query.  For the moment
	 * we are content with meeting the spec.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>actives</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>actives</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

		<comment type="block">/* Move wc from actives to result */</comment>
		<expr_stmt><expr><name>actives</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>actives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now move any matching windows from actives to result */</comment>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>actives</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>lc</name></expr>;</condition> <incr><expr><name>lc</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc2</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* framing options are NOT to be compared here! */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name><name>wc2</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name><name>wc2</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>actives</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>actives</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>wc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_window_input_target
 *	  Generate appropriate PathTarget for initial input to WindowAgg nodes.
 *
 * When the query has window functions, this function computes the desired
 * target to be computed by the node just below the first WindowAgg.
 * This tlist must contain all values needed to evaluate the window functions,
 * compute the final target list, and perform any required final sort step.
 * If multiple WindowAggs are needed, each intermediate one adds its window
 * function results onto this base tlist; only the topmost WindowAgg computes
 * the actual desired target list.
 *
 * This function is much like make_group_input_target, though not quite enough
 * like it to share code.  As in that function, we flatten most expressions
 * into their component variables.  But we do not want to flatten window
 * PARTITION BY/ORDER BY clauses, since that might result in multiple
 * evaluations of them, which would be bad (possibly even resulting in
 * inconsistent answers, if they contain volatile functions).
 * Also, we must not flatten GROUP BY clauses that were left unflattened by
 * make_group_input_target, because we may no longer have access to the
 * individual Vars in them.
 *
 * Another key difference from make_group_input_target is that we don't
 * flatten Aggref expressions, since those are to be computed below the
 * window functions and just referenced like Vars above that.
 *
 * 'final_target' is the query's final target list (in PathTarget form)
 * 'activeWindows' is the list of active windows previously identified by
 *			select_active_windows.
 *
 * The result is the PathTarget to be computed by the plan node immediately
 * below the first WindowAgg node.
 */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_window_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sgrefs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>flattenable_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>flattenable_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect the sortgroupref numbers of window PARTITION/ORDER BY clauses
	 * into a bitmapset for convenient reference below.
	 */</comment>
	<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>activeWindows</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>wc-&gt;partitionClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sgrefs</name></expr></argument>, <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>wc-&gt;orderClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sgrefs</name></expr></argument>, <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* Add in sortgroupref numbers of GROUP BY clauses, too */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sgrefs</name></expr></argument>, <argument><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Construct a target containing all the non-flattenable targetlist items,
	 * and save aside the others for a moment.
	 */</comment>
	<expr_stmt><expr><name>input_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flattenable_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Don't want to deconstruct window clauses or GROUP BY items.  (Note
		 * that such items can't contain window functions, so it's okay to
		 * compute them below the WindowAgg nodes.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name>sgrefs</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Don't want to deconstruct this value, so add it to the input
			 * target as-is.
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Column is to be flattened, so just remember the expression for
			 * later call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>flattenable_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>flattenable_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Pull out all the Vars and Aggrefs mentioned in flattenable columns, and
	 * add them to the input target if not already present.  (Some might be
	 * there already because they're used directly as window/group clauses.)
	 *
	 * Note: it's essential to use PVC_INCLUDE_AGGREGATES here, so that any
	 * Aggrefs are placed in the Agg node's tlist and not left to be computed
	 * at higher levels.  On the other hand, we should recurse into
	 * WindowFuncs to make sure their input expressions are available.
	 */</comment>
	<expr_stmt><expr><name>flattenable_vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>flattenable_cols</name></expr></argument>,
									   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
									   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>flattenable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flattenable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flattenable_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_pathkeys_for_window
 *		Create a pathkeys list describing the required input ordering
 *		for the given WindowClause.
 *
 * The required ordering is first the PARTITION keys, then the ORDER keys.
 * In the future we might try to implement windowing using hashing, in which
 * case the ordering could be relaxed, but for now we always sort.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>make_pathkeys_for_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>window_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>window_sortclauses</name></decl>;</decl_stmt>

	<comment type="block">/* Throw error if can't sort */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement window PARTITION BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Window partitioning columns must be of sortable datatypes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement window ORDER BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Window ordering columns must be of sortable datatypes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Okay, make the combined pathkeys */</comment>
	<expr_stmt><expr><name>window_sortclauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>window_pathkeys</name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><name>window_sortclauses</name></expr></argument>,
													<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>window_sortclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>window_pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_input_target
 *	  Generate appropriate PathTarget for initial input to Sort step.
 *
 * If the query has ORDER BY, this function chooses the target to be computed
 * by the node just below the Sort (and DISTINCT, if any, since Unique can't
 * project) steps.  This might or might not be identical to the query's final
 * output target.
 *
 * The main argument for keeping the sort-input tlist the same as the final
 * is that we avoid a separate projection node (which will be needed if
 * they're different, because Sort can't project).  However, there are also
 * advantages to postponing tlist evaluation till after the Sort: it ensures
 * a consistent order of evaluation for any volatile functions in the tlist,
 * and if there's also a LIMIT, we can stop the query without ever computing
 * tlist functions for later rows, which is beneficial for both volatile and
 * expensive functions.
 *
 * Our current policy is to postpone volatile expressions till after the sort
 * unconditionally (assuming that that's possible, ie they are in plain tlist
 * columns and not ORDER BY/GROUP BY/DISTINCT columns).  We also prefer to
 * postpone set-returning expressions, because running them beforehand would
 * bloat the sort dataset, and because it might cause unexpected output order
 * if the sort isn't stable.  However there's a constraint on that: all SRFs
 * in the tlist should be evaluated at the same plan step, so that they can
 * run in sync in nodeProjectSet.  So if any SRFs are in sort columns, we
 * mustn't postpone any SRFs.  (Note that in principle that policy should
 * probably get applied to the group/window input targetlists too, but we
 * have not done that historically.)  Lastly, expensive expressions are
 * postponed if there is a LIMIT, or if root-&gt;tuple_fraction shows that
 * partial evaluation of the query is possible (if neither is true, we expect
 * to have to evaluate the expressions for every row anyway), or if there are
 * any volatile or set-returning expressions (since once we've put in a
 * projection at all, it won't cost any more to postpone more stuff).
 *
 * Another issue that could potentially be considered here is that
 * evaluating tlist expressions could result in data that's either wider
 * or narrower than the input Vars, thus changing the volume of data that
 * has to go through the Sort.  However, we usually have only a very bad
 * idea of the output width of any expression more complex than a Var,
 * so for now it seems too risky to try to optimize on that basis.
 *
 * Note that if we do produce a modified sort-input target, and then the
 * query ends up not using an explicit Sort, no particular harm is done:
 * we'll initially use the modified target for the preceding path nodes,
 * but then change them to the final target with apply_projection_to_path.
 * Moreover, in such a case the guarantees about evaluation order of
 * volatile functions still hold, since the rows are sorted already.
 *
 * This function has some things in common with make_group_input_target and
 * make_window_input_target, though the detailed rules for what to do are
 * different.  We never flatten/postpone any grouping or ordering columns;
 * those are needed before the sort.  If we do flatten a particular
 * expression, we leave Aggref and WindowFunc nodes alone, since those were
 * computed earlier.
 *
 * 'final_target' is the query's final target list (in PathTarget form)
 * 'have_postponed_srfs' is an output argument, see below
 *
 * The result is the PathTarget to be computed by the plan node immediately
 * below the Sort step (and the Distinct step, if any).  This will be
 * exactly final_target if we decide a projection step wouldn't be helpful.
 *
 * In addition, *have_postponed_srfs is set to true if we choose to postpone
 * any set-returning functions to after the Sort.
 */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_sort_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_postponed_srfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>col_is_srf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>postpone_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_srf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_volatile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_expensive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_srf_sortcols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>postpone_srfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>postponable_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>postponable_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't get here unless query has ORDER BY */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>have_postponed_srfs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* default result */</comment>

	<comment type="block">/* Inspect tlist and collect per-column information */</comment>
	<expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>final_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>col_is_srf</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>postpone_col</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>have_srf</name> <operator>=</operator> <name>have_volatile</name> <operator>=</operator> <name>have_expensive</name> <operator>=</operator> <name>have_srf_sortcols</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the column has a sortgroupref, assume it has to be evaluated
		 * before sorting.  Generally such columns would be ORDER BY, GROUP
		 * BY, etc targets.  One exception is columns that were removed from
		 * GROUP BY by remove_useless_groupby_columns() ... but those would
		 * only be Vars anyway.  There don't seem to be any cases where it
		 * would be worth the trouble to double-check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check for SRF or volatile functions.  Check the SRF case first
			 * because we must know whether we have any postponed SRFs.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator>
				<call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We'll decide below whether these are postponable */</comment>
				<expr_stmt><expr><name><name>col_is_srf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_srf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Unconditionally postpone */</comment>
				<expr_stmt><expr><name><name>postpone_col</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_volatile</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Else check the cost.  XXX it's annoying to have to do this
				 * when set_pathtarget_cost_width() just did it.  Refactor to
				 * allow sharing the work?
				 */</comment>
				<decl_stmt><decl><type><name>QualCost</name></type>	<name>cost</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We arbitrarily define "expensive" as "more than 10X
				 * cpu_operator_cost".  Note this will take in any PL function
				 * with default cost.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&gt;</operator> <literal type="number">10</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>postpone_col</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_expensive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* For sortgroupref cols, just check if any contain SRFs */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_srf_sortcols</name> <operator>&amp;&amp;</operator>
				<name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator>
				<call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_srf_sortcols</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We can postpone SRFs if we have some but none are in sortgroupref cols.
	 */</comment>
	<expr_stmt><expr><name>postpone_srfs</name> <operator>=</operator> <operator>(</operator><name>have_srf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_srf_sortcols</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we don't need a post-sort projection, just return final_target.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>postpone_srfs</name> <operator>||</operator> <name>have_volatile</name> <operator>||</operator>
		  <operator>(</operator><name>have_expensive</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>final_target</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Report whether the post-sort projection will contain set-returning
	 * functions.  This is important because it affects whether the Sort can
	 * rely on the query's LIMIT (if any) to bound the number of rows it needs
	 * to return.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>have_postponed_srfs</name> <operator>=</operator> <name>postpone_srfs</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct the sort-input target, taking all non-postponable columns and
	 * then adding Vars, PlaceHolderVars, Aggrefs, and WindowFuncs found in
	 * the postponable ones.
	 */</comment>
	<expr_stmt><expr><name>input_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>postponable_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>postpone_col</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>postpone_srfs</name> <operator>&amp;&amp;</operator> <name><name>col_is_srf</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>postponable_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>postponable_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
									 <argument><expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Pull out all the Vars, Aggrefs, and WindowFuncs mentioned in
	 * postponable columns, and add them to the sort-input target if not
	 * already present.  (Some might be there already.)  We mustn't
	 * deconstruct Aggrefs or WindowFuncs here, since the projection node
	 * would be unable to recompute them.
	 */</comment>
	<expr_stmt><expr><name>postponable_vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>postponable_cols</name></expr></argument>,
									   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									   <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
									   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>postponable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>postponable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>postponable_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this represents even more redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_cheapest_fractional_path
 *	  Find the cheapest path for retrieving a specified fraction of all
 *	  the tuples expected to be returned by the given relation.
 *
 * We interpret tuple_fraction the same way as grouping_planner.
 *
 * We assume set_cheapest() has been run on the given rel.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>get_cheapest_fractional_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_path</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* If all tuples will be retrieved, just return the cheapest-total path */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>best_path</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Convert absolute # of tuples to a fraction; no need to clamp to 0..1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal> <operator>&amp;&amp;</operator> <name><name>best_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>/=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>||</operator>
			<call><name>compare_fractional_path_costs</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>best_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>best_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_paths_for_srfs
 *		Fix up the Paths of the given upperrel to handle tSRFs properly.
 *
 * The executor can only handle set-returning functions that appear at the
 * top level of the targetlist of a ProjectSet plan node.  If we have any SRFs
 * that are not at top level, we need to split up the evaluation into multiple
 * plan levels in which each level satisfies this constraint.  This function
 * modifies each Path of an upperrel that (might) compute any SRFs in its
 * output tlist to insert appropriate projection steps.
 *
 * The given targets and targets_contain_srfs lists are from
 * split_pathtarget_at_srfs().  We assume the existing Paths emit the first
 * target in targets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_paths_for_srfs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets_contain_srfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no SRFs appear at this plan level, nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Stack SRF-evaluation nodes atop each path for the rel.
	 *
	 * In principle we should re-run set_cheapest() here to identify the
	 * cheapest path, but it seems unlikely that adding the same tlist eval
	 * costs to all the paths would change that, so we don't bother. Instead,
	 * just assume that the cheapest-startup and cheapest-total paths remain
	 * so.  (There should be no parameterized paths anymore, so we needn't
	 * worry about updating cheapest_parameterized_paths.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>newpath</name> <init>= <expr><name>subpath</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>targets</argument>, <argument>lc2</argument>, <argument>targets_contain_srfs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>thistarget</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>contains_srfs</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If this level doesn't contain SRFs, do regular projection */</comment>
			<if_stmt><if>if <condition>(<expr><name>contains_srfs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_set_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>rel</name></expr></argument>,
															  <argument><expr><name>newpath</name></expr></argument>,
															  <argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>rel</name></expr></argument>,
															<argument><expr><name>newpath</name></expr></argument>,
															<argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Likewise for partial paths, if any */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>newpath</name> <init>= <expr><name>subpath</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>targets</argument>, <argument>lc2</argument>, <argument>targets_contain_srfs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>thistarget</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>contains_srfs</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If this level doesn't contain SRFs, do regular projection */</comment>
			<if_stmt><if>if <condition>(<expr><name>contains_srfs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_set_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>rel</name></expr></argument>,
															  <argument><expr><name>newpath</name></expr></argument>,
															  <argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* avoid apply_projection_to_path, in case of multiple refs */</comment>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>newpath</name></expr></argument>,
														  <argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * expression_planner
 *		Perform planner's transformations on a standalone expression.
 *
 * Various utility commands need to evaluate expressions that are not part
 * of a plannable query.  They can do so using the executor's regular
 * expression-execution machinery, but first the expression has to be fed
 * through here to transform it from parser output to something executable.
 *
 * Currently, we disallow sublinks in standalone expressions, so there's no
 * real "planning" involved here.  (That might not always be true though.)
 * What we must do is run eval_const_expressions to ensure that any function
 * calls are converted to positional notation and function default arguments
 * get inserted.  The fact that constant subexpressions get simplified is a
 * side-effect that is useful when the expression will get evaluated more than
 * once.  Also, we must fix operator function IDs.
 *
 * Note: this must not make any damaging changes to the passed-in expression
 * tree.  (It would actually be okay to apply fix_opfuncids to it, but since
 * we first do an expression_tree_mutator-based walk, what is returned will
 * be a new node tree.)
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>expression_planner</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert named-argument function calls, insert default arguments and
	 * simplify constant subexprs
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill in opfuncid values if missing */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * plan_cluster_use_sort
 *		Use the planner to decide how CLUSTER should implement sorting
 *
 * tableOid is the OID of a table to be clustered on its index indexOid
 * (which is already known to be a btree index).  Decide whether it's
 * cheaper to do an indexscan or a seqscan-plus-sort to execute the CLUSTER.
 * Return true to use sorting, false to use an indexscan.
 *
 * Note: caller had better already hold some type of lock on the table.
 */</comment>
<function><type><name>bool</name></type>
<name>plan_cluster_use_sort</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>indexExprCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>comparisonCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>seqScanPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>seqScanAndSortPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>indexScanPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We can short-circuit the cost comparison if indexscans are disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_indexscan</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* use sort */</comment>

	<comment type="block">/* Set up mostly-dummy planner state */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Build a minimal RTE for the rel */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>tableOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>	<comment type="block">/* Don't be too picky. */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up RTE/RelOptInfo arrays */</comment>
	<expr_stmt><expr><call><name>setup_simple_rel_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build RelOptInfo */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Locate IndexOptInfo for the target index */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexOptInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>indexoid</name></name> <operator>==</operator> <name>indexOid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * It's possible that get_relation_info did not generate an IndexOptInfo
	 * for the desired index; this could happen if it's not yet reached its
	 * indcheckxmin usability horizon, or if it's a system index and we're
	 * ignoring system indexes.  In such cases we should tell CLUSTER to not
	 * trust the index contents but use seqscan-and-sort.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* not in the list? */</comment>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* use sort */</comment>

	<comment type="block">/*
	 * Rather than doing all the pushups that would be needed to use
	 * set_baserel_size_estimates, just do a quick hack for rows and width.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>get_relation_data_width</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>total_table_pages</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine eval cost of the index expressions, if any.  We need to
	 * charge twice that amount for each tuple comparison that happens during
	 * the sort, since tuplesort.c will have to re-evaluate the index
	 * expressions each time.  (XXX that's pretty inefficient...)
	 */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexExprCost</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>comparisonCost</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>*</operator> <operator>(</operator><name><name>indexExprCost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>indexExprCost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Estimate the cost of seq scan + sort */</comment>
	<expr_stmt><expr><name>seqScanPath</name> <operator>=</operator> <call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqScanAndSortPath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
			  <argument><expr><name><name>seqScanPath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
			  <argument><expr><name>comparisonCost</name></expr></argument>, <argument><expr><name>maintenance_work_mem</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate the cost of index scan */</comment>
	<expr_stmt><expr><name>indexScanPath</name> <operator>=</operator> <call><name>create_index_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									  <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>seqScanAndSortPath</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>indexScanPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plan_create_index_workers
 *		Use the planner to decide how many parallel worker processes
 *		CREATE INDEX should request for use
 *
 * tableOid is the table on which the index is to be built.  indexOid is the
 * OID of an index to be created or reindexed (which must be a btree index).
 *
 * Return value is the number of parallel worker processes to request.  It
 * may be unsafe to proceed if this is 0.  Note that this does not include the
 * leader participating as a worker (value is always a number of parallel
 * worker processes).
 *
 * Note: caller had better already hold some type of lock on the table and
 * index.
 */</comment>
<function><type><name>int</name></type>
<name>plan_create_index_workers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallel_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>heap_blocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>allvisfrac</name></decl>;</decl_stmt>

	<comment type="block">/* Return immediately when parallelism disabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>dynamic_shared_memory_type</name> <operator>==</operator> <name>DSM_IMPL_NONE</name> <operator>||</operator>
		<name>max_parallel_maintenance_workers</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up largely-dummy planner state */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a minimal RTE.
	 *
	 * Set the target's table to be an inheritance parent.  This is a kludge
	 * that prevents problems within get_relation_info(), which does not
	 * expect that any IndexOptInfo is currently undergoing REINDEX.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>tableOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>	<comment type="block">/* Don't be too picky. */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up RTE/RelOptInfo arrays */</comment>
	<expr_stmt><expr><call><name>setup_simple_rel_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build RelOptInfo */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>heap</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine if it's safe to proceed.
	 *
	 * Currently, parallel workers can't access the leader's temporary tables,
	 * or the leader's relmapper.c state, which is needed for builds on mapped
	 * relations.  Furthermore, any index predicate or index expressions must
	 * be parallel safe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>heap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>||</operator>
		<call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If parallel_workers storage parameter is set for the table, accept that
	 * as the number of parallel worker processes to launch (though still cap
	 * at max_parallel_maintenance_workers).  Note that we deliberately do not
	 * consider any other factor when parallel_workers is set. (e.g., memory
	 * use by workers.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name></expr></argument>,
							   <argument><expr><name>max_parallel_maintenance_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Estimate heap relation size ourselves, since rel-&gt;pages cannot be
	 * trusted (heap RTE was marked as inheritance parent)
	 */</comment>
	<expr_stmt><expr><call><name>estimate_rel_size</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heap_blocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reltuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allvisfrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine number of workers to scan the heap relation using generic
	 * model
	 */</comment>
	<expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>compute_parallel_worker</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>heap_blocks</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>max_parallel_maintenance_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cap workers based on available maintenance_work_mem as needed.
	 *
	 * Note that each tuplesort participant receives an even share of the
	 * total maintenance_work_mem budget.  Aim to leave participants
	 * (including the leader as a participant) with no less than 32MB of
	 * memory.  This leaves cases where maintenance_work_mem is set to 64MB
	 * immediately past the threshold of being capable of launching a single
	 * parallel worker to sort.
	 */</comment>
	<while>while <condition>(<expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name>maintenance_work_mem</name> <operator>/</operator> <operator>(</operator><name>parallel_workers</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">32768L</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parallel_workers</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parallel_workers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_paths_to_grouping_rel
 *
 * Add non-partial paths to grouping relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_paths_to_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
						  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
						  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>,
						  <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_hash</name> <init>= <expr><operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GROUPING_CAN_USE_HASH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_sort</name> <init>= <expr><operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GROUPING_CAN_USE_SORT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>extra</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name> <init>= <expr><operator>&amp;</operator><name><name>extra</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_sort</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Use any available suitably-sorted path as input, and also consider
		 * sorting the cheapest-total path.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Sort the cheapest-total path if it isn't already sorted */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
													 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Now decide what to stick atop it */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>consider_groupingsets_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
												<argument><expr><name>path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>can_hash</name></expr></argument>,
												<argument><expr><name>gd</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We have aggregation, possibly with plain GROUP BY. Make
					 * an AggPath.
					 */</comment>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>havingQual</name></expr></argument>,
											 <argument><expr><name>agg_costs</name></expr></argument>,
											 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We have GROUP BY without aggregation or grouping sets.
					 * Make a GroupPath.
					 */</comment>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>grouped_rel</name></expr></argument>,
											   <argument><expr><name>path</name></expr></argument>,
											   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											   <argument><expr><name>havingQual</name></expr></argument>,
											   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Other cases should have been handled above */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Instead of operating directly on the input relation, we can
		 * consider finalizing a partially aggregated path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partially_grouped_rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partially_grouped_rel-&gt;pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Insert a Sort node, if required.  But there's no point in
				 * sorting anything but the cheapest path.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
													 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>havingQual</name></expr></argument>,
											 <argument><expr><name>agg_final_costs</name></expr></argument>,
											 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>grouped_rel</name></expr></argument>,
											   <argument><expr><name>path</name></expr></argument>,
											   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											   <argument><expr><name>havingQual</name></expr></argument>,
											   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_hash</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashaggtablesize</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Try for a hash-only groupingsets path over unsorted input.
			 */</comment>
			<expr_stmt><expr><call><name>consider_groupingsets_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
										<argument><expr><name>cheapest_path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										<argument><expr><name>gd</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>cheapest_path</name></expr></argument>,
														  <argument><expr><name>agg_costs</name></expr></argument>,
														  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Provided that the estimated size of the hashtable does not
			 * exceed work_mem, we'll generate a HashAgg Path, although if we
			 * were unable to sort above, then we'd better generate a Path, so
			 * that we at least have one.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator>
				<name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We just need an Agg over the cheapest-total input path,
				 * since input order won't matter.
				 */</comment>
				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>cheapest_path</name></expr></argument>,
										 <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
										 <argument><expr><name>AGG_HASHED</name></expr></argument>,
										 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Generate a Finalize HashAgg Path atop of the cheapest partially
		 * grouped path, assuming there is one. Once again, we'll only do this
		 * if it looks as though the hash table won't exceed work_mem.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partially_grouped_rel</name> <operator>&amp;&amp;</operator> <name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
														  <argument><expr><name>agg_final_costs</name></expr></argument>,
														  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
										 <argument><expr><name>AGG_HASHED</name></expr></argument>,
										 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_final_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When partitionwise aggregate is used, we might have fully aggregated
	 * paths in the partial pathlist, because add_paths_to_append_rel() will
	 * consider a path for grouped_rel consisting of a Parallel Append of
	 * non-partial paths from each child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gather_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_partial_grouping_paths
 *
 * Create a new upper relation representing the result of partial aggregation
 * and populate it with appropriate paths.  Note that we don't finalize the
 * lists of paths here, so the caller can add additional partial or non-partial
 * paths and must afterward call gather_grouping_paths and set_cheapest on
 * the returned upper relation.
 *
 * All paths for this new upper relation -- both partial and non-partial --
 * have been partially aggregated but require a subsequent FinalizeAggregate
 * step.
 *
 * NB: This function is allowed to return NULL if it determines that there is
 * no real need to create a new RelOptInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_partial_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
							  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							  <parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>force_rel_creation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_partial_costs</name> <init>= <expr><operator>&amp;</operator><name><name>extra</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name> <init>= <expr><operator>&amp;</operator><name><name>extra</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_total_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumPartialGroups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumPartialPartialGroups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_hash</name> <init>= <expr><operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GROUPING_CAN_USE_HASH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_sort</name> <init>= <expr><operator>(</operator><name><name>extra</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GROUPING_CAN_USE_SORT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Consider whether we should generate partially aggregated non-partial
	 * paths.  We can only do this if we have a non-partial path, and only if
	 * the parent of the input rel is performing partial partitionwise
	 * aggregation.  (Note that extra-&gt;patype is the type of partitionwise
	 * aggregation being used at the parent level, not this level.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<name><name>extra</name><operator>-&gt;</operator><name>patype</name></name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_PARTIAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cheapest_total_path</name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If parallelism is possible for grouped_rel, then we should consider
	 * generating partially-grouped partial paths.  However, if the input rel
	 * has no partial paths, then we can't.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cheapest_partial_path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we can't partially aggregate partial paths, and we can't partially
	 * aggregate non-partial paths, then don't bother creating the new
	 * RelOptInfo at all, unless the caller specified force_rel_creation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name>cheapest_partial_path</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>force_rel_creation</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build a new upper relation to represent the result of partially
	 * aggregating the rows from the input relation.
	 */</comment>
	<expr_stmt><expr><name>partially_grouped_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name>UPPERREL_PARTIAL_GROUP_AGG</name></expr></argument>,
											<argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator>
		<name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>reloptkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build target list for partial aggregate paths.  These paths cannot just
	 * emit the same tlist as regular aggregate paths, because (1) we must
	 * include Vars and Aggrefs needed in HAVING, which might not appear in
	 * the result tlist, and (2) the Aggrefs must be set in partial mode.
	 */</comment>
	<expr_stmt><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator>
		<call><name>make_partial_grouping_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
									 <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extra</name><operator>-&gt;</operator><name>partial_costs_set</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Collect statistics about aggregates for estimating costs of
		 * performing aggregation in parallel.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>agg_partial_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>agg_final_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partial_target_exprs</name></decl>;</decl_stmt>

			<comment type="block">/* partial phase */</comment>
			<expr_stmt><expr><name>partial_target_exprs</name> <operator>=</operator> <name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partial_target_exprs</name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
								 <argument><expr><name>agg_partial_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* final phase */</comment>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
								 <argument><expr><name>agg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
								 <argument><expr><name>agg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>extra</name><operator>-&gt;</operator><name>partial_costs_set</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Estimate number of partial groups. */</comment>
	<if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dNumPartialGroups</name> <operator>=</operator>
			<call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name><name>cheapest_total_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
								 <argument><expr><name>gd</name></expr></argument>,
								 <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cheapest_partial_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dNumPartialPartialGroups</name> <operator>=</operator>
			<call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
								 <argument><expr><name>gd</name></expr></argument>,
								 <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_sort</name> <operator>&amp;&amp;</operator> <name>cheapest_total_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This should have been checked previously */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use any available suitably-sorted path as input, and also consider
		 * sorting the cheapest partial path.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_total_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Sort the cheapest partial path, if it isn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>partially_grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
													 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>partially_grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name>agg_partial_costs</name></expr></argument>,
											 <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>partially_grouped_rel</name></expr></argument>,
											   <argument><expr><name>path</name></expr></argument>,
											   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											   <argument><expr><name>NIL</name></expr></argument>,
											   <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_sort</name> <operator>&amp;&amp;</operator> <name>cheapest_partial_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Similar to above logic, but for partial paths. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_partial_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Sort the cheapest partial path, if it isn't already */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>partially_grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
													 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
									 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>partially_grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
													 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
													 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
													 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name>NIL</name></expr></argument>,
													 <argument><expr><name>agg_partial_costs</name></expr></argument>,
													 <argument><expr><name>dNumPartialPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
									 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>partially_grouped_rel</name></expr></argument>,
													   <argument><expr><name>path</name></expr></argument>,
													   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													   <argument><expr><name>NIL</name></expr></argument>,
													   <argument><expr><name>dNumPartialPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_hash</name> <operator>&amp;&amp;</operator> <name>cheapest_total_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashaggtablesize</name></decl>;</decl_stmt>

		<comment type="block">/* Checked above */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator>
			<call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>,
									   <argument><expr><name>agg_partial_costs</name></expr></argument>,
									   <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Tentatively produce a partial HashAgg Path, depending on if it
		 * looks as if the hash table will fit in work_mem.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator>
			<name>cheapest_total_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name>partially_grouped_rel</name></expr></argument>,
									 <argument><expr><name>cheapest_total_path</name></expr></argument>,
									 <argument><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
									 <argument><expr><name>AGG_HASHED</name></expr></argument>,
									 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
									 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
									 <argument><expr><name>NIL</name></expr></argument>,
									 <argument><expr><name>agg_partial_costs</name></expr></argument>,
									 <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_hash</name> <operator>&amp;&amp;</operator> <name>cheapest_partial_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashaggtablesize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator>
			<call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>cheapest_partial_path</name></expr></argument>,
									   <argument><expr><name>agg_partial_costs</name></expr></argument>,
									   <argument><expr><name>dNumPartialPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the same for partial paths. */</comment>
		<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator>
			<name>cheapest_partial_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>partially_grouped_rel</name></expr></argument>,
											 <argument><expr><name>cheapest_partial_path</name></expr></argument>,
											 <argument><expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
											 <argument><expr><name>AGG_HASHED</name></expr></argument>,
											 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name>agg_partial_costs</name></expr></argument>,
											 <argument><expr><name>dNumPartialPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding partially grouped ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>UPPERREL_PARTIAL_GROUP_AGG</name></expr></argument>,
										 <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>partially_grouped_rel</name></expr></argument>,
										 <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>partially_grouped_rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate Gather and Gather Merge paths for a grouping relation or partial
 * grouping relation.
 *
 * generate_gather_paths does most of the work, but we also consider a special
 * case: we could try sorting the data by the group_pathkeys and then applying
 * Gather Merge.
 *
 * NB: This function shouldn't be used for anything other than a grouped or
 * partially grouped relation not only because of the fact that it explicitly
 * references group_pathkeys but we pass "true" as the third argument to
 * generate_gather_paths().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gather_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_path</name></decl>;</decl_stmt>

	<comment type="block">/* Try Gather for unordered paths and Gather Merge for ordered ones. */</comment>
	<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try cheapest partial path + explicit Sort + Gather Merge. */</comment>
	<expr_stmt><expr><name>cheapest_partial_path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
							   <argument><expr><name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>total_groups</name> <operator>=</operator>
			<name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cheapest_partial_path</name></expr></argument>,
										 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_gather_merge_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name>rel</name></expr></argument>,
									 <argument><expr><name>path</name></expr></argument>,
									 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></argument>,
									 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * can_partial_agg
 *
 * Determines whether or not partial grouping and/or aggregation is possible.
 * Returns true when possible, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_partial_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't know how to do parallel aggregation unless we have either
		 * some aggregates or a grouping clause.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We don't know how to do grouping sets in parallel. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Insufficient support for partial mode. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Everything looks good. */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * apply_scanjoin_target_to_paths
 *
 * Adjust the final scan/join relation, and recursively all of its children,
 * to generate the final scan/join target.  It would be more correct to model
 * this as a separate planning step with a new RelOptInfo at the toplevel and
 * for each child relation, but doing it this way is noticeably cheaper.
 * Maybe that problem can be solved at some point, but for now we do this.
 *
 * If tlist_same_exprs is true, then the scan/join target to be applied has
 * the same expressions as the existing reltarget, so we need only insert the
 * appropriate sortgroupref information.  By avoiding the creation of
 * projection paths we save effort both immediately and at plan creation time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_scanjoin_target_to_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanjoin_targets</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanjoin_targets_contain_srfs</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>scanjoin_target_parallel_safe</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>tlist_same_exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rel_is_partitioned</name> <init>= <expr><call><name>IS_PARTITIONED_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>scanjoin_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* This recurses, so be paranoid. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the rel is partitioned, we want to drop its existing paths and
	 * generate new ones.  This function would still be correct if we kept the
	 * existing paths: we'd modify them to generate the correct target above
	 * the partitioning Append, and then they'd compete on cost with paths
	 * generating the target below the Append.  However, in our current cost
	 * model the latter way is always the same or cheaper cost, so modifying
	 * the existing paths would just be useless work.  Moreover, when the cost
	 * is the same, varying roundoff errors might sometimes allow an existing
	 * path to be picked, resulting in undesirable cross-platform plan
	 * variations.  So we drop old paths and thereby force the work to be done
	 * below the Append, except in the case of a non-parallel-safe target.
	 *
	 * Some care is needed, because we have to allow generate_gather_paths to
	 * see the old partial paths in the next stanza.  Hence, zap the main
	 * pathlist here, then allow generate_gather_paths to add path(s) to the
	 * main list, and finally zap the partial pathlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel_is_partitioned</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the scan/join target is not parallel-safe, partial paths cannot
	 * generate it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scanjoin_target_parallel_safe</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since we can't generate the final scan/join target in parallel
		 * workers, this is our last opportunity to use any partial paths that
		 * exist; so build Gather path(s) that use them and emit whatever the
		 * current reltarget is.  We don't do this in the case where the
		 * target is parallel-safe, since we will be able to generate superior
		 * paths by doing it after the final scan/join target has been
		 * applied.
		 */</comment>
		<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Can't use parallel query above this level. */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finish dropping old paths for a partitioned rel, per comment above */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel_is_partitioned</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Extract SRF-free scan/join target. */</comment>
	<expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>scanjoin_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the SRF-free scan/join target to each existing path.
	 *
	 * If the tlist exprs are the same, we can just inject the sortgroupref
	 * information into the existing pathtargets.  Otherwise, replace each
	 * path with a projection path that generates the SRF-free scan/join
	 * target.  This can't change the ordering of paths within rel-&gt;pathlist,
	 * so we just modify the list in place.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Shouldn't have any parameterized paths anymore */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tlist_same_exprs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator>
				<name><name>scanjoin_target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>newpath</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
													  <argument><expr><name>scanjoin_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Likewise adjust the targets for any partial paths. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Shouldn't have any parameterized paths anymore */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tlist_same_exprs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator>
				<name><name>scanjoin_target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>newpath</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
													  <argument><expr><name>scanjoin_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now, if final scan/join target contains SRFs, insert ProjectSetPath(s)
	 * atop each existing path.  (Note that this function doesn't look at the
	 * cheapest-path fields, which is a good thing because they're bogus right
	 * now.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							  <argument><expr><name>scanjoin_targets</name></expr></argument>,
							  <argument><expr><name>scanjoin_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update the rel's target to be the final (with SRFs) scan/join target.
	 * This now matches the actual output of all the paths, and we might get
	 * confused in createplan.c if they don't agree.  We must do this now so
	 * that any append paths made in the next part will use the correct
	 * pathtarget (cf. create_append_path).
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <call><name>llast_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>scanjoin_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation is partitioned, recursively apply the scan/join target
	 * to all partitions, and generate brand-new Append paths in which the
	 * scan/join target is computed below the Append rather than above it.
	 * Since Append is not projection-capable, that might save a separate
	 * Result node, and it also is important for partitionwise aggregate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel_is_partitioned</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>live_children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>partition_idx</name></decl>;</decl_stmt>

		<comment type="block">/* Adjust each partition. */</comment>
		<for>for <control>(<init><expr><name>partition_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>partition_idx</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>partition_idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>partition_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_scanjoin_targets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* Pruned or dummy children can be ignored. */</comment>
			<if_stmt><if>if <condition>(<expr><name>child_rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Translate scan/join targets for this child. */</comment>
			<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>scanjoin_targets</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
					<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
										   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>child_scanjoin_targets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>child_scanjoin_targets</name></expr></argument>,
												 <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Recursion does the real work. */</comment>
			<expr_stmt><expr><call><name>apply_scanjoin_target_to_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>,
										   <argument><expr><name>child_scanjoin_targets</name></expr></argument>,
										   <argument><expr><name>scanjoin_targets_contain_srfs</name></expr></argument>,
										   <argument><expr><name>scanjoin_target_parallel_safe</name></expr></argument>,
										   <argument><expr><name>tlist_same_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save non-dummy children for Append paths. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>live_children</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>live_children</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Build new paths for this relation by appending child paths. */</comment>
		<expr_stmt><expr><call><name>add_paths_to_append_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>live_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Consider generating Gather or Gather Merge paths.  We must only do this
	 * if the relation is parallel safe, and we don't do it for child rels to
	 * avoid creating multiple Gather nodes within the same plan. We must do
	 * this after all paths have been generated and before set_cheapest, since
	 * one of the generated paths may turn out to be the cheapest one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reassess which paths are the cheapest, now that we've potentially added
	 * new Gather (or Gather Merge) and/or Append (or MergeAppend) paths to
	 * this relation.
	 */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_partitionwise_grouping_paths
 *
 * If the partition keys of input relation are part of the GROUP BY clause, all
 * the rows belonging to a given group come from a single partition.  This
 * allows aggregation/grouping over a partitioned relation to be broken down
 * into aggregation/grouping on each partition.  This should be no worse, and
 * often better, than the normal approach.
 *
 * However, if the GROUP BY clause does not contain all the partition keys,
 * rows from a given group may be spread across multiple partitions. In that
 * case, we perform partial aggregation for each group, append the results,
 * and then finalize aggregation.  This is less certain to win than the
 * previous case.  It may win if the PartialAggregate stage greatly reduces
 * the number of groups, because fewer rows will pass through the Append node.
 * It may lose if we have lots of small groups.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_partitionwise_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partially_grouped_rel</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
									<parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
									<parameter><decl><type><name>PartitionwiseAggregateType</name></type> <name>patype</name></decl></parameter>,
									<parameter><decl><type><name>GroupPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grouped_live_children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partially_grouped_live_children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partial_grouping_valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>patype</name> <operator>!=</operator> <name>PARTITIONWISE_AGGREGATE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>patype</name> <operator>!=</operator> <name>PARTITIONWISE_AGGREGATE_PARTIAL</name> <operator>||</operator>
		   <name>partially_grouped_rel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add paths for partitionwise aggregation/grouping. */</comment>
	<for>for <control>(<init><expr><name>cnt_parts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_parts</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>cnt_parts</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_input_rel</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>part_rels</name><index>[<expr><name>cnt_parts</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>child_target</name> <init>= <expr><call><name>copy_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>appinfos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nappinfos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupPathExtraData</name></type> <name>child_extra</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_grouped_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_partially_grouped_rel</name></decl>;</decl_stmt>

		<comment type="block">/* Pruned or dummy children can be ignored. */</comment>
		<if_stmt><if>if <condition>(<expr><name>child_input_rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_DUMMY_REL</name><argument_list>(<argument><expr><name>child_input_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Copy the given "extra" structure as is and then override the
		 * members specific to this child.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child_extra</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>child_extra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>appinfos</name> <operator>=</operator> <call><name>find_appinfos_by_relids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>child_input_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>nappinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>child_target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Translate havingQual and targetList. */</comment>
		<expr_stmt><expr><name><name>child_extra</name><operator>.</operator><name>havingQual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
								   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_extra</name><operator>.</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>extra</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
								   <argument><expr><name>nappinfos</name></expr></argument>, <argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * extra-&gt;patype was the value computed for our parent rel; patype is
		 * the value for this relation.  For the child, our value is its
		 * parent rel's value.
		 */</comment>
		<expr_stmt><expr><name><name>child_extra</name><operator>.</operator><name>patype</name></name> <operator>=</operator> <name>patype</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create grouping relation to hold fully aggregated grouping and/or
		 * aggregation paths for the child.
		 */</comment>
		<expr_stmt><expr><name>child_grouped_rel</name> <operator>=</operator> <call><name>make_grouping_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_input_rel</name></expr></argument>,
											  <argument><expr><name>child_target</name></expr></argument>,
											  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>target_parallel_safe</name></name></expr></argument>,
											  <argument><expr><name><name>child_extra</name><operator>.</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create grouping paths for this child relation. */</comment>
		<expr_stmt><expr><call><name>create_ordinary_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>child_input_rel</name></expr></argument>,
									   <argument><expr><name>child_grouped_rel</name></expr></argument>,
									   <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>gd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>child_extra</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>child_partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>child_partially_grouped_rel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>partially_grouped_live_children</name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name>partially_grouped_live_children</name></expr></argument>,
						<argument><expr><name>child_partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>partial_grouping_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>patype</name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_FULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>child_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouped_live_children</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>grouped_live_children</name></expr></argument>,
											<argument><expr><name>child_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>appinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Try to create append paths for partially grouped children. For full
	 * partitionwise aggregation, we might have paths in the partial_pathlist
	 * if parallel aggregation is possible.  For partial partitionwise
	 * aggregation, we may have paths in both pathlist and partial_pathlist.
	 *
	 * NB: We must have a partially grouped path for every child in order to
	 * generate a partially grouped path for this relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partially_grouped_rel</name> <operator>&amp;&amp;</operator> <name>partial_grouping_valid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partially_grouped_live_children</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_paths_to_append_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>partially_grouped_rel</name></expr></argument>,
								<argument><expr><name>partially_grouped_live_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need call set_cheapest, since the finalization step will use the
		 * cheapest path from the rel.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partially_grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>partially_grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If possible, create append paths for fully grouped children. */</comment>
	<if_stmt><if>if <condition>(<expr><name>patype</name> <operator>==</operator> <name>PARTITIONWISE_AGGREGATE_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>grouped_live_children</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_paths_to_append_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>grouped_live_children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * group_by_has_partkey
 *
 * Returns true, if all the partition keys of the given relation are part of
 * the GROUP BY clauses, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>group_by_has_partkey</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupexprs</name> <init>= <expr><call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>

	<comment type="block">/* Input relation should be partitioned. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>part_scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Rule out early, if there are no partition keys present. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input_rel</name><operator>-&gt;</operator><name>partexprs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>part_scheme</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>partexprs</name><index>[<expr><name>cnt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partexprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>groupexprs</name></expr></argument>, <argument><expr><name>partexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If none of the partition key expressions match with any of the
		 * GROUP BY expression, return false.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_ignore_functions_checker</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>func_oid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>px_function_oid_array</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>func_oid</name> <operator>==</operator> <name><name>px_function_oid_array</name><operator>.</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"px ignore function oid hit : %d"</literal></expr></argument>, <argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_returns_set_func</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* else fall through to check args */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* else fall through to check args */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_supported_func_checker</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOREACH_CHECK_EXPR_WITH_ARG</name><parameter_list>(<parameter><type><name>TYPE</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{								\
		TYPE *expr = (TYPE *)node;	\
		if (!contains_supported_func_checker(expr-&gt;arg))	\
			return false;									\
		return true;										\
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><parameter_list>(<parameter><type><name>TYPE</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{								\
		TYPE *expr = (TYPE *)node;	\
		ListCell *lc = NULL;		\
		foreach(lc, expr-&gt;args)		\
		{							\
			Expr *child_expr = (Expr *) lfirst(lc);				\
			if (!contains_supported_func_checker(child_expr))	\
				return false;									\
		}														\
		return true;											\
	}</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARG</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARG</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARG</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARG</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARG</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARG</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><call><name>FOREACH_CHECK_EXPR_WITH_ARGS</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains_supported_func_checker</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains_supported_func_checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains_supported_func_checker</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseWhen</name> <modifier>*</modifier></type><name>child_expr</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains_supported_func_checker</name><argument_list>(<argument><expr><name><name>child_expr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contains_supported_func_checker</name><argument_list>(<argument><expr><name><name>child_expr</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_not_supported_func</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target_entry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>target_entry</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><operator>!</operator><call><name>contains_supported_func_checker</name><argument_list>(<argument><expr><name><name>target_entry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_GroupId</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_multilevel_partitions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>child_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> 
		<operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>,<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>,<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px: tag plan with jit */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tag_should_jit</name><parameter_list>(	<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pxopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	<modifier>*</modifier></type><name>top_plan</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>=</operator> <name>PGJIT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>top_plan</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>jit_enabled</name> <operator>&amp;&amp;</operator> <name>jit_above_cost</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>top_plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name>jit_above_cost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>|=</operator> <name>PGJIT_PERFORM</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Decide how much effort should be put into generating better code.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jit_optimize_above_cost</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>top_plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name>jit_optimize_above_cost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>|=</operator> <name>PGJIT_OPT3</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>jit_inline_above_cost</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>top_plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name>jit_inline_above_cost</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>|=</operator> <name>PGJIT_INLINE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Decide which operations should be JITed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>jit_expressions</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>|=</operator> <name>PGJIT_EXPR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* px not support deform*/</comment>
		<if_stmt><if>if <condition>(<expr><name>jit_tuple_deforming</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pxopt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jitFlags</name></name> <operator>|=</operator> <name>PGJIT_DEFORM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_hit_function_oid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hit_function_oid</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>polar_px_ignore_function</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_print_func_names</name> <init>= <expr><operator>(</operator><name>client_min_messages</name> <operator>&lt;=</operator> <name>DEBUG5</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>names</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>px_function_oid_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>hit_function_oid</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>px_function_oid_list</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in function oid list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"polar px ignore function list is invalid, func1,func2,func3, ..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>px_function_oid_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>f_oid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/* function oid has been checked in GUC check hook, no need to check here */</comment>
			<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>f_oid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"polar_px_ignore_function contains invalid ignore function oid %d, continue"</literal></expr></argument>,
					<argument><expr><name>f_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>px_function_oid_array</name><operator>.</operator><name>array</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>f_oid</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_print_func_names</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><literal type="string">"%d:%s;"</literal></expr></argument>,
						<argument><expr><name>f_oid</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>px_function_oid_array</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_print_func_names</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"px ignore function is %s"</literal></expr></argument>, <argument><expr><name><name>names</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hit_function_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_disable_px_planner_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_RETURN_HELP_LOG</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>if ((condition))							\
	{											\
		elog(DEBUG1, "PX Failed: " msg);		\
		return true;							\
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_RETURN_HELP_LOG_ARG</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>, <parameter><type><name>intarg</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>if ((condition))										\
	{														\
		elog(DEBUG1, "PX Failed: " msg, intarg);			\
		return true;										\
	}</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_join</name></decl>, <decl><type ref="prev"/><name>has_same_column_cnt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_not_support_node</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_enable_pre_optimizer_check</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <name><name>expr</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><literal type="string">"sql with whole row var was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr></argument>, <argument><expr><literal type="string">"sql with variadic function was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check for px ignore functions in node itself */</comment>
			<expr_stmt><expr><name>has_not_support_node</name> <operator>=</operator> <name>polar_px_ignore_function</name> <operator>&amp;&amp;</operator>
							<name><name>px_function_oid_array</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							<call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								<argument><expr><name>contains_ignore_functions_checker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>has_not_support_node</name></expr></argument>, <argument><expr><literal type="string">"sql with px ignore functions was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>has_not_support_node</name> <operator>=</operator> <call><name>contains_not_supported_func</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG_ARG</name><argument_list>(<argument><expr><name>has_not_support_node</name></expr></argument>, <argument><expr><literal type="string">"sql with function %d was not supported in px"</literal></expr></argument>,
									<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>has_not_support_node</name> <operator>=</operator> <operator>!</operator><call><name>contains_returns_set_func</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
									<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG_ARG</name><argument_list>(<argument><expr><name>has_not_support_node</name></expr></argument>, <argument><expr><literal type="string">"sql with returns_set functions %d was not supported in px"</literal></expr></argument>,
									<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_disable_px_planner_walker</name></expr></argument>,
										<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check for px ignore functions in node itself */</comment>
			<expr_stmt><expr><name>has_not_support_node</name> <operator>=</operator> <name>polar_px_ignore_function</name> <operator>&amp;&amp;</operator>
							<name><name>px_function_oid_array</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							<call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								<argument><expr><name>contains_ignore_functions_checker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>has_not_support_node</name></expr></argument>, <argument><expr><literal type="string">"sql with px ignore functions was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_disable_px_planner_walker</name></expr></argument>,
										<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Query node */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_join</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>rtable</name><operator>-&gt;</operator><name>length</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_same_column_cnt</name> <operator>=</operator>
		<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_tableless_scan</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><literal type="string">"sql without rtable can`t run on px node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px: ordered sensitive */</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>found_insert_select</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>px_enable_insert_order_sensitive</name> <operator>&amp;&amp;</operator> <literal type="number">1</literal> <operator>!=</operator> <name>local_px_insert_dop_num</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,<argument><expr><literal type="string">"PX multi insert Failed: px_enable_insert_order_sensitive is on. One writer worker should be used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>local_px_insert_dop_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* check insert select from tableless_scan */</comment>
	<if_stmt><if>if <condition>(<expr><name>found_insert_select</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>==</operator> <name>local_px_insert_dop_num</name></expr></argument>, <argument><expr><literal type="string">"Insert worker is only one, select from tableless doesn't use PX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_insert_from_tableless</name></expr></argument>, <argument><expr><literal type="string">"polar_px_enable_insert_from_tableless is off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_enable_pre_optimizer_check</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>&amp;&amp;</operator> <name>has_same_column_cnt</name></expr></argument>, <argument><expr><literal type="string">"sql with distionct on was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr></argument>, <argument><expr><literal type="string">"sql with recursive cte was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr></argument>, <argument><expr><literal type="string">"sql with modifying cte cte was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr></argument>, <argument><expr><literal type="string">"sql with for update was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>hasRowSecurity</name></name></expr></argument>, <argument><expr><literal type="string">"sql with row security was not supported in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>, <argument><expr><literal type="string">"sql with groupingsets was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_join</name> <operator>&amp;&amp;</operator> <name>has_join</name></expr></argument>, <argument><expr><literal type="string">"sql with join was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_subquery</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr></argument>, <argument><expr><literal type="string">"sql with subquery was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_window_function</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr></argument>, <argument><expr><literal type="string">"sql with window function was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_cte</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>, <argument><expr><literal type="string">"sql with cte was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_partition</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>, <argument><expr><literal type="string">"sql with partition table was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
					<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* px workers option */</comment>
					<decl_stmt><decl><type><name>Oid</name></type> 		<name>relid</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>LOCKMODE</name></type> 	<name>lockmode</name> <init>= <expr><name>AccessShareLock</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type> 	<name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>min_px_workers</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>        <name>has_multilevel_partitions</name></decl>;</decl_stmt>
					<comment type="block">/*
					 * No use PXOPT:
					 * 1. temp table
					 * 2. table have any childrens
					 * 3. system catalogs
					 * 4. no set reloption 'px_workers'
					 */</comment>

					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>||</operator>
						<operator>(</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name><operator>)</operator> <operator>||</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name> <operator>&lt;</operator> <name>FirstNormalObjectId</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"sql not match some conditions was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * For a relation (if partitioned, together with all of its 
					 * descendant relations):
					 *   1. Reloption 'px_workers' set to negative
					 *   2. GUC param 'polar_px_enable_check_workers' is enabled
					 *      while 'px_workers' is not set (or set to 0)
					 * 
					 * If any condition above is met, then we should not use PX.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><name>min_px_workers</name> <operator>=</operator> <call><name>polar_relation_get_parallel_query_nodes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
						<operator>(</operator><name>px_enable_check_workers</name> <operator>&amp;&amp;</operator> <name>min_px_workers</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"px_workers was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>has_multilevel_partitions</name> <operator>=</operator> <call><name>contains_multilevel_partitions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>has_multilevel_partitions</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>px_optimizer_multilevel_partitioning</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"sql with multilevel partition was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
						 <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"only support relkind_relation and view/matview under RTE_RELATION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><operator>!</operator><name>px_enable_subquery</name></expr></argument>, <argument><expr><literal type="string">"sql with subquery was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>check_disable_px_planner_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<macro><name>foreach</name><argument_list>(<argument>lf</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtf</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>, <argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>rtf</name> <operator>&amp;&amp;</operator>
						<name><name>rtf</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>&amp;&amp;</operator>
						<call><name>IsA</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>rtf</name><operator>-&gt;</operator><name>funcexpr</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>isGlobalFunc</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>px_use_global_function</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"sql with function was not allowed in px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
			<case>case <expr><name>RTE_VOID</name></expr>:</case>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>CHECK_RETURN_HELP_LOG_ARG</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"the RTEKIND is not supported %d"</literal></expr></argument>,
										<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>check_disable_px_planner_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>should_px_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>current_parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_check_disable_px_planner_walker</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * do not step into PXOPT, when sql invoked on px.
	 * px scanner just scan part of all data pages,
	 * so new sql on px need scan all data pages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: planner can`t run on px node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>current_parse</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"current_parse should not be null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Polar PX Only enable CMD_INSERT */</comment>
	<if_stmt><if>if <condition>(<expr><name>CMD_INSERT</name> <operator>==</operator> <name><name>current_parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If px_enable_insert_select is off, no use PXOPT */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_insert_select</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: param px_enable_insert_select is off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Insert into .. VALUES(only one node) Case */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name><name>current_parse</name><operator>-&gt;</operator><name>rtable</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name>px_insert_dop_num</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: Insert worker is only one, select from tableless doesn't use PX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_insert_from_tableless</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"polar_px_enable_insert_from_tableless is off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>CMD_UPDATE</name> <operator>==</operator> <name><name>current_parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_update</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: param px_enable_update is off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>CMD_DELETE</name> <operator>==</operator> <name><name>current_parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_delete</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: param px_enable_delete is off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>current_parse</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: parallel delete can't support ModifyingCTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Only select and insert can run in px */</comment>
		<if_stmt><if>if <condition>(<expr><name>CMD_SELECT</name> <operator>!=</operator> <name><name>current_parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: px can't support and CMD_UTILITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If polar_enable_px set to off, no use PXOPT */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_stmt_enable_px</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: param polar_enable_px is off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Trigger is not support */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_trigger_depth</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: sql in trigger can`t run on px node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * If current context is in transaction, no use PXOPT.
	 * 1. PX can not see the changed data from ddl on QC.
	 * 2. Dead lock could happen when drop a table and then select it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_transaction</name> <operator>&amp;&amp;</operator> <call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: sql in transaction can`t run on px node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Polar px TODO: for sequence function, currval and nextval, replica
	 * can not execute nextval. But "select * from xxx where currval(xxx)"
	 * will use parallel execution, it will make some errors.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_px_ignore_function</name> <operator>&amp;&amp;</operator> <name><name>px_function_oid_array</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_hit_function_oid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>CMD_INSERT</name> <operator>==</operator> <name><name>current_parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>found_insert_select</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>is_check_disable_px_planner_walker</name> <operator>=</operator>
		<call><name>check_disable_px_planner_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>current_parse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>found_insert_select</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_check_disable_px_planner_walker</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If px_cluster_map is not set, we should notice user */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_cluster_map</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>polar_cluster_map</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"PX Failed: should use PX planner, but polar_cluster_map is not set, "</literal>
						  <literal type="string">"falling back to default optimizer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
