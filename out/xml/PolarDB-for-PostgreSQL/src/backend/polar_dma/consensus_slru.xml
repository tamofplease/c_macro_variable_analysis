<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_dma/consensus_slru.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * consensus_slru.c
 *		Simple LRU buffering for consensus logfiles
 *
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 * 	src/backend/polar_dma/censensus_slru.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"easy_log.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/consensus_slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>


<comment type="block">/*
 * During ConsensusSimpleLruFlush(), we will usually not need to fsync for every 
 * writes, because we may need to write several pages per file.  We can 
 * consolidate the I/O requests by leaving the file open until we flush next file.  
 */</comment>
<typedef>typedef <type><struct>struct <name>ConsensusSlruFlushFile</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>create_if_not_exists</name></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>bool</name></type>		<name>fsync</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConsensusSlruFlushFile</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConsensusSlruRecentlyUsed</name><parameter_list>(<parameter><type><name>shared</name></type></parameter>, <parameter><type><name>slotno</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		int		new_lru_count = (shared)-&gt;cur_lru_count; \
		if (new_lru_count != (shared)-&gt;page_lru_count[slotno]) { \
			(shared)-&gt;cur_lru_count = ++new_lru_count; \
			(shared)-&gt;page_lru_count[slotno] = new_lru_count; \
		} \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_SLRU_VICTIM_WINDOW</name></cpp:macro>	<cpp:value>128</cpp:value></cpp:define>      <comment type="block">/* victim slot window */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>CONSENSUS_SLRU_FILE_IN_SHARED_STORAGE</name><parameter_list>(<parameter><type><name>ctl</name></type></parameter>)</parameter_list></cpp:macro>	\
												<cpp:value>(polar_enable_shared_storage_mode &amp;&amp;  \
												(ctl)-&gt;shared-&gt;slru_file_in_shared_storage)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>consensus_slru_stat</name> <modifier>*</modifier></type><name><name>consensus_slru_stats</name><index>[<expr><name>CONSENSUS_SLRU_STATS_NUM</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_consensus_slru_stats</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_slru_wait_io</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_slru_internal_write_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruFlushFile</name> <modifier>*</modifier></type><name>fdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_slru_physical_read_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_slru_physical_write_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, 
													<parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruFlushFile</name> <modifier>*</modifier></type><name>fdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>consensus_slru_select_lru_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_slru_internal_delete_segment</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_slru_file_dir</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_slru_file_name_by_seg</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_slru_file_name_by_name</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>consensus_slru_set_page_status</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruShared</name></type> <name>shared</name></decl></parameter>, 
																			<parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruPageStatus</name></type> <name>pagestatus</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialization of shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>ConsensusSimpleLruShmemSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>szblock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusSlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_buffer[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusSlruPageStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_status[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_dirty[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_number[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_next_dirty[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_lru_count[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pthread_rwlock_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* buffer_locks[] */</comment>

	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>szblock</name> <operator>*</operator> <name>nslots</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Init share memory, so must be called by consensus master thread before start other thread 
 */</comment>
<function><type><name>void</name></type>
<name>ConsensusSimpleLruInit</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>szblock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>, 
							<parameter><decl><type><name>pthread_rwlock_t</name> <modifier>*</modifier></type><name>ctllock</name></decl></parameter>, <parameter><decl><type><name>flush_hook</name></type> <name>before_flush_hook</name></decl></parameter>, 
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>polar_shared_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> 		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>ConsensusSlruShared</name><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
										  <argument><expr><call><name>ConsensusSimpleLruShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>szblock</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>pthread_rwlockattr_t</name></type> <name>lock_attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pthread_rwlockattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlockattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>,<argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusSlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name> <operator>=</operator> <name>ctllock</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>slru_file_in_shared_storage</name></name> <operator>=</operator> <name>polar_shared_file</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name> <operator>=</operator> <name>nslots</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>cur_lru_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>=</operator> <name>nslots</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name> <operator>=</operator> <name>nslots</name></expr>;</expr_stmt>

		<comment type="block">/* shared-&gt;latest_page_number will be set later */</comment>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shared</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusSlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name></name> <operator>=</operator> <operator>(</operator><name>ConsensusSlruPageStatus</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusSlruPageStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name></name> <operator>=</operator> <operator>(</operator><name>pthread_rwlock_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pthread_rwlock_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>CONSENSUS_SLRU_MAX_NAME_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>CONSENSUS_SLRU_MAX_NAME_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name>nslots</name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>nslots</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>szblock</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* for slru stat */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>consensus_slru_stat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>stat</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>stat</name><operator>.</operator><name>n_slots</name></name> <operator>=</operator> <operator>(</operator><name>uint</name><operator>)</operator><name>nslots</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>stat</name><operator>.</operator><name>n_page_status_stat</name><index>[<expr><name>SLRU_PAGE_EMPTY</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint</name><operator>)</operator><name>nslots</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>n_consensus_slru_stats</name> <operator>&lt;</operator> <name>CONSENSUS_SLRU_STATS_NUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>consensus_slru_stats</name><index>[<expr><name>n_consensus_slru_stats</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Should fit to estimated shmem size */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shared</name> <operator>&lt;=</operator> <call><name>ConsensusSimpleLruShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>szblock</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Initialize the unshared control struct, including directory path 
	 * and block size.
	 */</comment>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name> <operator>=</operator> <name>szblock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>before_flush_hook</name></name> <operator>=</operator> <name>before_flush_hook</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>subdir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>consensus_slru_file_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name></name> <operator>=</operator> <call><name>polar_vfs_mgr</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ConsensusSimpleLruValidateDir</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>consensus_slru_file_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_stat</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_error_log</name><argument_list>(<argument><expr><literal type="string">"required consensus slru directory \"%s\" is not a directory"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"creating missing consensus slru directory \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_mkdir</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pg_dir_create_mode</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not create directory \"%s\": %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (or reinitialize) a page to zeroes.
 *
 * The page is not actually written, just set up in shared memory.
 * The slot number of the new page is returned.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>ConsensusSimpleLruZeroPage</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_zero_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Find a suitable buffer slot for the page */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>consensus_slru_select_lru_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
		   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator> <operator>||</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the slot as containing this page */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>consensus_slru_push_dirty</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConsensusSlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the buffer to zeroes */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume this page is now the latest active page */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

	<return>return <expr><name>slotno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for any active I/O on a page slot to finish.  (This does not
 * guarantee that new I/O hasn't been started before we return, though.
 * In fact the slot might not even contain the same page anymore.)
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_slru_wait_io</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>wait_reading</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>wait_writing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>wait_reading</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_reading_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>wait_writing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_writing_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>wait_reading</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_reading_count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>wait_writing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_writing_count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find a page in a shared buffer, reading it in if necessary.
 * The page number must correspond to an already-initialized page.
 *
 * If write_ok is true then it is OK to return a page that is in
 * WRITE_IN_PROGRESS state; it is the caller's responsibility to be sure
 * that modification of the page is safe.  If write_ok is false then we
 * will not return the page until it is not undergoing active I/O.
 *
 * Return value is the shared-buffer slot number now holding the page.
 * The buffer's LRU access info is updated.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>ConsensusSimpleLruReadPage</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Outer loop handles restart if we must wait for someone else's I/O */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

		<comment type="block">/* See if page already is in memory; if not, pick victim slot */</comment>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>consensus_slru_select_lru_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Did we find the page in memory? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If page is still being read in, we must wait for I/O.  Likewise
			 * if the page is being written and the caller said that's not OK.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
				<operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name>write_ok</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>consensus_slru_wait_io</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Now we must recheck state from the top */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Otherwise, it's ready to use */</comment>
			<expr_stmt><expr><call><name>ConsensusSlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slotno</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We found no match; assert we selected a freeable slot */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
			   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the slot read-busy */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_READ_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */</comment>
		<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release control lock while doing I/O */</comment>
		<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the read */</comment>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>consensus_slru_physical_read_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Re-acquire control lock and update page state */</comment>
		<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
			   <operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ok</name></expr> ?</condition><then> <expr><name>SLRU_PAGE_VALID</name></expr> </then><else>: <expr><name>SLRU_PAGE_EMPTY</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ConsensusSlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>slotno</name></expr>;</return>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Find a page in a shared buffer, reading it in if necessary.
 * The page number must correspond to an already-initialized page.
 * The caller must intend only read-only access to the page.
 *
 * Return value is the shared-buffer slot number now holding the page.
 * The buffer's LRU access info is updated.
 *
 * Control lock must NOT be held at entry, but will be held at exit.
 * It is unspecified whether the lock will be shared or exclusive.
 */</comment>
<function><type><name>int</name></type>
<name>ConsensusSimpleLruReadPage_ReadOnly</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Try to find the page while holding only shared lock */</comment>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_only_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* See comments for ConsensusSlruRecentlyUsed macro */</comment>
			<expr_stmt><expr><call><name>ConsensusSlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slotno</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>


	<comment type="block">/* No luck, so switch to normal exclusive lock and do regular read */</comment>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_upgrade_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><call><name>ConsensusSimpleLruReadPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_slru_try_write_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctl</name><operator>-&gt;</operator><name>before_flush_hook</name></name> <operator>||</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>before_flush_hook</name></name><argument_list>(<argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_slru_internal_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a page from a shared buffer, if necessary.
 * Does nothing if the specified slot is not dirty.
 *
 * NOTE: only one write attempt is made here.  Hence, it is possible that
 * the page is still dirty at exit (if someone else re-dirtied it during
 * the write).  However, we *do* attempt a fresh write even if the page
 * is already being written; this is for checkpoints.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>consensus_slru_internal_write_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruFlushFile</name> <modifier>*</modifier></type><name>fdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>pageno</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: stat */</comment>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_write_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* If a write is in progress, wait for it to finish */</comment>
	<while>while <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_slru_wait_io</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Do nothing if page is not dirty, or if buffer no longer contains the
	 * same page we were called for.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_VALID</name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>==</operator> <name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>first_dirty_offset</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>ctl</name><operator>-&gt;</operator><name>before_flush_hook</name></name> <operator>||</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>before_flush_hook</name></name><argument_list>(<argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the slot write-busy, and clear the dirtybit.  After this point, a
	 * transaction status update on this page will mark it dirty again.
	 */</comment>
	<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */</comment>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release control lock while doing I/O */</comment>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the write */</comment>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>consensus_slru_physical_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>fdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Re-acquire control lock and update page state */</comment>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_slru_pop_dirty</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Physical read of a (previously existing) page into a buffer slot
 *
 * For now, assume it's not worth keeping a file pointer open across
 * read/write operations.  We could cache one virtual file pointer ...
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_slru_physical_read_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_storage_read_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>consensus_slru_file_name_by_seg</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" physical read page, segno: %llu, rpageno: %d"</literal></expr></argument>, 
			<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>rpageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_open</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\": %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_lseek</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Could not seek in file \"%s\" to offset %u: %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_read</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Could not read from file \"%s\" at offset %u: %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not close file \"%s\": %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Physical write of a page from a buffer slot
 *
 * On failure, we cannot just ereport(ERROR) since caller has put state in
 * shared memory that must be undone.  So, we return false and save enough
 * info in static variables to let SlruReportIOError make the report.
 *
 * For now, assume it's not worth keeping a file pointer open across
 * independent read/write operations.  We do batch operations during
 * ConsensusSimpleLruFlush, though.
 *
 * fdata is NULL for a standalone write, pointer to open-file info during
 * ConsensusSimpleLruFlush.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_slru_physical_write_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, 
													<parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruFlushFile</name> <modifier>*</modifier></type><name>fdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>flag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: slru stat */</comment>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_storage_write_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fdata</name> <operator>&amp;&amp;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" reuse segno: %llu (fd: %d)"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>fdata</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fdata</name><operator>-&gt;</operator><name>segno</name></name> <operator>==</operator> <name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" physical write page, segno: %llu, rpageno: %d, offset: %d"</literal></expr></argument>, 
			<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>rpageno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>consensus_slru_file_name_by_seg</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rpageno</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>fdata</name> <operator>&amp;&amp;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>create_if_not_exists</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_open</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\": %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" vfs_open, path: %s (fd: %d)"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fdata</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fdata</name><operator>-&gt;</operator><name>fsync</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>segoffset</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>rpageno</name> <operator>*</operator> <name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fdata</name> <operator>&amp;&amp;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>create_if_not_exists</name></name> <operator>&amp;&amp;</operator> 
			<call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_fallocate</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <operator>(</operator><name>rpageno</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name> <operator>||</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fsync</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Could not seek in file \"%s\" (fd:%d) to offset %u: %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>segoffset</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" vfs_lseek path: %s (fd: %d) to offset %u"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>segoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_lseek</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>segoffset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name> <operator>||</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fsync</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Could not seek in file \"%s\" (fd:%d) to offset %u: %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>segoffset</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" vfs_write path: %s (fd: %d)"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_write</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> 
			<name><name>ctl</name><operator>-&gt;</operator><name>szblock</name></name> <operator>-</operator> <name>offset</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name> <operator>||</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fsync</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not write to file \"%s\" at offset %u: %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segoffset</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If not part of Flush, need to fsync now.  We assume this happens
	 * infrequently enough that it's not a performance issue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>fdata</name> <operator>||</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fsync</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_fsync</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not fsync file \"%s\": %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>fdata</name> <operator>||</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fsync</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not close file \"%s\": %s."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select the slot to re-use when we need a free slot.
 *
 * The target page number is passed because we need to consider the
 * possibility that some other process reads in the target page while
 * we are doing I/O to free a slot.  Hence, check or recheck to see if
 * any slot already holds the target page, and return that slot if so.
 * Thus, the returned slot is *either* a slot already holding the pageno
 * (could be any state except EMPTY), *or* a freeable slot (state EMPTY
 * or CLEAN).
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>consensus_slru_select_lru_page</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Outer loop handles restart after I/O */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bestvalidslot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_valid_delta</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_valid_page_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>bestinvalidslot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_invalid_delta</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_invalid_page_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>

		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
					<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>cur_count</name> <operator>=</operator> <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>cur_lru_count</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name></expr>;</init> 
				<condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name> <operator>+</operator> <name>CONSENSUS_SLRU_VICTIM_WINDOW</name> <operator>&amp;&amp;</operator> 
				<name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition>
				<incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_delta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_page_number</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>&amp;&amp;</operator> 
					<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>this_delta</name> <operator>=</operator> <name>cur_count</name> <operator>-</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Clean up in case shared updates have caused cur_count
				 * increments to get "lost".  We back off the page counts,
				 * rather than trying to increase cur_count, to avoid any
				 * question of infinite loops or failure in the presence of
				 * wrapped-around counts.
				 */</comment>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>cur_count</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>this_page_number</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_page_number</name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&gt;</operator> <name>best_valid_delta</name> <operator>||</operator>
					<operator>(</operator><name>this_delta</name> <operator>==</operator> <name>best_valid_delta</name> <operator>&amp;&amp;</operator>
					 <name>this_page_number</name> <operator>&lt;</operator> <name>best_valid_page_number</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bestvalidslot</name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_valid_delta</name> <operator>=</operator> <name>this_delta</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_valid_page_number</name> <operator>=</operator> <name>this_page_number</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&gt;</operator> <name>best_invalid_delta</name> <operator>||</operator>
					<operator>(</operator><name>this_delta</name> <operator>==</operator> <name>best_invalid_delta</name> <operator>&amp;&amp;</operator>
					 <name>this_page_number</name> <operator>&lt;</operator> <name>best_invalid_page_number</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bestinvalidslot</name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_invalid_delta</name> <operator>=</operator> <name>this_delta</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_invalid_page_number</name> <operator>=</operator> <name>this_page_number</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>slotno</name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>slotno</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_victim_count</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>best_valid_delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>bestvalidslot</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>best_invalid_delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consensus_slru_wait_io</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>bestinvalidslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>!=</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_victim_write_count</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>consensus_slru_try_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Flush dirty pages before pageno 
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>bool</name></type>
<name>ConsensusSimpleLruFlush</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>, <decl><type ref="prev"/><name>next_slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>pagesegno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusSlruFlushFile</name></type> <name>fdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_flush_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>fsync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>create_if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>ok</name> <operator>&amp;&amp;</operator> <name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>!=</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pageno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>&gt;</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pagesegno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>/</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>segno</name></name> <operator>=</operator> <name>pagesegno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ok</name> <operator>&amp;&amp;</operator> <name>slotno</name> <operator>!=</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name> <operator>&amp;&amp;</operator> <name><name>fdata</name><operator>.</operator><name>segno</name></name> <operator>==</operator> <name>pagesegno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" flush page, slotno: %d, pageno: %lld"</literal></expr></argument>, 
					<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_slotno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>consensus_slru_internal_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <name>next_slotno</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pageno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>&gt;</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>pagesegno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>/</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" fsync segno: %llu (fd: %d)"</literal></expr></argument>, 
				<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fdata</name><operator>.</operator><name>fd</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_fsync</name></name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not fsync file, segno: %llu, fd: %d, error: %s."</literal></expr></argument>, 
					<argument><expr><name><name>fdata</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" close segno: %llu (fd: %d)"</literal></expr></argument>, 
				<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fdata</name><operator>.</operator><name>fd</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_close</name></name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Could not close file, segno: %llu, fd: %d, error: %s."</literal></expr></argument>, 
					<argument><expr><name><name>fdata</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>control_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Flush dirty pages 
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>bool</name></type>
<name>ConsensusSimpleLruWritePage</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_if_not_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruFlushFile</name></type> <name>fdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>segno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>fsync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>create_if_not_exists</name></name> <operator>=</operator> <name>create_if_not_exists</name></expr>;</expr_stmt>

	<return>return <expr><call><name>consensus_slru_internal_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdata</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>consensus_slru_push_dirty</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>write_offset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_offset</name></name> <operator>=</operator> <name>write_offset</name></expr>;</expr_stmt> 
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>head</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name></expr>]</index></name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name><index>[<expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name></expr>]</index></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name></expr>]</index></name> <operator>&gt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" push dirty page, slotno: %d, offset: %d"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>write_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>consensus_slru_pop_dirty</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>==</operator> <name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>next_dirty_slot</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</expr_stmt> 

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>last_dirty_slot</name></name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus slru \"%s\" pop dirty page, slotno: %d"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all segments before the one holding the passed page number
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>void</name></type>
<name>ConsensusSimpleLruTruncateForward</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>cutoffPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_truncate_forward_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The cutoff point is the start of the segment containing cutoffPage.
	 */</comment>
	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * While we are holding the lock, make an important safety check: the
	 * planned cutoff point must be &lt;= the current endpoint page. 
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>&lt;=</operator> <name>cutoffPage</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>slotno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>first_dirty_slot</name></name><operator>)</operator> <operator>!=</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>&gt;=</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>consensus_slru_internal_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>consensus_slru_wait_io</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ok</name> <operator>&amp;&amp;</operator> <name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content> 
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>&gt;=</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * change state to EMPTY (expected case).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * empty the page after the one holding the passed page number
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>void</name></type>
<name>ConsensusSimpleLruTruncateBackward</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>cutoffPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsensusSlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_truncate_backward_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>&gt;=</operator> <name>cutoffPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ok</name> <operator>&amp;&amp;</operator> <name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content> 
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>&lt;=</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * change state to EMPTY (expected case).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>consensus_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Delete an individual SLRU segment, identified by the filename.
 *
 * NB: This does not touch the SLRU buffers themselves, callers have to ensure
 * they either can't yet contain anything, or have already been cleaned out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_slru_internal_delete_segment</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>consensus_slru_file_name_by_name</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"removing file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_unlink</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ConsensusSlruScanDirectory callback
 *		This callback reports true if there's any segment prior to the one
 *		containing the page passed as "data".
 */</comment>
<function><type><name>bool</name></type>
<name>ConsensusSlruScanDirCbReportPresenceForward</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, 
																			<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segpage</name> <operator>&lt;</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* found one; don't iterate any more */</comment>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * ConsensusConsensusSlruScanDirectory callback.
 *		This callback deletes segments prior to the one passed in as "data".
 */</comment>
<function><type><name>bool</name></type>
<name>consensus_slru_scan_dir_callback_delete_cutoff_forward</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, 
																			<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segpage</name> <operator>&lt;</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_slru_internal_delete_segment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * ConsensusSlruScanDirectory callback
 *		This callback reports true if there's any segment after the one
 *		containing the page passed as "data".
 */</comment>
<function><type><name>bool</name></type>
<name>ConsensusSlruScanDirCbReportPresenceBackward</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, 
		<parameter><decl><type><name>uint64</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segpage</name> <operator>&gt;</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* found one; don't iterate any more */</comment>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * ConsensusSlruScanDirectory callback.
 *		This callback deletes segments after the one passed in as "data".
 */</comment>
<function><type><name>bool</name></type>
<name>consensus_slru_scan_dir_callback_delete_cutoff_backward</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, 
																		<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segpage</name> <operator>&gt;</operator> <name>cutoffPage</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_slru_internal_delete_segment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Scan the SimpleLRU directory and apply a callback to each file found in it.
 *
 * If the callback returns true, the scan is stopped.  The last return value
 * from the callback is returned.
 *
 * The callback receives the following arguments: 1. the ConsensusSlruCtl struct for the
 * slru being truncated; 2. the filename being considered; 3. the page number
 * for the first page of that file; 4. a pointer to the opaque data given to us
 * by the caller.
 *
 * Note that the ordering in which the directory is scanned is not guaranteed.
 *
 * Note that no locking is applied.
 */</comment>
<function><type><name>bool</name></type>
<name>ConsensusSlruScanDirectory</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruScanCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>cldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>clde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>segpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>consensus_slru_file_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cldir</name> <operator>=</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_opendir</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>clde</name> <operator>=</operator> <call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_readdir</name></name><argument_list>(<argument><expr><name>cldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <call><name>strspn</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segpage</name> <operator>=</operator> <name>segno</name> <operator>*</operator> <name>CONSENSUS_SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"ConsensusSlruScanDirectory invoking callback on %s/%s"</literal></expr></argument>,
										<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>callback</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name><name>ctl</name><operator>-&gt;</operator><name>vfs_api</name><operator>-&gt;</operator><name>vfs_closedir</name></name><argument_list>(<argument><expr><name>cldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_slru_file_name_by_seg</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CONSENSUS_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%016lX"</literal></expr></argument>, <argument><expr><call><name>polar_path_remove_protocol</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%016lX"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_slru_file_dir</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CONSENSUS_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><call><name>polar_path_remove_protocol</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_slru_file_name_by_name</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CONSENSUS_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><call><name>polar_path_remove_protocol</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>consensus_slru_set_page_status</name><parameter_list>(<parameter><decl><type><name>ConsensusSlruShared</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>ConsensusSlruPageStatus</name></type> <name>pagestatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>consensus_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusSlruPageStatus</name></type> <name>oldstatus</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldstatus</name> <operator>!=</operator> <name>pagestatus</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_page_status_stat</name><index>[<expr><name>oldstatus</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_page_status_stat</name><index>[<expr><name>pagestatus</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pagestatus</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusSlruStatsInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>consensus_slru_stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>consensus_slru_stat</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CONSENSUS_SLRU_STATS_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_consensus_slru_stats</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
