<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_dma/libconsensus/dependency/easy/src/io/ev.c"><comment type="block">/*
 * libev event processing core, watcher management
 *
 * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann &lt;libev@schmorp.de&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modifica-
 * tion, are permitted provided that the following conditions are met:
 *
 *   1.  Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
 * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
 * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
 * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License ("GPL") version 2 or any later version,
 * in which case the provisions of the GPL are applicable instead of
 * the above. If you wish to allow the use of your version of this file
 * only under the terms of the GPL and not to allow others to use your
 * version of this file under the BSD license, indicate your decision
 * by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL. If you do not delete the
 * provisions above, a recipient may use your version of this file under
 * either the BSD or the GPL.
 */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EV_STANDALONE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_STANDALONE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* this big block deduces configuration from config.h */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_STANDALONE</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>EV_CONFIG_H</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> EV_CONFIG_H</cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_CLOCK_SYSCALL</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif># <cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EV_USE_CLOCK_SYSCALL</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_CLOCK_GETTIME</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_NANOSLEEP</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_NANOSLEEP</name></cpp:ifndef>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#   <cpp:directive>undef</cpp:directive> <name>EV_USE_NANOSLEEP</name></cpp:undef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_SELECT</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_SELECT_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_SELECT</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_SELECT</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_POLL</name> <operator>&amp;&amp;</operator> <name>HAVE_POLL_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_POLL</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_POLL</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_EPOLL_CTL</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_EPOLL_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_EPOLL</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_EPOLL</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_KQUEUE</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_EVENT_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_KQUEUE</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_KQUEUE</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_KQUEUE</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_KQUEUE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_PORT_H</name> <operator>&amp;&amp;</operator> <name>HAVE_PORT_CREATE</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_PORT</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_PORT</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_PORT</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_PORT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_INOTIFY_INIT</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_INOTIFY_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_SIGNALFD</name> <operator>&amp;&amp;</operator> <name>HAVE_SYS_SIGNALFD_H</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_SIGNALFD</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_SIGNALFD</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>HAVE_EVENTFD</name></expr></condition></ternary></expr></cpp:if>
<cpp:ifndef>#  <cpp:directive>ifndef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:ifndef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>defined</name> <name>__aarch64__</name></expr></condition></ternary></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/eventfd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syscall.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EV_H</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> EV_H</cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>EV_CPP</name><argument_list>(<argument>extern <literal type="string">"C"</literal> {</argument>
          )</argument_list></macro>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EV_SELECT_IS_WINSOCKET</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_SELECT_IS_WINSOCKET</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_AVOID_STDIO</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* OS X, in its infinite idiocy, actually HARDCODES
     * a limit of 1024 into their select. Where people have brains,
     * OS X engineers apparently have a vacuum. Or maybe they were
     * ordered to have a vacuum, or they do anything for money.
     * This might help. Or not.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DARWIN_UNLIMITED_SELECT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

    <comment type="block">/* this block tries to deduce configuration from header-defined symbols and defaults */</comment>

    <comment type="block">/* try to deduce the maximum number of signals on this platform */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>EV_NSIG</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
    <comment type="block">/* use what's provided */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>NSIG</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(NSIG)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>_NSIG</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(_NSIG)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>SIGMAX</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(SIGMAX+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>SIG_MAX</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(SIG_MAX+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>_SIG_MAX</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(_SIG_MAX+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>MAXSIG</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(MAXSIG+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>MAX_SIG</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(MAX_SIG+1)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>SIGARRAYSIZE</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(SIGARRAYSIZE)</cpp:value></cpp:define> <comment type="block">/* Assume ary[SIGARRAYSIZE] */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>_sys_nsig</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>(_sys_nsig)</cpp:value></cpp:define> <comment type="block">/* Solaris 2.5 */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error># <cpp:directive>error</cpp:directive> <cpp:literal>"unable to find value for NSIG, please report"</cpp:literal></cpp:error>
    <comment type="block">/* to make it compile regardless, just remove the above line, */</comment>
    <comment type="block">/* but consider reporting it, too! :) */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_NSIG</name></cpp:macro> <cpp:value>65</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__linux</name> <operator>&amp;&amp;</operator> <name>__GLIBC__</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name> <argument_list>(<argument><expr><name>_POSIX_MONOTONIC_CLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_POSIX_MONOTONIC_CLOCK</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro> <cpp:value>!EV_USE_CLOCK_SYSCALL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_NANOSLEEP</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>_POSIX_C_SOURCE</name> <operator>&gt;=</operator> <literal type="number">199309L</literal></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_NANOSLEEP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_SELECT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SELECT</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_POLL</name></cpp:ifndef>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_EPOLL</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>EV_FEATURE_BACKENDS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EPOLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_KQUEUE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_KQUEUE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_PORT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_PORT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></condition></ternary></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_PID_HASHSIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_PID_HASHSIZE</name></cpp:macro> <cpp:value>EV_FEATURE_DATA ? 16 : 1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_INOTIFY_HASHSIZE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INOTIFY_HASHSIZE</name></cpp:macro> <cpp:value>EV_FEATURE_DATA ? 16 : 1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__NR_eventfd2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__NR_eventfd</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EV_USE_EVENTFD</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_EVENTFD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_SIGNALFD</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>__linux</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>EV_FEATURE_OS</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_SIGNALFD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* debugging */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_VERIFY</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_4HEAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_HEAP_CACHE_AT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_VERIFY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_VERIFY</name></cpp:macro> <cpp:value>(EV_FEATURE_API ? 1 : 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_USE_4HEAP</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_4HEAP</name></cpp:macro> <cpp:value>EV_FEATURE_DATA</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_HEAP_CACHE_AT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_HEAP_CACHE_AT</name></cpp:macro> <cpp:value>EV_FEATURE_DATA</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* on linux, we can use a (slow) syscall to avoid a dependency on pthread, */</comment>
    <comment type="block">/* which makes programs even slower. might work on other unices, too. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_CLOCK_SYSCALL</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;syscall.h&gt;</cpp:file></cpp:include>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>SYS_clock_gettime</name></cpp:ifdef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>clock_gettime</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>ts</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>syscall (SYS_clock_gettime, (id), (ts))</cpp:value></cpp:define>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_CLOCK_SYSCALL</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_CLOCK_SYSCALL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* this block fixes any misconfiguration where we know we run into trouble otherwise */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_AIX</name></cpp:ifdef>
    <comment type="block">/* AIX has a completely broken poll.h header */</comment>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_POLL</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_POLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CLOCK_MONOTONIC</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_MONOTONIC</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_MONOTONIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CLOCK_REALTIME</name></cpp:ifndef>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_REALTIME</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_REALTIME</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>EV_STAT_ENABLE</name></expr></cpp:if>
<cpp:undef># <cpp:directive>undef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:undef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>EV_USE_NANOSLEEP</name></expr></cpp:if>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statfs.h&gt;</cpp:file></cpp:include>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/inotify.h&gt;</cpp:file></cpp:include>
    <comment type="block">/* some very old inotify.h headers don't have IN_DONT_FOLLOW */</comment>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>IN_DONT_FOLLOW</name></cpp:ifndef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>EV_USE_INOTIFY</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_USE_INOTIFY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SELECT_IS_WINSOCKET</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
    <comment type="block">/* our minimum requirement is glibc 2.7 which has the stub, but not the header */</comment>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EFD_NONBLOCK</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>EFD_NONBLOCK</name></cpp:macro> <cpp:value>O_NONBLOCK</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>EFD_CLOEXEC</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EFD_CLOEXEC</name></cpp:macro> <cpp:value>O_CLOEXEC</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>EFD_CLOEXEC</name></cpp:macro> <cpp:value>02000000</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
    <comment type="block">/* our minimum requirement is glibc 2.7 which has the stub, but not the header */</comment>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>SFD_NONBLOCK</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SFD_NONBLOCK</name></cpp:macro> <cpp:value>O_NONBLOCK</cpp:value></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive> <name>SFD_CLOEXEC</name></cpp:ifndef>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SFD_CLOEXEC</name></cpp:macro> <cpp:value>O_CLOEXEC</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>SFD_CLOEXEC</name></cpp:macro> <cpp:value>02000000</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
    <macro><name>EV_CPP</name> <argument_list>(<argument>extern <literal type="string">"C"</literal></argument>)</argument_list></macro> <function_decl><type><name>int</name></type> <name>signalfd</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sigset_t</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

    <struct>struct <name>signalfd_siginfo</name> <block>{
        <decl_stmt><decl><type><name>uint32_t</name></type>                <name>ssi_signo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>pad</name><index>[<expr><literal type="number">128</literal> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    }</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/**/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_FREQUENT_CHECK</name></cpp:macro> <cpp:value>ev_verify (EV_A)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_FREQUENT_CHECK</name></cpp:macro> <cpp:value>do { } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * This is used to avoid floating point rounding problems.
     * It is added to ev_rt_now when scheduling periodics
     * to ensure progress, time-wise, even when rounding
     * errors are against us.
     * This value is good at least till the year 4000.
     * Better solutions welcome.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_EPSILON</name></cpp:macro>  <cpp:value>0.0001220703125</cpp:value></cpp:define> <comment type="block">/* 1/8192 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_TIMEJUMP</name></cpp:macro>  <cpp:value>1.</cpp:value></cpp:define> <comment type="block">/* minimum timejump that gets detected (if monotonic clock available) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BLOCKTIME</name></cpp:macro> <cpp:value>59.743</cpp:value></cpp:define> <comment type="block">/* never wait longer than this time (to detect time jumps) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_TV_SET</name><parameter_list>(<parameter><type><name>tv</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tv.tv_sec = (long)t; tv.tv_usec = (long)((t - tv.tv_sec) * 1e6); } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_TS_SET</name><parameter_list>(<parameter><type><name>ts</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ts.tv_sec = (long)t; ts.tv_nsec = (long)((t - ts.tv_sec) * 1e9); } while (0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>expect</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>__builtin_expect ((expr),(value))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>noinline</name></cpp:macro>                   <cpp:value>__attribute__ ((noinline))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>expect</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>(expr)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>noinline</name></cpp:macro></cpp:define>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">199901L</literal> <operator>&amp;&amp;</operator> <name>__GNUC__</name> <operator>&lt;</operator> <literal type="number">2</literal></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>inline</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expect_false</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>expect ((expr) != 0, 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expect_true</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>expect ((expr) != 0, 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inline_size</name></cpp:macro>        <cpp:value>static inline</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_CODE</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>inline_speed</name></cpp:macro>      <cpp:value>static inline</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>inline_speed</name></cpp:macro>      <cpp:value>static noinline</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMPRI</name></cpp:macro> <cpp:value>(EV_MAXPRI - EV_MINPRI + 1)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MINPRI</name> <operator>==</operator> <name>EV_MAXPRI</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ABSPRI</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((W)w), 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ABSPRI</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((W)w)-&gt;priority - EV_MINPRI)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY</name></cpp:macro></cpp:define>       <comment type="block">/* required for microsofts broken pseudo-c compiler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EMPTY2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> <comment type="block">/* used to suppress some warnings */</comment>

    <typedef>typedef <type><name>ev_watcher</name>      <modifier>*</modifier></type><name>W</name>;</typedef>
    <typedef>typedef <type><name>ev_watcher_list</name> <modifier>*</modifier></type><name>WL</name>;</typedef>
    <typedef>typedef <type><name>ev_watcher_time</name> <modifier>*</modifier></type><name>WT</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_active</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((W)(w))-&gt;active</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_at</name><parameter_list>(<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((WT)(w))-&gt;at</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__x86_64__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_mb</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>__asm__ __volatile ("mfence" ::: "memory")</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__aarch64__</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_mb</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>__asm__ __volatile ("dsb sy" ::: "memory")</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_REALTIME</name></expr></cpp:if>
    <comment type="block">/* sig_atomic_t is used to avoid per-thread variables or locking but still */</comment>
    <comment type="block">/* giving it a reasonably high chance of working on typical architectures */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>EV_ATOMIC_T</name></type>      <name>have_realtime</name></decl>;</decl_stmt> <comment type="block">/* did clock_gettime (CLOCK_REALTIME) work? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <name>EV_ATOMIC_T</name></type>      <name>have_monotonic</name></decl>;</decl_stmt> <comment type="block">/* did clock_gettime (CLOCK_MONOTONIC) work? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_FD_TO_WIN32_HANDLE</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_FD_TO_WIN32_HANDLE</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_get_osfhandle (fd)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_WIN32_HANDLE_TO_FD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_WIN32_HANDLE_TO_FD</name><parameter_list>(<parameter><type><name>handle</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_open_osfhandle (handle, 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_WIN32_CLOSE_FD</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_WIN32_CLOSE_FD</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>close (fd)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_win32.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <name>noinline</name></type>
    <name>ev_linux_version</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux</name></cpp:ifdef>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>            <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type>          <name>buf</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>buf</name><operator>.</operator><name>release</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>uname</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>--</operator><name>i</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>            <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else <block>{<block_content>
                    <expr_stmt><expr><name>p</name> <operator>+=</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <return>return <expr><name>v</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_AVOID_STDIO</name></expr></cpp:if>
    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>ev_printerr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>write</name> <argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> ( <modifier>*</modifier><name>syserr_cb</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>

    <function><type><name>void</name></type>
    <name>ev_set_syserr_cb</name> <parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>syserr_cb</name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>ev_syserr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"(libev) system error"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>syserr_cb</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syserr_cb</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_AVOID_STDIO</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
    <name>ev_realloc_emul</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

    <function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>( <modifier>*</modifier><name>alloc</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <init>= <expr><name>ev_realloc_emul</name></expr></init>;</function_decl>

    <function><type><name>void</name></type>
    <name>ev_set_allocator</name> <parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>alloc</name> <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_speed</name> <name>void</name> <modifier>*</modifier></type>
    <name>ev_realloc</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>alloc</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>&amp;&amp;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_AVOID_STDIO</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ev_printerr</name> <argument_list>(<argument><expr><literal type="string">"(libev) memory allocation failed, aborting.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"(libev) cannot allocate %ld bytes, aborting."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>ptr</name></expr>;</return>
    </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_malloc</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ev_realloc (0, (size))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>ev_realloc ((ptr), 0)</cpp:value></cpp:define>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <comment type="block">/* set in reify when reification needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_ANFD_REIFY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

    <comment type="block">/* file descriptor info structure */</comment>
    <typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>WL</name></type>                      <name>head</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>events</name></decl>;</decl_stmt> <comment type="block">/* the events watched for */</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>reify</name></decl>;</decl_stmt>  <comment type="block">/* flag set when this ANFD needs reification (EV_ANFD_REIFY, EV__IOFDSET) */</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>emask</name></decl>;</decl_stmt>  <comment type="block">/* the epoll backend stores the actual kernel mask in here */</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>cdel</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>            <name>egen</name></decl>;</decl_stmt>    <comment type="block">/* generation counter to counter epoll bugs */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SELECT_IS_WINSOCKET</name> <operator>||</operator> <name>EV_USE_IOCP</name></expr></cpp:if>
        <decl_stmt><decl><type><name>SOCKET</name></type>                  <name>handle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_IOCP</name></expr></cpp:if>
        <decl_stmt><decl><type><name>OVERLAPPED</name></type>              <name>or</name></decl> , <name>ow</name>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></struct></type> <name>ANFD</name>;</typedef>

    <comment type="block">/* stores the pending event set for a given watcher */</comment>
    <typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>W</name></type>                       <name>w</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>events</name></decl>;</decl_stmt> <comment type="block">/* the pending event set for the given watcher */</comment>
    }</block></struct></type> <name>ANPENDING</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
    <comment type="block">/* hash table entry per inotify-id */</comment>
    <typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>WL</name></type>                      <name>head</name></decl>;</decl_stmt>
    }</block></struct></type> <name>ANFS</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Heap Entry */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_HEAP_CACHE_AT</name></expr></cpp:if>
    <comment type="block">/* a heap element */</comment>
    <typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>at</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WT</name></type>                      <name>w</name></decl>;</decl_stmt>
    }</block></struct></type> <name>ANHE</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_w</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>(he).w</cpp:value></cpp:define>     <comment type="block">/* access watcher, read-write */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(he).at</cpp:value></cpp:define>    <comment type="block">/* access cached at, read-only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at_cache</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(he).at = (he).w-&gt;at</cpp:value></cpp:define> <comment type="block">/* update at from watcher */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* a heap element */</comment>
    <typedef>typedef <type><name>WT</name></type>              <name>ANHE</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_w</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>(he)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(he)-&gt;at</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANHE_at_cache</name><parameter_list>(<parameter><type><name>he</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>

    <struct>struct <name>ev_loop</name> <block>{
        <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>ev_rt_now</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_rt_now</name></cpp:macro> <cpp:value>((loop)-&gt;ev_rt_now)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>decl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>decl;</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_vars.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VAR</name></cpp:undef>
    }</block>;</struct>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_wrap.h"</cpp:file></cpp:include>

    <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>ev_loop</name></name></type>   <name>default_loop_struct</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>ev_loop</name></name>          <modifier>*</modifier></type><name>easy_default_loop_ptr</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>ev_rt_now</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>decl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static decl;</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_vars.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VAR</name></cpp:undef>

    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>              <name>easy_default_loop_ptr</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_RELEASE_CB</name></cpp:macro> <cpp:value>if (expect_false (release_cb)) release_cb (EV_A)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_ACQUIRE_CB</name></cpp:macro> <cpp:value>if (expect_false (acquire_cb)) acquire_cb (EV_A)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INVOKE_PENDING</name></cpp:macro> <cpp:value>invoke_cb (EV_A)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_RELEASE_CB</name></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_ACQUIRE_CB</name></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INVOKE_PENDING</name></cpp:macro> <cpp:value>ev_invoke_pending (EV_A)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVBREAK_RECURSE</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>

        <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EV_HAVE_EV_TIME</name></cpp:ifndef>
                <function><type><name>ev_tstamp</name></type>
        <name>ev_time</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_REALTIME</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>have_realtime</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type>         <name>ts</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>*</operator> <literal type="number">1e-9</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>          <name>tv</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>gettimeofday</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1e-6</literal></expr>;</return>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>inline_size</name> <name>ev_tstamp</name></type>
    <name>get_clock</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>have_monotonic</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type>         <name>ts</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>*</operator> <literal type="number">1e-9</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <return>return <expr><call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
    <function><type><name>ev_tstamp</name></type>
    <name>ev_now</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>ev_rt_now</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>ev_tstamp</name></type>
    <name>ev_mn_now</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>mn_now</name></expr>;</return>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>void</name></type>
    <name>ev_sleep</name> <parameter_list>(<parameter><decl><type><name>ev_tstamp</name></type> <name>delay</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <literal type="number">0.</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_NANOSLEEP</name></expr></cpp:if>
            <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type>         <name>ts</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>EV_TS_SET</name> <argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>nanosleep</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
            <expr_stmt><expr><call><name>Sleep</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>delay</name> <operator>*</operator> <literal type="number">1e3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>          <name>tv</name></decl>;</decl_stmt>

            <comment type="block">/* here we rely on sys/time.h + sys/types.h + unistd.h providing select */</comment>
            <comment type="block">/* something not guaranteed by newer posix versions, but guaranteed */</comment>
            <comment type="block">/* by older ones */</comment>
            <expr_stmt><expr><call><name>EV_TV_SET</name> <argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>select</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC_ROUND</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define> <comment type="block">/* prefer to allocate in chunks of this size, must be 2**n and &gt;&gt; 4 longs */</comment>

    <comment type="block">/* find a suitable new size for the given array, */</comment>
    <comment type="block">/* hopefully by rounding to a nice-to-malloc size */</comment>
    <function><type><name>inline_size</name> <name>int</name></type>
    <name>array_nextsize</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>ncur</name> <init>= <expr><name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <do>do<block type="pseudo"><block_content>
            <expr_stmt><expr><name>ncur</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block>

        while <condition>(<expr><name>cnt</name> <operator>&gt;</operator> <name>ncur</name></expr>)</condition>;</do>

        <comment type="block">/* if size is large, round to MALLOC_ROUND - 4 * longs to accomodate malloc overhead */</comment>
        <if_stmt><if>if <condition>(<expr><name>elem</name> <operator>*</operator> <name>ncur</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>MALLOC_ROUND</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ncur</name>                    <operator>*=</operator> <name>elem</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ncur</name> <operator>=</operator> <operator>(</operator><name>ncur</name> <operator>+</operator> <name>elem</name> <operator>+</operator> <operator>(</operator><name>MALLOC_ROUND</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>MALLOC_ROUND</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ncur</name> <operator>=</operator> <name>ncur</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>ncur</name> <operator>/=</operator> <name>elem</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>ncur</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>noinline</name> <name>void</name> <modifier>*</modifier></type>
    <name>array_realloc</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>elem</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>cur</name> <operator>=</operator> <call><name>array_nextsize</name> <argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><operator>*</operator><name>cur</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>ev_realloc</name> <argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>elem</name> <operator>*</operator><operator>*</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_init_zero</name><parameter_list>(<parameter><type><name>base</name></type></parameter>,<parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>memset ((void *)(base), 0, sizeof (*(base)) * (count))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_needsize</name><parameter_list>(<parameter><type><name>type</name></type></parameter>,<parameter><type><name>base</name></type></parameter>,<parameter><type><name>cur</name></type></parameter>,<parameter><type><name>cnt</name></type></parameter>,<parameter><type><name>init</name></type></parameter>)</parameter_list></cpp:macro>          \
    <cpp:value>if (expect_false ((cnt) &gt; (cur)))             \
    {                               \
        int ocur_ __attribute__ ((unused)) = (cur);                    \
        (base) = (type *)array_realloc                \
                 (sizeof (type), (base), &amp;(cur), (cnt));        \
        init ((base) + (ocur_), (cur) - ocur_);           \
    }</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_slim</name><parameter_list>(<parameter><type><name>type</name></type></parameter>,<parameter><type><name>stem</name></type></parameter>)</parameter_list></cpp:macro>                   \
    <cpp:value>if (stem ## max &lt; array_roundsize (stem ## cnt &gt;&gt; 2))     \
    {                               \
        stem ## max = array_roundsize (stem ## cnt &gt;&gt; 1);     \
        base = (type *)ev_realloc (base, sizeof (type) * (stem ## max));\
        fprintf (stderr, "slimmed down " # stem " to %d\n", stem ## max);<comment type="block">/*D*/</comment>\
    }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>array_free</name><parameter_list>(<parameter><type><name>stem</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>ev_free (stem ## s idx); stem ## cnt idx = stem ## max idx = 0; stem ## s idx = 0</cpp:value></cpp:define>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <comment type="block">/* dummy callback for pending events */</comment>
    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>pendingcb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_feed_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>W</name></type>                       <name>w_</name> <init>= <expr><operator>(</operator><name>W</name><operator>)</operator><name>w</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>pri</name> <init>= <expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index><index>[<expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>revents</name></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <operator>++</operator><name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANPENDING</name></expr></argument>, <argument><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>pendingmax</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index><index>[<expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>w</name>      <operator>=</operator> <name>w_</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index><index>[<expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>revents</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>feed_reverse</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>W</name></expr></argument>, <argument><expr><name>rfeeds</name></expr></argument>, <argument><expr><name>rfeedmax</name></expr></argument>, <argument><expr><name>rfeedcnt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rfeeds</name> <index>[<expr><name>rfeedcnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>feed_reverse_done</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <do>do<block type="pseudo"><block_content>
            <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ rfeeds [--rfeedcnt]</argument>, <argument>revents</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block>

        while <condition>(<expr><name>rfeedcnt</name></expr>)</condition>;</do>
    </block_content>}</block></function>

    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>queue_events</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eventcnt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>eventcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ events [i]</argument>, <argument>type</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>fd_event_nocheck</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ANFD</name>                    <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ev_io</name>                   <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name><name>anfd</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>!=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type>                     <name>ev</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>revents</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>ev</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <comment type="block">/* do not submit kernel events for fds that have reify set */</comment>
    <comment type="block">/* because that means they changed while we were polling for new events */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>fd_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ANFD</name>                    <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>!</operator><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <macro><name>fd_event_nocheck</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>revents</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_feed_fd_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fd</name> <operator>&lt;</operator> <name>anfdmax</name></expr>)</condition><block type="pseudo"><block_content>
            <macro><name>fd_event_nocheck</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>revents</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block">/* make sure the external fd watch events are in-sync */</comment>
    <comment type="block">/* with the kernel/libev internal state */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>fd_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fdchangecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>fd</name> <init>= <expr><name><name>fdchanges</name> <index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ANFD</name>                    <modifier>*</modifier></type><name>anfd</name> <init>= <expr><name>anfds</name> <operator>+</operator> <name>fd</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ev_io</name>                   <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>o_events</name> <init>= <expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>o_reify</name>  <init>= <expr><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>reify</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SELECT_IS_WINSOCKET</name> <operator>||</operator> <name>EV_USE_IOCP</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><name>o_reify</name> <operator>&amp;</operator> <name>EV__IOFDSET</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type>           <name>arg</name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <call><name>EV_FD_TO_WIN32_HANDLE</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: only socket fds supported in this configuration"</literal><operator>,</operator> <call><name>ioctlsocket</name> <argument_list>(<argument><expr><name><name>anfd</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>FIONREAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"oi %d %x\n"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>anfd</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//D</comment>
            </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*if (expect_true (o_reify &amp; EV_ANFD_REIFY)) probably a deoptimisation */</comment>
            <block>{<block_content>
                <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name><name>anfd</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></incr>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>!=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>anfd</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>w</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>
                </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><name>o_events</name> <operator>!=</operator> <name><name>anfd</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>o_reify</name> <operator>=</operator> <name>EV__IOFDSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* actually |= */</comment>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>o_reify</name> <operator>&amp;</operator> <name>EV__IOFDSET</name></expr>)</condition><block type="pseudo"><block_content>
                <macro><name>backend_modify</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>o_events</argument>, <argument>anfd-&gt;events</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name>fdchangecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block">/* something about the given fd changed */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>fd_change</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>           <name>reify</name> <init>= <expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>reify</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>reify</name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>!</operator><name>reify</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>fdchangecnt</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>fdchanges</name></expr></argument>, <argument><expr><name>fdchangemax</name></expr></argument>, <argument><expr><name>fdchangecnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fdchanges</name> <index>[<expr><name>fdchangecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block">/* the given fd is invalid/unusable, so make sure it doesn't hurt us anymore */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>fd_kill</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_io</name>                   <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><operator>(</operator><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>head</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <macro><name>ev_io_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_ERROR</name> <operator>|</operator> <name>EV_READ</name> <operator>|</operator> <name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block">/* check whether the given fd is actually valid, for error recovery */</comment>
    <function><type><name>inline_size</name> <name>int</name></type>
    <name>fd_valid</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <return>return <expr><call><name>EV_FD_TO_WIN32_HANDLE</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <comment type="block">/* called on EBADF to verify fds */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type> <name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list>
    <name>fd_ebadf</name> <argument_list>(<argument><expr><name>EV_P</name></expr></argument>)</argument_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>fd</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fd</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>fd</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fd_valid</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition><block type="pseudo"><block_content>
                    <macro><name>fd_kill</name> <argument_list>(<argument>EV_A_ fd</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>
    </block_content>}</block></decl></decl_stmt>

    <comment type="block">/* called on ENOMEM in select/poll to kill some fds and retry */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type> <name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list>
    <name>fd_enomem</name> <argument_list>(<argument><expr><name>EV_P</name></expr></argument>)</argument_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>fd</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <name>anfdmax</name></expr>;</init> <condition><expr><name>fd</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name></expr>)</condition> <block>{<block_content>
                <macro><name>fd_kill</name> <argument_list>(<argument>EV_A_ fd</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt></block_content></block></for>
    </block_content>}</block></decl></decl_stmt>

    <comment type="block">/* usually called after fork if backend needs to re-arm all fds from scratch */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type> <name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list>
    <name>fd_rearm_all</name> <argument_list>(<argument><expr><name>EV_P</name></expr></argument>)</argument_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>fd</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fd</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>fd</name></expr></incr>)</control><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>emask</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>fd_change</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>EV__IOFDSET | EV_ANFD_REIFY</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block></if></if_stmt></block_content></block></for>
    </block_content>}</block></decl></decl_stmt>

    <comment type="block">/* used to prepare libev internal fd's */</comment>
    <comment type="block">/* this is not fork-safe */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>fd_intern</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type>           <name>arg</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ioctlsocket</name> <argument_list>(<argument><expr><call><name>EV_FD_TO_WIN32_HANDLE</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FIONBIO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <comment type="block">/*
     * the heap functions want a real array index. array index 0 is guaranteed to not
     * be in-use at any time. the first heap entry is at array [HEAP0]. DHEAP gives
     * the branching factor of the d-tree.
     */</comment>

    <comment type="block">/*
     * at the moment we allow libev the luxury of two heaps,
     * a small-code-size 2-heap one and a ~1.5kb larger 4-heap
     * which is more cache-efficient.
     * the difference is about 5% with 50000+ watchers.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_4HEAP</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DHEAP</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP0</name></cpp:macro> <cpp:value>(DHEAP - 1)</cpp:value></cpp:define> <comment type="block">/* index of first element in heap */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HPARENT</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((k) - HEAP0 - 1) / DHEAP) + HEAP0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPHEAP_DONE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p) == (k))</cpp:value></cpp:define>

    <comment type="block">/* away from the root */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>downheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ANHE</name></type>                    <name>he</name> <init>= <expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ANHE</name>                    <modifier>*</modifier></type><name>E</name> <init>= <expr><name>heap</name> <operator>+</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>minat</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ANHE</name>                    <modifier>*</modifier></type><name>minpos</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ANHE</name>                    <modifier>*</modifier></type><name>pos</name> <init>= <expr><name>heap</name> <operator>+</operator> <name>DHEAP</name> <operator>*</operator> <operator>(</operator><name>k</name> <operator>-</operator> <name>HEAP0</name><operator>)</operator> <operator>+</operator> <name>HEAP0</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* find minimum child */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <name>DHEAP</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>E</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* fast path */</comment>                               <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(               <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(               <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(               <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>E</name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* slow path */</comment>                               <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>E</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>E</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>+</operator> <literal type="number">3</literal> <operator>&lt;</operator> <name>E</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>pos</name> <index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>minpos</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr><operator>,</operator> <expr><operator>(</operator><name>minat</name> <operator>=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                <break>break;</break></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>minat</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>minpos</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><operator>*</operator><name>minpos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>k</name> <operator>=</operator> <name>minpos</name> <operator>-</operator> <name>heap</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
    </block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* 4HEAP */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAP0</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HPARENT</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((k) &gt;&gt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPHEAP_DONE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!(p))</cpp:value></cpp:define>

    <comment type="block">/* away from the root */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>downheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ANHE</name></type>                    <name>he</name> <init>= <expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>c</name> <init>= <expr><name>k</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>c</name> <operator>+=</operator> <ternary><condition><expr><name>c</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>c</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>
                 ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name> <index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>k</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* towards the root */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>upheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ANHE</name></type>                    <name>he</name> <init>= <expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>p</name> <init>= <expr><call><name>HPARENT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>UPHEAP_DONE</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>p</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name> <index>[<expr><name>p</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>k</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>he</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block">/* move an element suitably so it is in a correct place */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>adjustheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>HEAP0</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><call><name>HPARENT</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <comment type="block">/* rebuild the heap: this function is used only once and executed rarely */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>reheap</name> <parameter_list>(<parameter><decl><type><name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */</comment>
        <comment type="block">/* also, this is easy to implement and correct for both 2-heaps and 4-heaps */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <comment type="block">/* associate signal watchers to a signal signal */</comment>
    <typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>EV_ATOMIC_T</name></type>             <name>pending</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
        <expr_stmt><expr><name>EV_P</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><name>WL</name></type>                      <name>head</name></decl>;</decl_stmt>
    }</block></struct></type> <name>ANSIG</name>;</typedef>

    <decl_stmt><decl><type><specifier>static</specifier> <name>ANSIG</name></type> <name><name>signals</name> <index>[<expr><name>EV_NSIG</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name> <operator>||</operator> <name>EV_ASYNC_ENABLE</name></expr></cpp:if>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>evpipe_init</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__x86_64__</name></expr></cpp:if>
            <expr_stmt><expr><name>evfd</name> <operator>=</operator> <call><name>syscall</name><argument_list>(<argument><expr><name>__NR_eventfd2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EFD_NONBLOCK</name> <operator>|</operator> <name>EFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__aarch64__</name></expr></cpp:elif>
            <expr_stmt><expr><name>evfd</name> <operator>=</operator> <call><name>eventfd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EFD_NONBLOCK</name> <operator>|</operator> <name>EFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name>evfd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__x86_64__</name></expr></cpp:if>
                <expr_stmt><expr><name>evfd</name> <operator>=</operator> <call><name>syscall</name><argument_list>(<argument><expr><name>__NR_eventfd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__aarch64__</name></expr></cpp:elif>
                <expr_stmt><expr><name>evfd</name> <operator>=</operator> <call><name>eventfd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name>evfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>evfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* doing it twice doesn't hurt */</comment>
                <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>evfd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>
                <while>while <condition>(<expr><call><name>pipe</name> <argument_list>(<argument><expr><name>evpipe</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ev_syserr</name> <argument_list>(<argument><expr><literal type="string">"(libev) error creating signal/async pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

                <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fcntl</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name> <operator>|</operator> <name>O_NOATIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fcntl</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>O_NONBLOCK</name> <operator>|</operator> <name>O_NOATIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>pipe_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* watcher should not keep loop alive */</comment>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>evpipe_write</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>EV_ATOMIC_T</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>flag</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name>                     <name>ret</name></type> <name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>unused</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>                     <name>old_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt> <comment type="block">/* save errno because write might clobber it */</comment>
            <decl_stmt><decl><type><name>char</name></type>                    <name>dummy</name> <init>= <expr><literal type="char">'c'</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>*</operator><name>flag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><name>evfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>uint64_t</name></type>                <name>counter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write</name> <argument_list>(<argument><expr><name>evfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>counter</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* win32 people keep sending patches that change this write() to send() */</comment>
                <comment type="block">/* and then run away. but send() is wrong, it wants a socket handle on win32 */</comment>
                <comment type="block">/* so when you think this write should be a send instead, please find out */</comment>
                <comment type="block">/* where your send() is from - it's definitely not the microsoft send, and */</comment>
                <comment type="block">/* tell me. thank you. */</comment>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>old_errno</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block">/* called whenever the libev signal pipe */</comment>
    <comment type="block">/* got some events (signal, async) */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>pipecb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>iow</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>evfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>uint64_t</name></type>                <name>counter</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>counter</name> <operator>=</operator> <call><name>read</name> <argument_list>(<argument><expr><name>evfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>counter</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>                    <name>dummy</name></decl>;</decl_stmt>
            <comment type="block">/* see discussion in evpipe_write when you think this read should be recv in win32 */</comment>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>read</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>sig_pending</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sig_pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>EV_NSIG</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name><name>signals</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pending</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <macro><name>ev_feed_signal_event</name> <argument_list>(<argument>EV_A_ i + <literal type="number">1</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>async_pending</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>async_pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_mb</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>asynccnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>asyncs</name> <index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sent</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>asyncs</name> <index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ asyncs [i]</argument>, <argument>EV_ASYNC</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                </block_content>}</block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">///*****************************************************************************/</comment>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>ev_sighandler</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
        <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>signals</name> <index>[<expr><name>signum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>ev_sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name><name>signals</name> <index>[<expr><name>signum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pending</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>evpipe_write</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>sig_pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_feed_signal_event</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WL</name></type>                      <name>w</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>signum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>signum</name> <operator>&gt;</operator> <name>EV_NSIG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>--</operator><name>signum</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
        <comment type="block">/* it is permissible to try to feed a signal to the wrong loop */</comment>
        <comment type="block">/* or, likely more useful, feeding a signal nobody is waiting for */</comment>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name><name>signals</name> <index>[<expr><name>signum</name></expr>]</index></name><operator>.</operator><name>loop</name> <operator>!=</operator> <name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name><name>signals</name> <index>[<expr><name>signum</name></expr>]</index></name><operator>.</operator><name>pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <name><name>signals</name> <index>[<expr><name>signum</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>sigfdcb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>iow</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>signalfd_siginfo</name></name></type> <name><name>si</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sip</name></decl>;</decl_stmt> <comment type="block">/* these structs are big */</comment>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>ssize_t</name></type>                 <name>res</name> <init>= <expr><call><name>read</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>, <argument><expr><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* not ISO-C, as res might be -1, but works with SuS */</comment>
            <for>for <control>(<init><expr><name>sip</name> <operator>=</operator> <name>si</name></expr>;</init> <condition><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>sip</name> <operator>&lt;</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>si</name> <operator>+</operator> <name>res</name></expr>;</condition> <incr><expr><operator>++</operator><name>sip</name></expr></incr>)</control><block type="pseudo"><block_content>
                <macro><name>ev_feed_signal_event</name> <argument_list>(<argument>EV_A_ sip-&gt;ssi_signo</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for>

            <if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><sizeof>sizeof <argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
    <decl_stmt><decl><type><specifier>static</specifier> <name>WL</name></type>               <name><name>childs</name> <index>[<expr><name>EV_PID_HASHSIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>ev_signal</name></type>        <name>childev</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIFCONTINUED</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WIFCONTINUED</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* handle a single child status event */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>child_reap</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>chain</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_child</name>                <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>traced</name> <init>= <expr><call><name>WIFSTOPPED</name> <argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>WIFCONTINUED</name> <argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_child</name> <operator>*</operator><operator>)</operator><name><name>childs</name> <index>[<expr><name>chain</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>ev_child</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr></incr>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name> <operator>||</operator> <operator>!</operator><name><name>w</name><operator>-&gt;</operator><name>pid</name></name><operator>)</operator>
                    <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>traced</name> <operator>||</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* need to do it *now*, this *must* be the same prio as the signal watcher itself */</comment>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>rpid</name></name>    <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>rstatus</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WCONTINUED</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WCONTINUED</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* called on sigchld etc., calls waitpid */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>childcb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_signal</name> <modifier>*</modifier></type><name>sw</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>pid</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>

        <comment type="block">/* some systems define WCONTINUED but then fail to support it (linux 2.4) */</comment>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&gt;=</operator> <operator>(</operator><name>pid</name> <operator>=</operator> <call><name>waitpid</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>WNOHANG</name> <operator>|</operator> <name>WUNTRACED</name> <operator>|</operator> <name>WCONTINUED</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>WCONTINUED</name>
                    <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>EINVAL</name>
                    <operator>||</operator> <literal type="number">0</literal> <operator>&gt;=</operator> <operator>(</operator><name>pid</name> <operator>=</operator> <call><name>waitpid</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>WNOHANG</name> <operator>|</operator> <name>WUNTRACED</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* make sure we are called again until all children have been reaped */</comment>
        <comment type="block">/* we need to do it this way so that the callback gets called before we continue */</comment>
        <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>sw</name></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>child_reap</name> <argument_list>(<argument>EV_A_ pid</argument>, <argument>pid</argument>, <argument>status</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>child_reap</name> <argument_list>(<argument><expr><name>EV_A_</name> <literal type="number">0</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* this might trigger a watcher twice, but feed_event catches that */</comment>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_epoll.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SELECT</name></expr></cpp:if>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>"ev_select.c"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>int</name></type>
    <name>ev_version_major</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>EV_VERSION_MAJOR</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>int</name></type>
    <name>ev_version_minor</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>EV_VERSION_MINOR</name></expr>;</return>
    </block_content>}</block></function>

    <comment type="line" format="doxygen">///* return true if we are running with elevated privileges and should ignore env variables */</comment>

    <function><type><name>int</name> <name>inline_size</name></type>
    <name>enable_secure</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>getuid</name> <argument_list>()</argument_list></call> <operator>!=</operator> <call><name>geteuid</name> <argument_list>()</argument_list></call>
               <operator>||</operator> <call><name>getgid</name> <argument_list>()</argument_list></call> <operator>!=</operator> <call><name>getegid</name> <argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_supported_backends</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>            <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>EV_USE_PORT</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_PORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>EV_USE_KQUEUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_KQUEUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>EV_USE_EPOLL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_EPOLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>EV_USE_POLL</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_POLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>EV_USE_SELECT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EVBACKEND_SELECT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>flags</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_recommended_backends</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>            <name>flags</name> <init>= <expr><call><name>ev_supported_backends</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__NetBSD__</name></cpp:ifndef>
        <comment type="block">/* kqueue is borked on everything but netbsd apparently */</comment>
        <comment type="block">/* it usually doesn't work correctly on anything but sockets and pipes */</comment>
        <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_KQUEUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__APPLE__</name></cpp:ifdef>
        <comment type="block">/* only select works correctly on that "unix-certified" platform */</comment>
        <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_KQUEUE</name></expr>;</expr_stmt> <comment type="block">/* horribly broken, even for sockets */</comment>
        <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_POLL</name></expr>;</expr_stmt>   <comment type="block">/* poll is based on kqueue from 10.5 onwards */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FreeBSD__</name></cpp:ifdef>
        <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_POLL</name></expr>;</expr_stmt>   <comment type="block">/* poll return value is unusable (http://forums.freebsd.org/archive/index.php/t-10270.html) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <return>return <expr><name>flags</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_embeddable_backends</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>flags</name> <init>= <expr><name>EVBACKEND_EPOLL</name> <operator>|</operator> <name>EVBACKEND_KQUEUE</name> <operator>|</operator> <name>EVBACKEND_PORT</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* epoll embeddability broken on all linux versions up to at least 2.6.23 */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ev_linux_version</name> <argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0x020620</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* disable it on linux &lt; 2.6.32 */</comment>
            <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EVBACKEND_EPOLL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return <expr><name>flags</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_backend</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>backend</name></expr>;</return>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_iteration</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>loop_count</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_depth</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>loop_depth</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_set_io_collect_interval</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>interval</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>io_blocktime</name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_set_timeout_collect_interval</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>interval</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>timeout_blocktime</name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_set_userdata</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>userdata</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <modifier>*</modifier></type>
    <name>ev_userdata</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><name>userdata</name></expr>;</return>
    </block_content>}</block></function>

    <decl_stmt><decl><type><name>void</name></type> <name>ev_set_invoke_pending_cb</name> <argument_list>(<argument><expr><name>EV_P_</name> <call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>invoke_pending_cb</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>EV_P</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
    <block>{<block_content>
        <expr_stmt><expr><name>invoke_cb</name> <operator>=</operator> <name>invoke_pending_cb</name></expr>;</expr_stmt>
    </block_content>}</block></decl></decl_stmt>

    <decl_stmt><decl><type><name>void</name></type> <name>ev_set_loop_release_cb</name> <argument_list>(<argument><expr><name>EV_P_</name> <call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>release</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>EV_P</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>acquire</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>EV_P</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
    <block>{<block_content>
        <expr_stmt><expr><name>release_cb</name> <operator>=</operator> <name>release</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>acquire_cb</name> <operator>=</operator> <name>acquire</name></expr>;</expr_stmt>
    </block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* initialise a loop structure, must be zero-initialised */</comment>
    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>loop_init</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_REALTIME</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_realtime</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type>         <name>ts</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>have_realtime</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_monotonic</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type>         <name>ts</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>clock_gettime</name> <argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>have_monotonic</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* pid check not overridable via env */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>

            <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_FORKCHECK</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>curpid</name> <operator>=</operator> <call><name>getpid</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_NOENV</name><operator>)</operator>
                    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>enable_secure</name> <argument_list>()</argument_list></call>
                    <operator>&amp;&amp;</operator> <call><name>getenv</name> <argument_list>(<argument><expr><literal type="string">"LIBEV_FLAGS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><call><name>getenv</name> <argument_list>(<argument><expr><literal type="string">"LIBEV_FLAGS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>ev_rt_now</name>         <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>mn_now</name>            <operator>=</operator> <call><name>get_clock</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>now_floor</name>         <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rtmn_diff</name>         <operator>=</operator> <name>ev_rt_now</name> <operator>-</operator> <name>mn_now</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
            <expr_stmt><expr><name>invoke_cb</name>         <operator>=</operator> <name>ev_invoke_pending</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>io_blocktime</name>      <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>timeout_blocktime</name> <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>backend</name>           <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>backend_fd</name>        <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>sig_pending</name>       <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><name>async_pending</name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
            <expr_stmt><expr><name>fs_fd</name>             <operator>=</operator> <ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_NOINOTIFY</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
            <expr_stmt><expr><name>sigfd</name>             <operator>=</operator> <ternary><condition><expr><name>flags</name> <operator>&amp;</operator> <name>EVFLAG_SIGNALFD</name></expr>  ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">0x0000ffffU</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>flags</name> <operator>|=</operator> <call><name>ev_recommended_backends</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_EPOLL</name> <operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>epoll_init</name>  <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SELECT</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>backend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVBACKEND_SELECT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>backend</name> <operator>=</operator> <macro><name>select_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name>ev_prepare_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pending_w</name></expr></argument>, <argument><expr><name>pendingcb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name> <operator>||</operator> <name>EV_ASYNC_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ev_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>pipecb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block">/* free up a loop structure */</comment>
    <function><type><name>void</name></type>
    <name>ev_loop_destroy</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>

        <comment type="block">/* mimic free (0) */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>EV_A</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>

        <comment type="block">/* queue cleanup watchers (and execute them) */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>cleanups</name></expr></argument>, <argument><expr><name>cleanupcnt</name></expr></argument>, <argument><expr><name>EV_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>childev</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* child watcher */</comment>
            <expr_stmt><expr><call><name>ev_signal_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>childev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/*ev_ref (EV_A);*/</comment>
            <comment type="block">/*ev_io_stop (EV_A_ &amp;pipe_w);*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>evfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>evfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name>backend_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>backend_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_EPOLL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>epoll_destroy</name>  <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SELECT</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_SELECT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>select_destroy</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>pending</name></expr></argument>, <argument><expr><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>idle</name></expr></argument>, <argument><expr><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>anfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>anfds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>anfdmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* have to use the microsoft-never-gets-it-right macro */</comment>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>rfeed</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>fdchange</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>timer</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>periodic</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>fork</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>cleanup</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>prepare</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>check</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>array_free</name> <argument_list>(<argument><expr><name>async</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>backend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_default_loop</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>easy_default_loop_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
    <function_decl><type><name>inline_size</name> <name>void</name></type> <name>infy_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>loop_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_PORT</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_PORT</name></expr>  )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>port_fork</name>   <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_KQUEUE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_KQUEUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>kqueue_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EPOLL</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>backend</name> <operator>==</operator> <name>EVBACKEND_EPOLL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>epoll_fork</name>  <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
        <expr_stmt><expr><call><name>infy_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* this "locks" the handlers against writing to the pipe */</comment>
            <comment type="block">/* while we modify the fd vars */</comment>
            <expr_stmt><expr><name>sig_pending</name>   <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><name>async_pending</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>pipe_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_EVENTFD</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><name>evfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>evfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EV_WIN32_CLOSE_FD</name> <argument_list>(<argument><expr><name><name>evpipe</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name> <operator>||</operator> <name>EV_ASYNC_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* now iterate over everything, in case we missed something */</comment>
            <expr_stmt><expr><call><name>pipecb</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>pipe_w</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>postfork</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>

    <function><type><name><name>struct</name> <name>ev_loop</name></name> <modifier>*</modifier></type>
    <name>ev_loop_new</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <operator>(</operator>struct <name>ev_loop</name> <operator>*</operator><operator>)</operator><call><name>ev_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ev_loop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ev_loop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>loop_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ev_backend</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EV_A</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* multiplicity */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name></expr></cpp:if>
    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>verify_watcher</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: watcher has invalid priority"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NUMPRI</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: pending watcher not on pending queue"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pendings</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>w</name> <operator>==</operator> <name>w</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>verify_heap</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ANHE</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name> <operator>+</operator> <name>HEAP0</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: active index mismatch in heap"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ev_active</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: heap condition violated"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>==</operator> <name>HEAP0</name> <operator>||</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><call><name>HPARENT</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: heap at cache mismatch"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ev_at</name> <argument_list>(<argument><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>verify_watcher</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>heap</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>array_verify</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name> <modifier>*</modifier></type><name>ws</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <while>while <condition>(<expr><name>cnt</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: active index mismatch"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>ws</name> <index>[<expr><name>cnt</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cnt</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>verify_watcher</name> <argument_list>(<argument>EV_A_ ws [cnt]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_verify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name></expr></cpp:if>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WL</name></type>                      <name>w</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>activecnt</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>fdchangemax</name> <operator>&gt;=</operator> <name>fdchangecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fdchangecnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: negative fd in fdchanges"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>fdchanges</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>anfdmax</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>w</name> <operator>=</operator> <name><name>anfds</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>w</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>verify_watcher</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: inactive fd watcher on anfd list"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: fd mismatch between watcher and anfd"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>fd</name> <operator>==</operator> <name>i</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></for>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>timermax</name> <operator>&gt;=</operator> <name>timercnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>verify_heap</name> <argument_list>(<argument>EV_A_ timers</argument>, <argument>timercnt</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>periodicmax</name> <operator>&gt;=</operator> <name>periodiccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>verify_heap</name> <argument_list>(<argument>EV_A_ periodics</argument>, <argument>periodiccnt</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>pendingmax</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>pendingcnt</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>idleall</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name><name>idlemax</name> <index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>idlecnt</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name><name>idles</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>idlecnt</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>forkmax</name> <operator>&gt;=</operator> <name>forkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>forks</name></expr></argument>, <argument><expr><name>forkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>cleanupmax</name> <operator>&gt;=</operator> <name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>cleanups</name></expr></argument>, <argument><expr><name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>asyncmax</name> <operator>&gt;=</operator> <name>asynccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>asyncs</name></expr></argument>, <argument><expr><name>asynccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>preparemax</name> <operator>&gt;=</operator> <name>preparecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>prepares</name></expr></argument>, <argument><expr><name>preparecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>checkmax</name> <operator>&gt;=</operator> <name>checkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_verify</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>checks</name></expr></argument>, <argument><expr><name>checkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if># <cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>

        for (w = (ev_child *)childs [chain &amp; ((EV_PID_HASHSIZE) - 1)]; w; w = (ev_child *)((WL)w)-&gt;next)
            for (signum = EV_NSIG; signum--; ) if (signals [signum].pending)
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
    <function><type><name><name>struct</name> <name>ev_loop</name></name> <modifier>*</modifier>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <name>int</name></type>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <name>ev_default_loop</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>easy_default_loop_ptr</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
            <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name>easy_default_loop_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>default_loop_struct</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>easy_default_loop_ptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <macro><name>loop_init</name> <argument_list>(<argument>EV_A_ flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ev_backend</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>
                <expr_stmt><expr><call><name>ev_signal_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>childev</name></expr></argument>, <argument><expr><name>childcb</name></expr></argument>, <argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>childev</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_signal_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>childev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* child watcher should not keep loop alive */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>easy_default_loop_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>easy_default_loop_ptr</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_loop_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>postfork</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* must be in line with ev_default_fork */</comment>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <function><type><name>void</name></type>
    <name>ev_invoke</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>EV_CB_INVOKE</name> <argument_list>(<argument><expr><operator>(</operator><name>W</name><operator>)</operator><name>w</name></expr></argument>, <argument><expr><name>revents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>unsigned</name> <name>int</name></type>
    <name>ev_pending_count</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>pri</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>            <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>pri</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>pri</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

        <return>return <expr><name>count</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_invoke_pending</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>pri</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>pri</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>pri</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
            <while>while <condition>(<expr><name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>ANPENDING</name>               <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pendings</name> <index>[<expr><name>pri</name></expr>]</index></name> <operator>+</operator> <operator>--</operator><name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*assert (("libev: non-pending watcher on pending list", p-&gt;w-&gt;pending));*/</comment>
                <comment type="block">/* ^ this is no longer true, as pending_w could be here */</comment>

                <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>EV_CB_INVOKE</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
            </block_content>}</block></while></block_content></block></for>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
    <comment type="block">/* make idle watchers pending. this handles the "call-idle */</comment>
    <comment type="block">/* only when higher priorities are idle" logic */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>idle_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>idleall</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>pri</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>pri</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>pri</name><operator>--</operator></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>pendingcnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>idlecnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name><name>idles</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>idlecnt</name> <index>[<expr><name>pri</name></expr>]</index></name></expr></argument>, <argument><expr><name>EV_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* make timers pending */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>timers_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>timercnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>mn_now</name></expr>)</condition> <block>{<block_content>
            <do>do <block>{<block_content>
                <decl_stmt><decl><type><name>ev_timer</name>                <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_timer</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/*assert (("libev: inactive timer on timer heap detected", ev_is_active (w)));*/</comment>

                <comment type="block">/* first reschedule or stop timer */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>mn_now</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: negative ev_timer repeat value found while processing timers"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name> <operator>&gt;</operator> <literal type="number">0.</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timercnt</name></expr></argument>, <argument><expr><name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                    <macro><name>ev_timer_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt> <comment type="block">/* nonrepeating: stop timer */</comment>

                <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>feed_reverse</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>timercnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>mn_now</name></expr>)</condition>;</do>

            <macro><name>feed_reverse_done</name> <argument_list>(<argument>EV_A_ EV_TIMER</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
    <comment type="block">/* make periodics pending */</comment>
    <function><type><name>inline_size</name> <name>void</name></type>
    <name>periodics_reify</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>periodiccnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ev_rt_now</name></expr>)</condition> <block>{<block_content>
            <do>do <block>{<block_content>
                <decl_stmt><decl><type><name>ev_periodic</name>             <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_periodic</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/*assert (("libev: inactive timer on periodic heap detected", ev_is_active (w)));*/</comment>

                <comment type="block">/* first reschedule or stop timer */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_rt_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_periodic reschedule callback returned time in the past"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>ev_rt_now</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>, <argument><expr><name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <call><name>ceil</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_rt_now</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator> <operator>/</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>;</expr_stmt>

                    <comment type="block">/* if next trigger time is not sufficiently in the future, put it there */</comment>
                    <comment type="block">/* this might happen because of floating point inexactness */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ev_rt_now</name> <operator>&lt;</operator> <name>TIME_EPSILON</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>;</expr_stmt>

                        <comment type="block">/* if interval is unreasonably low we might still have a time in the past */</comment>
                        <comment type="block">/* so correct this. this will make the periodic very inexact, but the user */</comment>
                        <comment type="block">/* has effectively asked to get triggered more often than possible */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ev_rt_now</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ev_rt_now</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>downheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>, <argument><expr><name>HEAP0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                    <macro><name>ev_periodic_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt> <comment type="block">/* nonrepeating: stop timer */</comment>

                <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>feed_reverse</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>periodiccnt</name> <operator>&amp;&amp;</operator> <call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ev_rt_now</name></expr>)</condition>;</do>

            <macro><name>feed_reverse_done</name> <argument_list>(<argument>EV_A_ EV_PERIODIC</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block">/* simply recalculate all periodics */</comment>
    <comment type="block">/* TODO: maybe ensure that at least one event happens when jumping forward? */</comment>
    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>periodics_reschedule</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* adjust periodics after time jump */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>ev_periodic</name>             <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_periodic</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_rt_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <call><name>ceil</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_rt_now</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator> <operator>/</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>reheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* adjust all timers by a given offset */</comment>
    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>timers_reschedule</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>adjust</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timercnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>ANHE</name>                    <modifier>*</modifier></type><name>he</name> <init>= <expr><name>timers</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>HEAP0</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><operator>*</operator><name>he</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>at</name> <operator>+=</operator> <name>adjust</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><operator>*</operator><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <comment type="block">/* fetch new monotonic and realtime times from the kernel */</comment>
    <comment type="block">/* also detect if there was a timejump, and act accordingly */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>time_update</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_tstamp</name></type> <name>max_block</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_MONOTONIC</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>have_monotonic</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>odiff</name> <init>= <expr><name>rtmn_diff</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>mn_now</name> <operator>=</operator> <call><name>get_clock</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* only fetch the realtime clock every 0.5*MIN_TIMEJUMP seconds */</comment>
            <comment type="block">/* interpolate in the meantime */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>mn_now</name> <operator>-</operator> <name>now_floor</name> <operator>&lt;</operator> <name>MIN_TIMEJUMP</name> <operator>*</operator> <literal type="number">.5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <name>rtmn_diff</name> <operator>+</operator> <name>mn_now</name></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>now_floor</name> <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* loop a few times, before making important decisions.
             * on the choice of "4": one iteration isn't enough,
             * in case we get preempted during the calls to
             * ev_time and get_clock. a second call is almost guaranteed
             * to succeed in that case, though. and looping a few more times
             * doesn't hurt either as we only do this on time-jumps or
             * in the unlikely event of having been preempted here.
             */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">4</literal></expr>;</init> <condition><expr><operator>--</operator><name>i</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <expr_stmt><expr><name>rtmn_diff</name> <operator>=</operator> <name>ev_rt_now</name> <operator>-</operator> <name>mn_now</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><call><name>fabs</name> <argument_list>(<argument><expr><name>odiff</name> <operator>-</operator> <name>rtmn_diff</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MIN_TIMEJUMP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* all is well */</comment>

                <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>mn_now</name>    <operator>=</operator> <call><name>get_clock</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>now_floor</name> <operator>=</operator> <name>mn_now</name></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/* no timer adjustment, as the monotonic clock doesn't jump */</comment>
            <comment type="block">/* timers_reschedule (EV_A_ rtmn_diff - odiff) */</comment>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><call><name>periodics_reschedule</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <expr_stmt><expr><name>ev_rt_now</name> <operator>=</operator> <call><name>ev_time</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>mn_now</name> <operator>&gt;</operator> <name>ev_rt_now</name> <operator>||</operator> <name>ev_rt_now</name> <operator>&gt;</operator> <name>mn_now</name> <operator>+</operator> <name>max_block</name> <operator>+</operator> <name>MIN_TIMEJUMP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="block">/* adjust timers. this is easy, as the offset is the same for all of them */</comment>
                <macro><name>timers_reschedule</name> <argument_list>(<argument>EV_A_ ev_rt_now - mn_now</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
                <expr_stmt><expr><call><name>periodics_reschedule</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>mn_now</name> <operator>=</operator> <name>ev_rt_now</name></expr>;</expr_stmt>
            <comment type="line">//__asm__ __volatile__("mfence" : : : "memory");</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_run</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
        <expr_stmt><expr><operator>++</operator><name>loop_depth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_loop recursion during release detected"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>loop_done</name> <operator>!=</operator> <name>EVBREAK_RECURSE</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>loop_done</name> <operator>=</operator> <name>EVBREAK_CANCEL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt> <comment type="block">/* in case we recurse, ensure ordering stays nice and clean */</comment>

        <do>do <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_VERIFY</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>
            <expr_stmt><expr><call><name>ev_verify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>

            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>curpid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* penalise the forking check even more */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>getpid</name> <argument_list>()</argument_list></call> <operator>!=</operator> <name>curpid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>curpid</name> <operator>=</operator> <call><name>getpid</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>postfork</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>

            <comment type="block">/* we might have forked, so queue fork handlers */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>postfork</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name>forkcnt</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>forks</name></expr></argument>, <argument><expr><name>forkcnt</name></expr></argument>, <argument><expr><name>EV_FORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>

            <comment type="block">/* queue prepare watchers (and execute them) */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>preparecnt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>prepares</name></expr></argument>, <argument><expr><name>preparecnt</name></expr></argument>, <argument><expr><name>EV_PREPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>loop_done</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* we might have forked, so reify kernel state if necessary */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>postfork</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>loop_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* update fd-related kernel structures */</comment>
            <expr_stmt><expr><call><name>fd_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* calculate blocking time */</comment>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>waittime</name>  <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>sleeptime</name> <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>

                <comment type="block">/* remember old timestamp for io_blocktime calculation */</comment>
                <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>prev_mn_now</name> <init>= <expr><name>mn_now</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* update time to cancel out callback processing overhead */</comment>
                <expr_stmt><expr><call><name>time_update</name> <argument_list>(<argument><expr><name>EV_A_</name> <literal type="number">1e100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EVRUN_NOWAIT</name> <operator>||</operator> <name>idleall</name> <operator>||</operator> <operator>!</operator><name>activecnt</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>MAX_BLOCKTIME</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>timercnt</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>to</name> <init>= <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>mn_now</name> <operator>+</operator> <name>backend_fudge</name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>waittime</name> <operator>&gt;</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>

                    <if_stmt><if>if <condition>(<expr><name>periodiccnt</name></expr>)</condition> <block>{<block_content>
                        <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>to</name> <init>= <expr><call><name>ANHE_at</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>HEAP0</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>ev_rt_now</name> <operator>+</operator> <name>backend_fudge</name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name>waittime</name> <operator>&gt;</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <comment type="block">/* don't let timeouts decrease the waittime below timeout_blocktime */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>waittime</name> <operator>&lt;</operator> <name>timeout_blocktime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>waittime</name> <operator>=</operator> <name>timeout_blocktime</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* extra check because io_blocktime is commonly 0 */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>io_blocktime</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <name>io_blocktime</name> <operator>-</operator> <operator>(</operator><name>mn_now</name> <operator>-</operator> <name>prev_mn_now</name><operator>)</operator></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>sleeptime</name> <operator>&gt;</operator> <name>waittime</name> <operator>-</operator> <name>backend_fudge</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <name>waittime</name> <operator>-</operator> <name>backend_fudge</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>sleeptime</name> <operator>&gt;</operator> <literal type="number">0.</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                            <expr_stmt><expr><call><name>ev_sleep</name> <argument_list>(<argument><expr><name>sleeptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>waittime</name> <operator>-=</operator> <name>sleeptime</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
                <expr_stmt><expr><operator>++</operator><name>loop_count</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><name>loop_done</name> <operator>=</operator> <name>EVBREAK_RECURSE</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assert for side effect */</comment>
                <macro><name>backend_poll</name> <argument_list>(<argument>EV_A_ waittime</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><name>loop_done</name> <operator>=</operator> <name>EVBREAK_CANCEL</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assert for side effect */</comment>

                <comment type="block">/* update ev_rt_now, do magic */</comment>
                <macro><name>time_update</name> <argument_list>(<argument>EV_A_ waittime + sleeptime</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block>

            <comment type="block">/* queue pending timers and reschedule them */</comment>
            <expr_stmt><expr><call><name>timers_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* relative timers called last */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
            <expr_stmt><expr><call><name>periodics_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* absolute timers called first */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
            <comment type="block">/* queue idle watchers unless other events are pending */</comment>
            <expr_stmt><expr><call><name>idle_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>

            <comment type="block">/* queue check watchers, to be executed first */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><name>checkcnt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>queue_events</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W *</argument>)</argument_list></macro><name>checks</name></expr></argument>, <argument><expr><name>checkcnt</name></expr></argument>, <argument><expr><name>EV_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>EV_INVOKE_PENDING</name></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><call><name>expect_true</name> <argument_list>(
                     <argument><expr><name>activecnt</name>
                     <operator>&amp;&amp;</operator> <operator>!</operator><name>loop_done</name>
                     <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EVRUN_ONCE</name> <operator>|</operator> <name>EVRUN_NOWAIT</name><operator>)</operator><operator>)</operator></expr></argument>
                 )</argument_list></call></expr>)</condition>;</do>

        <if_stmt><if>if <condition>(<expr><name>loop_done</name> <operator>==</operator> <name>EVBREAK_ONE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>loop_done</name> <operator>=</operator> <name>EVBREAK_CANCEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FEATURE_API</name></expr></cpp:if>
        <expr_stmt><expr><operator>--</operator><name>loop_depth</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_break</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>how</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>loop_done</name> <operator>=</operator> <name>how</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_ref</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>activecnt</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_unref</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><operator>--</operator><name>activecnt</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_now_update</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>time_update</name> <argument_list>(<argument><expr><name>EV_A_</name> <literal type="number">1e100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_suspend</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ev_now_update</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_resume</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_tstamp</name></type>               <name>mn_prev</name> <init>= <expr><name>mn_now</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ev_now_update</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>timers_reschedule</name> <argument_list>(<argument>EV_A_ mn_now - mn_prev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
        <comment type="block">/* TODO: really do this? */</comment>
        <expr_stmt><expr><call><name>periodics_reschedule</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>
    <comment type="block">/* singly-linked list management, used when the expected list length is short */</comment>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>wlist_add</name> <parameter_list>(<parameter><decl><type><name>WL</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>WL</name></type> <name>elem</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>head</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>head</name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>wlist_del</name> <parameter_list>(<parameter><decl><type><name>WL</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>WL</name></type> <name>elem</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <while>while <condition>(<expr><operator>*</operator><name>head</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><operator>*</operator><name>head</name> <operator>==</operator> <name>elem</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>head</name> <operator>=</operator> <name><name>elem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>head</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>head</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></function>

    <comment type="block">/* internal, faster, version of ev_clear_pending */</comment>
    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>clear_pending</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>pendings</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>w</name> <operator>=</operator> <operator>(</operator><name>W</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pending_w</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>int</name></type>
    <name>ev_clear_pending</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>W</name></type>                       <name>w_</name> <init>= <expr><operator>(</operator><name>W</name><operator>)</operator><name>w</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>pending</name> <init>= <expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ANPENDING</name>               <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pendings</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w_</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>+</operator> <name>pending</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <operator>(</operator><name>W</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pending_w</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>w_</name><operator>-&gt;</operator><name>pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>events</name></name></expr>;</return>
        </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>pri_adjust</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>pri</name> <init>= <expr><call><name>ev_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pri</name> <operator>=</operator> <ternary><condition><expr><name>pri</name> <operator>&lt;</operator> <name>EV_MINPRI</name></expr> ?</condition><then> <expr><name>EV_MINPRI</name></expr> </then><else>: <expr><name>pri</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>pri</name> <operator>=</operator> <ternary><condition><expr><name>pri</name> <operator>&gt;</operator> <name>EV_MAXPRI</name></expr> ?</condition><then> <expr><name>EV_MAXPRI</name></expr> </then><else>: <expr><name>pri</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>pri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_speed</name> <name>void</name></type>
    <name>ev_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>active</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <macro><name>pri_adjust</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>ev_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>W</name></type> <name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_io_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>fd</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_start called with negative fd"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_start called with illegal event mask"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>EV__IOFDSET</name> <operator>|</operator> <name>EV_READ</name> <operator>|</operator> <name>EV_WRITE</name> <operator>|</operator> <name>EV_CLEANUP</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANFD</name></expr></argument>, <argument><expr><name>anfds</name></expr></argument>, <argument><expr><name>anfdmax</name></expr></argument>, <argument><expr><name>fd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>array_init_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>anfds</name><index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>fd_change</name> <argument_list>(<argument>EV_A_ fd</argument>, <argument>((w-&gt;events &amp; EV__IOFDSET) | EV_ANFD_REIFY)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>EV_CLEANUP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>anfds</name> <index>[<expr><name>fd</name></expr>]</index></name><operator>.</operator><name>cdel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EV__IOFDSET</name> <operator>|</operator> <name>EV_CLEANUP</name><operator>)</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_io_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_stop called with illegal fd (must stay constant after start!)"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <name>anfdmax</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>fd_change</name> <argument_list>(<argument>EV_A_ w-&gt;fd</argument>, <argument>EV_ANFD_REIFY</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_io_stop_ctrl</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_io_stop called with illegal fd (must stay constant after start!)"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>fd</name></name> <operator>&lt;</operator> <name>anfdmax</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>old</name> <init>= <expr><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>cdel</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>cdel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <macro><name>backend_modify</name> <argument_list>(<argument>EV_A_ w-&gt;fd</argument>, <argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        <expr_stmt><expr><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>cdel</name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>anfds</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>fd</name></name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_timer_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+=</operator> <name>mn_now</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_timer_start called with negative timer repeat value"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name> <operator>&gt;=</operator> <literal type="number">0.</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>++</operator><name>timercnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>timercnt</name> <operator>+</operator> <name>HEAP0</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANHE</name></expr></argument>, <argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timermax</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <comment type="block">/*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/</comment>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_timer_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: internal timer heap corruption"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>active</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>--</operator><name>timercnt</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>active</name> <operator>&lt;</operator> <name>timercnt</name> <operator>+</operator> <name>HEAP0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>timers</name> <index>[<expr><name>active</name></expr>]</index></name> <operator>=</operator> <name><name>timers</name> <index>[<expr><name>timercnt</name> <operator>+</operator> <name>HEAP0</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>adjustheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timercnt</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-=</operator> <name>mn_now</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_timer_again</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>mn_now</name> <operator>+</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>adjustheap</name> <argument_list>(<argument><expr><name>timers</name></expr></argument>, <argument><expr><name>timercnt</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
                <macro><name>ev_timer_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>repeat</name></name></expr>;</expr_stmt>
            <macro><name>ev_timer_start</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>ev_tstamp</name></type>
    <name>ev_timer_remaining</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <return>return <expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><ternary><condition><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>mn_now</name></expr> </then><else>: <expr><literal type="number">0.</literal></expr></else></ternary><operator>)</operator></expr>;</return>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_periodic_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name><name>w</name><operator>-&gt;</operator><name>reschedule_cb</name></name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>ev_rt_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_periodic_start called with negative interval value"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>&gt;=</operator> <literal type="number">0.</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* this formula differs from the one in periodic_reify because we do not always round up */</comment>
            <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <call><name>ceil</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_rt_now</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator> <operator>/</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_at</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>++</operator><name>periodiccnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ANHE</name></expr></argument>, <argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodicmax</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ANHE_at_cache</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>upheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <comment type="block">/*assert (("libev: internal periodic heap corruption", ANHE_w (periodics [ev_active (w)]) == (WT)w));*/</comment>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_periodic_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: internal periodic heap corruption"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>periodics</name> <index>[<expr><name>active</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>WT</name><operator>)</operator><name>w</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><operator>--</operator><name>periodiccnt</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>expect_true</name> <argument_list>(<argument><expr><name>active</name> <operator>&lt;</operator> <name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>periodics</name> <index>[<expr><name>active</name></expr>]</index></name> <operator>=</operator> <name><name>periodics</name> <index>[<expr><name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>adjustheap</name> <argument_list>(<argument><expr><name>periodics</name></expr></argument>, <argument><expr><name>periodiccnt</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_periodic_again</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_periodic</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="block">/* TODO: use adjustheap and recalculation */</comment>
        <macro><name>ev_periodic_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        <macro><name>ev_periodic_start</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SA_RESTART</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SA_RESTART</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name></expr></cpp:if>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_signal_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_signal</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: ev_signal_start called with illegal signal number"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>&lt;</operator> <name>EV_NSIG</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: a signal must not be attached to two different loops"</literal> <operator>&amp;&amp;</operator>
                 <operator>(</operator><operator>!</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>||</operator> <name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>==</operator> <name>loop</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>=</operator> <name>EV_A</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sigfd</name> <operator>=</operator> <call><name>signalfd</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><name>SFD_NONBLOCK</name> <operator>|</operator> <name>SFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>sigfd</name> <operator>=</operator> <call><name>signalfd</name> <argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* retry without flags */</comment>

            <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* doing it twice will not hurt */</comment>

                <expr_stmt><expr><call><name>sigemptyset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ev_io_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_w</name></expr></argument>, <argument><expr><name>sigfdcb</name></expr></argument>, <argument><expr><name>sigfd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>sigfd_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* signalfd watcher should not keep loop alive */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* TODO: check .head */</comment>
            <expr_stmt><expr><call><name>sigaddset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sigprocmask</name> <argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>signalfd</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>WL</name><operator>)</operator><name>w</name><operator>)</operator><operator>-&gt;</operator><name>next</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/*TODO*/</comment>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>
<cpp:ifdef># <cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
                <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>, <argument><expr><name>ev_sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
                <decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type>        <name>sa</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>ev_sighandler</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sigfillset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_RESTART</name></expr>;</expr_stmt> <comment type="block">/* if restarting works we save one iteration */</comment>
                <expr_stmt><expr><call><name>sigaction</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>sigemptyset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sigaddset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sigprocmask</name> <argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_signal_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_signal</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>head</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
            <expr_stmt><expr><name><name>signals</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* unattach from signal */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_SIGNALFD</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><name>sigfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>sigset_t</name></type>                <name>ss</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>sigemptyset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sigaddset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sigdelset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>signalfd</name> <argument_list>(<argument><expr><name>sigfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigfd_set</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sigprocmask</name> <argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>signum</name></name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>

    <function><type><name>void</name></type>
    <name>ev_child_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_child</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
        <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: child watchers are only supported in the default loop"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>loop</name> <operator>==</operator> <name>easy_default_loop_ptr</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>childs</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pid</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_child_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_child</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>childs</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>pid</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_STAT_ENABLE</name></expr></cpp:if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>lstat</name></cpp:undef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_stati64 (a,b)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_STAT_INTERVAL</name></cpp:macro>  <cpp:value>5.0074891</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NFS_STAT_INTERVAL</name></cpp:macro> <cpp:value>30.1074891</cpp:value></cpp:define> <comment type="block">/* for filesystems potentially failing inotify */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_STAT_INTERVAL</name></cpp:macro>  <cpp:value>0.1074891</cpp:value></cpp:define>

    <function_decl><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type> <name>stat_timer_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w_</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>

    <comment type="block">/* the * 2 is to allow for alignment padding, which for some reason is &gt;&gt; 8 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EV_INOTIFY_BUFSIZE</name></cpp:macro> <cpp:value>(sizeof (struct inotify_event) * 2 + NAME_MAX)</cpp:value></cpp:define>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>infy_add</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <call><name>inotify_add_watch</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>IN_ATTRIB</name> <operator>|</operator> <name>IN_DELETE_SELF</name> <operator>|</operator> <name>IN_MOVE_SELF</name> <operator>|</operator> <name>IN_MODIFY</name> <operator>|</operator> <name>IN_DONT_FOLLOW</name> <operator>|</operator> <name>IN_MASK_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>statfs</name></name></type>           <name>sfs</name></decl>;</decl_stmt>

            <comment type="block">/* now local changes will be tracked by inotify, but remote changes won't */</comment>
            <comment type="block">/* unless the filesystem is known to be local, we therefore still poll */</comment>
            <comment type="block">/* also do poll on &lt;2.6.25, but with normal frequency */</comment>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fs_2625</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>statfs</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sfs</name></expr></argument>)</argument_list></call>
                     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x1373</literal> <comment type="block">/* devfs */</comment>
                         <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0xEF53</literal> <comment type="block">/* ext2/3 */</comment>
                         <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x3153464a</literal> <comment type="block">/* jfs */</comment>
                         <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x52654973</literal> <comment type="block">/* reiser3 */</comment>
                         <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x01021994</literal> <comment type="block">/* tempfs */</comment>
                         <operator>||</operator> <name><name>sfs</name><operator>.</operator><name>f_type</name></name> <operator>==</operator> <literal type="number">0x58465342</literal> <comment type="block">/* xfs */</comment><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <literal type="number">0.</literal></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* filesystem is local, kernel new enough */</comment>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>NFS_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* remote, use reduced frequency */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* can't use inotify, continue to stat */</comment>
            <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt>

            <comment type="block">/* if path is not there, monitor some parent directory for speedup hints */</comment>
            <comment type="block">/* note that exceeding the hardcoded path limit is not a correctness issue, */</comment>
            <comment type="block">/* but an efficiency issue only */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type>                    <name><name>path</name> <index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <do>do <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>                     <name>mask</name> <init>= <expr><name>IN_MASK_ADD</name> <operator>|</operator> <name>IN_DELETE_SELF</name> <operator>|</operator> <name>IN_MOVE_SELF</name>
                                                   <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>errno</name> <operator>==</operator> <name>EACCES</name></expr> ?</condition><then> <expr><name>IN_ATTRIB</name></expr> </then><else>: <expr><name>IN_CREATE</name> <operator>|</operator> <name>IN_MOVED_TO</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier></type><name>pend</name> <init>= <expr><call><name>strrchr</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pend</name> <operator>||</operator> <name>pend</name> <operator>==</operator> <name>path</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>

                    <expr_stmt><expr><operator>*</operator><name>pend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <call><name>inotify_add_watch</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block> while <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr>)</condition>;</do>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>wlist_add</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs_hash</name> <index>[<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* now re-arm timer, if required */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_timer_again</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>infy_del</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>wd</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>wd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name>wd</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs_hash</name> <index>[<expr><name>slot</name></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remove this watcher, if others are watching it, they will rearm */</comment>
        <expr_stmt><expr><call><name>inotify_rm_watch</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>wd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>infy_wd</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>inotify_event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

            <comment type="block">/* overflow, need to check for all hash slots */</comment>
            <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>slot</name></expr></incr>)</control><block type="pseudo"><block_content>
                <macro><name>infy_wd</name> <argument_list>(<argument>EV_A_ slot</argument>, <argument>wd</argument>, <argument>ev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if>
        <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>WL</name></type>                      <name>w_</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>w_</name> <operator>=</operator> <name><name>fs_hash</name> <index>[<expr><name>slot</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>w_</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>ev_stat</name>                 <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_stat</name> <operator>*</operator><operator>)</operator><name>w_</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>w_</name> <operator>=</operator> <name><name>w_</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> <comment type="block">/* lets us remove this watcher and all before it */</comment>

                <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <name>wd</name> <operator>||</operator> <name>wd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>mask</name></name> <operator>&amp;</operator> <operator>(</operator><name>IN_IGNORED</name> <operator>|</operator> <name>IN_UNMOUNT</name> <operator>|</operator> <name>IN_DELETE_SELF</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>wlist_del</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs_hash</name> <index>[<expr><name>slot</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>]</index></name><operator>.</operator><name>head</name></expr></argument>, <argument><expr><operator>(</operator><name>WL</name><operator>)</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                        <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> <comment type="block">/* re-add, no matter what */</comment>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><call><name>stat_timer_cb</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>infy_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>                    <name><name>buf</name> <index>[<expr><name>EV_INOTIFY_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>ofs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                     <name>len</name> <init>= <expr><call><name>read</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>ofs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ofs</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>inotify_event</name></name>    <modifier>*</modifier></type><name>ev</name> <init>= <expr><operator>(</operator>struct <name>inotify_event</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>buf</name> <operator>+</operator> <name>ofs</name><operator>)</operator></expr></init></decl>;</decl_stmt>
            <macro><name>infy_wd</name> <argument_list>(<argument>EV_A_ ev-&gt;wd</argument>, <argument>ev-&gt;wd</argument>, <argument>ev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>inotify_event</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>ev</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>ev_check_2625</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <comment type="block">/* kernels &lt; 2.6.25 are borked
         * http://www.ussg.indiana.edu/hypermail/linux/kernel/0711.3/1208.html
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ev_linux_version</name> <argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0x020619</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>fs_2625</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>int</name></type>
    <name>infy_newfd</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>IN_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>IN_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <decl_stmt><decl><type><name>int</name></type>                     <name>fd</name> <init>= <expr><call><name>inotify_init1</name> <argument_list>(<argument><expr><name>IN_CLOEXEC</name> <operator>|</operator> <name>IN_NONBLOCK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>fd</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><call><name>inotify_init</name> <argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>infy_init</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>fs_fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_check_2625</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>fs_fd</name> <operator>=</operator> <call><name>infy_newfd</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>fs_w</name></expr></argument>, <argument><expr><name>infy_cb</name></expr></argument>, <argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>fs_w</name></expr></argument>, <argument><expr><name>EV_MAXPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>fs_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>inline_size</name> <name>void</name></type>
    <name>infy_fork</name> <parameter_list>(<parameter><decl><type><name>EV_P</name></type></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>slot</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_io_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>fs_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fs_fd</name> <operator>=</operator> <call><name>infy_newfd</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>fd_intern</name> <argument_list>(<argument><expr><name>fs_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>fs_w</name></expr></argument>, <argument><expr><name>fs_fd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>fs_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><expr><name>slot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slot</name> <operator>&lt;</operator> <operator>(</operator><name>EV_INOTIFY_HASHSIZE</name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>slot</name></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>WL</name></type>                      <name>w_</name> <init>= <expr><name><name>fs_hash</name> <index>[<expr><name>slot</name></expr>]</index></name><operator>.</operator><name>head</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>fs_hash</name> <index>[<expr><name>slot</name></expr>]</index></name><operator>.</operator><name>head</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <while>while <condition>(<expr><name>w_</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>ev_stat</name>                 <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_stat</name> <operator>*</operator><operator>)</operator><name>w_</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>w_</name> <operator>=</operator> <name><name>w_</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> <comment type="block">/* lets us add this watcher */</comment>

                <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if> <comment type="block">/* re-add, no matter what */</comment>
                <else>else <block>{<block_content>
                    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>timer</name><operator>.</operator><name>repeat</name></name> <operator>=</operator> <ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>ev_timer_again</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></for>
    </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_LSTAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_stati64 (p, b)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>EV_LSTAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lstat (p, b)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>void</name></type>
    <name>ev_stat_stat</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>lstat</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name> <name>noinline</name></type>
    <name>stat_timer_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w_</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_stat</name>                 <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_stat</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>w_</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_stat</name></expr></argument>, <argument><expr><name>timer</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>ev_statdata</name></type>             <name>prev</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>attr</name></name></expr></init></decl>;</decl_stmt>
        <macro><name>ev_stat_stat</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <comment type="block">/* memcmp doesn't work on netbsd, they.... do stuff to their struct stat */</comment>
        <if_stmt><if>if <condition>(
            <expr><name><name>prev</name><operator>.</operator><name>st_dev</name></name>      <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_dev</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_ino</name></name>   <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_ino</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_mode</name></name>  <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_mode</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_nlink</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_nlink</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_uid</name></name>   <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_uid</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_gid</name></name>   <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_gid</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_rdev</name></name>  <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_rdev</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_size</name></name>  <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_size</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_atime</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_atime</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_mtime</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_mtime</name></name>
            <operator>||</operator> <name><name>prev</name><operator>.</operator><name>st_ctime</name></name> <operator>!=</operator> <name><name>w</name><operator>-&gt;</operator><name>attr</name><operator>.</operator><name>st_ctime</name></name></expr>
        )</condition> <block>{<block_content>
            <comment type="block">/* we only update w-&gt;prev on actual differences */</comment>
            <comment type="block">/* in case we test more often than invoke the callback, */</comment>
            <comment type="block">/* to ensure that prev is always different to attr */</comment>
            <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>

            <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <macro><name>infy_del</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                <macro><name>ev_stat_stat</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> <comment type="block">/* avoid race... */</comment>
            </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <macro><name>ev_feed_event</name> <argument_list>(<argument>EV_A_ w</argument>, <argument>EV_STAT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_stat_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <macro><name>ev_stat_stat</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>&lt;</operator> <name>MIN_STAT_INTERVAL</name> <operator>&amp;&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <name>MIN_STAT_INTERVAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_timer_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><name>stat_timer_cb</name></expr></argument>, <argument><expr><literal type="number">0.</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> ?</condition><then> <expr><name><name>w</name><operator>-&gt;</operator><name>interval</name></name></expr> </then><else>: <expr><name>DEF_STAT_INTERVAL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>, <argument><expr><call><name>ev_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
        <expr_stmt><expr><call><name>infy_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fs_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <macro><name>infy_add</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ev_timer_again</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_stat_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_stat</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
        <macro><name>infy_del</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_timer_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>timer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_idle_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_idle</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pri_adjust</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><operator>++</operator><name><name>idlecnt</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>++</operator><name>idleall</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_idle</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name><name>idlemax</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>, <argument><expr><name>active</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_idle_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_idle</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><operator>--</operator><name><name>idlecnt</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>idles</name> <index>[<expr><call><name>ABSPRI</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>]</index><index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>--</operator><name>idleall</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_prepare_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>preparecnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_prepare</name> <operator>*</operator></expr></argument>, <argument><expr><name>prepares</name></expr></argument>, <argument><expr><name>preparemax</name></expr></argument>, <argument><expr><name>preparecnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>prepares</name> <index>[<expr><name>preparecnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_prepare_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>prepares</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>prepares</name> <index>[<expr><operator>--</operator><name>preparecnt</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>prepares</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_check_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_check</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>checkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_check</name> <operator>*</operator></expr></argument>, <argument><expr><name>checks</name></expr></argument>, <argument><expr><name>checkmax</name></expr></argument>, <argument><expr><name>checkcnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>checks</name> <index>[<expr><name>checkcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_check_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_check</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>checks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>checks</name> <index>[<expr><operator>--</operator><name>checkcnt</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>checks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_EMBED_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name> <name>noinline</name></type>
    <name>ev_embed_sweep</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_embed</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ev_run</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr></argument>, <argument><expr><name>EVRUN_NOWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>embed_io_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_embed</name>                <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_embed</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>io</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_embed</name></expr></argument>, <argument><expr><name>io</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_feed_event</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><name>EV_EMBED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ev_run</name> <argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr></argument>, <argument><expr><name>EVRUN_NOWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>embed_prepare_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_prepare</name> <modifier>*</modifier></type><name>prepare</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_embed</name>                <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_embed</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>prepare</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_embed</name></expr></argument>, <argument><expr><name>prepare</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

        <block>{<block_content>
            <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr>;</expr_stmt>

            <while>while <condition>(<expr><name>fdchangecnt</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>fd_reify</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <macro><name>ev_run</name> <argument_list>(<argument>EV_A_ EVRUN_NOWAIT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
            </block_content>}</block></while>
        </block_content>}</block>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>embed_fork_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_fork</name> <modifier>*</modifier></type><name>fork_w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ev_embed</name>                <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>ev_embed</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fork_w</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr><name>ev_embed</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

        <macro><name>ev_embed_stop</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

        <block>{<block_content>
            <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ev_loop_fork</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>ev_run</name> <argument_list>(<argument>EV_A_ EVRUN_NOWAIT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block>

        <macro><name>ev_embed_start</name> <argument_list>(<argument>EV_A_ w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    static void
    embed_idle_cb (EV_P_ ev_idle *idle, int revents)
    {
        ev_idle_stop (EV_A_ idle);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function><type><name>void</name></type>
    <name>ev_embed_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_embed</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <block>{<block_content>
            <expr_stmt><expr><name>EV_P</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>other</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><operator>(</operator><literal type="string">"libev: loop to be embedded is not embeddable"</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>backend</name> <operator>&amp;</operator> <call><name>ev_embeddable_backends</name> <argument_list>()</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>embed_io_cb</name></expr></argument>, <argument><expr><name>backend_fd</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><call><name>ev_priority</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_prepare_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>, <argument><expr><name>embed_prepare_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_set_priority</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>, <argument><expr><name>EV_MINPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_prepare_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_fork_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>fork</name></name></expr></argument>, <argument><expr><name>embed_fork_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_fork_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>fork</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*ev_idle_init (&amp;w-&gt;idle, e,bed_idle_cb);*/</comment>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_embed_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_embed</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_io_stop</name>      <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_prepare_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>prepare</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_fork_stop</name>    <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>w</name><operator>-&gt;</operator><name>fork</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_fork_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_fork</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>forkcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_fork</name> <operator>*</operator></expr></argument>, <argument><expr><name>forks</name></expr></argument>, <argument><expr><name>forkmax</name></expr></argument>, <argument><expr><name>forkcnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>forks</name> <index>[<expr><name>forkcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_fork_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_fork</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>forks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>forks</name> <index>[<expr><operator>--</operator><name>forkcnt</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>forks</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CLEANUP_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_cleanup_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_cleanup</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>cleanupcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_cleanup</name> <operator>*</operator></expr></argument>, <argument><expr><name>cleanups</name></expr></argument>, <argument><expr><name>cleanupmax</name></expr></argument>, <argument><expr><name>cleanupcnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cleanups</name> <index>[<expr><name>cleanupcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

        <comment type="block">/* cleanup watchers should never keep a refcount on the loop */</comment>
        <expr_stmt><expr><call><name>ev_unref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_cleanup_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_cleanup</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_ref</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cleanups</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>cleanups</name> <index>[<expr><operator>--</operator><name>cleanupcnt</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>cleanups</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_async_start</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>evpipe_init</name> <argument_list>(<argument><expr><name>EV_A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_start</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>, <argument><expr><operator>++</operator><name>asynccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>array_needsize</name> <argument_list>(<argument><expr><name>ev_async</name> <operator>*</operator></expr></argument>, <argument><expr><name>asyncs</name></expr></argument>, <argument><expr><name>asyncmax</name></expr></argument>, <argument><expr><name>asynccnt</name></expr></argument>, <argument><expr><name>EMPTY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>asyncs</name> <index>[<expr><name>asynccnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_async_stop</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><call><name>clear_pending</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><call><name>ev_is_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>                     <name>active</name> <init>= <expr><call><name>ev_active</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>asyncs</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>asyncs</name> <index>[<expr><operator>--</operator><name>asynccnt</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_active</name> <argument_list>(<argument><expr><name><name>asyncs</name> <index>[<expr><name>active</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>ev_stop</name> <argument_list>(<argument><expr><macro><name>EV_A_</name> <argument_list>(<argument>W</argument>)</argument_list></macro><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>EV_FREQUENT_CHECK</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_async_send</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>sent</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_mb</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>evpipe_write</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>async_pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_async_fsend</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_async</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>sent</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>async_pending</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>evpipe_write</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name>async_pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

    <struct>struct <name>ev_once</name> <block>{
        <decl_stmt><decl><type><name>ev_io</name></type>                   <name>io</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ev_timer</name></type>                <name>to</name></decl>;</decl_stmt>
        <function_decl><type><name>void</name></type> ( <modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
        <decl_stmt><decl><type><name>void</name>                    <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
    }</block>;</struct>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>once_cb</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name><name>struct</name> <name>ev_once</name></name> <modifier>*</modifier></type><name>once</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <init>= <expr><name><name>once</name><operator>-&gt;</operator><name>cb</name></name></expr></init>;</function_decl>
        <decl_stmt><decl><type><name>void</name>                    <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>once</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ev_io_stop</name>    <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_timer_stop</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ev_free</name> <argument_list>(<argument><expr><name>once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>revents</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>once_cb_io</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_io</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>ev_once</name></name>          <modifier>*</modifier></type><name>once</name> <init>= <expr><operator>(</operator>struct <name>ev_once</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>w</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr>struct <name>ev_once</name></expr></argument>, <argument><expr><name>io</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

        <macro><name>once_cb</name> <argument_list>(<argument>EV_A_ once</argument>, <argument>revents | ev_clear_pending (EV_A_ &amp; once-&gt;to)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type>
    <name>once_cb_to</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>ev_timer</name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>ev_once</name></name>          <modifier>*</modifier></type><name>once</name> <init>= <expr><operator>(</operator>struct <name>ev_once</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>w</name><operator>)</operator> <operator>-</operator> <call><name>offsetof</name> <argument_list>(<argument><expr>struct <name>ev_once</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

        <macro><name>once_cb</name> <argument_list>(<argument>EV_A_ once</argument>, <argument>revents | ev_clear_pending (EV_A_ &amp; once-&gt;io)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></function>

    <function><type><name>void</name></type>
    <name>ev_once</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>ev_tstamp</name></type> <name>timeout</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>revents</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name><name>struct</name> <name>ev_once</name></name>          <modifier>*</modifier></type><name>once</name> <init>= <expr><operator>(</operator>struct <name>ev_once</name> <operator>*</operator><operator>)</operator><call><name>ev_malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ev_once</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>expect_false</name> <argument_list>(<argument><expr><operator>!</operator><name>once</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>EV_ERROR</name> <operator>|</operator> <name>EV_READ</name> <operator>|</operator> <name>EV_WRITE</name> <operator>|</operator> <name>EV_TIMER</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>once</name><operator>-&gt;</operator><name>cb</name></name>  <operator>=</operator> <name>cb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>once</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ev_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>once_cb_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ev_io_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_io_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>once</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ev_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>once_cb_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&gt;=</operator> <literal type="number">0.</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>ev_timer_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><literal type="number">0.</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ev_timer_start</name> <argument_list>(<argument><expr><name>EV_A_</name> <operator>&amp;</operator> <name><name>once</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>

    <comment type="block" format="doxygen">/*****************************************************************************/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_WALK_ENABLE</name></expr></cpp:if>
    <function><type><name>void</name></type>
    <name>ev_walk</name> <parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>types</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>EV_P_</name> <name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ev_watcher_list</name>         <modifier>*</modifier></type><name>wl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wn</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <operator>(</operator><name>EV_IO</name> <operator>|</operator> <name>EV_EMBED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>anfdmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <for>for <control>(<init><expr><name>wl</name> <operator>=</operator> <name><name>anfds</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>wl</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>wn</name> <operator>=</operator> <name><name>wl</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_EMBED_ENABLE</name></expr></cpp:if>

                    <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>wl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>embed_io_cb</name></expr>)</condition> <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_EMBED</name></expr>)</condition><block type="pseudo"><block_content>
                            <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_EMBED</argument>, <argument>((char *)wl) - offsetof (struct ev_embed, io)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_USE_INOTIFY</name></expr></cpp:if>
                        if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>wl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>infy_cb</name></expr>)</condition><block type="pseudo"><block_content>
                            <empty_stmt>;</empty_stmt></block_content></block></if>
                        <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            if <condition>(<expr><operator>(</operator><name>ev_io</name> <operator>*</operator><operator>)</operator><name>wl</name> <operator>!=</operator> <operator>&amp;</operator><name>pipe_w</name></expr>)</condition><block type="pseudo"><block_content>
                                <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_IO</name></expr>)</condition><block type="pseudo"><block_content>
                                    <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_IO</argument>, <argument>wl</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>wl</name> <operator>=</operator> <name>wn</name></expr>;</expr_stmt>
                </block_content>}</block></for></block_content></block></for></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <operator>(</operator><name>EV_TIMER</name> <operator>|</operator> <name>EV_STAT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>timercnt</name> <operator>+</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <name>HEAP0</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_STAT_ENABLE</name></expr></cpp:if>

                <comment type="block">/*TODO: timer is not always active*/</comment>
                <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><operator>(</operator><name>ev_timer</name> <operator>*</operator><operator>)</operator><call><name>ANHE_w</name> <argument_list>(<argument><expr><name><name>timers</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>stat_timer_cb</name></expr>)</condition> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_STAT</name></expr>)</condition><block type="pseudo"><block_content>
                        <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_STAT</argument>, <argument>((char *)ANHE_w (timers [i])) - offsetof (struct ev_stat, timer)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_TIMER</name></expr>)</condition><block type="pseudo"><block_content>
                        <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_TIMER</argument>, <argument>ANHE_w (timers [i])</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PERIODIC_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_PERIODIC</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>periodiccnt</name> <operator>+</operator> <name>HEAP0</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <name>HEAP0</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_PERIODIC</argument>, <argument>ANHE_w (periodics [i])</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_IDLE_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>NUMPRI</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>idlecnt</name> <index>[<expr><name>j</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                    <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_IDLE</argument>, <argument>idles [j][i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_FORK_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_FORK</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>forkcnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><name><name>forks</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>embed_fork_cb</name></expr>)</condition><block type="pseudo"><block_content>
                    <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_FORK</argument>, <argument>forks [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_ASYNC_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_ASYNC</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>asynccnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_ASYNC</argument>, <argument>asyncs [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_PREPARE_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_PREPARE</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>preparecnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>EV_EMBED_ENABLE</name></expr></cpp:if>
                <if_stmt><if>if <condition>(<expr><call><name>ev_cb</name> <argument_list>(<argument><expr><name><name>prepares</name> <index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>embed_prepare_cb</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
                    <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_PREPARE</argument>, <argument>prepares [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHECK_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>checkcnt</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_CHECK</argument>, <argument>checks [i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_SIGNAL_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_SIGNAL</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>EV_NSIG</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
                <for>for <control>(<init><expr><name>wl</name> <operator>=</operator> <name><name>signals</name> <index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>head</name></expr>;</init> <condition><expr><name>wl</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>wn</name> <operator>=</operator> <name><name>wl</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                    <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_SIGNAL</argument>, <argument>wl</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                    <expr_stmt><expr><name>wl</name> <operator>=</operator> <name>wn</name></expr>;</expr_stmt>
                </block_content>}</block></for></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_CHILD_ENABLE</name></expr></cpp:if>

        <if_stmt><if>if <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>EV_CHILD</name></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>EV_PID_HASHSIZE</name><operator>)</operator></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
                <for>for <control>(<init><expr><name>wl</name> <operator>=</operator> <name><name>childs</name> <index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>wl</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
                    <expr_stmt><expr><name>wn</name> <operator>=</operator> <name><name>wl</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                    <macro><name>cb</name> <argument_list>(<argument>EV_A_ EV_CHILD</argument>, <argument>wl</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
                    <expr_stmt><expr><name>wl</name> <operator>=</operator> <name>wn</name></expr>;</expr_stmt>
                </block_content>}</block></for></block_content></block></for></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line" format="doxygen">///* EV_STAT     0x00001000 /* stat data changed */</comment>
        <comment type="line" format="doxygen">///* EV_EMBED    0x00010000 /* embedded event loop needs sweep */</comment>
    </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EV_MULTIPLICITY</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ev_wrap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <macro><name>EV_CPP</name><argument_list>(
<argument>}</argument>)</argument_list></macro>
</unit>
