<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_dma/consensus_repl.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_dma.c
 *		Consensus Service for XLOG replication
 *
 * Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 * 	src/backend/polar_dma/consensus_repl.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"easy_log.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_consensus_c.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_datamax/polar_datamax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/polar_dma.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/consensus_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/consensus_repl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_TRANSFER_LEADER</name></cpp:macro> 	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_ADD_FOLLOWER</name></cpp:macro>    	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_DROP_FOLLOWER</name></cpp:macro>    	<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_REQUEST_VOTE</name></cpp:macro>			<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_ADD_LEARNER</name></cpp:macro> 			<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_DROP_LEARNER</name></cpp:macro> 			<cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_CHANGE_LEARNER_TO_FOLLOWER</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_CHANGE_FOLLOWER_TO_LEARNER</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_CHANGE_WEIGHT_CONFIG</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_FORCE_SIGNLE_MODE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_CHANGE_MATCH_INDEX</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_PURGE_LOGS</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_FORCE_PURGE_LOGS</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_CHANGE_CLUSTER_ID</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSNESUS_TRANSIT_CHECK_INTERVAL</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HISTORIC_COMMIT_ADVANCE_INTERVAL</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLOG_STREAMING_CHECK_INTERVAL</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_COMMIT_TIMEOUT</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_SYNC_TIMEOUT</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_COMMAND_TIMEOUT</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_STAT_FETCH_TIMEOUT</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_CHECK_SHUTDOWN_INTERVAL</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSENSUS_ARCHIVE_ADVANCE_INTERVAL</name></cpp:macro> <cpp:value>5000</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>uint64</name></type> <name>ConsensusGetCommitIndex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* GUC variables */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_enable_dma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_async_commit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_force_change_meta</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_init_meta</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>polar_dma_members_info_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>polar_dma_learners_info_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>polar_dma_start_point_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_cluster_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64</name></type>		<name>polar_dma_current_term</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> 		<modifier>*</modifier></type><name>polar_dma_repl_slot_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> 		<modifier>*</modifier></type><name>polar_dma_repl_app_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> 		<modifier>*</modifier></type><name>polar_dma_repl_user</name> <init>= <expr><literal type="string">"polardb"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> 		<modifier>*</modifier></type><name>polar_dma_repl_password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_port_deviation</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_election_timeout</name> <init>= <expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 5s */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_purge_timeout</name> <init>= <expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 30s */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_io_thread_count</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_hb_thread_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_worker_thread_count</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_log_slots</name> <init>= <expr><literal type="number">8192</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 64M */</comment>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_log_keep_size_mb</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 128M */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_auto_leader_transfer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_send_timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_new_follower_threshold</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_disable_election</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_auto_purge</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_dma_delay_election</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_delay_electionTimeout</name> <init>= <expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 30 mins */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_xlog_check_timeout</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 5 ms */</comment>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_max_packet_size</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* kB */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_pipeline_timeout</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 3 ms */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_dma_config_change_timeout</name> <init>= <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 60 secs */</comment>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_max_delay_index</name> <init>= <expr><literal type="number">50000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_dma_min_delay_index</name> <init>= <expr><literal type="number">5000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_dma_time_statistics</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Consensus control data structure in the shared memory */</comment>
<typedef>typedef <type><struct>struct <name>ConsensusCtlData</name>
<block>{
	<decl_stmt><decl><type><name>slock_t</name></type>			<name>mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>				<name>consensusPid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * All subprocesses can wait on this queue.  Their waiting LSN
	 * (PGPROC-&gt;consensusInfo.waitLSN) are in increasing order. Protected by ConsensusLock.
	 */</comment>
	<decl_stmt><decl><type><name>SHM_QUEUE</name></type>		<name>waitQueue</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>syncSuspending</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>syncRqstLSN</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>sync_cond_mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_cond_t</name></type>	<name>sync_cond</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The LSN that has been committed on the consensus log. checked while
	 * follower replaying WAL record and leader flushing WAL, Protected by
	 * cs_info_lck
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>syncedLSN</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>syncedTLI</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * The LSN that can be purged on the consensus log. checked while
	 * deleting old xlog files, Protected by cs_info_lock
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>purgeLSN</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>uint64</name></type> 		<name>commitIndex</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>commitIndex</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>pthread_rwlock_t</name></type> <name>cs_info_lck</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * current term of XLOG.
	 * Modified while Postmaster/StartupProcess changing state
	 * Protected by xlog_term_lck.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>xlogTerm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_rwlock_t</name></type> <name>xlog_term_lck</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * local flushed LSN. modified by XLogFlush or Walreciever
	 * Protected by xlog_flush_lck.
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>flushedLSN</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>flushedTLI</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>flushWaitTimeout</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>flushWaitTimeout</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>pthread_rwlock_t</name></type> <name>xlog_flush_lck</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For views &amp;&amp; commands
	 */</comment>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> 	<name>rqst_lck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type>		<name>rqstInstage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>rqstType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>nodeInfo</name><index>[<expr><name>NI_MAXHOST</name><operator>+</operator><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>responce</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutex_t</name> 	<modifier>*</modifier></type><name>wait_cond_mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_cond_t</name>		<modifier>*</modifier></type><name>wait_cond</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	<modifier>*</modifier></type><name>finished</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> 	<name>rqst_cond_mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_cond_t</name></type>		<name>rqst_cond</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>stat_lck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name></type>			<name>statRqstQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>				<name>statRqstFlag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_rwlock_t</name></type> <name>stat_info_lck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusMemberInfo</name></type>	 	<name>memberInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusClusterInfo</name></type>	<name><name>clusterInfo</name><index>[<expr><name>POLAR_DMA_MAX_NODES_NUM</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusStatsInfo</name></type>	 	<name>statsInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>numCluster</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> 	<name>stat_cond_mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_cond_t</name></type>		<name>stat_cond</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire current_status_lock write lock by Consensus Process,
	 * and acquire read lock for status view by backend process
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>currentStateTerm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>currentLeaderId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>currentLogTerm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>inSmartShutdown</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_rwlock_t</name></type> <name>current_status_lock</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<comment type="block">/*
	 * Protect by current_status_lock
	 */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>currentAppendedLSN</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusState</name></type>  <name>currentState</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>currentAppendedLSN</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>currentState</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
	<struct>struct
	<block>{
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>transit_waits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>xlog_transit_waits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>xlog_flush_waits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>consensus_appends</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>consensus_wakeups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>consensus_backend_wakeups</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>consensus_commit_waits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>consensus_commit_wait_time</name></decl>;</decl_stmt>
	}</block> <decl><name>stats</name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>ConsensusCtlData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ConsensusCtlData</name> <modifier>*</modifier></type><name>ConsensusCtl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>ConsensusContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>shutdown_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>CONSENSUS_HANDLE</name></type> <name>consensusHandle</name> <init>= <expr><name>INVALID_CONSENSUS_HANDLE</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConsensusSigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConsensusSigUsr2Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConsensusProcShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConsensusSigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_startup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_learner</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_logger</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>mock_start_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_mainloop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_on_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_try_synchronizing_flush_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_wait_for_next_entry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_maybe_transit_state</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leader_addr</name></decl></parameter>,
		<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leader_host</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>leader_port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_wakeup_backends</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>consensus_stat_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>consensus_command_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>consensus_append_log_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>consensus_advance_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_set_flush_wait_timeout</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>wait_time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>consensus_get_flush_wait_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConsensusLockXLogTermShared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConsensusUnlockXLogTerm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_set_in_smart_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_get_in_smart_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_set_state</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>consensus_get_state</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_set_appended_lsn</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>append_lsn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>consensus_get_appended_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>consensus_wait_for_command</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cmd_type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>consensus_get_stat_collect_queue_length</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>consensus_get_commit_wait_queue_length</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consensus_get_current_status</name><parameter_list>(<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>term</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>leader_id</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>log_term</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_covert_start_pos</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_point_str</name></decl></parameter>,
		<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>start_index</name></decl></parameter>,
		<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>start_lsn</name></decl></parameter>,
		<parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>start_tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>start_index_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>start_index_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>start_tli_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>start_tli_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>start_lsn_start</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>start_point_str</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>start_point_str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* parse start index */</comment>
	<expr_stmt><expr><name>start_index_start</name> <operator>=</operator> <name>start_point_str</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>start_index</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>start_index_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_index_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>start_index_end</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>start_index_end</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid start index specified in start point address: %s"</literal></expr></argument>,
						<argument><expr><name>start_index_start</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* parse start timeline */</comment>
	<expr_stmt><expr><name>start_tli_start</name> <operator>=</operator> <operator>++</operator><name>start_index_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>start_tli</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>start_tli_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_tli_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>start_tli_end</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>start_tli_end</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid start timeline specified in start point address: %s"</literal></expr></argument>,
						<argument><expr><name>start_index_start</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* parse start lsn */</comment>
	<expr_stmt><expr><name>start_lsn_start</name> <operator>=</operator> <operator>++</operator><name>start_tli_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>start_lsn</name> <operator>=</operator> <call><name>DatumGetLSN</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_lsn_in</name></expr></argument>, 
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>start_lsn_start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Consensus log start position: %s, start index: %lu, "</literal>
						<literal type="string">"start lsn: %X/%X timeline %u"</literal></expr></argument>,
					<argument><expr><name>start_point_str</name></expr></argument>, <argument><expr><operator>*</operator><name>start_index</name></expr></argument>, 
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>start_lsn</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>start_lsn</name><operator>)</operator></expr></argument>,
					<argument><expr><operator>*</operator><name>start_tli</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_covert_server_address</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>server_address_str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pg_ip</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pg_port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>colon</name> <init>= <expr><name>server_address_str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>source_ip_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>source_ip_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>source_port_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>source_port</name></decl>;</decl_stmt>

	<comment type="block">/* parse ip */</comment>
	<expr_stmt><expr><name>source_ip_start</name> <operator>=</operator> <name>server_address_str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>colon</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>colon</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>colon</name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><operator>*</operator><name>colon</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>source_ip_end</name> <operator>=</operator> <name>colon</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>source_ip_end</name> <operator>-</operator> <name>source_ip_start</name> <operator>&lt;</operator> <name>NI_MAXHOST</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* parse source port */</comment>
	<expr_stmt><expr><name>source_port_start</name> <operator>=</operator> <name>colon</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>source_port</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>source_port_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>source_port</name> <operator>&gt;</operator> <name>polar_dma_port_deviation</name> <operator>&amp;&amp;</operator> <name>source_port</name> <operator>&lt;</operator> <literal type="number">65535</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pg_ip</name></expr></argument>, <argument><expr><name>source_ip_start</name></expr></argument>, <argument><expr><name>source_ip_end</name> <operator>-</operator> <name>source_ip_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pg_ip</name><index>[<expr><name>source_ip_end</name> <operator>-</operator> <name>source_ip_start</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pg_port</name> <operator>=</operator> <name>source_port</name> <operator>-</operator> <name>polar_dma_port_deviation</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* process-safe, called by main thread or PG backends */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_check_and_convert_member_info</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>member_info</name></decl></parameter>,
																			  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>consensus_node_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>colon</name> <init>= <expr><name>member_info</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>ip_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>ip_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>pg_port_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>pg_port_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pg_port</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>consensus_port</name></decl>;</decl_stmt>

	<comment type="block">/* parse ip */</comment>
	<expr_stmt><expr><name>ip_start</name> <operator>=</operator> <name>member_info</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>colon</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>colon</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>colon</name></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>colon</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid server address string specified in server address: %s"</literal></expr></argument>,
						<argument><expr><name>member_info</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ip_end</name> <operator>=</operator> <name>colon</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* parse pg port */</comment>
	<expr_stmt><expr><name>pg_port_start</name> <operator>=</operator> <name>colon</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_port</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>pg_port_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pg_port_end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>consensus_port</name> <operator>=</operator> <name>pg_port</name> <operator>+</operator> <name>polar_dma_port_deviation</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pg_port</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>pg_port</name> <operator>&gt;</operator> <literal type="number">65535</literal> <operator>||</operator> <name>consensus_port</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid port number specified in server address: %d, plus the "</literal>
								<literal type="string">"client port obtained by adding %d to the consensus port."</literal></expr></argument>,
						<argument><expr><name>pg_port</name></expr></argument>, <argument><expr><name>polar_dma_port_deviation</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>ip_end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pg_port_end</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>consensus_node_info</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s:%d"</literal></expr></argument>, <argument><expr><name>ip_start</name></expr></argument>, <argument><expr><name>consensus_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>consensus_node_info</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s:%d%s"</literal></expr></argument>, <argument><expr><name>ip_start</name></expr></argument>, <argument><expr><name>consensus_port</name></expr></argument>, <argument><expr><name>pg_port_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>ip_end</name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>consensus_check_cluster_info</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cluster_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 	<name>num_servers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>member_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>consensus_nodes_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>consensus_cluster_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>consensus_node_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>consensus_node_info_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>consensus_cluster_info_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>consensus_node_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>ConsensusContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* "127.0.0.1:10001#9F;0;127.0.0.1:10003#5N@1" */</comment>
	<expr_stmt><expr><name>member_info</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>cluster_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>save_p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>member_info</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">';'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>save_p</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* null server */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>member_info</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>member_info</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>consensus_node_info</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>member_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>consensus_cluster_info_len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name>member_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>consensus_nodes_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>consensus_nodes_list</name></expr></argument>,
																		 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>num_servers</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>save_p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>consensus_cluster_info_len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>save_p</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>consensus_cluster_info_len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>p</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>consensus_node_p</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>consensus_cluster_info_len</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>consensus_cluster_info_len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_info</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>member_info</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>consensus_cluster_info</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>consensus_cluster_info_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>consensus_node_info_p</name> <operator>=</operator> <name>consensus_cluster_info</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>consensus_nodes_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>consensus_node_info</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consensus_node_info_p</name> <operator>-</operator> <name>consensus_cluster_info</name> <operator>&lt;=</operator>
								<name>consensus_cluster_info_len</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>consensus_node_info_p</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>consensus_node_info_p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>!=</operator> <call><name>list_tail</name><argument_list>(<argument><expr><name>consensus_nodes_list</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consensus_node_info_p</name> <operator>-</operator> <name>consensus_cluster_info</name> <operator>&lt;=</operator>
												<name>consensus_cluster_info_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>consensus_node_info_p</name> <operator>=</operator> <literal type="char">';'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>consensus_node_info_p</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>consensus_node_p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consensus_node_info_p</name> <operator>-</operator> <name>consensus_cluster_info</name> <operator>&lt;=</operator>
								<name>consensus_cluster_info_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>consensus_node_info_p</name> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>consensus_node_info_p</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consensus_node_info_p</name> <operator>-</operator> <name>consensus_cluster_info</name> <operator>&lt;=</operator>
								<name>consensus_cluster_info_len</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>consensus_node_info_p</name></expr></argument>, <argument><expr><name>consensus_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>consensus_node_info_p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>consensus_node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>consensus_node_info_p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consensus_node_info_p</name> <operator>-</operator> <name>consensus_cluster_info</name> <operator>==</operator> <name>consensus_cluster_info_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cluster_info: %s, node_info: %s"</literal></expr></argument>,
									<argument><expr><name>cluster_info</name></expr></argument>, <argument><expr><name>consensus_cluster_info</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>consensus_cluster_info</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_get_leader_info</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>leader_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leader_host</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>leader_port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>members_info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>member_info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>   <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>   <name>server_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ConsensusMetaGetMemberInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>members_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>members_info</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>members_info</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>members_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>member_info</name> <operator>=</operator> <name>members_info</name></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>member_info</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">';'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

    <expr_stmt><expr><name>server_id</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>server_id</name> <operator>==</operator> <name>leader_id</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type>  <name>save_p</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>consensus_covert_server_address</name><argument_list>(<argument><expr><name>member_info</name></expr></argument>, <argument><expr><name>leader_host</name></expr></argument>, <argument><expr><name>leader_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>save_p</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>member_info</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>members_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusGetStatus</name><parameter_list>(<parameter><decl><type><name>ConsensusStatus</name> <modifier>*</modifier></type><name>consensus_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>current_state</name></name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator><call><name>consensus_get_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>xlog_term</name></name> <operator>=</operator> <call><name>ConsensusGetXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>consensus_get_current_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>term</name></name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>leader_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>log_term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>sync_rqst_lsn</name></name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncRqstLSN</name></name></expr> ;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>appended_lsn</name></name> <operator>=</operator> <call><name>consensus_get_appended_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConsensusGetSyncedLSNAndTLI</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>synced_lsn</name></name></expr></argument>, 
			<argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>synced_tli</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>purge_lsn</name></name> <operator>=</operator> <call><name>ConsensusGetPurgeLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>commit_index</name></name> <operator>=</operator> <call><name>ConsensusGetCommitIndex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConsensusGetXLogFlushedLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>flushed_lsn</name></name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name><name>consensus_status</name><operator>-&gt;</operator><name>flushed_tli</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>commit_queue_length</name></name> <operator>=</operator>
		  <call><name>consensus_get_commit_wait_queue_length</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>consensus_status</name><operator>-&gt;</operator><name>stats_queue_length</name></name> <operator>=</operator>
		  <call><name>consensus_get_stat_collect_queue_length</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusGetStats</name><parameter_list>(<parameter><decl><type><name>ConsensusStats</name> <modifier>*</modifier></type><name>consensus_stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>transit_waits</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>transit_waits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>xlog_transit_waits</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>xlog_transit_waits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>xlog_flush_waits</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>xlog_flush_waits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>consensus_appends</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_appends</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>consensus_wakeups</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_wakeups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>consensus_backend_wakeups</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_backend_wakeups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>consensus_commit_waits</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_commit_waits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>consensus_stats</name><operator>-&gt;</operator><name>consensus_commit_wait_time</name></name> <operator>=</operator>
		<call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_commit_wait_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>consensus_stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_stats_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>transit_waits</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>xlog_transit_waits</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>xlog_flush_waits</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_appends</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_wakeups</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_backend_wakeups</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_commit_waits</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_commit_wait_time</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_meta_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>consensus_meta_cluster_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>consensus_cluster_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>consensus_learner_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>start_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>start_tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>start_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 	<name>is_learner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_dma_members_info_string</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>polar_dma_members_info_string</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>consensus_cluster_info</name> <operator>=</operator> <call><name>consensus_check_cluster_info</name><argument_list>(<argument><expr><name>polar_dma_members_info_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>consensus_cluster_info</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>polar_dma_members_info_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>polar_dma_init_meta</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>consensus_cluster_info</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_dma_learners_info_string</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>polar_dma_learners_info_string</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>consensus_learner_info</name> <operator>=</operator> <call><name>consensus_check_cluster_info</name><argument_list>(<argument><expr><name>polar_dma_learners_info_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>consensus_learner_info</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>polar_dma_learners_info_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>polar_dma_init_meta</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>consensus_learner_info</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_dma_start_point_string</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_covert_start_pos</name><argument_list>(<argument><expr><name>polar_dma_start_point_string</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>start_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_dma_cluster_id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ConsensusMetaSetInt64</name><argument_list>(<argument><expr><name>ClusterIdMetaKey</name></expr></argument>, <argument><expr><name>polar_dma_cluster_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>consensus_cluster_info</name> <operator>&amp;&amp;</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>consensus_cluster_info</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
			<call><name>ConsensusMetaGetMemberInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>consensus_meta_cluster_info</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strrchr</name><argument_list>(<argument><expr><name>consensus_meta_cluster_info</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>is_learner</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_dma_force_change_meta</name> <operator>||</operator> <name>polar_dma_init_meta</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusMetaForceChange</name><argument_list>(<argument><expr><name>polar_dma_current_term</name></expr></argument>,
				<argument><expr><name>consensus_cluster_info</name></expr></argument>,
				<argument><expr><ternary><condition><expr><operator>(</operator><name>consensus_cluster_info</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>consensus_cluster_info</name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then>
					<expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>consensus_cluster_info</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>,
				<argument><expr><name>consensus_learner_info</name></expr></argument>,
				<argument><expr><ternary><condition><expr><operator>(</operator><name>consensus_learner_info</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>consensus_learner_info</name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then>
					<expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>consensus_learner_info</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>,
				<argument><expr><name>start_index</name></expr></argument>, <argument><expr><name>start_tli</name></expr></argument>, <argument><expr><name>start_lsn</name></expr></argument>,
				<argument><expr><name>is_learner</name></expr></argument>, <argument><expr><name>polar_dma_init_meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>consensus_cluster_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ConsensusMetaSetMemberInfo</name><argument_list>(<argument><expr><name>consensus_cluster_info</name></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>consensus_cluster_info</name> <operator>==</operator> <literal type="char">'\0'</literal></expr> ?</condition><then>  <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>consensus_cluster_info</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>consensus_learner_info</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ConsensusMetaSetLearnerInfo</name><argument_list>(<argument><expr><name>consensus_learner_info</name></expr></argument>,
					<argument><expr><ternary><condition><expr><operator>*</operator><name>consensus_learner_info</name> <operator>==</operator> <literal type="char">'\0'</literal></expr> ?</condition><then>  <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>consensus_learner_info</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>consensus_meta_cluster_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>consensus_meta_cluster_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>consensus_cluster_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>consensus_cluster_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>consensus_learner_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>consensus_learner_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>is_learner</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Consensus main entry point
 *
 * no return
 */</comment>
<function><type><name>void</name></type>
<name>ConsensusMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pthread_t</name></type> 	<name>appendpid</name></decl>, <decl><type ref="prev"/><name>statpid</name></decl>, <decl><type ref="prev"/><name>cmdpid</name></decl>, <decl><type ref="prev"/><name>advancepid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>start_commit_index</name></decl>, <decl><type ref="prev"/><name>mock_start_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> 	<name>timeline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> 	<name>lsn</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>pthread_rwlockattr_t</name></type> <name>lock_attr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>is_learner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ConsensusContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"PolarDMA"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextAllowInCriticalSection</name><argument_list>(<argument><expr><name>ConsensusContext</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ConsensusContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unblock signals (they were blocked when the postmaster forked us)
	 */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>PostgresSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>ConsensusSigIntHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>ConsensusProcShutdownHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* request shutdown */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>consensus_quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* hard crash time */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>ConsensusSigUsr1Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>ConsensusSigUsr2Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>consensusPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>consensus_on_exit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>consensus_stats_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

 	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConsensusMetaStartup</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"polar dma startup faild"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>is_learner</name> <operator>=</operator> <call><name>consensus_meta_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_dma_force_change_meta</name> <operator>||</operator> <name>polar_dma_init_meta</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consensus process normal shutdown after force change or intialize meta"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>PostmasterPid</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConsensusLOGStartup</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consensus log startup faild"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ConsensusLOGSetKeepSize</name><argument_list>(<argument><expr><name>polar_dma_log_keep_size_mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConsensusLOGGetLastLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConsensusSetXLogFlushedLSN</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>timeline</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>consensus_set_flush_wait_timeout</name><argument_list>(<argument><expr><name>polar_dma_xlog_check_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentState</name></name> <operator>=</operator> <name>CONSENSUS_STATE_DOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentAppendedLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentState</name></name></expr></argument>, <argument><expr><name>CONSENSUS_STATE_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentAppendedLSN</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncRqstLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConsensusMetaGetInt64</name><argument_list>(<argument><expr><name>CommitIndexMetaKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_commit_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>consensus_log_get_entry_lsn</name><argument_list>(<argument><expr><name>start_commit_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeline</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedLSN</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedTLI</name></name> <operator>=</operator> <name>timeline</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ConsensusGetCommitIndex</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConsensusSetCommitIndex</name><argument_list>(<argument><expr><name>start_commit_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start up consensus */</comment>
	<expr_stmt><expr><call><name>ConsensusMetaGetInt64</name><argument_list>(<argument><expr><name>MockStartIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mock_start_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>consensus_startup</name><argument_list>(<argument><expr><name>is_learner</name></expr></argument>, <argument><expr><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mock_start_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmdpid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>consensus_command_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consensus create pthread faild"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statpid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>consensus_stat_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consensus create pthread faild"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>appendpid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>consensus_append_log_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consensus create pthread faild"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancepid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>consensus_advance_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"consensus create pthread faild"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>consensus_mainloop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_shutdown</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>advancepid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>appendpid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>cmdpid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>statpid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><ternary><condition><expr><name>shutdown_requested</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_log_messages_to_easy_level</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>min_messages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>min_messages</name> <operator>&gt;=</operator> <name>FATAL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_FATAL</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>min_messages</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_ERROR</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>min_messages</name> <operator>&gt;=</operator> <name>WARNING</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_WARN</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>min_messages</name> <operator>&gt;=</operator> <name>LOG</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_INFO</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>min_messages</name> <operator>==</operator> <name>DEBUG1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_DEBUG</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>min_messages</name> <operator>&lt;</operator> <name>DEBUG1</name> <operator>&amp;&amp;</operator> <name>log_min_messages</name> <operator>&gt;=</operator> <name>DEBUG5</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_TRACE</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>EASY_LOG_WARN</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_startup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_learner</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_logger</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>mock_start_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>consensus_log_level</name> <init>= <expr><call><name>convert_log_messages_to_easy_level</name><argument_list>(<argument><expr><name>log_min_messages</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>consensusHandle</name> <operator>=</operator> <call><name>consensus_create_instance</name><argument_list>(
							<argument><expr><ternary><condition><expr><name>is_logger</name></expr> ?</condition><then> <expr><name>mock_start_index</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>polar_dma_election_timeout</name></expr></argument>,
							<argument><expr><name>polar_dma_purge_timeout</name></expr></argument>,
							<argument><expr><name>polar_dma_max_packet_size</name> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
							<argument><expr><name>polar_dma_pipeline_timeout</name></expr></argument>,
							<argument><expr><name>polar_dma_config_change_timeout</name></expr></argument>,
							<argument><expr><name>consensus_log_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>==</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unable to initialize consensus service."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_learner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>consensus_init_as_peer</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
										<argument><expr><name>is_logger</name></expr></argument>,
										<argument><expr><name>polar_dma_io_thread_count</name></expr></argument>,
										<argument><expr><name>polar_dma_hb_thread_count</name></expr></argument>,
										<argument><expr><name>polar_dma_worker_thread_count</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name>is_logger</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>polar_dma_auto_leader_transfer</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>polar_dma_auto_purge</name></expr></argument>,
										<argument><expr><name>polar_dma_delay_election</name></expr></argument>,
										<argument><expr><name>polar_dma_delay_electionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>consensus_init_as_learner</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
										<argument><expr><name>is_logger</name></expr></argument>,
										<argument><expr><name>polar_dma_io_thread_count</name></expr></argument>,
										<argument><expr><name>polar_dma_hb_thread_count</name></expr></argument>,
										<argument><expr><name>polar_dma_worker_thread_count</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name>is_logger</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>polar_dma_auto_leader_transfer</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>polar_dma_auto_purge</name></expr></argument>,
										<argument><expr><name>polar_dma_delay_election</name></expr></argument>,
										<argument><expr><name>polar_dma_delay_electionTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unable to initialize consensus service. return: %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_mainloop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type> <name>old_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>old_committed_tli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><name>CONSENSUS_CHECK_SHUTDOWN_INTERVAL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consensus_quickdie</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>shutdown_requested</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingAlways</name><argument_list>()</argument_list></call> <operator>||</operator>
				<call><name>GetRecoveryState</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>RECOVERY_STATE_ARCHIVE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TimeLineID</name></type> <name>tli</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>xlog</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ConsensusGetSyncedLSNAndTLI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>old_committed_tli</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>old_segno</name> <operator>&lt;</operator> <name>segno</name> <operator>||</operator> <name>old_committed_tli</name> <operator>&lt;</operator> <name>tli</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <call><name>polar_is_datamax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* POLAR: Enter datamax Mode. */</comment>
				<expr_stmt><expr><call><name>polar_dma_xlog_archive_notify</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>polar_is_datamax_mode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>				<comment type="block">/* POLAR: Leave datamax mode. */</comment>
				<expr_stmt><expr><name>old_segno</name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>old_committed_tli</name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>CONSENSUS_ARCHIVE_ADVANCE_INTERVAL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
								  <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
								  <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>WAIT_EVENT_CONSENSUS_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>
<name>consensus_advance_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>current_leader_addr</name><index>[<expr><name>NI_MAXHOST</name> <operator>+</operator> <name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>current_leader_host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>current_leader_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* main loop */</comment>
	<while>while <condition>(<expr><operator>!</operator><name>shutdown_requested</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check if we need transit our state based on our current state and XPaxos state. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>consensus_maybe_transit_state</name><argument_list>(<argument><expr><name>current_leader_addr</name></expr></argument>, <argument><expr><name>current_leader_host</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_leader_port</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* transit failed, sleep 1ms and retry */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
			<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>transit_waits</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>CONSNESUS_TRANSIT_CHECK_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>consensus_wait_for_next_entry</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consensus_wakeup_backends</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* SIGUSR1: let latch facility handle the signal */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConsensusSigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConsensusSigUsr2Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ConsensusMetaSetInt64</name><argument_list>(<argument><expr><name>CommitIndexMetaKey</name></expr></argument>, <argument><expr><call><name>ConsensusGetCommitIndex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConsensusSigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>consensus_set_in_smart_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConsensusProcShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ConsensusMetaSetInt64</name><argument_list>(<argument><expr><name>CommitIndexMetaKey</name></expr></argument>, <argument><expr><call><name>ConsensusGetCommitIndex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shutdown_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Quickly exit without cleaning up anything.
	 */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>ConsensusShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>sz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ConsensusLOGShmemSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusCtlData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sz</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ConsensusCtl</name> <operator>=</operator> <operator>(</operator><name>ConsensusCtlData</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Consensus Ctl"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusCtlData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pthread_rwlockattr_t</name></type> <name>rwlock_attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>mutex_attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pthread_condattr_t</name></type> <name>cond_attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pthread_rwlockattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlockattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>,<argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutexattr_settype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutexattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>,<argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_condattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_condattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>, <argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* initialize the control structure */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ConsensusCtl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusCtlData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstInstage</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mutex_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pthread_rwlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rwlock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>commitIndex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushWaitTimeout</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ConsensusLOGShmemInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusProcInit</name><parameter_list>(<parameter><decl><type><name>ConsensusProcInfo</name> <modifier>*</modifier></type><name>procInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>lock_attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_condattr_t</name></type> <name>cond_attr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_condattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_condattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>, <argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procInfo</name><operator>-&gt;</operator><name>wait_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cond_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutexattr_settype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutexattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>,<argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procInfo</name><operator>-&gt;</operator><name>wait_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>procInfo</name><operator>-&gt;</operator><name>waitLSN</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>procInfo</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueElemInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>procInfo</name><operator>-&gt;</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_on_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>consensusPid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>consensus_set_state</name><argument_list>(<argument><expr><name>CONSENSUS_STATE_DOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transit the state of consensus if needed and bring down or up other components
 * (Startup, WALSender, WALReceivers) accordingly.
 *
 * Returns true if anything requires immediate attention without waiting.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_maybe_transit_state</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leader_addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leader_host</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>leader_port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>term</name></decl>,
				 <decl><type ref="prev"/><name>leader_id</name></decl>,
				 <decl><type ref="prev"/><name>local_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>current_append_term</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>last_write_timeline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>last_write_lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>state_change</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_check_pm_in_state_change</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"PostMaster is in a state of changing. signale PostMaster and "</literal>
			 <literal type="string">"check the consensus state next time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get current term and leader */</comment>
	<expr_stmt><expr><call><name>consensus_get_leader</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leader_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>term</name></expr></argument>,
			<argument><expr><name>leader_addr</name></expr></argument>, <argument><expr><name>NI_MAXHOST</name> <operator>+</operator> <name>NI_MAXSERV</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name> <operator>!=</operator> <name>term</name> <operator>||</operator>
			 <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLeaderId</name></name> <operator>!=</operator> <name>leader_id</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>leader_id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Consensus state change, current term: %llu, current leader: %lu,"</literal>
					<literal type="string">"current leader addr: %s, old term: %llu, old leader: %lu"</literal></expr></argument>,
					<argument><expr><name>term</name></expr></argument>, <argument><expr><name>leader_id</name></expr></argument>, <argument><expr><name>leader_addr</name></expr></argument>,
					<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLeaderId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>leader_id</name> <operator>==</operator> <name>local_id</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * After became leader, reset consensus appended LSN align to consensus log
			 * and advance consensus log term. Disable consensus log to truncate
			 * backward, avoid shutdown while transfer back and forth between leader
			 * and follower
			 */</comment>
			<expr_stmt><expr><call><name>ConsensusLOGGetLastLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_write_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_write_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>consensus_set_appended_lsn</name><argument_list>(<argument><expr><name>last_write_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Logger's WAL and consensus log could be purged after downgrade from leader. 
			 * Because the data caches don't need to cleanup */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>polar_is_dma_data_node</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ConsensusLOGSetDisablePurge</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ConsensusLOGSetLogTerm</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>current_append_term</name> <operator>=</operator> <name>term</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>consensus_set_state</name><argument_list>(<argument><expr><name>CONSENSUS_STATE_LEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>state_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>leader_id</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>leader_addr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>consensus_covert_server_address</name><argument_list>(<argument><expr><name>leader_addr</name></expr></argument>,
						<argument><expr><name>leader_host</name></expr></argument>, <argument><expr><name>leader_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>state_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>leader_id</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>consensus_get_leader_info</name><argument_list>(<argument><expr><name>leader_id</name></expr></argument>, <argument><expr><name>leader_host</name></expr></argument>, <argument><expr><name>leader_port</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>state_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>consensus_get_state</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CONSENSUS_STATE_LEADER</name> <operator>&amp;&amp;</operator>
					<call><name>consensus_get_in_smart_shutdown</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>state_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>state_change</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>consensus_set_state</name><argument_list>(<argument><expr><name>CONSENSUS_STATE_FOLLOWER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>current_append_term</name> <operator>=</operator> <call><name>ConsensusLOGGetLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ConsensusLOGGetLastLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_write_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_write_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>state_change</name> <operator>&amp;&amp;</operator> <name>leader_id</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>leader_addr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
			<call><name>consensus_get_state</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CONSENSUS_STATE_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>current_append_term</name> <operator>=</operator> <call><name>ConsensusLOGGetLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLogTerm</name></name> <operator>!=</operator> <name>current_append_term</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Consensus log term changed, current log term: %llu,"</literal>
					<literal type="string">" old log term: %llu"</literal></expr></argument>, <argument><expr><name>current_append_term</name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLogTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>consensus_covert_server_address</name><argument_list>(<argument><expr><name>leader_addr</name></expr></argument>, <argument><expr><name>leader_host</name></expr></argument>, <argument><expr><name>leader_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ConsensusLOGGetLastLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_write_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_write_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>state_change</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>state_change</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>xlog_flushed_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>xlog_flushed_tli</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>committed_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>committed_tli</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Consensus try signal Postmaster, term: %llu,"</literal>
				<literal type="string">" leader: %lu, logTerm: %llu, logUpto: %X/%X, logTLI: %u"</literal></expr></argument>,
				<argument><expr><name>term</name></expr></argument>, <argument><expr><name>leader_id</name></expr></argument>, <argument><expr><name>current_append_term</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>last_write_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>last_write_lsn</name></expr></argument>, <argument><expr><name>last_write_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>ConsensusGetXLogFlushedLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlog_flushed_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlog_flushed_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xlog_flushed_tli</name> <operator>&gt;=</operator> <name>last_write_timeline</name> <operator>&amp;&amp;</operator> <name>xlog_flushed_lsn</name> <operator>&gt;=</operator> <name>last_write_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>ConsensusGetSyncedLSNAndTLI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>committed_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>committed_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if synced point beyond last entry point, advance switch point */</comment>
		<if_stmt><if>if <condition>(<expr><name>committed_tli</name> <operator>&gt;</operator> <name>last_write_timeline</name> <operator>||</operator> <name>committed_lsn</name> <operator>&gt;</operator> <name>last_write_lsn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_write_timeline</name> <operator>=</operator> <name>committed_tli</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_write_lsn</name> <operator>=</operator> <name>committed_lsn</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Consensus advance logUpto, term: %llu,"</literal>
					<literal type="string">" leader: %lu, logTerm: %llu, logUpto: %X/%X, logTLI: %u"</literal></expr></argument>,
					<argument><expr><name>term</name></expr></argument>, <argument><expr><name>leader_id</name></expr></argument>, <argument><expr><name>current_append_term</name></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>last_write_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>last_write_lsn</name></expr></argument>, <argument><expr><name>last_write_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_signal_pm_state_change</name><argument_list>(<argument><expr><call><name>consensus_get_state</name><argument_list>()</argument_list></call></expr></argument>,
				<argument><expr><name>leader_host</name></expr></argument>, <argument><expr><operator>*</operator><name>leader_port</name></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>current_append_term</name></expr></argument>,
				<argument><expr><name>last_write_timeline</name></expr></argument>, <argument><expr><name>last_write_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name> <operator>=</operator> <name>term</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLeaderId</name></name> <operator>=</operator> <name>leader_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLogTerm</name></name> <operator>=</operator> <name>current_append_term</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>!</operator><operator>(</operator><name>leader_id</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_try_synchronizing_flush_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>xlog_flushed_lsn</name></decl>,
							<decl><type ref="prev"/><name>last_append_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>xlog_flushed_tli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>index</name></decl>,
							<decl><type ref="prev"/><name>term</name></decl>,
							<decl><type ref="prev"/><name>xlog_term</name></decl>,
							<decl><type ref="prev"/><name>consensus_term</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConsensusLogPayload</name></type> <name>consensus_log_payload</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lock xlog term shared and check XLog state change finished.
	 * set consensus log term, then append the flushed point to x-paxos
	 */</comment>
	<expr_stmt><expr><call><name>ConsensusLockXLogTermShared</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>consensus_get_state</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>CONSENSUS_STATE_LEADER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusUnlockXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>xlog_term</name> <operator>=</operator> <call><name>ConsensusGetXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>consensus_term</name> <operator>=</operator> <call><name>ConsensusLOGGetTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xlog_term</name> <operator>&lt;</operator> <name>consensus_term</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusUnlockXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"consensus_try_synchronizing_flush_lsn, Append log entry "</literal>
				<literal type="string">"ignore, consensus term: %llu, xlog_term: %llu"</literal></expr></argument>, <argument><expr><name>consensus_term</name></expr></argument>, <argument><expr><name>xlog_term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>last_append_lsn</name> <operator>=</operator> <call><name>consensus_get_appended_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConsensusGetXLogFlushedLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlog_flushed_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlog_flushed_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xlog_flushed_lsn</name> <operator>&lt;=</operator> <name>last_append_lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusUnlockXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"consensus_try_synchronizing_flush_lsn, Append log entry "</literal>
				<literal type="string">"ignore, xlog flushed lsn: %X/%X timeline %u, last_append_lsn: %X/%X"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>xlog_flushed_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>xlog_flushed_lsn</name></expr></argument>, <argument><expr><name>xlog_flushed_tli</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>last_append_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>last_append_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"begin to append entry, append_lsn: %X/%X, append_tli: %u"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>xlog_flushed_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>xlog_flushed_lsn</name></expr></argument>,
			<argument><expr><name>xlog_flushed_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
	<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_appends</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ConsensusLOGNormalPayloadInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>consensus_log_payload</name></expr></argument>,
			<argument><expr><name>xlog_flushed_lsn</name></expr></argument>, <argument><expr><name>xlog_flushed_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>consensus_append_normal_entry</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>term</name></expr></argument>,
					<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>consensus_log_payload</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>consensus_log_payload</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusUnlockXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>CONSENSUS_NOT_LEADER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"consensus_try_synchronizing_flush_lsn, Append log entry "</literal>
					<literal type="string">"ignore, this server may be not leader now!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* requested votes since last state check. to append in the next loop. */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Or we have a problem. Report and crash. */</comment>
		<expr_stmt><expr><call><name>easy_fatal_log</name><argument_list>(<argument><expr><literal type="string">"Unexpected error in consensus library"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ConsensusUnlockXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>consensus_set_appended_lsn</name><argument_list>(<argument><expr><name>xlog_flushed_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"consensus_try_synchronizing_flush_lsn, Append log entry "</literal>
			<literal type="string">"term: %llu, index: %llu, lsn: %X/%X, timeline: %u"</literal></expr></argument>, <argument><expr><name>term</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>xlog_flushed_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>xlog_flushed_lsn</name></expr></argument>,
			<argument><expr><name>xlog_flushed_tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type>
<name>ConsensusGetCommitIndex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>uint64</name></type> <name>commit_index</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commit_index</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>commitIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>commit_index</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>commitIndex</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusSetCommitIndex</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>commit_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>commitIndex</name></name> <operator>=</operator> <name>commit_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>commitIndex</name></name></expr></argument>, <argument><expr><name>commit_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_wait_for_next_entry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>commit_timeline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>last_committed_index</name> <init>= <expr><call><name>ConsensusGetCommitIndex</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus begin wait for commit, last commit index %llu, current state term %llu"</literal></expr></argument>,
			<argument><expr><name>last_committed_index</name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ConsensusGetXLogTerm</name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_commit_waits</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_commit_wait_time</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>index</name> <operator>=</operator> <call><name>consensus_wait_for_commit</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
						<argument><expr><name>last_committed_index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Consensus term change when wait for commit, index %llu"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Term changed, let our caller perform state transition */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>HISTORIC_COMMIT_ADVANCE_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>xlog_transit_waits</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>consensus_get_commit_index</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"Consensus finish waitting for commit, current commit index %llu, "</literal>
			<literal type="string">"last commit index %llu, current state term %llu"</literal></expr></argument>,
			<argument><expr><name>index</name></expr></argument>, <argument><expr><name>last_committed_index</name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we now a new batch of committed indexes, find and update flush lsn. */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name>last_committed_index</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>old_commit_lsn</name> <init>= <expr><call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>consensus_log_get_entry_lsn</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"Advance committed lsn: %X/%X timeline: %u, old committed lsn: %X/%X"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>commit_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>commit_lsn</name></expr></argument>, <argument><expr><name>commit_timeline</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>old_commit_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>old_commit_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConsensusMetaSetInt64</name><argument_list>(<argument><expr><name>CommitIndexMetaKey</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>commit_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator> <name>commit_timeline</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConsensusSetSyncedLSN</name><argument_list>(<argument><expr><name>commit_lsn</name></expr></argument>, <argument><expr><name>commit_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ConsensusSetCommitIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Locked consensus log term before call this function.
 */</comment>
<function><type><name>bool</name></type>
<name>consensus_check_physical_flush_lsn</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>term</name></decl></parameter>,
		<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>physical_flush_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type> <name>physical_flush_timeline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>physical_flush_term</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_retries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_retries</name> <init>= <expr><call><name>consensus_get_flush_wait_timeout</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>physical_flush_term</name> <operator>=</operator> <call><name>ConsensusGetXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConsensusGetXLogFlushedLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>physical_flush_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>physical_flush_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"consensus_check_physical_flush_lsn, physical_flush_term: %llu, "</literal>
			<literal type="string">"physical_flush_lsn: %X/%X timeline %u, term: %llu, lsn: %X/%X"</literal></expr></argument>,
			<argument><expr><name>physical_flush_term</name></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>physical_flush_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>physical_flush_lsn</name></expr></argument>, <argument><expr><name>physical_flush_timeline</name></expr></argument>,
			<argument><expr><name>term</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>physical_flush_term</name> <operator>&gt;=</operator> <name>term</name> <operator>&amp;&amp;</operator>
			<name>physical_flush_lsn</name> <operator>&gt;=</operator> <name>lsn</name> <operator>&amp;&amp;</operator>
			<name>physical_flush_timeline</name> <operator>&gt;=</operator> <name>tli</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"consensus_check_physical_flush_lsn success. "</literal>
				<literal type="string">"physical_flush_term: %llu, physical_flush_lsn: %X/%X, physical_flush_timeline: %u"</literal>
				<literal type="string">"check_term: %llu, check_lsn: %X/%X, check_timeline: %u"</literal></expr></argument>,
				<argument><expr><name>physical_flush_term</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>physical_flush_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>physical_flush_lsn</name></expr></argument>, <argument><expr><name>physical_flush_timeline</name></expr></argument>,
				<argument><expr><name>term</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_check_physical_flush_lsn failed without retry. "</literal>
				<literal type="string">"physical_flush_term: %llu, physical_flush_lsn: %X/%X timeline %u, "</literal>
				<literal type="string">"check_term: %llu, check_lsn: %X/%X, check_timeline: %u"</literal></expr></argument>,
				<argument><expr><name>physical_flush_term</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>physical_flush_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>physical_flush_lsn</name></expr></argument>, <argument><expr><name>physical_flush_timeline</name></expr></argument>,
				<argument><expr><name>term</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>XLOG_STREAMING_CHECK_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_retries</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>xlog_flush_waits</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>ConsensusGetXLogFlushedLSN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>physical_flush_lsn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>physical_flush_timeline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>physical_flush_term</name> <operator>=</operator> <call><name>ConsensusGetXLogTerm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>num_retries</name> <operator>&lt;</operator> <name>total_retries</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>physical_flush_term</name> <operator>&lt;</operator> <name>term</name> <operator>||</operator> <name>physical_flush_lsn</name> <operator>&lt;</operator> <name>lsn</name> <operator>||</operator> <name>physical_flush_timeline</name> <operator>&lt;</operator> <name>tli</name><operator>)</operator></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>num_retries</name> <operator>&gt;=</operator> <name>total_retries</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"consensus_check_physical_flush_lsn wait timeout after %d retries, "</literal>
				<literal type="string">"physical_flush_term: %llu, physical_flush_lsn: %X/%X timeline: %u, "</literal>
				<literal type="string">"check_term: %llu, check_lsn: %X/%X, check_timeline: %u"</literal></expr></argument>,
				<argument><expr><name>num_retries</name></expr></argument>, <argument><expr><name>physical_flush_term</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>physical_flush_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>physical_flush_lsn</name></expr></argument>, <argument><expr><name>physical_flush_timeline</name></expr></argument>,
				<argument><expr><name>term</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_debug_log</name><argument_list>(<argument><expr><literal type="string">"consensus_check_physical_flush_lsn success after %d retries. "</literal>
				<literal type="string">"physical_flush_term: %llu, physical_flush_lsn: %X/%X timeline %u, "</literal>
				<literal type="string">"check_term: %llu, check_lsn: %X/%X, check_timeline: %u"</literal></expr></argument>,
				<argument><expr><name>num_retries</name></expr></argument>, <argument><expr><name>physical_flush_term</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>physical_flush_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>physical_flush_lsn</name></expr></argument>, <argument><expr><name>physical_flush_timeline</name></expr></argument>,
				<argument><expr><name>term</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>, <argument><expr><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>consensus_get_commit_wait_queue_length</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while<condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
										  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>,
										  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_wakeup_backends</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>all</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>thisproc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>flush</name> <init>= <expr><call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
	<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_wakeups</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>proc</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name> <operator>&amp;&amp;</operator> <name>flush</name> <operator>&lt;</operator> <name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitLSN</name></name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>thisproc</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
				<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SHMQueueIsDetached</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifndef>
		<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stats</name><operator>.</operator><name>consensus_backend_wakeups</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Notify the process. */</comment>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_get_wait_tv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>abstime</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wait_us</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>now</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>abstime</name><operator>-&gt;</operator><name>tv_nsec</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>+</operator> <name>wait_us</name><operator>)</operator> <operator>%</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>abstime</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <operator>(</operator><name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>+</operator> <name>wait_us</name><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_cancel_wait</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SHMQueueIsDetached</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for the flush lsn to be raised above the given lsn argument.
 * return true if committed success or wait timeout
 * Note: Only if the database shutdown or restart, this function return false
 */</comment>
<function><type><name>bool</name></type>
<name>ConsensusWaitForLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flush</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	<modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>abstime</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flush</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ConsensusWakeupCommit</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueuePrev</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>proc</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitLSN</name></name> <operator>&lt;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitLSN</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueuePrev</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>,
				<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>proc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueInsertAfter</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueInsertAfter</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>waitQueue</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ConsensusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>commit_lsn</name> <operator>=</operator> <call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_CONSENSUS_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while<condition>(<expr><name>commit_lsn</name> <operator>&lt;</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_get_wait_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>, <argument><expr><name>CONSENSUS_COMMIT_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>commit_lsn</name> <operator>=</operator> <call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>commit_lsn</name> <operator>&gt;=</operator> <name>lsn</name> <operator>||</operator> <operator>!</operator><name>flush</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flush</name> <operator>&amp;&amp;</operator> <name>ProcDiePending</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>commit_lsn</name> <operator>=</operator> <call><name>ConsensusGetSyncedLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>consensus_cancel_wait</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitLSN</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>commit_lsn</name> <operator>&gt;=</operator> <name>lsn</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ConsensusWakeupCommit</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>rqstLSN</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>consensusPid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rqstLSN</name> <operator>&gt;</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncRqstLSN</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncRqstLSN</name></name> <operator>=</operator> <name>rqstLSN</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncSuspending</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConsensusLockXLogTermShared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConsensusUnlockXLogTerm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>uint64</name></type>
<name>ConsensusGetXLogTerm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>term</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>term</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlogTerm</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>term</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusSetXLogTerm</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>term</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlogTerm</name></name> <operator>=</operator> <name>term</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_term_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"XLog term changed, term: %lu"</literal></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Only called by postgres backend or consensus main thread */</comment>
<function><type><name>void</name></type>
<name>ConsensusSetXLogFlushedLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>flush_lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>flush_timeline</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator>
			<name>flush_lsn</name> <operator>&gt;</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushedLSN</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushedLSN</name></name> <operator>=</operator> <name>flush_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushedTLI</name></name> <operator>=</operator> <name>flush_timeline</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>update</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"XLog flushed point advanced, timeline %u, LSN: %X/%X"</literal></expr></argument>,
						<argument><expr><name>flush_timeline</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>flush_lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
						<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flush_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusGetXLogFlushedLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>flush_lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>flush_timeline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>flush_lsn</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushedLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>flush_timeline</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushedTLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_set_flush_wait_timeout</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>wait_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushWaitTimeout</name></name> <operator>=</operator> <name>wait_time</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushWaitTimeout</name></name></expr></argument>, <argument><expr><name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>consensus_get_flush_wait_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>uint64</name></type> <name>wait_time</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushWaitTimeout</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>xlog_flush_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>wait_time</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>flushWaitTimeout</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_set_appended_lsn</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>append_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentAppendedLSN</name></name> <operator>=</operator> <name>append_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentAppendedLSN</name></name></expr></argument>, <argument><expr><name>append_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>consensus_get_appended_lsn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>appendedLSN</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>appendedLSN</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentAppendedLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>appendedLSN</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentAppendedLSN</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_set_state</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentState</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentState</name></name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>consensus_get_state</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PG_HAVE_ATOMIC_U64_SIMULATION</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentState</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>state</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentState</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_set_in_smart_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>inSmartShutdown</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_get_in_smart_shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>inSmartShutdown</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_get_current_status</name><parameter_list>(<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>term</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>leader_id</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>log_term</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>term</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentStateTerm</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>leader_id</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLeaderId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>log_term</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>currentLogTerm</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>current_status_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusSetSyncedLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedLSN</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedTLI</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusGetSyncedLSNAndTLI</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>tli</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lsn</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tli</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedTLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>ConsensusGetSyncedLSN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>syncedLSN</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>syncedLSN</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncedLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>syncedLSN</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusSetPurgeLSN</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>purgeLSN</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>purgeLSN</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>easy_info_log</name><argument_list>(<argument><expr><literal type="string">"consensus_set_purge_lsn, lsn: %X/%X"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>XLogRecPtr</name></type>
<name>ConsensusGetPurgeLSN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>purgeLSN</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>purgeLSN</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>purgeLSN</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>cs_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>purgeLSN</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ConsensusCheckpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>consensusPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusGetMemberInfo</name><parameter_list>(<parameter><decl><type><name>ConsensusMemberInfo</name> <modifier>*</modifier></type><name>member_info</name></decl></parameter>)</parameter_list>
 <block>{<block_content>
	 <expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	 <expr_stmt><expr><operator>*</operator><name>member_info</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>memberInfo</name></name></expr>;</expr_stmt>
	 <expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ConsensusGetClusterInfo</name><parameter_list>(<parameter><decl><type><name>ConsensusClusterInfo</name> <modifier>*</modifier></type><name>cluster_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>numCluster</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numCluster</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>numCluster</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cluster_info</name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>clusterInfo</name></name></expr></argument>,
			<argument><expr><name>numCluster</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConsensusClusterInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>numCluster</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ConsensusGetStatsInfo</name><parameter_list>(<parameter><decl><type><name>ConsensusStatsInfo</name> <modifier>*</modifier></type><name>stats_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_rwlock_rdlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>stats_info</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statsInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>consensus_get_stat_collect_queue_length</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 	<name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> 	<modifier>*</modifier></type><name>proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>,
			<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>proc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>,
				<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consesus_cancel_stat_collect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SHMQueueIsDetached</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ConsensusWaitForStatCollect</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>info_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>abstime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>|=</operator> <name>info_flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SHMQueueInsertAfter</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while<condition>(<expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consesus_cancel_stat_collect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling the wait for consensus stat fetch and "</literal>
						 <literal type="string">"terminating connection due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consesus_cancel_stat_collect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling wait for consensus stat fetch due to user request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consesus_cancel_stat_collect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>consensus_get_wait_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>, <argument><expr><name>CONSENSUS_STAT_FETCH_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>consesus_cancel_stat_collect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>consesus_cancel_consensus_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_wait_for_command</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cmd_type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args1</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>args2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>abstime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstInstage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>=</operator> <name>cmd_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>args1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>args1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmd_type</name> <operator>==</operator> <name>CONSENSUS_CHANGE_WEIGHT_CONFIG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>args2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>args2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cmd_type</name> <operator>==</operator> <name>CONSENSUS_CHANGE_MATCH_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>args2</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator><name>args2</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>wait_cond_mutex</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>wait_cond</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* signal consensus cmd request handler */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while<condition>(<expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ProcDiePending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>consesus_cancel_consensus_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstInstage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling the wait for consensus command and "</literal>
						 <literal type="string">"terminating connection due to administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>consesus_cancel_consensus_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstInstage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling wait for consesus command due to user request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ProcDiePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>consensus_get_wait_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>, <argument><expr><name>CONSENSUS_COMMAND_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>consesus_cancel_consensus_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstInstage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to execute consensus command: %s"</literal></expr></argument>,
				 <argument><expr><call><name>consensus_get_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>MyProc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_handle_stat_request</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>thisproc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pthread_rwlock_wrlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>&amp;</operator> <name>POLAR_DMA_STAT_MEMBER_INFO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_get_member_info</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>memberInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>&amp;</operator> <name>POLAR_DMA_STAT_CLUSTER_INFO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>numCluster</name></name> <operator>=</operator> <call><name>consensus_get_cluster_info</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
														  <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>clusterInfo</name></name></expr></argument>,
														  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>clusterInfo</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>&amp;</operator> <name>POLAR_DMA_STATS_INFO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_get_stats_info</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statsInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_rwlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>,
								   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>,
								   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>thisproc</name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstQueue</name></name><operator>)</operator></expr></argument>,
									   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>,
									   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SHMQueueIsDetached</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>waitQueueElem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Notify the process. */</comment>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thisproc</name><operator>-&gt;</operator><name>consensusInfo</name><operator>.</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>statRqstFlag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>consensus_handle_cmd_request</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_TRANSFER_LEADER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_transfer_leader: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator>
			<call><name>consensus_transfer_leader</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_ADD_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_add_follower: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_member</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name>CONFIGURE_MEMBER_ADD_FOLLOWER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_DROP_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_drop_follower: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_member</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name>CONFIGURE_MEMBER_DROP_FOLLOWER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_ADD_LEARNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_add_learner: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_learner</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name>CONFIGURE_LEARNER_ADD_LEARNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_DROP_LEARNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_drop_learner: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_learner</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name>CONFIGURE_LEARNER_DROP_LEARNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_CHANGE_LEARNER_TO_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_change_learner_to_follower: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_member</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name>CONFIGURE_MEMBER_CHANGE_LEARNER_TO_FOLLOWER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_CHANGE_FOLLOWER_TO_LEARNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_change_follower_to_learner: %s"</literal></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_downgrade_member</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_CHANGE_WEIGHT_CONFIG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_change_election_weigth: %s, %d"</literal></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_configure_member</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_REQUEST_VOTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_request_vote"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_request_vote</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_FORCE_SIGNLE_MODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_force_single_mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_to_single_mode</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_CHANGE_MATCH_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_change_match_index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_match_index</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>nodeInfo</name></name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_PURGE_LOGS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_purge_logs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_purge_logs</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_FORCE_PURGE_LOGS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_force_purge_logs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ConsensusLOGTruncateForward</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>==</operator> <name>CONSENSUS_CHANGE_CLUSTER_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>easy_warn_log</name><argument_list>(<argument><expr><literal type="string">"consensus_change_cluster_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>responce</name></name> <operator>=</operator> <call><name>consensus_change_cluster_id</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>,
				<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Notify the process. */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>finished</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>finished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>wait_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>wait_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqstType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>
<name>consensus_command_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>abstime</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>shutdown_requested</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_get_wait_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>, <argument><expr><name>CONSENSUS_CHECK_SHUTDOWN_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>rqst_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>consensus_handle_cmd_request</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>
<name>consensus_stat_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>abstime</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>shutdown_requested</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_get_wait_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>, <argument><expr><name>CONSENSUS_CHECK_SHUTDOWN_INTERVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>stat_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>consensus_handle_stat_request</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>consensus_append_log_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>do_wait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>abstime</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>shutdown_requested</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>do_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>consensus_get_state</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CONSENSUS_STATE_LEADER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>do_wait</name> <operator>=</operator> <call><name>consensus_try_synchronizing_flush_lsn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>do_wait</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>consensus_get_wait_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>, <argument><expr><name>CONSENSUS_SYNC_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncRqstLSN</name></name> <operator>&lt;=</operator> <call><name>consensus_get_appended_lsn</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncSuspending</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pthread_cond_timedwait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>abstime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>syncSuspending</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConsensusCtl</name><operator>-&gt;</operator><name>sync_cond_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_xlog_check_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_set_flush_wait_timeout</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_send_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_SEND_TIMEOUT</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_pipeline_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_PIPELINE_TIMEOUT</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_config_change_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_CONFIG_CHANGE_TIMEOUT</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_delay_election_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_DELAY_ELECTION_TIMEOUT</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_max_packet_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_MAX_PACKET_SIZE</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_new_follower_threshold</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_NEW_FOLLOWER_THRESHOLD</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_max_delay_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_MAX_DELAY_INDEX</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_min_delay_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_MIN_DELAY_INDEX</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_log_level</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_int</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_INT_LOG_LEVEL</name></expr></argument>,
				<argument><expr><call><name>convert_log_messages_to_easy_level</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_log_keep_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ConsensusLOGSetKeepSize</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_auto_leader_transfer</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_bool</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_BOOL_AUTO_LEADER_TRANSFER</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_disable_election</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_bool</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_BOOL_DISABLE_ELECTION</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_dma_delay_election</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>consensusHandle</name> <operator>!=</operator> <name>INVALID_CONSENSUS_HANDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>consensus_assign_conf_bool</name><argument_list>(<argument><expr><name>consensusHandle</name></expr></argument>, <argument><expr><name>ASSIGN_BOOL_DELAY_ELECTION</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_polar_dma_repl_password</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>	<name><name>crypt_pwd</name><index>[<expr><name>MD5_PASSWD_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_encrypt</name><argument_list>(<argument><expr><name>polar_dma_repl_user</name></expr></argument>, <argument><expr><name>polar_dma_repl_password</name></expr></argument>,
				<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>polar_dma_repl_password</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>crypt_pwd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"unavailable"</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>crypt_pwd</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>consensus_command_disabled_on_logger</name><parameter_list>(<parameter><decl><type><name>DMACommandKind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_ADD_FOLLOWER</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_DROP_FOLLOWER</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_ADD_LEARNER</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_DROP_LEARNER</name><operator>)</operator> <operator>||</operator>
		<comment type="line">// CC_REQUEST_VOTE</comment>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_CHANGE_LEARNER_TO_FOLLOWER</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_CHANGE_FOLLOWER_TO_LEARNER</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_CHANGE_WEIGHT_CONFIG</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>kind</name> <operator>==</operator> <name>CC_FORCE_SIGNLE_MODE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>PolarDMAUtility</name><parameter_list>(<parameter><decl><type><name>PolarDMACommandStmt</name> <modifier>*</modifier></type><name>dma_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>consensus_node_info</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to execute ALTER SYSTEM command"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_is_dma_logger_node</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>consensus_command_disabled_on_logger</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute this DMA command on logger node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_TRANSFER_LEADER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_TRANSFER_LEADER</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_ADD_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_ADD_FOLLOWER</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_ADD_LEARNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_ADD_LEARNER</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_DROP_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_DROP_FOLLOWER</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_DROP_LEARNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_DROP_LEARNER</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_CHANGE_LEARNER_TO_FOLLOWER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_CHANGE_LEARNER_TO_FOLLOWER</name></expr></argument>,
				<argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_CHANGE_FOLLOWER_TO_LEARNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_CHANGE_FOLLOWER_TO_LEARNER</name></expr></argument>,
				<argument><expr><name>consensus_node_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_FORCE_SIGNLE_MODE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_FORCE_SIGNLE_MODE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_CHANGE_WEIGHT_CONFIG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_CHANGE_WEIGHT_CONFIG</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>dma_stmt</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_CHANGE_MATCH_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>consensus_check_and_convert_member_info</name><argument_list>(<argument><expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>consensus_node_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_CHANGE_MATCH_INDEX</name></expr></argument>, <argument><expr><name>consensus_node_info</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name><name>dma_stmt</name><operator>-&gt;</operator><name>matchindex</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_REQUEST_VOTE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_REQUEST_VOTE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_PURGE_LOGS</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_PURGE_LOGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dma_stmt</name><operator>-&gt;</operator><name>purgeindex</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_FORCE_PURGE_LOGS</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_FORCE_PURGE_LOGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dma_stmt</name><operator>-&gt;</operator><name>purgeindex</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dma_stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>CC_CHANGE_CLUSTER_ID</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>consensus_wait_for_command</name><argument_list>(<argument><expr><name>CONSENSUS_CHANGE_CLUSTER_ID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dma_stmt</name><operator>-&gt;</operator><name>clusterid</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


</unit>
