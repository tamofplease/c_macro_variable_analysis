<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/parser/parse_func.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_func.c
 *		handle function calls in parser
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_func.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unify_hypothetical_args</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fargs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numAggregatedArgs</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>FuncNameAsType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>ParseComplexProjection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
					   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>first_arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	Parse a function call
 *
 *	For historical reasons, Postgres tries to treat the notations tab.col
 *	and col(tab) as equivalent: if a single-argument function call has an
 *	argument of complex type and the (unqualified) function name matches
 *	any attribute of the type, we can interpret it as a column projection.
 *	Conversely a function of a single complex-type argument can be written
 *	like a column reference, allowing functions to act like computed columns.
 *
 *	If both interpretations are possible, we prefer the one matching the
 *	syntactic form, but otherwise the form does not matter.
 *
 *	Hence, both cases come through here.  If fn is null, we're dealing with
 *	column syntax not function syntax.  In the function-syntax case,
 *	the FuncCall struct is needed to carry various decoration that applies
 *	to aggregate and window functions.
 *
 *	Also, when fn is null, we return NULL on failure rather than
 *	reporting a no-such-function error.
 *
 *	The argument expressions (in fargs) must have been transformed
 *	already.  However, nothing in *fn has been transformed.
 *
 *	last_srf should be a copy of pstate-&gt;p_last_srf from just before we
 *	started transforming fargs.  If the caller knows that fargs couldn't
 *	contain any SRF calls, last_srf can just be pstate-&gt;p_last_srf.
 *
 *	proc_call is true if we are considering a CALL statement, so that the
 *	name must resolve to a procedure name, not anything else.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ParseFuncOrColumn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fargs</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>proc_call</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_column</name> <init>= <expr><operator>(</operator><name>fn</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>agg_order</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>fn</name></expr> ?</condition><then> <expr><name><name>fn</name><operator>-&gt;</operator><name>agg_order</name></name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>agg_filter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>agg_within_group</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>fn</name></expr> ?</condition><then> <expr><name><name>fn</name><operator>-&gt;</operator><name>agg_within_group</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>agg_star</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>fn</name></expr> ?</condition><then> <expr><name><name>fn</name><operator>-&gt;</operator><name>agg_star</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>agg_distinct</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>fn</name></expr> ?</condition><then> <expr><name><name>fn</name><operator>-&gt;</operator><name>agg_distinct</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>func_variadic</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>fn</name></expr> ?</condition><then> <expr><name><name>fn</name><operator>-&gt;</operator><name>func_variadic</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>over</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>fn</name></expr> ?</condition><then> <expr><name><name>fn</name><operator>-&gt;</operator><name>over</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>could_be_projection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nextl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>first_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargsplusdefs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>actual_arg_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>declared_arg_types</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argdefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>vatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>fdresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggkind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If there's an aggregate filter, transform it using transformWhereClause
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fn</name> <operator>&amp;&amp;</operator> <name><name>fn</name><operator>-&gt;</operator><name>agg_filter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>agg_filter</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>agg_filter</name></name></expr></argument>,
												   <argument><expr><name>EXPR_KIND_FILTER</name></expr></argument>,
												   <argument><expr><literal type="string">"FILTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Most of the rest of the parser just assumes that functions do not have
	 * more than FUNC_MAX_ARGS parameters.  We have to test here to protect
	 * against array overruns, etc.  Of course, this may not be a function,
	 * but the test doesn't hurt.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a function"</literal></expr></argument>,
							   <argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract arg type info in preparation for function lookup.
	 *
	 * If any arguments are Param markers of type VOID, we discard them from
	 * the parameter list. This is a hack to allow the JDBC driver to not have
	 * to distinguish "input" and "output" parameter symbols while parsing
	 * function-call constructs.  Don't do this if dealing with column syntax,
	 * nor if we had WITHIN GROUP (because in that case it's critical to keep
	 * the argument count unchanged).  We can't use foreach() because we may
	 * modify the list ...
	 */</comment>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>nextl</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>==</operator> <name>VOIDOID</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>is_column</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>agg_within_group</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fargs</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><name>nargs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>argtype</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Check for named arguments; if there are any, build a list of names.
	 *
	 * We allow mixed notation (some named and some not), but only with all
	 * the named parameters after all the unnamed ones.  So the name list
	 * corresponds to the last N actual parameters and we don't need any extra
	 * bookkeeping to match things up.
	 */</comment>
	<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>fargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/* Reject duplicate arg names */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>argnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>na</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument name \"%s\" used more than once"</literal></expr></argument>,
									<argument><expr><name><name>na</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>na</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>argnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name><name>na</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>argnames</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"positional argument cannot follow named argument"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>fargs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>first_arg</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_arg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
 	 * POLAR: When creating rule, no-super user can put system functions into
 	 * rule view, so when superuser select this rule view, that will execute
 	 * system functions, it is unsafe, so we must filter so functions.
 	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_creating_rule</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>polar_check_is_forbidden_funcs</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for function %s during creating rule"</literal></expr></argument>,
					 <argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
						 							<argument><expr><name>argnames</name></expr></argument>,
													<argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Decide whether it's legitimate to consider the construct to be a column
	 * projection.  For that, there has to be a single argument of complex
	 * type, the function name must not be qualified, and there cannot be any
	 * syntactic decoration that'd require it to be a function (such as
	 * aggregate or variadic decoration, or named arguments).
	 */</comment>
	<expr_stmt><expr><name>could_be_projection</name> <operator>=</operator> <operator>(</operator><name>nargs</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>proc_call</name> <operator>&amp;&amp;</operator>
						   <name>agg_order</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>agg_filter</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						   <operator>!</operator><name>agg_star</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>agg_distinct</name> <operator>&amp;&amp;</operator> <name>over</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						   <operator>!</operator><name>func_variadic</name> <operator>&amp;&amp;</operator> <name>argnames</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
						   <call><name>list_length</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name><name>actual_arg_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator>
							<call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name><name>actual_arg_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's column syntax, check for column projection case first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>could_be_projection</name> <operator>&amp;&amp;</operator> <name>is_column</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>ParseComplexProjection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>first_arg</name></expr></argument>,
										<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>retval</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If ParseComplexProjection doesn't recognize it as a projection,
		 * just press on.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * func_get_detail looks up the function in the catalogs, does
	 * disambiguation for polymorphic functions, handles inheritance, and
	 * returns the funcid and type and set or singleton status of the
	 * function's return value.  It also returns the true argument types to
	 * the function.
	 *
	 * Note: for a named-notation or variadic function call, the reported
	 * "true" types aren't really what is in pg_proc: the types are reordered
	 * to match the given argument order of named arguments, and a variadic
	 * argument is replaced by a suitable number of copies of its element
	 * type.  We'll fix up the variadic case below.  We may also have to deal
	 * with default arguments.
	 */</comment>

	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fdresult</name> <operator>=</operator> <call><name>func_get_detail</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
							   <argument><expr><name>actual_arg_types</name></expr></argument>,
							   <argument><expr><operator>!</operator><name>func_variadic</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retset</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>nvargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vatype</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>declared_arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for various wrong-kind-of-routine cases.
	 */</comment>

	<comment type="block">/* If this is a CALL, reject things that aren't procedures */</comment>
	<if_stmt><if>if <condition>(<expr><name>proc_call</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator>
		 <name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_AGGREGATE</name> <operator>||</operator>
		 <name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_WINDOWFUNC</name> <operator>||</operator>
		 <name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_COERCION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a procedure"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>argnames</name></expr></argument>,
											  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To call a function, use SELECT."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Conversely, if not a CALL, reject procedures */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_PROCEDURE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>proc_call</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is a procedure"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>argnames</name></expr></argument>,
											  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To call a procedure, use CALL."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator>
		<name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_PROCEDURE</name> <operator>||</operator>
		<name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_COERCION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In these cases, complain if there was anything indicating it must
		 * be an aggregate or window function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>agg_star</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s(*) specified, but %s is not an aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>agg_distinct</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DISTINCT specified, but %s is not an aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>agg_within_group</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITHIN GROUP specified, but %s is not an aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>agg_order</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ORDER BY specified, but %s is not an aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>agg_filter</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FILTER specified, but %s is not an aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>over</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OVER specified, but %s is not a window function nor an aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * So far so good, so do some fdresult-type-specific processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator> <name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_PROCEDURE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing special to do for these cases. */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_AGGREGATE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's an aggregate; fetch needed info from the pg_aggregate entry.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>classForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>catDirectArgs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggkind</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>aggkind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>catDirectArgs</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>aggnumdirectargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now check various disallowed cases. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>numAggregatedArgs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numDirectArgs</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>agg_within_group</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITHIN GROUP is required for ordered-set aggregate %s"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>over</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"OVER is not supported for ordered-set aggregate %s"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* gram.y rejects DISTINCT + WITHIN GROUP */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* gram.y rejects VARIADIC + WITHIN GROUP */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>func_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since func_get_detail was working with an undifferentiated list
			 * of arguments, it might have selected an aggregate that doesn't
			 * really match because it requires a different division of direct
			 * and aggregated arguments.  Check that the number of direct
			 * arguments is actually OK; if not, throw an "undefined function"
			 * error, similarly to the case where a misplaced ORDER BY is used
			 * in a regular aggregate call.
			 */</comment>
			<expr_stmt><expr><name>numAggregatedArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>agg_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <name>nargs</name> <operator>-</operator> <name>numAggregatedArgs</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numDirectArgs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>vatype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Test is simple if aggregate isn't variadic */</comment>
				<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>!=</operator> <name>catDirectArgs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
									<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
														  <argument><expr><name>argnames</name></expr></argument>,
														  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There is an ordered-set aggregate %s, but it requires %d direct arguments, not %d."</literal></expr></argument>,
									 <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>catDirectArgs</name></expr></argument>, <argument><expr><name>numDirectArgs</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If it's variadic, we have two cases depending on whether
				 * the agg was "... ORDER BY VARIADIC" or "..., VARIADIC ORDER
				 * BY VARIADIC".  It's the latter if catDirectArgs equals
				 * pronargs; to save a catalog lookup, we reverse-engineer
				 * pronargs from the info we got from func_get_detail.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>pronargs</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pronargs</name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nvargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pronargs</name> <operator>-=</operator> <name>nvargs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>catDirectArgs</name> <operator>&lt;</operator> <name>pronargs</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* VARIADIC isn't part of direct args, so still easy */</comment>
					<if_stmt><if>if <condition>(<expr><name>numDirectArgs</name> <operator>!=</operator> <name>catDirectArgs</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
										<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
															  <argument><expr><name>argnames</name></expr></argument>,
															  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There is an ordered-set aggregate %s, but it requires %d direct arguments, not %d."</literal></expr></argument>,
										 <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>catDirectArgs</name></expr></argument>, <argument><expr><name>numDirectArgs</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Both direct and aggregated args were declared variadic.
					 * For a standard ordered-set aggregate, it's okay as long
					 * as there aren't too few direct args.  For a
					 * hypothetical-set aggregate, we assume that the
					 * hypothetical arguments are those that matched the
					 * variadic parameter; there must be just as many of them
					 * as there are aggregated arguments.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>aggkind</name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nvargs</name> <operator>!=</operator> <literal type="number">2</literal> <operator>*</operator> <name>numAggregatedArgs</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
											<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
																  <argument><expr><name>argnames</name></expr></argument>,
																  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To use the hypothetical-set aggregate %s, the number of hypothetical direct arguments (here %d) must match the number of ordering columns (here %d)."</literal></expr></argument>,
											 <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>nvargs</name> <operator>-</operator> <name>numAggregatedArgs</name></expr></argument>, <argument><expr><name>numAggregatedArgs</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nvargs</name> <operator>&lt;=</operator> <name>numAggregatedArgs</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
											<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
																  <argument><expr><name>argnames</name></expr></argument>,
																  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"There is an ordered-set aggregate %s, but it requires at least %d direct arguments."</literal></expr></argument>,
											 <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>catDirectArgs</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Check type matching of hypothetical arguments */</comment>
			<if_stmt><if>if <condition>(<expr><name>aggkind</name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>unify_hypothetical_args</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>numAggregatedArgs</name></expr></argument>,
										<argument><expr><name>actual_arg_types</name></expr></argument>, <argument><expr><name>declared_arg_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Normal aggregate, so it can't have WITHIN GROUP */</comment>
			<if_stmt><if>if <condition>(<expr><name>agg_within_group</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not an ordered-set aggregate, so it cannot have WITHIN GROUP"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_WINDOWFUNC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * True window functions must be called with a window definition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>over</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window function %s requires an OVER clause"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* And, per spec, WITHIN GROUP isn't allowed */</comment>
		<if_stmt><if>if <condition>(<expr><name>agg_within_group</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window function %s cannot have WITHIN GROUP"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_COERCION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We interpreted it as a type coercion. coerce_type can handle these
		 * cases, so why duplicate code...
		 */</comment>
		<return>return <expr><call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name><name>actual_arg_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_MULTIPLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We found multiple possible functional matches.  If we are dealing
		 * with attribute notation, return failure, letting the caller report
		 * "no such column" (we already determined there wasn't one).  If
		 * dealing with function notation, report "ambiguous function",
		 * regardless of whether there's also a column by this name.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_column</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>proc_call</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure %s is not unique"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>,
												  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Could not choose a best candidate procedure. "</literal>
							 <literal type="string">"You might need to add explicit type casts."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s is not unique"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>,
												  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Could not choose a best candidate function. "</literal>
							 <literal type="string">"You might need to add explicit type casts."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Not found as a function.  If we are dealing with attribute
		 * notation, return failure, letting the caller report "no such
		 * column" (we already determined there wasn't one).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_column</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check for column projection interpretation, since we didn't before.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>could_be_projection</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>ParseComplexProjection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>first_arg</name></expr></argument>,
											<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>retval</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * No function, and no column either.  Since we're dealing with
		 * function notation, report "function does not exist".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>agg_order</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>agg_within_group</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It's agg(x, ORDER BY y,z) ... perhaps misplaced ORDER BY */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>,
												  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"No aggregate function matches the given name and argument types. "</literal>
							 <literal type="string">"Perhaps you misplaced ORDER BY; ORDER BY must appear "</literal>
							 <literal type="string">"after all regular arguments of the aggregate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>proc_call</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure %s does not exist"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>,
												  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"No procedure matches the given name and argument types. "</literal>
							 <literal type="string">"You might need to add explicit type casts."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>,
												  <argument><expr><name>actual_arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"No function matches the given name and argument types. "</literal>
							 <literal type="string">"You might need to add explicit type casts."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If there are default arguments, we have to include their types in
	 * actual_arg_types for the purpose of checking generic type consistency.
	 * However, we do NOT put them into the generated parse node, because
	 * their actual values might change before the query gets run.  The
	 * planner has to insert the up-to-date values at plan time.
	 */</comment>
	<expr_stmt><expr><name>nargsplusdefs</name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>argdefaults</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* probably shouldn't happen ... */</comment>
		<if_stmt><if>if <condition>(<expr><name>nargsplusdefs</name> <operator>&gt;=</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a function"</literal></expr></argument>,
								   <argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
								   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
								   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><name>nargsplusdefs</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * enforce consistency with polymorphic argument and return types,
	 * possibly adjusting return type or declared_arg_types (which will be
	 * used as the cast destination by make_fn_arguments)
	 */</comment>
	<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>enforce_generic_type_consistency</name><argument_list>(<argument><expr><name>actual_arg_types</name></expr></argument>,
											   <argument><expr><name>declared_arg_types</name></expr></argument>,
											   <argument><expr><name>nargsplusdefs</name></expr></argument>,
											   <argument><expr><name>rettype</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* perform the necessary typecasting of arguments */</comment>
	<expr_stmt><expr><call><name>make_fn_arguments</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>actual_arg_types</name></expr></argument>, <argument><expr><name>declared_arg_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the function isn't actually variadic, forget any VARIADIC decoration
	 * on the call.  (Perhaps we should throw an error instead, but
	 * historically we've allowed people to write that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>vatype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvargs</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>func_variadic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a variadic function call, transform the last nvargs arguments
	 * into an array --- unless it's an "any" variadic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvargs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>vatype</name> <operator>!=</operator> <name>ANYOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>newa</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>non_var_args</name> <init>= <expr><name>nargs</name> <operator>-</operator> <name>nvargs</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vargs</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>non_var_args</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vargs</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>non_var_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fargs</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>non_var_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>vargs</name></expr>;</expr_stmt>
		<comment type="block">/* assume all the variadic arguments were coerced to the same type */</comment>
		<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* array_collid will be set by parse_collate.c */</comment>
		<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>newa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We could not have had VARIADIC marking before ... */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>func_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... but now, it's a VARIADIC call */</comment>
		<expr_stmt><expr><name>func_variadic</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If an "any" variadic is called with explicit VARIADIC marking, insist
	 * that the variadic parameter be of some array type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>vatype</name> <operator>==</operator> <name>ANYOID</name> <operator>&amp;&amp;</operator> <name>func_variadic</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>va_arr_typid</name> <init>= <expr><name><name>actual_arg_types</name><index>[<expr><name>nargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name>va_arr_typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VARIADIC argument must be an array"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if it returns a set, check that's OK */</comment>
	<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_srf_call_placement</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* build the appropriate output structure */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator> <name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_PROCEDURE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>retset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>func_variadic</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt>
		<comment type="block">/* funccollid and inputcollid will be set by parse_collate.c */</comment>
		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fargs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_AGGREGATE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>over</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* aggregate function */</comment>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
		<comment type="block">/* aggcollid and inputcollid will be set by parse_collate.c */</comment>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* will be set by planner */</comment>
		<comment type="block">/* aggargtypes will be set by transformAggregateCall */</comment>
		<comment type="block">/* aggdirectargs and args will be set by transformAggregateCall */</comment>
		<comment type="block">/* aggorder and aggdistinct will be set by transformAggregateCall */</comment>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>agg_filter</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>=</operator> <name>agg_star</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name> <operator>=</operator> <name>func_variadic</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>aggkind</name></expr>;</expr_stmt>
		<comment type="block">/* agglevelsup will be set by transformAggregateCall */</comment>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt> <comment type="block">/* planner might change this */</comment>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reject attempt to call a parameterless aggregate without (*)
		 * syntax.  This is mere pedantry but some folks insisted ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fargs</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>agg_star</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>agg_within_group</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s(*) must be used to call a parameterless aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregates cannot return sets"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We might want to support named arguments later, but disallow it for
		 * now.  We'd need to figure out the parsed representation (should the
		 * NamedArgExprs go above or below the TargetEntry nodes?) and then
		 * teach the planner to reorder the list properly.  Or maybe we could
		 * make transformAggregateCall do that?  However, if you'd also like
		 * to allow default arguments for aggregates, we'd need to do it in
		 * planning to avoid semantic problems.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>argnames</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregates cannot use named arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* parse_agg.c does additional aggregate-specific processing */</comment>
		<expr_stmt><expr><call><name>transformAggregateCall</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>fargs</name></expr></argument>, <argument><expr><name>agg_order</name></expr></argument>, <argument><expr><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aggref</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* window function */</comment>
		<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>over</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* lack of this was checked above */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>agg_within_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* also checked above */</comment>

		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>wintype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
		<comment type="block">/* wincollid and inputcollid will be set by parse_collate.c */</comment>
		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>fargs</name></expr>;</expr_stmt>
		<comment type="block">/* winref will be set by transformWindowFuncCall */</comment>
		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winstar</name></name> <operator>=</operator> <name>agg_star</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name> <operator>=</operator> <operator>(</operator><name>fdresult</name> <operator>==</operator> <name>FUNCDETAIL_AGGREGATE</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>agg_filter</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * agg_star is allowed for aggregate functions but distinct isn't
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>agg_distinct</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DISTINCT is not implemented for window functions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reject attempt to call a parameterless aggregate without (*)
		 * syntax.  This is mere pedantry but some folks insisted ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name> <operator>&amp;&amp;</operator> <name>fargs</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>agg_star</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s(*) must be used to call a parameterless aggregate function"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ordered aggs not allowed in windows yet
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>agg_order</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate ORDER BY is not implemented for window functions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * FILTER is not yet supported with true window functions
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name> <operator>&amp;&amp;</operator> <name>agg_filter</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FILTER is not implemented for non-aggregate window functions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Window functions can't either take or return sets
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window function calls cannot contain set-returning function calls"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might be able to move the set-returning function into a LATERAL FROM item."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window functions cannot return sets"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* parse_agg.c does additional window-func-specific processing */</comment>
		<expr_stmt><expr><call><name>transformWindowFuncCall</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>wfunc</name></expr></argument>, <argument><expr><name>over</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>wfunc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if it returns a set, remember it for error checks at higher levels */</comment>
	<if_stmt><if>if <condition>(<expr><name>retset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>=</operator> <name>retval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* func_match_argtypes()
 *
 * Given a list of candidate functions (having the right name and number
 * of arguments) and an array of input datatype OIDs, produce a shortlist of
 * those candidates that actually accept the input datatypes (either exactly
 * or by coercion), and return the number of such candidates.
 *
 * Note that can_coerce_type will assume that UNKNOWN inputs are coercible to
 * anything, so candidates will not be eliminated on that basis.
 *
 * NB: okay to modify input list structure, as long as we find at least
 * one match.  If no match at all, the list must remain unmodified.
 */</comment>
<function><type><name>int</name></type>
<name>func_match_argtypes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_typeids</name></decl></parameter>,
					<parameter><decl><type><name>FuncCandidateList</name></type> <name>raw_candidates</name></decl></parameter>,
					<parameter><decl><type><name>FuncCandidateList</name> <modifier>*</modifier></type><name>candidates</name></decl></parameter>)</parameter_list>	<comment type="block">/* return value */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>next_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>candidates</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>raw_candidates</name></expr>;</init>
		 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>current_candidate</name> <operator>=</operator> <name>next_candidate</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>next_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>input_typeids</name></expr></argument>, <argument><expr><name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
							<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>candidates</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>candidates</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ncandidates</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* func_match_argtypes() */</comment>


<comment type="block">/* func_select_candidate()
 *		Given the input argtype array and more than one candidate
 *		for the function, attempt to resolve the conflict.
 *
 * Returns the selected candidate if the conflict can be resolved,
 * otherwise returns NULL.
 *
 * Note that the caller has already determined that there is no candidate
 * exactly matching the input argtypes, and has pruned away any "candidates"
 * that aren't actually coercion-compatible with the input types.
 *
 * This is also used for resolving ambiguous operator references.  Formerly
 * parse_oper.c had its own, essentially duplicate code for the purpose.
 * The following comments (formerly in parse_oper.c) are kept to record some
 * of the history of these heuristics.
 *
 * OLD COMMENTS:
 *
 * This routine is new code, replacing binary_oper_select_candidate()
 * which dates from v4.2/v1.0.x days. It tries very hard to match up
 * operators with types, including allowing type coercions if necessary.
 * The important thing is that the code do as much as possible,
 * while _never_ doing the wrong thing, where "the wrong thing" would
 * be returning an operator when other better choices are available,
 * or returning an operator which is a non-intuitive possibility.
 * - thomas 1998-05-21
 *
 * The comments below came from binary_oper_select_candidate(), and
 * illustrate the issues and choices which are possible:
 * - thomas 1998-05-20
 *
 * current wisdom holds that the default operator should be one in which
 * both operands have the same type (there will only be one such
 * operator)
 *
 * 7.27.93 - I have decided not to do this; it's too hard to justify, and
 * it's easy enough to typecast explicitly - avi
 * [the rest of this routine was commented out since then - ay]
 *
 * 6/23/95 - I don't complete agree with avi. In particular, casting
 * floats is a pain for users. Whatever the rationale behind not doing
 * this is, I need the following special case to work.
 *
 * In the WHERE clause of a query, if a float is specified without
 * quotes, we treat it as float8. I added the float48* operators so
 * that we can operate on float4 and float8. But now we have more than
 * one matching operator if the right arg is unknown (eg. float
 * specified with quotes). This break some stuff in the regression
 * test where there are floats in quotes not properly casted. Below is
 * the solution. In addition to requiring the operator operates on the
 * same type for both operands [as in the code Avi originally
 * commented out], we also require that the operators be equivalent in
 * some sense. (see equivalentOpersAfterPromotion for details.)
 * - ay 6/95
 */</comment>
<function><type><name>FuncCandidateList</name></type>
<name>func_select_candidate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>input_typeids</name></decl></parameter>,
					  <parameter><decl><type><name>FuncCandidateList</name></type> <name>candidates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidate</name></decl>,
				<decl><type ref="prev"/><name>first_candidate</name></decl>,
				<decl><type ref="prev"/><name>last_candidate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>current_typeids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>current_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbestMatch</name></decl>,
				<decl><type ref="prev"/><name>nmatch</name></decl>,
				<decl><type ref="prev"/><name>nunknowns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>input_base_typeids</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TYPCATEGORY</name></type> <name><name>slot_category</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name>current_category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>current_is_preferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>slot_has_preferred_type</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resolved_unknowns</name></decl>;</decl_stmt>

	<comment type="block">/* protect local fixed-size arrays */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a function"</literal></expr></argument>,
							   <argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If any input types are domains, reduce them to their base types. This
	 * ensures that we will consider functions on the base type to be "exact
	 * matches" in the exact-match heuristic; it also makes it possible to do
	 * something useful with the type-category heuristics. Note that this
	 * makes it difficult, but not impossible, to use functions declared to
	 * take a domain as an input datatype.  Such a function will be selected
	 * over the base-type function only if it is an exact match at all
	 * argument positions, and so was already chosen by our caller.
	 *
	 * While we're at it, count the number of unknown-type arguments for use
	 * later.
	 */</comment>
	<expr_stmt><expr><name>nunknowns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>input_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name><name>input_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no need to call getBaseType on UNKNOWNOID */</comment>
			<expr_stmt><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nunknowns</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Run through all candidates and keep those with the most matches on
	 * exact types. Keep all candidates if none match.
	 */</comment>
	<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbestMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
		 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator>
				<name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* take this one as the best choice so far? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nmatch</name> <operator>&gt;</operator> <name>nbestMatch</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>last_candidate</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nbestMatch</name> <operator>=</operator> <name>nmatch</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>candidates</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* no worse than the last choice, so keep this one too? */</comment>
		<if type="elseif">else if <condition>(<expr><name>nmatch</name> <operator>==</operator> <name>nbestMatch</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* otherwise, don't bother keeping this one... */</comment>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>last_candidate</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* terminate rebuilt list */</comment>
		<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>candidates</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Still too many candidates? Now look for candidates which have either
	 * exact matches or preferred types at the args that will require
	 * coercion. (Restriction added in 7.4: preferred type must be of same
	 * category as input type; give no preference to cross-category
	 * conversions to preferred types.)  Keep all candidates if none match.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <comment type="block">/* avoid multiple lookups */</comment>
		<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TypeCategory</name><argument_list>(<argument><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbestMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
		 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
					<call><name>IsPreferredType</name><argument_list>(<argument><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nmatch</name> <operator>&gt;</operator> <name>nbestMatch</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>last_candidate</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nbestMatch</name> <operator>=</operator> <name>nmatch</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>candidates</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>nmatch</name> <operator>==</operator> <name>nbestMatch</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>last_candidate</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* terminate rebuilt list */</comment>
		<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>candidates</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Still too many candidates?  Try assigning types for the unknown inputs.
	 *
	 * If there are no unknown inputs, we have no more heuristics that apply,
	 * and must fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nunknowns</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* failed to select a best candidate */</comment>

	<comment type="block">/*
	 * The next step examines each unknown argument position to see if we can
	 * determine a "type category" for it.  If any candidate has an input
	 * datatype of STRING category, use STRING category (this bias towards
	 * STRING is appropriate since unknown-type literals look like strings).
	 * Otherwise, if all the candidates agree on the type category of this
	 * argument position, use that category.  Otherwise, fail because we
	 * cannot determine a category.
	 *
	 * If we are able to determine a type category, also notice whether any of
	 * the candidates takes a preferred datatype within the category.
	 *
	 * Having completed this examination, remove candidates that accept the
	 * wrong category at any unknown position.  Also, if at least one
	 * candidate accepted a preferred type at a position, remove candidates
	 * that accept non-preferred types.  If just one candidate remains, return
	 * that one.  However, if this rule turns out to reject all candidates,
	 * keep them all instead.
	 */</comment>
	<expr_stmt><expr><name>resolved_unknowns</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>have_conflict</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>resolved_unknowns</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* assume we can do it */</comment>
		<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TYPCATEGORY_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_conflict</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
			 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>current_type</name> <operator>=</operator> <name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>current_type</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>current_category</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>current_is_preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>TYPCATEGORY_INVALID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* first candidate */</comment>
				<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_category</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_is_preferred</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>current_category</name> <operator>==</operator> <name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* more candidates in same category */</comment>
				<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name>current_is_preferred</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* category conflict! */</comment>
				<if_stmt><if>if <condition>(<expr><name>current_category</name> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* STRING always wins if available */</comment>
					<expr_stmt><expr><name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_category</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>current_is_preferred</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Remember conflict, but keep going (might find STRING)
					 */</comment>
					<expr_stmt><expr><name>have_conflict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>have_conflict</name> <operator>&amp;&amp;</operator> <name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Failed to resolve category conflict at this position */</comment>
			<expr_stmt><expr><name>resolved_unknowns</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>resolved_unknowns</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Strip non-matching candidates */</comment>
		<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
			 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
			 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>keepit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>current_type</name> <operator>=</operator> <name><name>current_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_type_category_preferred</name><argument_list>(<argument><expr><name>current_type</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>current_category</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>current_is_preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>current_category</name> <operator>!=</operator> <name><name>slot_category</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>keepit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>slot_has_preferred_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>current_is_preferred</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>keepit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>keepit</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* keep this candidate */</comment>
				<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ncandidates</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* forget this candidate */</comment>
				<if_stmt><if>if <condition>(<expr><name>last_candidate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>first_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* if we found any matches, restrict our attention to those */</comment>
		<if_stmt><if>if <condition>(<expr><name>last_candidate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>candidates</name> <operator>=</operator> <name>first_candidate</name></expr>;</expr_stmt>
			<comment type="block">/* terminate rebuilt list */</comment>
			<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>candidates</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Last gasp: if there are both known- and unknown-type inputs, and all
	 * the known types are the same, assume the unknown inputs are also that
	 * type, and see if that gives us a unique match.  If so, use that match.
	 *
	 * NOTE: for a binary operator with one unknown and one non-unknown input,
	 * we already tried this heuristic in binary_oper_exact().  However, that
	 * code only finds exact matches, whereas here we will handle matches that
	 * involve coercion, polymorphic type resolution, etc.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nunknowns</name> <operator>&lt;</operator> <name>nargs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>known_type</name> <init>= <expr><name>UNKNOWNOID</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>known_type</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* first known arg? */</comment>
				<expr_stmt><expr><name>known_type</name> <operator>=</operator> <name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>known_type</name> <operator>!=</operator> <name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* oops, not all match */</comment>
				<expr_stmt><expr><name>known_type</name> <operator>=</operator> <name>UNKNOWNOID</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>known_type</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* okay, just one known type, apply the heuristic */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>input_base_typeids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>known_type</name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>current_candidate</name> <operator>=</operator> <name>candidates</name></expr>;</init>
				 <condition><expr><name>current_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
				 <incr><expr><name>current_candidate</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>current_typeids</name> <operator>=</operator> <name><name>current_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>input_base_typeids</name></expr></argument>, <argument><expr><name>current_typeids</name></expr></argument>,
									<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>++</operator><name>ncandidates</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* not unique, give up */</comment>
					<expr_stmt><expr><name>last_candidate</name> <operator>=</operator> <name>current_candidate</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* successfully identified a unique match */</comment>
				<expr_stmt><expr><name><name>last_candidate</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return <expr><name>last_candidate</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* failed to select a best candidate */</comment>
</block_content>}</block></function>								<comment type="block">/* func_select_candidate() */</comment>


<comment type="block">/* func_get_detail()
 *
 * Find the named function in the system catalogs.
 *
 * Attempt to find the named function in the system catalogs with
 * arguments exactly as specified, so that the normal case (exact match)
 * is as quick as possible.
 *
 * If an exact match isn't found:
 *	1) check for possible interpretation as a type coercion request
 *	2) apply the ambiguous-function resolution rules
 *
 * Return values *funcid through *true_typeids receive info about the function.
 * If argdefaults isn't NULL, *argdefaults receives a list of any default
 * argument expressions that need to be added to the given arguments.
 *
 * When processing a named- or mixed-notation call (ie, fargnames isn't NIL),
 * the returned true_typeids and argdefaults are ordered according to the
 * call's argument ordering: first any positional arguments, then the named
 * arguments, then defaulted arguments (if needed and allowed by
 * expand_defaults).  Some care is needed if this information is to be compared
 * to the function's pg_proc entry, but in practice the caller can usually
 * just work with the call's argument ordering.
 *
 * We rely primarily on fargnames/nargs/argtypes as the argument description.
 * The actual expression node list is passed in fargs so that we can check
 * for type coercion of a constant.  Some callers pass fargs == NIL indicating
 * they don't need that check made.  Note also that when fargnames isn't NIL,
 * the fargs list must be passed if the caller wants actual argument position
 * information to be returned into the NamedArgExpr nodes.
 */</comment>
<function><type><name>FuncDetailCode</name></type>
<name>func_get_detail</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fargs</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fargnames</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>expand_variadic</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>expand_defaults</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>,	<comment type="block">/* return value */</comment>
				<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rettype</name></decl></parameter>,	<comment type="block">/* return value */</comment>
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>retset</name></decl></parameter>,	<comment type="block">/* return value */</comment>
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nvargs</name></decl></parameter>,	<comment type="block">/* return value */</comment>
				<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>vatype</name></decl></parameter>,	<comment type="block">/* return value */</comment>
				<parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>true_typeids</name></decl></parameter>, <comment type="block">/* return value */</comment>
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>argdefaults</name></decl></parameter>)</parameter_list> <comment type="block">/* optional return value */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>raw_candidates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>best_candidate</name></decl>;</decl_stmt>

	<comment type="block">/* Passing NULL for argtypes is no longer allowed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize output arguments to silence compiler warnings */</comment>
	<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>retset</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nvargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>vatype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>true_typeids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>argdefaults</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>argdefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get list of possible candidates from namespace search */</comment>
	<expr_stmt><expr><name>raw_candidates</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>fargnames</name></expr></argument>,
										   <argument><expr><name>expand_variadic</name></expr></argument>, <argument><expr><name>expand_defaults</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quickly check if there is an exact match to the input datatypes (there
	 * can be only one)
	 */</comment>
	<for>for <control>(<init><expr><name>best_candidate</name> <operator>=</operator> <name>raw_candidates</name></expr>;</init>
		 <condition><expr><name>best_candidate</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>best_candidate</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name><name>best_candidate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>best_candidate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't find an exact match, next consider the possibility
		 * that this is really a type-coercion request: a single-argument
		 * function call where the function name is a type name.  If so, and
		 * if the coercion path is RELABELTYPE or COERCEVIAIO, then go ahead
		 * and treat the "function call" as a coercion.
		 *
		 * This interpretation needs to be given higher priority than
		 * interpretations involving a type coercion followed by a function
		 * call, otherwise we can produce surprising results. For example, we
		 * want "text(varchar)" to be interpreted as a simple coercion, not as
		 * "text(name(varchar))" which the code below this point is entirely
		 * capable of selecting.
		 *
		 * We also treat a coercion of a previously-unknown-type literal
		 * constant to a specific type this way.
		 *
		 * The reason we reject COERCION_PATH_FUNC here is that we expect the
		 * cast implementation function to be named after the target type.
		 * Thus the function will be found by normal lookup if appropriate.
		 *
		 * The reason we reject COERCION_PATH_ARRAYCOERCE is mainly that you
		 * can't write "foo[] (something)" as a function call.  In theory
		 * someone might want to invoke it as "_foo (something)" but we have
		 * never supported that historically, so we can insist that people
		 * write it as a normal cast instead.
		 *
		 * We also reject the specific case of COERCEVIAIO for a composite
		 * source type and a string-category target type.  This is a case that
		 * find_coercion_pathway() allows by default, but experience has shown
		 * that it's too commonly invoked by mistake.  So, again, insist that
		 * people use cast syntax if they want to do that.
		 *
		 * NB: it's important that this code does not exceed what coerce_type
		 * can do, because the caller will try to apply coerce_type if we
		 * return FUNCDETAIL_COERCION.  If we return that result for something
		 * coerce_type can't handle, we'll cause infinite recursion between
		 * this module and coerce_type!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>fargs</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>fargnames</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>targetType</name> <init>= <expr><call><name>FuncNameAsType</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>sourceType</name> <init>= <expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>iscoercion</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>sourceType</name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* always treat typename('literal') as coercion */</comment>
					<expr_stmt><expr><name>iscoercion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>cpathtype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>cfuncid</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>cpathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>sourceType</name></expr></argument>,
													  <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>cfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<switch>switch <condition>(<expr><name>cpathtype</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>COERCION_PATH_RELABELTYPE</name></expr>:</case>
							<expr_stmt><expr><name>iscoercion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>COERCION_PATH_COERCEVIAIO</name></expr>:</case>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sourceType</name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator>
								 <call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>sourceType</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
								<call><name>TypeCategory</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPCATEGORY_STRING</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>iscoercion</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name>iscoercion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><name>iscoercion</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>iscoercion</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Treat it as a type coercion */</comment>
					<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>retset</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>nvargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>vatype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>true_typeids</name> <operator>=</operator> <name>argtypes</name></expr>;</expr_stmt>
					<return>return <expr><name>FUNCDETAIL_COERCION</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * didn't find an exact match, so now try to match up candidates...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>raw_candidates</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>current_candidates</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ncandidates</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ncandidates</name> <operator>=</operator> <call><name>func_match_argtypes</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>argtypes</name></expr></argument>,
											  <argument><expr><name>raw_candidates</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>current_candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* one match only? then run with it... */</comment>
			<if_stmt><if>if <condition>(<expr><name>ncandidates</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>best_candidate</name> <operator>=</operator> <name>current_candidates</name></expr>;</expr_stmt></block_content></block></if>

			<comment type="block">/*
			 * multiple candidates? then better decide or throw an error...
			 */</comment>
			<if type="elseif">else if <condition>(<expr><name>ncandidates</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>best_candidate</name> <operator>=</operator> <call><name>func_select_candidate</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>,
													   <argument><expr><name>argtypes</name></expr></argument>,
													   <argument><expr><name>current_candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we were able to choose a best candidate, we're done.
				 * Otherwise, ambiguous function call.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>best_candidate</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>FUNCDETAIL_MULTIPLE</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>best_candidate</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ftup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>pform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If processing named args or expanding variadics or defaults, the
		 * "best candidate" might represent multiple equivalently good
		 * functions; treat this case as ambiguous.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>best_candidate</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>FUNCDETAIL_MULTIPLE</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We disallow VARIADIC with named arguments unless the last argument
		 * (the one with VARIADIC attached) actually matched the variadic
		 * parameter.  This is mere pedantry, really, but some folks insisted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fargnames</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>expand_variadic</name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>best_candidate</name><operator>-&gt;</operator><name>argnumbers</name><index>[<expr><name>nargs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>nargs</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>FUNCDETAIL_NOTFOUND</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nvargs</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>nvargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>true_typeids</name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If processing named args, return actual argument positions into
		 * NamedArgExpr nodes in the fargs list.  This is a bit ugly but not
		 * worth the extra notation needed to do it differently.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>best_candidate</name><operator>-&gt;</operator><name>argnumbers</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fargs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>na</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>na</name><operator>-&gt;</operator><name>argnumber</name></name> <operator>=</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>argnumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ftup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>best_candidate</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>,
				 <argument><expr><name><name>best_candidate</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rettype</name> <operator>=</operator> <name><name>pform</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>retset</name> <operator>=</operator> <name><name>pform</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>vatype</name> <operator>=</operator> <name><name>pform</name><operator>-&gt;</operator><name>provariadic</name></name></expr>;</expr_stmt>
		<comment type="block">/* fetch default args if caller wants 'em */</comment>
		<if_stmt><if>if <condition>(<expr><name>argdefaults</name> <operator>&amp;&amp;</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>ndargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>proargdefaults</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defaults</name></decl>;</decl_stmt>

			<comment type="block">/* shouldn't happen, FuncnameGetCandidates messed up */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>best_candidate</name><operator>-&gt;</operator><name>ndargs</name></name> <operator>&gt;</operator> <name><name>pform</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough default arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>proargdefaults</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>ftup</name></expr></argument>,
											 <argument><expr><name>Anum_pg_proc_proargdefaults</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proargdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>defaults</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Delete any unused defaults from the returned list */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>best_candidate</name><operator>-&gt;</operator><name>argnumbers</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This is a bit tricky in named notation, since the supplied
				 * arguments could replace any subset of the defaults.  We
				 * work by making a bitmapset of the argnumbers of defaulted
				 * arguments, then scanning the defaults list and selecting
				 * the needed items.  (This assumes that defaulted arguments
				 * should be supplied in their positional order.)
				 */</comment>
				<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>defargnumbers</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>firstdefarg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newdefaults</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>defargnumbers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>firstdefarg</name> <operator>=</operator> <operator>&amp;</operator><name><name>best_candidate</name><operator>-&gt;</operator><name>argnumbers</name><index>[<expr><name><name>best_candidate</name><operator>-&gt;</operator><name>nargs</name></name> <operator>-</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>ndargs</name></name></expr>]</index></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>ndargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name>defargnumbers</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>defargnumbers</name></expr></argument>,
												   <argument><expr><name><name>firstdefarg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				<expr_stmt><expr><name>newdefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pform</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>-</operator> <name><name>pform</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>defaults</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>defargnumbers</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>newdefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newdefaults</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>newdefaults</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>ndargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>defargnumbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>argdefaults</name> <operator>=</operator> <name>newdefaults</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Defaults for positional notation are lots easier; just
				 * remove any unwanted ones from the front.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>ndelete</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ndelete</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>best_candidate</name><operator>-&gt;</operator><name>ndargs</name></name></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>ndelete</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>defaults</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
				<expr_stmt><expr><operator>*</operator><name>argdefaults</name> <operator>=</operator> <name>defaults</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>pform</name><operator>-&gt;</operator><name>prokind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROKIND_AGGREGATE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FUNCDETAIL_AGGREGATE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROKIND_FUNCTION</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FUNCDETAIL_NORMAL</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROKIND_PROCEDURE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FUNCDETAIL_PROCEDURE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROKIND_WINDOW</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FUNCDETAIL_WINDOWFUNC</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized prokind: %c"</literal></expr></argument>, <argument><expr><name><name>pform</name><operator>-&gt;</operator><name>prokind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FUNCDETAIL_NORMAL</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ftup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>FUNCDETAIL_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * unify_hypothetical_args()
 *
 * Ensure that each hypothetical direct argument of a hypothetical-set
 * aggregate has the same type as the corresponding aggregated argument.
 * Modify the expressions in the fargs list, if necessary, and update
 * actual_arg_types[].
 *
 * If the agg declared its args non-ANY (even ANYELEMENT), we need only a
 * sanity check that the declared types match; make_fn_arguments will coerce
 * the actual arguments to match the declared ones.  But if the declaration
 * is ANY, nothing will happen in make_fn_arguments, so we need to fix any
 * mismatch here.  We use the same type resolution logic as UNION etc.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unify_hypothetical_args</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fargs</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numAggregatedArgs</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name><name>args</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numDirectArgs</name></decl>,
				<decl><type ref="prev"/><name>numNonHypotheticalArgs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numDirectArgs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>numAggregatedArgs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numNonHypotheticalArgs</name> <operator>=</operator> <name>numDirectArgs</name> <operator>-</operator> <name>numAggregatedArgs</name></expr>;</expr_stmt>
	<comment type="block">/* safety check (should only trigger with a misdeclared agg) */</comment>
	<if_stmt><if>if <condition>(<expr><name>numNonHypotheticalArgs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect number of arguments to hypothetical-set aggregate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Deconstruct fargs into an array for ease of subscripting */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Check each hypothetical arg and corresponding aggregated arg */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numNonHypotheticalArgs</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numDirectArgs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>aargpos</name> <init>= <expr><name>numDirectArgs</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>numNonHypotheticalArgs</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>commontype</name></decl>;</decl_stmt>

		<comment type="block">/* A mismatch means AggregateCreate didn't check properly ... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>declared_arg_types</name><index>[<expr><name>aargpos</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hypothetical-set aggregate has inconsistent declared argument types"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* No need to unify if make_fn_arguments will coerce */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>ANYOID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Select common type, giving preference to the aggregated argument's
		 * type (we'd rather coerce the direct argument once than coerce all
		 * the aggregated values).
		 */</comment>
		<expr_stmt><expr><name>commontype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>aargpos</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><literal type="string">"WITHIN GROUP"</literal></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Perform the coercions.  We don't need to worry about NamedArgExprs
		 * here because they aren't supported with aggregates.
		 */</comment>
		<expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
							  <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>actual_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							  <argument><expr><name>commontype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
							  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
							  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>commontype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>args</name><index>[<expr><name>aargpos</name></expr>]</index></name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><name><name>args</name><index>[<expr><name>aargpos</name></expr>]</index></name></expr></argument>,
									<argument><expr><name><name>actual_arg_types</name><index>[<expr><name>aargpos</name></expr>]</index></name></expr></argument>,
									<argument><expr><name>commontype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
									<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><name>aargpos</name></expr>]</index></name> <operator>=</operator> <name>commontype</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Reconstruct fargs from array */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>args</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * make_fn_arguments()
 *
 * Given the actual argument expressions for a function, and the desired
 * input types for the function, add any necessary typecasting to the
 * expression tree.  Caller should already have verified that casting is
 * allowed.
 *
 * Caution: given argument list is modified in-place.
 *
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 */</comment>
<function><type><name>void</name></type>
<name>make_fn_arguments</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fargs</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>actual_arg_types</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>declared_arg_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>current_fargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>current_fargs</argument>, <argument>fargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* types don't match? then force coercion using a function call... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>actual_arg_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>current_fargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If arg is a NamedArgExpr, coerce its input expr instead --- we
			 * want the NamedArgExpr to stay at the top level of the list.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>na</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
								   <argument><expr><name><name>actual_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
								   <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>na</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								   <argument><expr><name>node</name></expr></argument>,
								   <argument><expr><name><name>actual_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>declared_arg_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
								   <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>current_fargs</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * FuncNameAsType -
 *	  convenience routine to see if a function name matches a type name
 *
 * Returns the OID of the matching type, or InvalidOid if none.  We ignore
 * shell types and complex types.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>FuncNameAsType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Type</name></type>		<name>typtup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * temp_ok=false protects the &lt;refsect1 id="sql-createfunction-security"&gt;
	 * contract for writing SECURITY DEFINER functions safely.
	 */</comment>
	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <call><name>LookupTypeNameExtended</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typtup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typisdefined</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>typeTypeRelid</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>typeTypeId</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ParseComplexProjection -
 *	  handles function calls with a single argument that is of complex type.
 *	  If the function call is actually a column projection, return a suitably
 *	  transformed expression tree.  If not, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>ParseComplexProjection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>first_arg</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Special case for whole-row Vars so that we can resolve (foo.*).bar even
	 * when foo is a reference to a subselect, join, or RECORD function. A
	 * bonus is that we avoid generating an unnecessary FieldSelect; our
	 * result can omit the whole-row Var and just be a Var for the selected
	 * field.
	 *
	 * This case could be handled by expandRecordVariable, but it's more
	 * efficient to do it this way when possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>first_arg</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>first_arg</name><operator>)</operator><operator>-&gt;</operator><name>varno</name></expr></argument>,
									 <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>first_arg</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Return a Var if funcname matches a column, else NULL */</comment>
		<return>return <expr><call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Else do it the hard way with get_expr_result_tupdesc().
	 *
	 * If it's a Var of type RECORD, we have to work even harder: we have to
	 * find what the Var refers to, and pass that to get_expr_result_tupdesc.
	 * That task is handled by expandRecordVariable().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>first_arg</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>expandRecordVariable</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>first_arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tupdesc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* unresolvable RECORD type */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Success, so generate a FieldSelect expression */</comment>
			<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>first_arg</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
			<comment type="block">/* save attribute's collation for parse_collate.c */</comment>
			<expr_stmt><expr><name><name>fselect</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fselect</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* funcname does not match any column */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * funcname_signature_string
 *		Build a string representing a function name, including arg types.
 *		The result is something like "foo(integer)".
 *
 * If argnames isn't NIL, it is a list of C strings representing the actual
 * arg names for the last N arguments.  This must be considered part of the
 * function signature too, when dealing with named-notation function calls.
 *
 * This is typically used in the construction of function-not-found error
 * messages.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>funcname_signature_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>argbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numposargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argbuf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numposargs</name> <operator>=</operator> <name>nargs</name> <operator>-</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>numposargs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argbuf</name></expr></argument>, <argument><expr><literal type="string">"%s =&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argbuf</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argbuf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>argbuf</name><operator>.</operator><name>data</name></name></expr>;</return>			<comment type="block">/* return palloc'd string buffer */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * func_signature_string
 *		As above, but function name is passed as a qualified name list.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>func_signature_string</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>funcname_signature_string</name><argument_list>(<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LookupFuncName
 *
 * Given a possibly-qualified function name and optionally a set of argument
 * types, look up the function.  Pass nargs == -1 to indicate that no argument
 * types are specified.
 *
 * If the function name is not schema-qualified, it is sought in the current
 * namespace search path.
 *
 * If the function is not found, we return InvalidOid if noError is true,
 * else raise an error.
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupFuncName</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

	<comment type="block">/* Passing NULL for argtypes is no longer allowed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>noError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no arguments were specified, the name must yield a unique candidate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>clist</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function name \"%s\" is not unique"</literal></expr></argument>,
									<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify the argument list to select the function unambiguously."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>InvalidOid</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Otherwise return the match */</comment>
			<return>return <expr><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find a function named \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>InvalidOid</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, look for a match to the arg types.  FuncnameGetCandidates
	 * has ensured that there's at most one match in the returned list.
	 */</comment>
	<while>while <condition>(<expr><name>clist</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name><name>clist</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s does not exist"</literal></expr></argument>,
						<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LookupFuncWithArgs
 *
 * Like LookupFuncName, but the argument types are specified by a
 * ObjectWithArgs node.  Also, this function can check whether the result is a
 * function, procedure, or aggregate, based on the objtype argument.  Pass
 * OBJECT_ROUTINE to accept any of them.
 *
 * For historical reasons, we also accept aggregates when looking for a
 * function.
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupFuncWithArgs</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argoids</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>argcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>args_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>objtype</name> <operator>==</operator> <name>OBJECT_AGGREGATE</name> <operator>||</operator>
		   <name>objtype</name> <operator>==</operator> <name>OBJECT_FUNCTION</name> <operator>||</operator>
		   <name>objtype</name> <operator>==</operator> <name>OBJECT_PROCEDURE</name> <operator>||</operator>
		   <name>objtype</name> <operator>==</operator> <name>OBJECT_ROUTINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>argcount</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>argcount</name> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"functions cannot have more than %d argument"</literal></expr></argument>,
							   <argument><expr><literal type="string">"functions cannot have more than %d arguments"</literal></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
							   <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>args_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>argoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>noError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>args_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * When looking for a function or routine, we pass noError through to
	 * LookupFuncName and let it make any error messages.  Otherwise, we make
	 * our own errors for the aggregate and procedure cases.
	 */</comment>
	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>func</name><operator>-&gt;</operator><name>args_unspecified</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>argcount</name></expr></else></ternary></expr></argument>, <argument><expr><name>argoids</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><operator>(</operator><name>objtype</name> <operator>==</operator> <name>OBJECT_FUNCTION</name> <operator>||</operator> <name>objtype</name> <operator>==</operator> <name>OBJECT_ROUTINE</name><operator>)</operator></expr> ?</condition><then> <expr><name>noError</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure it's a function, not a procedure */</comment>
		<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>&amp;&amp;</operator> <call><name>get_func_prokind</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a function"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>,
												  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argoids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_PROCEDURE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>args_unspecified</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find a procedure named \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure %s does not exist"</literal></expr></argument>,
								<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>,
													  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argoids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure it's a procedure */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_func_prokind</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a procedure"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>,
												  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argoids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_AGGREGATE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>args_unspecified</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find an aggregate named \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>argcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate %s(*) does not exist"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate %s does not exist"</literal></expr></argument>,
								<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>,
													  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argoids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure it's an aggregate */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_func_prokind</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* we do not use the (*) notation for functions... */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function %s is not an aggregate"</literal></expr></argument>,
							<argument><expr><call><name>func_signature_string</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>,
												  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argoids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_srf_call_placement
 *		Verify that a set-returning function is called in a valid place,
 *		and throw a nice error if not.
 *
 * A side-effect is to set pstate-&gt;p_hasTargetSRFs true if appropriate.
 *
 * last_srf should be a copy of pstate-&gt;p_last_srf from just before we
 * started transforming the function's arguments.  This allows detection
 * of whether the SRF's arguments contain any SRFs.
 */</comment>
<function><type><name>void</name></type>
<name>check_srf_call_placement</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>errkind</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check to see if the set-returning function is in an invalid place
	 * within the query.  Basically, we don't allow SRFs anywhere except in
	 * the targetlist (which includes GROUP BY/ORDER BY expressions), VALUES,
	 * and functions in FROM.
	 *
	 * For brevity we support two schemes for reporting an error here: set
	 * "err" to a custom message, or set "errkind" true if the error context
	 * is sufficiently identified by what ParseExprKindName will return, *and*
	 * what it will return is just a SQL keyword.  (Otherwise, use a custom
	 * message to avoid creating translation problems.)
	 */</comment>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPR_KIND_NONE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* can't happen */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_OTHER</name></expr>:</case>
			<comment type="block">/* Accept SRF here; caller must throw error if wanted */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_JOIN_ON</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_JOIN_USING</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in JOIN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FROM_SUBSELECT</name></expr>:</case>
			<comment type="block">/* can't get here, but just in case, throw an error */</comment>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FROM_FUNCTION</name></expr>:</case>
			<comment type="block">/* okay, but we don't allow nested SRFs here */</comment>
			<comment type="block">/* errmsg is chosen to match transformRangeFunction() */</comment>
			<comment type="block">/* errposition should point to the inner SRF */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions must appear at top level of FROM"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WHERE</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_POLICY</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in policy expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_HAVING</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FILTER</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_PARTITION</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_ORDER</name></expr>:</case>
			<comment type="block">/* okay, these are effectively GROUP BY/ORDER BY */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_RANGE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_ROWS</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_GROUPS</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in window definitions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_SELECT_TARGET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_INSERT_TARGET</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_TARGET</name></expr>:</case>
			<comment type="block">/* disallowed because it would be ambiguous what to do */</comment>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_GROUP_BY</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_ORDER_BY</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_DISTINCT_ON</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_LIMIT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_OFFSET</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_RETURNING</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_VALUES</name></expr>:</case>
			<comment type="block">/* SRFs are presently not supported by nodeValuesscan.c */</comment>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_VALUES_SINGLE</name></expr>:</case>
			<comment type="block">/* okay, since we process this like a SELECT tlist */</comment>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CHECK_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_DOMAIN_CHECK</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in check constraints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FUNCTION_DEFAULT</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in DEFAULT expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in index predicates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in transform expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_EXECUTE_PARAMETER</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in EXECUTE parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_TRIGGER_WHEN</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in trigger WHEN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CALL_ARGUMENT</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in CALL arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * There is intentionally no default: case here, so that the
			 * compiler will warn if we add a new ParseExprKind without
			 * extending this switch.  If we do see an unrecognized value at
			 * runtime, the behavior will be the same as for EXPR_KIND_OTHER,
			 * which is sane anyway.
			 */</comment>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>errkind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in %s"</literal></expr></argument>,
						<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
