<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/parser/parse_agg.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_agg.c
 *	  handle aggregates and window functions in parser
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_agg.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_varlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_agglevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>check_agg_arguments_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClauses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClauseCommonVars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_non_var_grouping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>func_grouped_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_agg_direct_args</name></decl>;</decl_stmt>
}</block></struct></type> <name>check_ungrouped_columns_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>check_agg_arguments</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>directargs</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
					<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_agg_arguments_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>check_agg_arguments_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_ungrouped_columns</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseVars</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>func_grouped_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_ungrouped_columns_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_grouping_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_grouping_exprs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_agglevels_and_constraints</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>expand_groupingset_node</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_agg_arg</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>argtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>argcollation</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * transformAggregateCall -
 *		Finish initial transformation of an aggregate call
 *
 * parse_func.c has recognized the function as an aggregate, and has set up
 * all the fields of the Aggref except aggargtypes, aggdirectargs, args,
 * aggorder, aggdistinct and agglevelsup.  The passed-in args list has been
 * through standard expression transformation and type coercion to match the
 * agg's declared arg types, while the passed-in aggorder list hasn't been
 * transformed at all.
 *
 * Here we separate the args list into direct and aggregated args, storing the
 * former in agg-&gt;aggdirectargs and the latter in agg-&gt;args.  The regular
 * args, but not the direct args, are converted into a targetlist by inserting
 * TargetEntry nodes.  We then transform the aggorder and agg_distinct
 * specifications to produce lists of SortGroupClause nodes for agg-&gt;aggorder
 * and agg-&gt;aggdistinct.  (For a regular aggregate, this might result in
 * adding resjunk expressions to the targetlist; but for ordered-set
 * aggregates the aggorder list will always be one-to-one with the aggregated
 * args.)
 *
 * We must also determine which query level the aggregate actually belongs to,
 * set agglevelsup accordingly, and mark p_hasAggs true in the corresponding
 * pstate level.
 */</comment>
<function><type><name>void</name></type>
<name>transformAggregateCall</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aggorder</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>agg_distinct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>torder</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tdistinct</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_next_resno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before separating the args into direct and aggregated args, make a list
	 * of their data type OIDs for use later.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>argtypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <name>argtypes</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For an ordered-set agg, the args list includes direct args and
		 * aggregated args; we must split them apart.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>numDirectArgs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>aggorder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>aargs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numDirectArgs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aargs</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>numDirectArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>numDirectArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build a tlist from the aggregated args, and make a sortlist entry
		 * for each one.  Note that the expressions in the SortBy nodes are
		 * ignored (they are the raw versions of the transformed args); we are
		 * just looking at the sort information in the SortBy nodes.
		 */</comment>
		<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>aargs</argument>, <argument>lc2</argument>, <argument>aggorder</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SortBy</name>	   <modifier>*</modifier></type><name>sortby</name> <init>= <expr><operator>(</operator><name>SortBy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<comment type="block">/* We don't bother to assign column names to the entries */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>torder</name> <operator>=</operator> <call><name>addTargetToSortList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>,
										 <argument><expr><name>torder</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>sortby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Never any DISTINCT in an ordered-set agg */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Regular aggregate, so it has no direct args */</comment>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Transform the plain list of Exprs into a targetlist.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<comment type="block">/* We don't bother to assign column names to the entries */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we have an ORDER BY, transform it.  This will add columns to the
		 * tlist if they appear in ORDER BY but weren't already in the arg
		 * list.  They will be marked resjunk = true so we can tell them apart
		 * from regular aggregate arguments later.
		 *
		 * We need to mess with p_next_resno since it will be used to number
		 * any new targetlist entries.
		 */</comment>
		<expr_stmt><expr><name>save_next_resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <name>attno</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>torder</name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><name>aggorder</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>tlist</name></expr></argument>,
									 <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument> <comment type="block">/* force SQL99 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have DISTINCT, transform that to produce a distinctList.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>agg_distinct</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tdistinct</name> <operator>=</operator> <call><name>transformDistinctClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlist</name></expr></argument>, <argument><expr><name>torder</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove this check if executor support for hashed distinct for
			 * aggregates is ever added.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tdistinct</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify an ordering operator for type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Aggregates with DISTINCT must be able to sort their inputs."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name> <operator>=</operator> <name>save_next_resno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update the Aggref with the transformation results */</comment>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>=</operator> <name>torder</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>=</operator> <name>tdistinct</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_agglevels_and_constraints</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformGroupingFunc
 *		Transform a GROUPING expression
 *
 * GROUPING() behaves very like an aggregate.  Processing of levels and nesting
 * is done as for aggregates.  We set p_hasAggs for these expressions too.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformGroupingFunc</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GROUPING must have fewer than 32 arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>current_result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>current_result</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* acceptability of expressions is checked later */</comment>

		<expr_stmt><expr><name>result_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result_list</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>result_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_agglevels_and_constraints</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Aggregate functions and grouping operations (which are combined in the spec
 * as &lt;set function specification&gt;) are very similar with regard to level and
 * nesting restrictions (though we allow a lot more things than the spec does).
 * Centralise those restrictions here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_agglevels_and_constraints</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>directargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>filter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>min_varlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name>	   <modifier>*</modifier></type><name>p_levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>errkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isAgg</name> <init>= <expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>directargs</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>filter</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_levelsup</name> <operator>=</operator> <operator>&amp;</operator><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <name><name>grp</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>grp</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_levelsup</name> <operator>=</operator> <operator>&amp;</operator><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Check the arguments to compute the aggregate's level and detect
	 * improper nesting.
	 */</comment>
	<expr_stmt><expr><name>min_varlevel</name> <operator>=</operator> <call><name>check_agg_arguments</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									   <argument><expr><name>directargs</name></expr></argument>,
									   <argument><expr><name>args</name></expr></argument>,
									   <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>p_levelsup</name> <operator>=</operator> <name>min_varlevel</name></expr>;</expr_stmt>

	<comment type="block">/* Mark the correct pstate level as having aggregates */</comment>
	<while>while <condition>(<expr><name>min_varlevel</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if the aggregate function is in an invalid place within
	 * its aggregation query.
	 *
	 * For brevity we support two schemes for reporting an error here: set
	 * "err" to a custom message, or set "errkind" true if the error context
	 * is sufficiently identified by what ParseExprKindName will return, *and*
	 * what it will return is just a SQL keyword.  (Otherwise, use a custom
	 * message to avoid creating translation problems.)
	 */</comment>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPR_KIND_NONE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* can't happen */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_OTHER</name></expr>:</case>

			<comment type="block">/*
			 * Accept aggregate/grouping here; caller must throw error if
			 * wanted
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_JOIN_ON</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_JOIN_USING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in JOIN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in JOIN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FROM_SUBSELECT</name></expr>:</case>
			<comment type="block">/* Should only be possible in a LATERAL subquery */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Aggregate/grouping scope rules make it worth being explicit
			 * here
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in FROM clause of their own query level"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in FROM clause of their own query level"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FROM_FUNCTION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in functions in FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in functions in FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WHERE</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_POLICY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in policy expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in policy expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_HAVING</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FILTER</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_PARTITION</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_ORDER</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_RANGE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in window RANGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in window RANGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_ROWS</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in window ROWS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in window ROWS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_GROUPS</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in window GROUPS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in window GROUPS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_SELECT_TARGET</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INSERT_TARGET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_TARGET</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_GROUP_BY</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ORDER_BY</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_DISTINCT_ON</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_LIMIT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_OFFSET</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_RETURNING</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_VALUES</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_VALUES_SINGLE</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CHECK_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_DOMAIN_CHECK</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in check constraints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in check constraints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FUNCTION_DEFAULT</name></expr>:</case>

			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in DEFAULT expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in DEFAULT expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in index predicates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in index predicates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in transform expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in transform expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_EXECUTE_PARAMETER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in EXECUTE parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in EXECUTE parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_TRIGGER_WHEN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in trigger WHEN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in trigger WHEN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>

		<case>case <expr><name>EXPR_KIND_CALL_ARGUMENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in CALL arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in CALL arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>

			<comment type="block">/*
			 * There is intentionally no default: case here, so that the
			 * compiler will warn if we add a new ParseExprKind without
			 * extending this switch.  If we do see an unrecognized value at
			 * runtime, the behavior will be the same as for EXPR_KIND_OTHER,
			 * which is sane anyway.
			 */</comment>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errkind</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isAgg</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"grouping operations are not allowed in %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
								 <argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_agg_arguments
 *	  Scan the arguments of an aggregate function to determine the
 *	  aggregate's semantic level (zero is the current select's level,
 *	  one is its parent, etc).
 *
 * The aggregate's level is the same as the level of the lowest-level variable
 * or aggregate in its aggregated arguments (including any ORDER BY columns)
 * or filter expression; or if it contains no variables at all, we presume it
 * to be local.
 *
 * Vars/Aggs in direct arguments are *not* counted towards determining the
 * agg's level, as those arguments aren't evaluated per-row but only
 * per-group, and so in some sense aren't really agg arguments.  However,
 * this can mean that we decide an agg is upper-level even when its direct
 * args contain lower-level Vars/Aggs, and that case has to be disallowed.
 * (This is a little strange, but the SQL standard seems pretty definite that
 * direct args are not to be considered when setting the agg's level.)
 *
 * We also take this opportunity to detect any aggregates or window functions
 * nested within the arguments.  We can throw error immediately if we find
 * a window function.  Aggregates are a bit trickier because it's only an
 * error if the inner aggregate is of the same semantic level as the outer,
 * which we can't know until we finish scanning the arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_agg_arguments</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>directargs</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
					<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>agglevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>check_agg_arguments_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_varlevel</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* signifies nothing found yet */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></argument>,
								  <argument><expr><name>check_agg_arguments_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>filter</name></expr></argument>,
								  <argument><expr><name>check_agg_arguments_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we found no vars nor aggs at all, it's a level-zero aggregate;
	 * otherwise, its level is the minimum of vars or aggs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>min_varlevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>agglevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>agglevel</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>min_agglevel</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>agglevel</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>min_varlevel</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>agglevel</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>min_varlevel</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If there's a nested aggregate of the same semantic level, complain.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>agglevel</name> <operator>==</operator> <name><name>context</name><operator>.</operator><name>min_agglevel</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>aggloc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aggloc</name> <operator>=</operator> <call><name>locate_agg_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></argument>, <argument><expr><name>agglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggloc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>aggloc</name> <operator>=</operator> <call><name>locate_agg_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>filter</name></expr></argument>, <argument><expr><name>agglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>aggloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now check for vars/aggs in the direct arguments, and throw error if
	 * needed.  Note that we allow a Var of the agg's semantic level, but not
	 * an Agg of that level.  In principle such Aggs could probably be
	 * supported, but it would create an ordering dependency among the
	 * aggregates at execution time.  Since the case appears neither to be
	 * required by spec nor particularly useful, we just treat it as a
	 * nested-aggregate situation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>directargs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_varlevel</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directargs</name></expr></argument>,
									  <argument><expr><name>check_agg_arguments_walker</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>min_varlevel</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>context</name><operator>.</operator><name>min_varlevel</name></name> <operator>&lt;</operator> <name>agglevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"outer-level aggregate cannot contain a lower-level variable in its direct arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directargs</name></expr></argument>,
															<argument><expr><name><name>context</name><operator>.</operator><name>min_varlevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>context</name><operator>.</operator><name>min_agglevel</name></name> <operator>&lt;=</operator> <name>agglevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><call><name>locate_agg_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directargs</name></expr></argument>,
															<argument><expr><name><name>context</name><operator>.</operator><name>min_agglevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>agglevel</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_agg_arguments_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
						   <parameter><decl><type><name>check_agg_arguments_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varlevelsup</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* convert levelsup to frame of reference of original query */</comment>
		<expr_stmt><expr><name>varlevelsup</name> <operator>-=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>;</expr_stmt>
		<comment type="block">/* ignore local vars of subqueries */</comment>
		<if_stmt><if>if <condition>(<expr><name>varlevelsup</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>min_varlevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>context</name><operator>-&gt;</operator><name>min_varlevel</name></name> <operator>&gt;</operator> <name>varlevelsup</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>min_varlevel</name></name> <operator>=</operator> <name>varlevelsup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>agglevelsup</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* convert levelsup to frame of reference of original query */</comment>
		<expr_stmt><expr><name>agglevelsup</name> <operator>-=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>;</expr_stmt>
		<comment type="block">/* ignore local aggs of subqueries */</comment>
		<if_stmt><if>if <condition>(<expr><name>agglevelsup</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>min_agglevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>context</name><operator>-&gt;</operator><name>min_agglevel</name></name> <operator>&gt;</operator> <name>agglevelsup</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>min_agglevel</name></name> <operator>=</operator> <name>agglevelsup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* no need to examine args of the inner aggregate */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>agglevelsup</name> <init>= <expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* convert levelsup to frame of reference of original query */</comment>
		<expr_stmt><expr><name>agglevelsup</name> <operator>-=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>;</expr_stmt>
		<comment type="block">/* ignore local aggs of subqueries */</comment>
		<if_stmt><if>if <condition>(<expr><name>agglevelsup</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>min_agglevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>context</name><operator>-&gt;</operator><name>min_agglevel</name></name> <operator>&gt;</operator> <name>agglevelsup</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>min_agglevel</name></name> <operator>=</operator> <name>agglevelsup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Continue and descend into subtree */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * SRFs and window functions can be rejected immediately, unless we are
	 * within a sub-select within the aggregate's arguments; in that case
	 * they're OK.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcretset</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>opretset</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot contain set-returning function calls"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might be able to move the set-returning function into a LATERAL FROM item."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate function calls cannot contain window function calls"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>check_agg_arguments_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								  <argument><expr><name>check_agg_arguments_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformWindowFuncCall -
 *		Finish initial transformation of a window function call
 *
 * parse_func.c has recognized the function as a window function, and has set
 * up all the fields of the WindowFunc except winref.  Here we must (1) add
 * the WindowDef to the pstate (if not a duplicate of one already present) and
 * set winref to link to it; and (2) mark p_hasWindowFuncs true in the pstate.
 * Unlike aggregates, only the most closely nested pstate level need be
 * considered --- there are no "outer window functions" per SQL spec.
 */</comment>
<function><type><name>void</name></type>
<name>transformWindowFuncCall</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>,
						<parameter><decl><type><name>WindowDef</name> <modifier>*</modifier></type><name>windef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>errkind</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A window function call can't contain another one (but aggs are OK). XXX
	 * is this required by spec, or just an unimplemented feature?
	 *
	 * Note: we don't need to check the filter expression here, because the
	 * context checks done below and in transformAggregateCall would have
	 * already rejected any window funcs or aggs within the filter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name> <operator>&amp;&amp;</operator>
		<call><name>contain_windowfuncs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>locate_windowfunc</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check to see if the window function is in an invalid place within the
	 * query.
	 *
	 * For brevity we support two schemes for reporting an error here: set
	 * "err" to a custom message, or set "errkind" true if the error context
	 * is sufficiently identified by what ParseExprKindName will return, *and*
	 * what it will return is just a SQL keyword.  (Otherwise, use a custom
	 * message to avoid creating translation problems.)
	 */</comment>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPR_KIND_NONE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* can't happen */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_OTHER</name></expr>:</case>
			<comment type="block">/* Accept window func here; caller must throw error if wanted */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_JOIN_ON</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_JOIN_USING</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in JOIN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FROM_SUBSELECT</name></expr>:</case>
			<comment type="block">/* can't get here, but just in case, throw an error */</comment>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FROM_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in functions in FROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WHERE</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_POLICY</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in policy expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_HAVING</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_FILTER</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_WINDOW_PARTITION</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_ORDER</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_RANGE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_ROWS</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_GROUPS</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in window definitions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_SELECT_TARGET</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INSERT_TARGET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_TARGET</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_GROUP_BY</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ORDER_BY</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_DISTINCT_ON</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_LIMIT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_OFFSET</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_RETURNING</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_VALUES</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_VALUES_SINGLE</name></expr>:</case>
			<expr_stmt><expr><name>errkind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CHECK_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_DOMAIN_CHECK</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in check constraints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FUNCTION_DEFAULT</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in DEFAULT expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in index predicates"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in transform expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_EXECUTE_PARAMETER</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in EXECUTE parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_TRIGGER_WHEN</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in trigger WHEN conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CALL_ARGUMENT</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in CALL arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * There is intentionally no default: case here, so that the
			 * compiler will warn if we add a new ParseExprKind without
			 * extending this switch.  If we do see an unrecognized value at
			 * runtime, the behavior will be the same as for EXPR_KIND_OTHER,
			 * which is sane anyway.
			 */</comment>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>errkind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window functions are not allowed in %s"</literal></expr></argument>,
						<argument><expr><call><name>ParseExprKindName</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the OVER clause just specifies a window name, find that WINDOW
	 * clause (which had better be present).  Otherwise, try to match all the
	 * properties of the OVER clause, and make a new entry in the p_windowdefs
	 * list if no luck.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>winref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <name><name>windef</name><operator>-&gt;</operator><name>partitionClause</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			   <name><name>windef</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			   <name><name>windef</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>==</operator> <name>FRAMEOPTION_DEFAULTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pstate-&gt;p_windowdefs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>refwin</name> <init>= <expr><operator>(</operator><name>WindowDef</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>winref</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>refwin</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>refwin</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <name>winref</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* didn't find it? */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>winref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pstate-&gt;p_windowdefs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WindowDef</name>  <modifier>*</modifier></type><name>refwin</name> <init>= <expr><operator>(</operator><name>WindowDef</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>winref</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>refwin</name><operator>-&gt;</operator><name>refname</name></name> <operator>&amp;&amp;</operator> <name><name>windef</name><operator>-&gt;</operator><name>refname</name></name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>refwin</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* matched on refname */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>refwin</name><operator>-&gt;</operator><name>refname</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>windef</name><operator>-&gt;</operator><name>refname</name></name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* matched, no refname */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>refwin</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>refwin</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>refwin</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>==</operator> <name><name>windef</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>refwin</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>refwin</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name><name>windef</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* found a duplicate window specification */</comment>
				<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <name>winref</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>			<comment type="block">/* didn't find it? */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name></expr></argument>, <argument><expr><name>windef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_windowdefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parseCheckAggregates
 *	Check for aggregates where they shouldn't be and improper grouping.
 *	This function should be called after the target list and qualifications
 *	are finalized.
 *
 *	Misplaced aggregates are now mostly detected in transformAggregateCall,
 *	but it seems more robust to check for aggregates in recursive queries
 *	only after everything is finalized.  In any case it's hard to detect
 *	improper grouping on-the-fly, so we have to make another pass over the
 *	query for that.
 */</comment>
<function><type><name>void</name></type>
<name>parseCheckAggregates</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gset_common</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClauseCommonVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_non_var_grouping</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>func_grouped_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasJoinRTEs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasSelfRefRTEs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

	<comment type="block">/* This should only be called if we found aggregates or grouping */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have grouping sets, expand them and find the intersection of all
	 * sets.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The limit of 4096 is arbitrary and exists simply to avoid resource
		 * issues from pathological constructs.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gsets</name> <init>= <expr><call><name>expand_grouping_sets</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gsets</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many grouping sets present (maximum 4096)"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name></expr>
										?</condition><then> <expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>
										</then><else>: <expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The intersection will often be empty, so help things along by
		 * seeding the intersect with the smallest set.
		 */</comment>
		<expr_stmt><expr><name>gset_common</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>gset_common</name></expr>)</condition>
		<block>{<block_content>
			<macro><name>for_each_cell</name><argument_list>(<argument>l</argument>, <argument>lnext(list_head(gsets))</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>gset_common</name> <operator>=</operator> <call><name>list_intersection_int</name><argument_list>(<argument><expr><name>gset_common</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gset_common</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there was only one grouping set in the expansion, AND if the
		 * groupClause is non-empty (meaning that the grouping set is not
		 * empty either), then we can ditch the grouping set and pretend we
		 * just had a normal GROUP BY.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the range table to see if there are JOIN or self-reference CTE
	 * entries.  We'll need this info below.
	 */</comment>
	<expr_stmt><expr><name>hasJoinRTEs</name> <operator>=</operator> <name>hasSelfRefRTEs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hasJoinRTEs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hasSelfRefRTEs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Build a list of the acceptable GROUP BY expressions for use by
	 * check_ungrouped_columns().
	 *
	 * We get the TLE, not just the expr, because GROUPING wants to know the
	 * sortgroupref.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>grpcl</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* probably cannot happen */</comment>

		<expr_stmt><expr><name>groupClauses</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there are join alias vars involved, we have to flatten them to the
	 * underlying vars, so that aliased and unaliased vars will be correctly
	 * taken as equal.  We can skip the expense of doing this if no rangetable
	 * entries are RTE_JOIN kind. We use the planner's flatten_join_alias_vars
	 * routine to do the flattening; it wants a PlannerInfo root node, which
	 * fortunately can be mostly dummy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasJoinRTEs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>groupClauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Detect whether any of the grouping expressions aren't simple Vars; if
	 * they're all Vars then we don't have to work so hard in the recursive
	 * scans.  (Note we have to flatten aliases before this.)
	 *
	 * Track Vars that are included in all grouping sets separately in
	 * groupClauseCommonVars, since these are the only ones we can use to
	 * check for functional dependencies.
	 */</comment>
	<expr_stmt><expr><name>have_non_var_grouping</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>groupClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>have_non_var_grouping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
				 <call><name>list_member_int</name><argument_list>(<argument><expr><name>gset_common</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>groupClauseCommonVars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>groupClauseCommonVars</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check the targetlist and HAVING clause for ungrouped variables.
	 *
	 * Note: because we check resjunk tlist elements as well as regular ones,
	 * this will also find ungrouped variables that came from ORDER BY and
	 * WINDOW clauses.  For that matter, it's also going to examine the
	 * grouping expressions themselves --- but they'll all pass the test ...
	 *
	 * We also finalize GROUPING expressions, but for that we need to traverse
	 * the original (unflattened) clause in order to modify nodes.
	 */</comment>
	<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finalize_grouping_exprs</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
							<argument><expr><name>groupClauses</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
							<argument><expr><name>have_non_var_grouping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasJoinRTEs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>check_ungrouped_columns</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
							<argument><expr><name>groupClauses</name></expr></argument>, <argument><expr><name>groupClauseCommonVars</name></expr></argument>,
							<argument><expr><name>have_non_var_grouping</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>func_grouped_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finalize_grouping_exprs</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
							<argument><expr><name>groupClauses</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
							<argument><expr><name>have_non_var_grouping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasJoinRTEs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>check_ungrouped_columns</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>,
							<argument><expr><name>groupClauses</name></expr></argument>, <argument><expr><name>groupClauseCommonVars</name></expr></argument>,
							<argument><expr><name>have_non_var_grouping</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>func_grouped_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Per spec, aggregates can't appear in a recursive term.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>&amp;&amp;</operator> <name>hasSelfRefRTEs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_RECURSION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in a recursive query's recursive term"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>locate_agg_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_ungrouped_columns -
 *	  Scan the given expression tree for ungrouped variables (variables
 *	  that are not listed in the groupClauses list and are not within
 *	  the arguments of aggregate functions).  Emit a suitable error message
 *	  if any are found.
 *
 * NOTE: we assume that the given clause has been transformed suitably for
 * parser output.  This means we can use expression_tree_walker.
 *
 * NOTE: we recognize grouping expressions in the main query, but only
 * grouping Vars in subqueries.  For example, this will be rejected,
 * although it could be allowed:
 *		SELECT
 *			(SELECT x FROM bar where y = (foo.a + foo.b))
 *		FROM foo
 *		GROUP BY a + b;
 * The difficulty is the need to account for different sublevels_up.
 * This appears to require a whole custom version of equal(), which is
 * way more pain than the feature seems worth.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_ungrouped_columns</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseCommonVars</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>func_grouped_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>check_ungrouped_columns_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>qry</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauses</name></name> <operator>=</operator> <name>groupClauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauseCommonVars</name></name> <operator>=</operator> <name>groupClauseCommonVars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>have_non_var_grouping</name></name> <operator>=</operator> <name>have_non_var_grouping</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>func_grouped_rels</name></name> <operator>=</operator> <name>func_grouped_rels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_ungrouped_columns_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_ungrouped_columns_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* constants are always acceptable */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we find an aggregate call of the original level, do not
			 * recurse into its normal arguments, ORDER BY arguments, or
			 * filter; ungrouped vars there are not an error.  But we should
			 * check direct arguments as though they weren't in an aggregate.
			 * We set a special flag in the context to help produce a useful
			 * error message for ungrouped vars in direct arguments.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>check_ungrouped_columns_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
													<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We can skip recursing into aggregates of higher levels altogether,
		 * since they could not possibly contain Vars of concern to us (see
		 * transformAggregateCall).  We do need to look at aggregates of lower
		 * levels, however.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* handled GroupingFunc separately, no need to recheck at this level */</comment>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have any GROUP BY items that are not simple Vars, check to see if
	 * subexpression as a whole matches any GROUP BY item. We need to do this
	 * at every recursion level so that we recognize GROUPed-BY expressions
	 * before reaching variables within them. But this only works at the outer
	 * query level, as noted above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>have_non_var_grouping</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* acceptable, do not descend more */</comment>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have an ungrouped Var of the original query level, we have a
	 * failure.  Vars below the original query level are not a problem, and
	 * neither are Vars from above it.  (If such Vars are ungrouped as far as
	 * their own query level is concerned, that's someone else's problem...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* it's not local to my query, ignore */</comment>

		<comment type="block">/*
		 * Check for a match, if we didn't do it above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>have_non_var_grouping</name></name> <operator>||</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>gvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>gvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>gvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
					<name><name>gvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
					<name><name>gvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* acceptable, we're okay */</comment>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check whether the Var is known functionally dependent on the GROUP
		 * BY columns.  If so, we can allow the Var to be used, because the
		 * grouping is really a no-op for this table.  However, this deduction
		 * depends on one or more constraints of the table, so we have to add
		 * those constraints to the query's constraintDeps list, because it's
		 * not semantically valid anymore if the constraint(s) get dropped.
		 * (Therefore, this check must be the last-ditch effort before raising
		 * error: we don't want to add dependencies unnecessarily.)
		 *
		 * Because this is a pretty expensive check, and will have the same
		 * outcome for all columns of a table, we remember which RTEs we've
		 * already proven functional dependency for in the func_grouped_rels
		 * list.  This test also prevents us from adding duplicate entries to
		 * the constraintDeps list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>func_grouped_rels</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* previously proven acceptable */</comment>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <operator>(</operator><name>int</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>check_functional_grouping</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>,
										  <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupClauseCommonVars</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>qry</name><operator>-&gt;</operator><name>constraintDeps</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>func_grouped_rels</name></name> <operator>=</operator>
					<call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>func_grouped_rels</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* acceptable */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Found an ungrouped local variable; generate error message */</comment>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s.%s\" must appear in the GROUP BY clause or be used in an aggregate function"</literal></expr></argument>,
							<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name></expr> ?</condition><then>
					 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Direct arguments of an ordered-set aggregate must use only grouped columns."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subquery uses ungrouped column \"%s.%s\" from outer query"</literal></expr></argument>,
							<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>check_ungrouped_columns_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_ungrouped_columns_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_grouping_exprs -
 *	  Scan the given expression tree for GROUPING() and related calls,
 *	  and validate and process their arguments.
 *
 * This is split out from check_ungrouped_columns above because it needs
 * to modify the nodes (which it does in-place, not via a mutator) while
 * check_ungrouped_columns may see only a copy of the original thanks to
 * flattening of join alias vars. So here, we flatten each individual
 * GROUPING argument as we see it before comparing it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finalize_grouping_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>check_ungrouped_columns_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>qry</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauses</name></name> <operator>=</operator> <name>groupClauses</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauseCommonVars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>have_non_var_grouping</name></name> <operator>=</operator> <name>have_non_var_grouping</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>func_grouped_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finalize_grouping_exprs_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>finalize_grouping_exprs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* constants are always acceptable */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we find an aggregate call of the original level, do not
			 * recurse into its normal arguments, ORDER BY arguments, or
			 * filter; GROUPING exprs of this level are not allowed there. But
			 * check direct arguments as though they weren't in an aggregate.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>finalize_grouping_exprs_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
													<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We can skip recursing into aggregates of higher levels altogether,
		 * since they could not possibly contain exprs of concern to us (see
		 * transformAggregateCall).  We do need to look at aggregates of lower
		 * levels, however.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only need to check GroupingFunc nodes at the exact level to
		 * which they belong, since they cannot mix levels in arguments.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ref_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>grp-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Each expression must match a grouping entry at the current
				 * query level. Unlike the general expression case, we don't
				 * allow functional dependencies or outer references.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
					<block>{<block_content>
						<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>gvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>gvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<name><name>gvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
								<name><name>gvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
								<name><name>gvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>have_non_var_grouping</name></name> <operator>&amp;&amp;</operator>
						 <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments to GROUPING must be grouping expressions of the associated query level"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>ref_list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>ref_list</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <name>ref_list</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subselects */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
								   <argument><expr><name>finalize_grouping_exprs_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>finalize_grouping_exprs_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a GroupingSet node, expand it and return a list of lists.
 *
 * For EMPTY nodes, return a list of one empty list.
 *
 * For SIMPLE nodes, return a list of one list, which is the node content.
 *
 * For CUBE and ROLLUP nodes, return a list of the expansions.
 *
 * For SET nodes, recursively expand contained CUBE and ROLLUP.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>expand_groupingset_node</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GROUPING_SET_EMPTY</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>GROUPING_SET_SIMPLE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>GROUPING_SET_ROLLUP</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rollup_val</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>curgroup_size</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<while>while <condition>(<expr><name>curgroup_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name>curgroup_size</name></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rollup_val</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs_current</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>GROUPING_SET_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>current_result</name>
							<operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>current_result</name></expr></argument>,
										  <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* If we are done with making the current group, break */</comment>
						<if_stmt><if>if <condition>(<expr><operator>--</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>--</operator><name>curgroup_size</name></expr>;</expr_stmt>
				</block_content>}</block></while>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>GROUPING_SET_CUBE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cube_list</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>number_bits</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>cube_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>num_sets</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

				<comment type="block">/* parser should cap this much lower */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>number_bits</name> <operator>&lt;</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>num_sets</name> <operator>=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>number_bits</name><operator>)</operator></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>uint32</name></type>		<name>mask</name> <init>= <expr><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cube_list</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs_current</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>GROUPING_SET_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <name>i</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>current_result</name>
								<operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>current_result</name></expr></argument>,
											  <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>GROUPING_SET_SETS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gs-&gt;content</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_result</name> <init>= <expr><call><name>expand_groupingset_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_list_len_asc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>la</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lb</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>la</name> <operator>&gt;</operator> <name>lb</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>la</name> <operator>==</operator> <name>lb</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expand a groupingSets clause to a flat list of grouping sets.
 * The returned list is sorted by length, shortest sets first.
 *
 * This is mainly for the planner, but we use it here too to do
 * some consistency checks.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>expand_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>expanded_groups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numsets</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupingSets</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupingSets</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>current_result</name> <operator>=</operator> <call><name>expand_groupingset_node</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>current_result</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>numsets</name> <operator>*=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numsets</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>expanded_groups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>expanded_groups</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Do cartesian product between sublists of expanded_groups. While at it,
	 * remove any duplicate elements from individual grouping sets (we must
	 * NOT change the number of sets though)
	 */</comment>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) linitial(expanded_groups)</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>list_union_int</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(list_head(expanded_groups))</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>result</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>p</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>new_result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_result</name></expr></argument>,
									 <argument><expr><call><name>list_union_int</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>new_result</name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>result_len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>result_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>result</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_list_len_asc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>result_len</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_aggregate_argtypes
 *	Identify the specific datatypes passed to an aggregate call.
 *
 * Given an Aggref, extract the actual datatypes of the input arguments.
 * The input datatypes are reported in a way that matches up with the
 * aggregate's declaration, ie, any ORDER BY columns attached to a plain
 * aggregate are ignored, but we report both direct and aggregated args of
 * an ordered-set aggregate.
 *
 * Datatypes are returned into inputTypes[], which must reference an array
 * of length FUNC_MAX_ARGS.
 *
 * The function result is the number of actual arguments.
 */</comment>
<function><type><name>int</name></type>
<name>get_aggregate_argtypes</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numArguments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aggref-&gt;aggargtypes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>inputTypes</name><index>[<expr><name>numArguments</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>numArguments</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * resolve_aggregate_transtype
 *	Identify the transition state value's datatype for an aggregate call.
 *
 * This function resolves a polymorphic aggregate's state datatype.
 * It must be passed the aggtranstype from the aggregate's catalog entry,
 * as well as the actual argument types extracted by get_aggregate_argtypes.
 * (We could fetch pg_aggregate.aggtranstype internally, but all existing
 * callers already have the value at hand, so we make them pass it.)
 */</comment>
<function><type><name>Oid</name></type>
<name>resolve_aggregate_transtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>aggfuncid</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>aggtranstype</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTypes</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>numArguments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* resolve actual type of transition state, if polymorphic */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* have to fetch the agg's declared input types... */</comment>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>declaredArgTypes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>agg_nargs</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_func_signature</name><argument_list>(<argument><expr><name>aggfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>declaredArgTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * VARIADIC ANY aggs could have more actual than declared args, but
		 * such extra args can't affect polymorphic type resolution.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agg_nargs</name> <operator>&lt;=</operator> <name>numArguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <call><name>enforce_generic_type_consistency</name><argument_list>(<argument><expr><name>inputTypes</name></expr></argument>,
														<argument><expr><name>declaredArgTypes</name></expr></argument>,
														<argument><expr><name>agg_nargs</name></expr></argument>,
														<argument><expr><name>aggtranstype</name></expr></argument>,
														<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>declaredArgTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>aggtranstype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create an expression tree for the transition function of an aggregate.
 * This is needed so that polymorphic functions can be used within an
 * aggregate --- without the expression tree, such functions would not know
 * the datatypes they are supposed to use.  (The trees will never actually
 * be executed, however, so we can skimp a bit on correctness.)
 *
 * agg_input_types and agg_state_type identifies the input types of the
 * aggregate.  These should be resolved to actual types (ie, none should
 * ever be ANYELEMENT etc).
 * agg_input_collation is the aggregate function's input collation.
 *
 * For an ordered-set aggregate, remember that agg_input_types describes
 * the direct arguments followed by the aggregated arguments.
 *
 * transfn_oid and invtransfn_oid identify the funcs to be called; the
 * latter may be InvalidOid, however if invtransfn_oid is set then
 * transfn_oid must also be set.
 *
 * Pointers to the constructed trees are returned into *transfnexpr,
 * *invtransfnexpr. If there is no invtransfn, the respective pointer is set
 * to NULL.  Since use of the invtransfn is optional, NULL may be passed for
 * invtransfnexpr.
 */</comment>
<function><type><name>void</name></type>
<name>build_aggregate_transfn_expr</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>agg_input_types</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>agg_num_inputs</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>agg_num_direct_inputs</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>agg_variadic</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>agg_state_type</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>agg_input_collation</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>transfn_oid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>invtransfn_oid</name></decl></parameter>,
							 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>transfnexpr</name></decl></parameter>,
							 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>invtransfnexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build arg list to use in the transfn FuncExpr node.
	 */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name>agg_state_type</name></expr></argument>, <argument><expr><name>agg_input_collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>agg_num_direct_inputs</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>agg_num_inputs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
					   <argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name><name>agg_input_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>agg_input_collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>transfn_oid</name></expr></argument>,
						 <argument><expr><name>agg_state_type</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>agg_input_collation</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>agg_variadic</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>transfnexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build invtransfn expression if requested, with same args as transfn
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>invtransfnexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>invtransfn_oid</name></expr></argument>,
								 <argument><expr><name>agg_state_type</name></expr></argument>,
								 <argument><expr><name>args</name></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>agg_input_collation</name></expr></argument>,
								 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>agg_variadic</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>invtransfnexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>invtransfnexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like build_aggregate_transfn_expr, but creates an expression tree for the
 * combine function of an aggregate, rather than the transition function.
 */</comment>
<function><type><name>void</name></type>
<name>build_aggregate_combinefn_expr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>agg_state_type</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>agg_input_collation</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>combinefn_oid</name></decl></parameter>,
							   <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>combinefnexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>argp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>

	<comment type="block">/* combinefn takes two arguments of the aggregate state type */</comment>
	<expr_stmt><expr><name>argp</name> <operator>=</operator> <call><name>make_agg_arg</name><argument_list>(<argument><expr><name>agg_state_type</name></expr></argument>, <argument><expr><name>agg_input_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>combinefn_oid</name></expr></argument>,
						 <argument><expr><name>agg_state_type</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>agg_input_collation</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* combinefn is currently never treated as variadic */</comment>
	<expr_stmt><expr><operator>*</operator><name>combinefnexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like build_aggregate_transfn_expr, but creates an expression tree for the
 * serialization function of an aggregate.
 */</comment>
<function><type><name>void</name></type>
<name>build_aggregate_serialfn_expr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>serialfn_oid</name></decl></parameter>,
							  <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>serialfnexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>

	<comment type="block">/* serialfn always takes INTERNAL and returns BYTEA */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name>INTERNALOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>serialfn_oid</name></expr></argument>,
						 <argument><expr><name>BYTEAOID</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>serialfnexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like build_aggregate_transfn_expr, but creates an expression tree for the
 * deserialization function of an aggregate.
 */</comment>
<function><type><name>void</name></type>
<name>build_aggregate_deserialfn_expr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>deserialfn_oid</name></decl></parameter>,
								<parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>deserialfnexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>

	<comment type="block">/* deserialfn always takes BYTEA, INTERNAL and returns INTERNAL */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name>INTERNALOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>deserialfn_oid</name></expr></argument>,
						 <argument><expr><name>INTERNALOID</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>deserialfnexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fexpr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like build_aggregate_transfn_expr, but creates an expression tree for the
 * final function of an aggregate, rather than the transition function.
 */</comment>
<function><type><name>void</name></type>
<name>build_aggregate_finalfn_expr</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>agg_input_types</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>num_finalfn_inputs</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>agg_state_type</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>agg_result_type</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>agg_input_collation</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>finalfn_oid</name></decl></parameter>,
							 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>finalfnexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build expr tree for final function
	 */</comment>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name>agg_state_type</name></expr></argument>, <argument><expr><name>agg_input_collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finalfn may take additional args, which match agg's input types */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_finalfn_inputs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>,
					   <argument><expr><call><name>make_agg_arg</name><argument_list>(<argument><expr><name><name>agg_input_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>agg_input_collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>finalfnexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>finalfn_oid</name></expr></argument>,
										 <argument><expr><name>agg_result_type</name></expr></argument>,
										 <argument><expr><name>args</name></expr></argument>,
										 <argument><expr><name>InvalidOid</name></expr></argument>,
										 <argument><expr><name>agg_input_collation</name></expr></argument>,
										 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* finalfn is currently never treated as variadic */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience function to build dummy argument expressions for aggregates.
 *
 * We really only care that an aggregate support function can discover its
 * actual argument types at runtime using get_fn_expr_argtype(), so it's okay
 * to use Param nodes that don't correspond to any real Param.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_agg_arg</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>argtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>argcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>argp</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>argp</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argp</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argp</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>argtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argp</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argp</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>argcollation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argp</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>argp</name></expr>;</return>
</block_content>}</block></function>
</unit>
